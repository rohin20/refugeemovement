"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = MapContainerFactory;
exports.Attribution = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactMapGl = _interopRequireDefault(require("react-map-gl"));

var _react2 = _interopRequireDefault(require("@deck.gl/react"));

var _reselect = require("reselect");

var _viewportMercatorProject = _interopRequireDefault(require("viewport-mercator-project"));

var _notificationsUtils = require("../utils/notifications-utils");

var _mapPopover = _interopRequireDefault(require("./map/map-popover"));

var _mapControl = _interopRequireDefault(require("./map/map-control"));

var _styledComponents = require("./common/styled-components");

var _editor = _interopRequireDefault(require("./editor/editor"));

var _mapboxUtils = require("../layers/mapbox-utils");

var _glUtils = require("../utils/gl-utils");

var _mapboxUtils2 = require("../utils/map-style-utils/mapbox-utils");

var _layerUtils = require("../utils/layer-utils");

var _dBuildingLayer = _interopRequireDefault(require("../deckgl-layers/3d-building-layer/3d-building-layer"));

var _defaultSettings = require("../constants/default-settings");

var _errorBoundary = _interopRequireDefault(require("./common/error-boundary"));

var _observeDimensions = require("../utils/observe-dimensions");

var _locales = require("../localization/locales");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/** @type {{[key: string]: React.CSSProperties}} */
var MAP_STYLE = {
  container: {
    display: 'inline-block',
    position: 'relative',
    width: '100%',
    height: '100%'
  },
  top: {
    position: 'absolute',
    top: '0px',
    pointerEvents: 'none',
    width: '100%',
    height: '100%'
  }
};
var MAPBOXGL_STYLE_UPDATE = 'style.load';
var MAPBOXGL_RENDER = 'render';
var TRANSITION_DURATION = 0;

var Attribution = function Attribution() {
  return /*#__PURE__*/_react["default"].createElement(_styledComponents.StyledAttrbution, null, /*#__PURE__*/_react["default"].createElement("div", {
    className: "attrition-logo"
  }, "Basemap by:", /*#__PURE__*/_react["default"].createElement("a", {
    className: "mapboxgl-ctrl-logo",
    target: "_blank",
    rel: "noopener noreferrer",
    href: "https://www.mapbox.com/",
    "aria-label": "Mapbox logo"
  })), /*#__PURE__*/_react["default"].createElement("div", {
    className: "attrition-link"
  }, /*#__PURE__*/_react["default"].createElement("a", {
    href: "https://kepler.gl/policy/",
    target: "_blank",
    rel: "noopener noreferrer"
  }, "\xA9 kepler.gl |", ' '), /*#__PURE__*/_react["default"].createElement("a", {
    href: "https://www.mapbox.com/about/maps/",
    target: "_blank",
    rel: "noopener noreferrer"
  }, "\xA9 Mapbox |", ' '), /*#__PURE__*/_react["default"].createElement("a", {
    href: "http://www.openstreetmap.org/copyright",
    target: "_blank",
    rel: "noopener noreferrer"
  }, "\xA9 OpenStreetMap |", ' '), /*#__PURE__*/_react["default"].createElement("a", {
    href: "https://www.mapbox.com/map-feedback/",
    target: "_blank",
    rel: "noopener noreferrer"
  }, /*#__PURE__*/_react["default"].createElement("strong", null, "Improve this map"))));
};

exports.Attribution = Attribution;
MapContainerFactory.deps = [_mapPopover["default"], _mapControl["default"], _editor["default"]];

function MapContainerFactory(MapPopover, MapControl, Editor) {
  var MapContainer = /*#__PURE__*/function (_Component) {
    (0, _inherits2["default"])(MapContainer, _Component);

    var _super = _createSuper(MapContainer);

    function MapContainer(_props) {
      var _this;

      (0, _classCallCheck2["default"])(this, MapContainer);
      _this = _super.call(this, _props);
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleResize", function (dimensions) {
        var primary = _this.props.primary;

        if (primary) {
          var mapStateActions = _this.props.mapStateActions;

          if (dimensions && dimensions.width > 0 && dimensions.height > 0) {
            mapStateActions.updateMap(dimensions);
          }
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layersSelector", function (props) {
        return props.layers;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layerDataSelector", function (props) {
        return props.layerData;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "mapLayersSelector", function (props) {
        return props.mapLayers;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layerOrderSelector", function (props) {
        return props.layerOrder;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layersToRenderSelector", (0, _reselect.createSelector)(_this.layersSelector, _this.layerDataSelector, _this.mapLayersSelector, _layerUtils.prepareLayersToRender));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "layersForDeckSelector", (0, _reselect.createSelector)(_this.layersSelector, _this.layerDataSelector, _layerUtils.prepareLayersForDeck));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "filtersSelector", function (props) {
        return props.filters;
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "polygonFilters", (0, _reselect.createSelector)(_this.filtersSelector, function (filters) {
        return filters.filter(function (f) {
          return f.type === _defaultSettings.FILTER_TYPES.polygon;
        });
      }));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "mapboxLayersSelector", (0, _reselect.createSelector)(_this.layersSelector, _this.layerDataSelector, _this.layerOrderSelector, _this.layersToRenderSelector, _mapboxUtils.generateMapboxLayers));
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onCloseMapPopover", function () {
        _this.props.visStateActions.onLayerClick(null);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onLayerSetDomain", function (idx, colorDomain) {
        _this.props.visStateActions.layerConfigChange(_this.props.layers[idx], {
          colorDomain: colorDomain
        });
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleMapToggleLayer", function (layerId) {
        var _this$props = _this.props,
            _this$props$index = _this$props.index,
            mapIndex = _this$props$index === void 0 ? 0 : _this$props$index,
            visStateActions = _this$props.visStateActions;
        visStateActions.toggleLayerForMap(mapIndex, layerId);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onMapboxStyleUpdate", function () {
        // force refresh mapboxgl layers
        _this.previousLayers = {};

        _this._updateMapboxLayers();

        if (typeof _this.props.onMapStyleLoaded === 'function') {
          _this.props.onMapStyleLoaded(_this._map);
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_setMapboxMap", function (mapbox) {
        if (!_this._map && mapbox) {
          _this._map = mapbox.getMap(); // i noticed in certain context we don't access the actual map element

          if (!_this._map) {
            return;
          } // bind mapboxgl event listener


          _this._map.on(MAPBOXGL_STYLE_UPDATE, _this._onMapboxStyleUpdate);

          _this._map.on(MAPBOXGL_RENDER, function () {
            if (typeof _this.props.onMapRender === 'function') {
              _this.props.onMapRender(_this._map);
            }
          });
        }

        if (_this.props.getMapboxRef) {
          // The parent component can gain access to our MapboxGlMap by
          // providing this callback. Note that 'mapbox' will be null when the
          // ref is unset (e.g. when a split map is closed).
          _this.props.getMapboxRef(mapbox, _this.props.index);
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onBeforeRender", function (_ref) {
        var gl = _ref.gl;
        (0, _glUtils.setLayerBlending)(gl, _this.props.layerBlending);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onDeckError", function (error, layer) {
        var errorMessage = "An error in deck.gl: ".concat(error.message, " in ").concat(layer.id);
        var notificationId = "".concat(layer.id, "-").concat(error.message); // Throttle error notifications, as React doesn't like too many state changes from here.

        _this._deckGLErrorsElapsed = _this._deckGLErrorsElapsed || {};
        var lastShown = _this._deckGLErrorsElapsed[notificationId];

        if (!lastShown || lastShown < Date.now() - _defaultSettings.THROTTLE_NOTIFICATION_TIME) {
          _this._deckGLErrorsElapsed[notificationId] = Date.now(); // Create new error notification or update existing one with same id.
          // Update is required to preserve the order of notifications as they probably are going to "jump" based on order of errors.

          var uiStateActions = _this.props.uiStateActions;
          uiStateActions.addNotification((0, _notificationsUtils.errorNotification)({
            message: errorMessage,
            id: notificationId
          }));
        }
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onViewportChange", function (viewState) {
        var width = viewState.width,
            height = viewState.height,
            restViewState = (0, _objectWithoutProperties2["default"])(viewState, ["width", "height"]);
        var primary = _this.props.primary; // react-map-gl sends 0,0 dimensions during initialization
        // after we have received proper dimensions from observeDimensions

        var next = _objectSpread(_objectSpread({}, width > 0 && height > 0 ? viewState : restViewState), {}, {
          // enabling transition in two maps may lead to endless update loops
          transitionDuration: primary ? TRANSITION_DURATION : 0
        });

        if (typeof _this.props.onViewStateChange === 'function') {
          _this.props.onViewStateChange(next);
        }

        _this.props.mapStateActions.updateMap(next);
      });
      (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_toggleMapControl", function (panelId) {
        var _this$props2 = _this.props,
            index = _this$props2.index,
            uiStateActions = _this$props2.uiStateActions;
        uiStateActions.toggleMapControl(panelId, index);
      });
      _this.previousLayers = {// [layers.id]: mapboxLayerConfig
      };
      _this._deck = null;
      _this._ref = /*#__PURE__*/(0, _react.createRef)();
      return _this;
    }

    (0, _createClass2["default"])(MapContainer, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        (0, _observeDimensions.observeDimensions)(this._ref.current, this._handleResize);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        // unbind mapboxgl event listener
        if (this._map) {
          this._map.off(MAPBOXGL_STYLE_UPDATE);

          this._map.off(MAPBOXGL_RENDER);
        }

        (0, _observeDimensions.unobserveDimensions)(this._ref.current);
      }
    }, {
      key: "_onDeckInitialized",
      value: function _onDeckInitialized(gl) {
        if (this.props.onDeckInitialized) {
          this.props.onDeckInitialized(this._deck, gl);
        }
      }
    }, {
      key: "_renderMapPopover",
      value:
      /* component render functions */

      /* eslint-disable complexity */
      function _renderMapPopover(layersToRender) {
        // TODO: move this into reducer so it can be tested
        var _this$props3 = this.props,
            mapState = _this$props3.mapState,
            hoverInfo = _this$props3.hoverInfo,
            clicked = _this$props3.clicked,
            datasets = _this$props3.datasets,
            interactionConfig = _this$props3.interactionConfig,
            layers = _this$props3.layers,
            _this$props3$mousePos = _this$props3.mousePos,
            mousePosition = _this$props3$mousePos.mousePosition,
            coordinate = _this$props3$mousePos.coordinate,
            pinned = _this$props3$mousePos.pinned;

        if (!mousePosition || !interactionConfig.tooltip) {
          return null;
        }

        var layerHoverProp = (0, _layerUtils.getLayerHoverProp)({
          interactionConfig: interactionConfig,
          hoverInfo: hoverInfo,
          layers: layers,
          layersToRender: layersToRender,
          datasets: datasets
        });
        var compareMode = interactionConfig.tooltip.config ? interactionConfig.tooltip.config.compareMode : false;
        var pinnedPosition = {};
        var layerPinnedProp = null;

        if (pinned || clicked) {
          // project lnglat to screen so that tooltip follows the object on zoom
          var viewport = new _viewportMercatorProject["default"](mapState);
          var lngLat = clicked ? clicked.lngLat : pinned.coordinate;
          pinnedPosition = this._getHoverXY(viewport, lngLat);
          layerPinnedProp = (0, _layerUtils.getLayerHoverProp)({
            interactionConfig: interactionConfig,
            hoverInfo: clicked,
            layers: layers,
            layersToRender: layersToRender,
            datasets: datasets
          });

          if (layerHoverProp && layerPinnedProp) {
            layerHoverProp.primaryData = layerPinnedProp.data;
            layerHoverProp.compareType = interactionConfig.tooltip.config.compareType;
          }
        }

        var commonProp = {
          onClose: this._onCloseMapPopover,
          zoom: mapState.zoom,
          container: this._deck ? this._deck.canvas : undefined
        };
        return /*#__PURE__*/_react["default"].createElement(_errorBoundary["default"], null, layerPinnedProp && /*#__PURE__*/_react["default"].createElement(MapPopover, (0, _extends2["default"])({}, pinnedPosition, commonProp, {
          layerHoverProp: layerPinnedProp,
          coordinate: interactionConfig.coordinate.enabled && (pinned || {}).coordinate,
          frozen: true,
          isBase: compareMode
        })), layerHoverProp && (!layerPinnedProp || compareMode) && /*#__PURE__*/_react["default"].createElement(MapPopover, (0, _extends2["default"])({
          x: mousePosition[0],
          y: mousePosition[1]
        }, commonProp, {
          layerHoverProp: layerHoverProp,
          frozen: false,
          coordinate: interactionConfig.coordinate.enabled && coordinate
        })));
      }
      /* eslint-enable complexity */

    }, {
      key: "_getHoverXY",
      value: function _getHoverXY(viewport, lngLat) {
        var screenCoord = !viewport || !lngLat ? null : viewport.project(lngLat);
        return screenCoord && {
          x: screenCoord[0],
          y: screenCoord[1]
        };
      }
    }, {
      key: "_renderDeckOverlay",
      value: function _renderDeckOverlay(layersForDeck) {
        var _this$props$deckGlPro,
            _this2 = this;

        var _this$props4 = this.props,
            mapState = _this$props4.mapState,
            mapStyle = _this$props4.mapStyle,
            layerData = _this$props4.layerData,
            layerOrder = _this$props4.layerOrder,
            layers = _this$props4.layers,
            visStateActions = _this$props4.visStateActions,
            mapboxApiAccessToken = _this$props4.mapboxApiAccessToken,
            mapboxApiUrl = _this$props4.mapboxApiUrl; // initialise layers from props if exists

        var deckGlLayers = ((_this$props$deckGlPro = this.props.deckGlProps) === null || _this$props$deckGlPro === void 0 ? void 0 : _this$props$deckGlPro.layers) || []; // wait until data is ready before render data layers

        if (layerData && layerData.length) {
          // last layer render first
          var dataLayers = layerOrder.slice().reverse().filter(function (idx) {
            return layersForDeck[layers[idx].id];
          }).reduce(function (overlays, idx) {
            var layerCallbacks = {
              onSetLayerDomain: function onSetLayerDomain(val) {
                return _this2._onLayerSetDomain(idx, val);
              }
            };
            var layerOverlay = (0, _layerUtils.renderDeckGlLayer)(_this2.props, layerCallbacks, idx);
            return overlays.concat(layerOverlay || []);
          }, []);
          deckGlLayers = deckGlLayers.concat(dataLayers);
        }

        if (mapStyle.visibleLayerGroups['3d building']) {
          deckGlLayers.push(new _dBuildingLayer["default"]({
            id: '_keplergl_3d-building',
            mapboxApiAccessToken: mapboxApiAccessToken,
            mapboxApiUrl: mapboxApiUrl,
            threeDBuildingColor: mapStyle.threeDBuildingColor,
            updateTriggers: {
              getFillColor: mapStyle.threeDBuildingColor
            }
          }));
        }

        return /*#__PURE__*/_react["default"].createElement(_react2["default"], (0, _extends2["default"])({}, this.props.deckGlProps, {
          viewState: mapState,
          id: "default-deckgl-overlay",
          layers: deckGlLayers,
          onBeforeRender: this._onBeforeRender,
          onHover: visStateActions.onLayerHover,
          onClick: visStateActions.onLayerClick,
          onError: this._onDeckError,
          ref: function ref(comp) {
            if (comp && comp.deck && !_this2._deck) {
              _this2._deck = comp.deck;
            }
          },
          onWebGLInitialized: function onWebGLInitialized(gl) {
            return _this2._onDeckInitialized(gl);
          }
        }));
      }
    }, {
      key: "_updateMapboxLayers",
      value: function _updateMapboxLayers() {
        var mapboxLayers = this.mapboxLayersSelector(this.props);

        if (!Object.keys(mapboxLayers).length && !Object.keys(this.previousLayers).length) {
          return;
        }

        (0, _mapboxUtils.updateMapboxLayers)(this._map, mapboxLayers, this.previousLayers);
        this.previousLayers = mapboxLayers;
      }
    }, {
      key: "_renderMapboxOverlays",
      value: function _renderMapboxOverlays() {
        if (this._map && this._map.isStyleLoaded()) {
          this._updateMapboxLayers();
        }
      }
    }, {
      key: "_renderMap",
      value:
      /* eslint-disable complexity */
      function _renderMap() {
        var _this$props5 = this.props,
            mapState = _this$props5.mapState,
            mapStyle = _this$props5.mapStyle,
            mapStateActions = _this$props5.mapStateActions,
            layers = _this$props5.layers,
            MapComponent = _this$props5.MapComponent,
            datasets = _this$props5.datasets,
            mapboxApiAccessToken = _this$props5.mapboxApiAccessToken,
            mapboxApiUrl = _this$props5.mapboxApiUrl,
            mapControls = _this$props5.mapControls,
            isExport = _this$props5.isExport,
            locale = _this$props5.locale,
            uiStateActions = _this$props5.uiStateActions,
            visStateActions = _this$props5.visStateActions,
            interactionConfig = _this$props5.interactionConfig,
            editor = _this$props5.editor,
            index = _this$props5.index,
            primary = _this$props5.primary;
        var layersToRender = this.layersToRenderSelector(this.props);
        var layersForDeck = this.layersForDeckSelector(this.props);

        var mapProps = _objectSpread(_objectSpread({}, mapState), {}, {
          width: '100%',
          height: '100%',
          preserveDrawingBuffer: true,
          mapboxApiAccessToken: mapboxApiAccessToken,
          mapboxApiUrl: mapboxApiUrl,
          onViewportChange: this._onViewportChange,
          transformRequest: _mapboxUtils2.transformRequest
        });

        var isEdit = (mapControls.mapDraw || {}).active;
        var hasGeocoderLayer = layers.find(function (l) {
          return l.id === _defaultSettings.GEOCODER_LAYER_ID;
        });
        var isSplit = Boolean(mapState.isSplit);
        return /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null, /*#__PURE__*/_react["default"].createElement(MapControl, {
          datasets: datasets,
          availableLocales: Object.keys(_locales.LOCALE_CODES),
          dragRotate: mapState.dragRotate,
          isSplit: isSplit,
          primary: primary,
          isExport: isExport,
          layers: layers,
          layersToRender: layersToRender,
          mapIndex: index,
          mapControls: mapControls,
          readOnly: this.props.readOnly,
          scale: mapState.scale || 1,
          top: interactionConfig.geocoder && interactionConfig.geocoder.enabled ? 52 : 0,
          editor: editor,
          locale: locale,
          onTogglePerspective: mapStateActions.togglePerspective,
          onToggleSplitMap: mapStateActions.toggleSplitMap,
          onMapToggleLayer: this._handleMapToggleLayer,
          onToggleMapControl: this._toggleMapControl,
          onSetEditorMode: visStateActions.setEditorMode,
          onSetLocale: uiStateActions.setLocale,
          onToggleEditorVisibility: visStateActions.toggleEditorVisibility
        }), /*#__PURE__*/_react["default"].createElement(MapComponent, (0, _extends2["default"])({}, mapProps, {
          key: "bottom",
          ref: this._setMapboxMap,
          mapStyle: mapStyle.bottomMapStyle,
          getCursor: this.props.hoverInfo ? function () {
            return 'pointer';
          } : undefined,
          onMouseMove: this.props.visStateActions.onMouseMove
        }), this._renderDeckOverlay(layersForDeck), this._renderMapboxOverlays(), /*#__PURE__*/_react["default"].createElement(Editor, {
          index: index,
          datasets: datasets,
          editor: editor,
          filters: this.polygonFilters(this.props),
          isEnabled: isEdit,
          layers: layers,
          layersToRender: layersToRender,
          onDeleteFeature: visStateActions.deleteFeature,
          onSelect: visStateActions.setSelectedFeature,
          onUpdate: visStateActions.setFeatures,
          onTogglePolygonFilter: visStateActions.setPolygonFilterLayer,
          style: {
            pointerEvents: isEdit ? 'all' : 'none',
            position: 'absolute',
            display: editor.visible ? 'block' : 'none'
          }
        })), mapStyle.topMapStyle || hasGeocoderLayer ? /*#__PURE__*/_react["default"].createElement("div", {
          style: MAP_STYLE.top
        }, /*#__PURE__*/_react["default"].createElement(MapComponent, (0, _extends2["default"])({}, mapProps, {
          key: "top",
          mapStyle: mapStyle.topMapStyle
        }), this._renderDeckOverlay((0, _defineProperty2["default"])({}, _defaultSettings.GEOCODER_LAYER_ID, true)))) : null, this._renderMapPopover(layersToRender), !isSplit || index === 1 ? /*#__PURE__*/_react["default"].createElement(Attribution, null) : null);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props6 = this.props,
            mapState = _this$props6.mapState,
            mapStyle = _this$props6.mapStyle;
        return /*#__PURE__*/_react["default"].createElement(_styledComponents.StyledMapContainer, {
          ref: this._ref,
          style: MAP_STYLE.container,
          globe: mapState.globe
        }, mapStyle.bottomMapStyle && this._renderMap());
      }
    }]);
    return MapContainer;
  }(_react.Component);

  (0, _defineProperty2["default"])(MapContainer, "propTypes", {
    // required
    datasets: _propTypes["default"].object,
    interactionConfig: _propTypes["default"].object.isRequired,
    layerBlending: _propTypes["default"].string.isRequired,
    layerOrder: _propTypes["default"].arrayOf(_propTypes["default"].any).isRequired,
    layerData: _propTypes["default"].arrayOf(_propTypes["default"].any).isRequired,
    layers: _propTypes["default"].arrayOf(_propTypes["default"].any).isRequired,
    filters: _propTypes["default"].arrayOf(_propTypes["default"].any).isRequired,
    mapState: _propTypes["default"].object.isRequired,
    mapControls: _propTypes["default"].object.isRequired,
    mapStyle: _propTypes["default"].object.isRequired,
    mousePos: _propTypes["default"].object.isRequired,
    mapboxApiAccessToken: _propTypes["default"].string.isRequired,
    mapboxApiUrl: _propTypes["default"].string,
    visStateActions: _propTypes["default"].object.isRequired,
    mapStateActions: _propTypes["default"].object.isRequired,
    uiStateActions: _propTypes["default"].object.isRequired,
    // optional
    primary: _propTypes["default"].bool,
    // primary one will be reporting its size to appState
    readOnly: _propTypes["default"].bool,
    isExport: _propTypes["default"].bool,
    clicked: _propTypes["default"].object,
    hoverInfo: _propTypes["default"].object,
    mapLayers: _propTypes["default"].object,
    onMapToggleLayer: _propTypes["default"].func,
    onMapStyleLoaded: _propTypes["default"].func,
    onMapRender: _propTypes["default"].func,
    getMapboxRef: _propTypes["default"].func,
    index: _propTypes["default"].number
  });
  (0, _defineProperty2["default"])(MapContainer, "defaultProps", {
    MapComponent: _reactMapGl["default"],
    deckGlProps: {},
    index: 0,
    primary: true
  });
  MapContainer.displayName = 'MapContainer';
  return MapContainer;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL21hcC1jb250YWluZXIuanMiXSwibmFtZXMiOlsiTUFQX1NUWUxFIiwiY29udGFpbmVyIiwiZGlzcGxheSIsInBvc2l0aW9uIiwid2lkdGgiLCJoZWlnaHQiLCJ0b3AiLCJwb2ludGVyRXZlbnRzIiwiTUFQQk9YR0xfU1RZTEVfVVBEQVRFIiwiTUFQQk9YR0xfUkVOREVSIiwiVFJBTlNJVElPTl9EVVJBVElPTiIsIkF0dHJpYnV0aW9uIiwiTWFwQ29udGFpbmVyRmFjdG9yeSIsImRlcHMiLCJNYXBQb3BvdmVyRmFjdG9yeSIsIk1hcENvbnRyb2xGYWN0b3J5IiwiRWRpdG9yRmFjdG9yeSIsIk1hcFBvcG92ZXIiLCJNYXBDb250cm9sIiwiRWRpdG9yIiwiTWFwQ29udGFpbmVyIiwicHJvcHMiLCJkaW1lbnNpb25zIiwicHJpbWFyeSIsIm1hcFN0YXRlQWN0aW9ucyIsInVwZGF0ZU1hcCIsImxheWVycyIsImxheWVyRGF0YSIsIm1hcExheWVycyIsImxheWVyT3JkZXIiLCJsYXllcnNTZWxlY3RvciIsImxheWVyRGF0YVNlbGVjdG9yIiwibWFwTGF5ZXJzU2VsZWN0b3IiLCJwcmVwYXJlTGF5ZXJzVG9SZW5kZXIiLCJwcmVwYXJlTGF5ZXJzRm9yRGVjayIsImZpbHRlcnMiLCJmaWx0ZXJzU2VsZWN0b3IiLCJmaWx0ZXIiLCJmIiwidHlwZSIsIkZJTFRFUl9UWVBFUyIsInBvbHlnb24iLCJsYXllck9yZGVyU2VsZWN0b3IiLCJsYXllcnNUb1JlbmRlclNlbGVjdG9yIiwiZ2VuZXJhdGVNYXBib3hMYXllcnMiLCJ2aXNTdGF0ZUFjdGlvbnMiLCJvbkxheWVyQ2xpY2siLCJpZHgiLCJjb2xvckRvbWFpbiIsImxheWVyQ29uZmlnQ2hhbmdlIiwibGF5ZXJJZCIsImluZGV4IiwibWFwSW5kZXgiLCJ0b2dnbGVMYXllckZvck1hcCIsInByZXZpb3VzTGF5ZXJzIiwiX3VwZGF0ZU1hcGJveExheWVycyIsIm9uTWFwU3R5bGVMb2FkZWQiLCJfbWFwIiwibWFwYm94IiwiZ2V0TWFwIiwib24iLCJfb25NYXBib3hTdHlsZVVwZGF0ZSIsIm9uTWFwUmVuZGVyIiwiZ2V0TWFwYm94UmVmIiwiZ2wiLCJsYXllckJsZW5kaW5nIiwiZXJyb3IiLCJsYXllciIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJpZCIsIm5vdGlmaWNhdGlvbklkIiwiX2RlY2tHTEVycm9yc0VsYXBzZWQiLCJsYXN0U2hvd24iLCJEYXRlIiwibm93IiwiVEhST1RUTEVfTk9USUZJQ0FUSU9OX1RJTUUiLCJ1aVN0YXRlQWN0aW9ucyIsImFkZE5vdGlmaWNhdGlvbiIsInZpZXdTdGF0ZSIsInJlc3RWaWV3U3RhdGUiLCJuZXh0IiwidHJhbnNpdGlvbkR1cmF0aW9uIiwib25WaWV3U3RhdGVDaGFuZ2UiLCJwYW5lbElkIiwidG9nZ2xlTWFwQ29udHJvbCIsIl9kZWNrIiwiX3JlZiIsImN1cnJlbnQiLCJfaGFuZGxlUmVzaXplIiwib2ZmIiwib25EZWNrSW5pdGlhbGl6ZWQiLCJsYXllcnNUb1JlbmRlciIsIm1hcFN0YXRlIiwiaG92ZXJJbmZvIiwiY2xpY2tlZCIsImRhdGFzZXRzIiwiaW50ZXJhY3Rpb25Db25maWciLCJtb3VzZVBvcyIsIm1vdXNlUG9zaXRpb24iLCJjb29yZGluYXRlIiwicGlubmVkIiwidG9vbHRpcCIsImxheWVySG92ZXJQcm9wIiwiY29tcGFyZU1vZGUiLCJjb25maWciLCJwaW5uZWRQb3NpdGlvbiIsImxheWVyUGlubmVkUHJvcCIsInZpZXdwb3J0IiwiV2ViTWVyY2F0b3JWaWV3cG9ydCIsImxuZ0xhdCIsIl9nZXRIb3ZlclhZIiwicHJpbWFyeURhdGEiLCJkYXRhIiwiY29tcGFyZVR5cGUiLCJjb21tb25Qcm9wIiwib25DbG9zZSIsIl9vbkNsb3NlTWFwUG9wb3ZlciIsInpvb20iLCJjYW52YXMiLCJ1bmRlZmluZWQiLCJlbmFibGVkIiwic2NyZWVuQ29vcmQiLCJwcm9qZWN0IiwieCIsInkiLCJsYXllcnNGb3JEZWNrIiwibWFwU3R5bGUiLCJtYXBib3hBcGlBY2Nlc3NUb2tlbiIsIm1hcGJveEFwaVVybCIsImRlY2tHbExheWVycyIsImRlY2tHbFByb3BzIiwibGVuZ3RoIiwiZGF0YUxheWVycyIsInNsaWNlIiwicmV2ZXJzZSIsInJlZHVjZSIsIm92ZXJsYXlzIiwibGF5ZXJDYWxsYmFja3MiLCJvblNldExheWVyRG9tYWluIiwidmFsIiwiX29uTGF5ZXJTZXREb21haW4iLCJsYXllck92ZXJsYXkiLCJjb25jYXQiLCJ2aXNpYmxlTGF5ZXJHcm91cHMiLCJwdXNoIiwiVGhyZWVEQnVpbGRpbmdMYXllciIsInRocmVlREJ1aWxkaW5nQ29sb3IiLCJ1cGRhdGVUcmlnZ2VycyIsImdldEZpbGxDb2xvciIsIl9vbkJlZm9yZVJlbmRlciIsIm9uTGF5ZXJIb3ZlciIsIl9vbkRlY2tFcnJvciIsImNvbXAiLCJkZWNrIiwiX29uRGVja0luaXRpYWxpemVkIiwibWFwYm94TGF5ZXJzIiwibWFwYm94TGF5ZXJzU2VsZWN0b3IiLCJPYmplY3QiLCJrZXlzIiwiaXNTdHlsZUxvYWRlZCIsIk1hcENvbXBvbmVudCIsIm1hcENvbnRyb2xzIiwiaXNFeHBvcnQiLCJsb2NhbGUiLCJlZGl0b3IiLCJsYXllcnNGb3JEZWNrU2VsZWN0b3IiLCJtYXBQcm9wcyIsInByZXNlcnZlRHJhd2luZ0J1ZmZlciIsIm9uVmlld3BvcnRDaGFuZ2UiLCJfb25WaWV3cG9ydENoYW5nZSIsInRyYW5zZm9ybVJlcXVlc3QiLCJpc0VkaXQiLCJtYXBEcmF3IiwiYWN0aXZlIiwiaGFzR2VvY29kZXJMYXllciIsImZpbmQiLCJsIiwiR0VPQ09ERVJfTEFZRVJfSUQiLCJpc1NwbGl0IiwiQm9vbGVhbiIsIkxPQ0FMRV9DT0RFUyIsImRyYWdSb3RhdGUiLCJyZWFkT25seSIsInNjYWxlIiwiZ2VvY29kZXIiLCJ0b2dnbGVQZXJzcGVjdGl2ZSIsInRvZ2dsZVNwbGl0TWFwIiwiX2hhbmRsZU1hcFRvZ2dsZUxheWVyIiwiX3RvZ2dsZU1hcENvbnRyb2wiLCJzZXRFZGl0b3JNb2RlIiwic2V0TG9jYWxlIiwidG9nZ2xlRWRpdG9yVmlzaWJpbGl0eSIsIl9zZXRNYXBib3hNYXAiLCJib3R0b21NYXBTdHlsZSIsIm9uTW91c2VNb3ZlIiwiX3JlbmRlckRlY2tPdmVybGF5IiwiX3JlbmRlck1hcGJveE92ZXJsYXlzIiwicG9seWdvbkZpbHRlcnMiLCJkZWxldGVGZWF0dXJlIiwic2V0U2VsZWN0ZWRGZWF0dXJlIiwic2V0RmVhdHVyZXMiLCJzZXRQb2x5Z29uRmlsdGVyTGF5ZXIiLCJ2aXNpYmxlIiwidG9wTWFwU3R5bGUiLCJfcmVuZGVyTWFwUG9wb3ZlciIsImdsb2JlIiwiX3JlbmRlck1hcCIsIkNvbXBvbmVudCIsIlByb3BUeXBlcyIsIm9iamVjdCIsImlzUmVxdWlyZWQiLCJzdHJpbmciLCJhcnJheU9mIiwiYW55IiwiYm9vbCIsIm9uTWFwVG9nZ2xlTGF5ZXIiLCJmdW5jIiwibnVtYmVyIiwiTWFwYm94R0xNYXAiLCJkaXNwbGF5TmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBOztBQUNBOztBQUNBOztBQUVBOztBQUdBOztBQUNBOztBQUNBOztBQUNBOztBQVFBOztBQUNBOztBQU1BOztBQUNBOztBQUNBOzs7Ozs7Ozs7O0FBRUE7QUFDQSxJQUFNQSxTQUFTLEdBQUc7QUFDaEJDLEVBQUFBLFNBQVMsRUFBRTtBQUNUQyxJQUFBQSxPQUFPLEVBQUUsY0FEQTtBQUVUQyxJQUFBQSxRQUFRLEVBQUUsVUFGRDtBQUdUQyxJQUFBQSxLQUFLLEVBQUUsTUFIRTtBQUlUQyxJQUFBQSxNQUFNLEVBQUU7QUFKQyxHQURLO0FBT2hCQyxFQUFBQSxHQUFHLEVBQUU7QUFDSEgsSUFBQUEsUUFBUSxFQUFFLFVBRFA7QUFFSEcsSUFBQUEsR0FBRyxFQUFFLEtBRkY7QUFHSEMsSUFBQUEsYUFBYSxFQUFFLE1BSFo7QUFJSEgsSUFBQUEsS0FBSyxFQUFFLE1BSko7QUFLSEMsSUFB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WSxFQUFFMEQsc0JBRE07QUFFcEJ4RixJQUFBQSxXQUFXLEVBQUUsRUFGTztBQUdwQmhGLElBQUFBLEtBQUssRUFBRSxDQUhhO0FBSXBCNUIsSUFBQUEsT0FBTyxFQUFFO0FBSlcsR0FuQ2tEO0FBcWYxRUgsRUFBQUEsWUFBWSxDQUFDd00sV0FBYixHQUEyQixjQUEzQjtBQUVBLFNBQU94TSxZQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjEgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBsaWJyYXJpZXNcbmltcG9ydCBSZWFjdCwge0NvbXBvbmVudCwgY3JlYXRlUmVmfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE1hcGJveEdMTWFwIGZyb20gJ3JlYWN0LW1hcC1nbCc7XG5pbXBvcnQgRGVja0dMIGZyb20gJ0BkZWNrLmdsL3JlYWN0JztcbmltcG9ydCB7Y3JlYXRlU2VsZWN0b3J9IGZyb20gJ3Jlc2VsZWN0JztcbmltcG9ydCBXZWJNZXJjYXRvclZpZXdwb3J0IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuaW1wb3J0IHtlcnJvck5vdGlmaWNhdGlvbn0gZnJvbSAndXRpbHMvbm90aWZpY2F0aW9ucy11dGlscyc7XG5cbi8vIGNvbXBvbmVudHNcbmltcG9ydCBNYXBQb3BvdmVyRmFjdG9yeSBmcm9tICdjb21wb25lbnRzL21hcC9tYXAtcG9wb3Zlcic7XG5pbXBvcnQgTWFwQ29udHJvbEZhY3RvcnkgZnJvbSAnY29tcG9uZW50cy9tYXAvbWFwLWNvbnRyb2wnO1xuaW1wb3J0IHtTdHlsZWRNYXBDb250YWluZXIsIFN0eWxlZEF0dHJidXRpb259IGZyb20gJ2NvbXBvbmVudHMvY29tbW9uL3N0eWxlZC1jb21wb25lbnRzJztcblxuaW1wb3J0IEVkaXRvckZhY3RvcnkgZnJvbSAnLi9lZGl0b3IvZWRpdG9yJztcblxuLy8gdXRpbHNcbmltcG9ydCB7Z2VuZXJhdGVNYXBib3hMYXllcnMsIHVwZGF0ZU1hcGJveExheWVyc30gZnJvbSAnbGF5ZXJzL21hcGJveC11dGlscyc7XG5pbXBvcnQge3NldExheWVyQmxlbmRpbmd9IGZyb20gJ3V0aWxzL2dsLXV0aWxzJztcbmltcG9ydCB7dHJhbnNmb3JtUmVxdWVzdH0gZnJvbSAndXRpbHMvbWFwLXN0eWxlLXV0aWxzL21hcGJveC11dGlscyc7XG5pbXBvcnQge1xuICBnZXRMYXllckhvdmVyUHJvcCxcbiAgcmVuZGVyRGVja0dsTGF5ZXIsXG4gIHByZXBhcmVMYXllcnNUb1JlbmRlcixcbiAgcHJlcGFyZUxheWVyc0ZvckRlY2tcbn0gZnJvbSAndXRpbHMvbGF5ZXItdXRpbHMnO1xuXG4vLyBkZWZhdWx0LXNldHRpbmdzXG5pbXBvcnQgVGhyZWVEQnVpbGRpbmdMYXllciBmcm9tICdkZWNrZ2wtbGF5ZXJzLzNkLWJ1aWxkaW5nLWxheWVyLzNkLWJ1aWxkaW5nLWxheWVyJztcbmltcG9ydCB7XG4gIEZJTFRFUl9UWVBFUyxcbiAgR0VPQ09ERVJfTEFZRVJfSUQsXG4gIFRIUk9UVExFX05PVElGSUNBVElPTl9USU1FXG59IGZyb20gJ2NvbnN0YW50cy9kZWZhdWx0LXNldHRpbmdzJztcblxuaW1wb3J0IEVycm9yQm91bmRhcnkgZnJvbSAnY29tcG9uZW50cy9jb21tb24vZXJyb3ItYm91bmRhcnknO1xuaW1wb3J0IHtvYnNlcnZlRGltZW5zaW9ucywgdW5vYnNlcnZlRGltZW5zaW9uc30gZnJvbSAnLi4vdXRpbHMvb2JzZXJ2ZS1kaW1lbnNpb25zJztcbmltcG9ydCB7TE9DQUxFX0NPREVTfSBmcm9tICdsb2NhbGl6YXRpb24vbG9jYWxlcyc7XG5cbi8qKiBAdHlwZSB7e1trZXk6IHN0cmluZ106IFJlYWN0LkNTU1Byb3BlcnRpZXN9fSAqL1xuY29uc3QgTUFQX1NUWUxFID0ge1xuICBjb250YWluZXI6IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnXG4gIH0sXG4gIHRvcDoge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogJzBweCcsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJSdcbiAgfVxufTtcblxuY29uc3QgTUFQQk9YR0xfU1RZTEVfVVBEQVRFID0gJ3N0eWxlLmxvYWQnO1xuY29uc3QgTUFQQk9YR0xfUkVOREVSID0gJ3JlbmRlcic7XG5jb25zdCBUUkFOU0lUSU9OX0RVUkFUSU9OID0gMDtcblxuZXhwb3J0IGNvbnN0IEF0dHJpYnV0aW9uID0gKCkgPT4gKFxuICA8U3R5bGVkQXR0cmJ1dGlvbj5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cImF0dHJpdGlvbi1sb2dvXCI+XG4gICAgICBCYXNlbWFwIGJ5OlxuICAgICAgPGFcbiAgICAgICAgY2xhc3NOYW1lPVwibWFwYm94Z2wtY3RybC1sb2dvXCJcbiAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXG4gICAgICAgIGhyZWY9XCJodHRwczovL3d3dy5tYXBib3guY29tL1wiXG4gICAgICAgIGFyaWEtbGFiZWw9XCJNYXBib3ggbG9nb1wiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3NOYW1lPVwiYXR0cml0aW9uLWxpbmtcIj5cbiAgICAgIDxhIGhyZWY9XCJodHRwczovL2tlcGxlci5nbC9wb2xpY3kvXCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiPlxuICAgICAgICDCqSBrZXBsZXIuZ2wgfHsnICd9XG4gICAgICA8L2E+XG4gICAgICA8YSBocmVmPVwiaHR0cHM6Ly93d3cubWFwYm94LmNvbS9hYm91dC9tYXBzL1wiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIj5cbiAgICAgICAgwqkgTWFwYm94IHx7JyAnfVxuICAgICAgPC9hPlxuICAgICAgPGEgaHJlZj1cImh0dHA6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiPlxuICAgICAgICDCqSBPcGVuU3RyZWV0TWFwIHx7JyAnfVxuICAgICAgPC9hPlxuICAgICAgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwLWZlZWRiYWNrL1wiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIj5cbiAgICAgICAgPHN0cm9uZz5JbXByb3ZlIHRoaXMgbWFwPC9zdHJvbmc+XG4gICAgICA8L2E+XG4gICAgPC9kaXY+XG4gIDwvU3R5bGVkQXR0cmJ1dGlvbj5cbik7XG5cbk1hcENvbnRhaW5lckZhY3RvcnkuZGVwcyA9IFtNYXBQb3BvdmVyRmFjdG9yeSwgTWFwQ29udHJvbEZhY3RvcnksIEVkaXRvckZhY3RvcnldO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXBDb250YWluZXJGYWN0b3J5KE1hcFBvcG92ZXIsIE1hcENvbnRyb2wsIEVkaXRvcikge1xuICBjbGFzcyBNYXBDb250YWluZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICAvLyByZXF1aXJlZFxuICAgICAgZGF0YXNldHM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICBpbnRlcmFjdGlvbkNvbmZpZzogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgICAgbGF5ZXJCbGVuZGluZzogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgICAgbGF5ZXJPcmRlcjogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmFueSkuaXNSZXF1aXJlZCxcbiAgICAgIGxheWVyRGF0YTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmFueSkuaXNSZXF1aXJlZCxcbiAgICAgIGxheWVyczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmFueSkuaXNSZXF1aXJlZCxcbiAgICAgIGZpbHRlcnM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5hbnkpLmlzUmVxdWlyZWQsXG4gICAgICBtYXBTdGF0ZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgICAgbWFwQ29udHJvbHM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICAgIG1hcFN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgICBtb3VzZVBvczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgICAgbWFwYm94QXBpQWNjZXNzVG9rZW46IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICAgIG1hcGJveEFwaVVybDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgIHZpc1N0YXRlQWN0aW9uczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgICAgbWFwU3RhdGVBY3Rpb25zOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgICB1aVN0YXRlQWN0aW9uczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXG4gICAgICAvLyBvcHRpb25hbFxuICAgICAgcHJpbWFyeTogUHJvcFR5cGVzLmJvb2wsIC8vIHByaW1hcnkgb25lIHdpbGwgYmUgcmVwb3J0aW5nIGl0cyBzaXplIHRvIGFwcFN0YXRlXG4gICAgICByZWFkT25seTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICBpc0V4cG9ydDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICBjbGlja2VkOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgaG92ZXJJbmZvOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgbWFwTGF5ZXJzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgICAgb25NYXBUb2dnbGVMYXllcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICBvbk1hcFN0eWxlTG9hZGVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgIG9uTWFwUmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAgIGdldE1hcGJveFJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICBpbmRleDogUHJvcFR5cGVzLm51bWJlclxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgICAgTWFwQ29tcG9uZW50OiBNYXBib3hHTE1hcCxcbiAgICAgIGRlY2tHbFByb3BzOiB7fSxcbiAgICAgIGluZGV4OiAwLFxuICAgICAgcHJpbWFyeTogdHJ1ZVxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICB0aGlzLnByZXZpb3VzTGF5ZXJzID0ge1xuICAgICAgICAvLyBbbGF5ZXJzLmlkXTogbWFwYm94TGF5ZXJDb25maWdcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2RlY2sgPSBudWxsO1xuICAgICAgdGhpcy5fcmVmID0gY3JlYXRlUmVmKCk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBvYnNlcnZlRGltZW5zaW9ucyh0aGlzLl9yZWYuY3VycmVudCwgdGhpcy5faGFuZGxlUmVzaXplKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIC8vIHVuYmluZCBtYXBib3hnbCBldmVudCBsaXN0ZW5lclxuICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICB0aGlzLl9tYXAub2ZmKE1BUEJPWEdMX1NUWUxFX1VQREFURSk7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoTUFQQk9YR0xfUkVOREVSKTtcbiAgICAgIH1cbiAgICAgIHVub2JzZXJ2ZURpbWVuc2lvbnModGhpcy5fcmVmLmN1cnJlbnQpO1xuICAgIH1cblxuICAgIF9oYW5kbGVSZXNpemUgPSBkaW1lbnNpb25zID0+IHtcbiAgICAgIGNvbnN0IHtwcmltYXJ5fSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAocHJpbWFyeSkge1xuICAgICAgICBjb25zdCB7bWFwU3RhdGVBY3Rpb25zfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChkaW1lbnNpb25zICYmIGRpbWVuc2lvbnMud2lkdGggPiAwICYmIGRpbWVuc2lvbnMuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgIG1hcFN0YXRlQWN0aW9ucy51cGRhdGVNYXAoZGltZW5zaW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGF5ZXJzU2VsZWN0b3IgPSBwcm9wcyA9PiBwcm9wcy5sYXllcnM7XG4gICAgbGF5ZXJEYXRhU2VsZWN0b3IgPSBwcm9wcyA9PiBwcm9wcy5sYXllckRhdGE7XG4gICAgbWFwTGF5ZXJzU2VsZWN0b3IgPSBwcm9wcyA9PiBwcm9wcy5tYXBMYXllcnM7XG4gICAgbGF5ZXJPcmRlclNlbGVjdG9yID0gcHJvcHMgPT4gcHJvcHMubGF5ZXJPcmRlcjtcbiAgICBsYXllcnNUb1JlbmRlclNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3IoXG4gICAgICB0aGlzLmxheWVyc1NlbGVjdG9yLFxuICAgICAgdGhpcy5sYXllckRhdGFTZWxlY3RvcixcbiAgICAgIHRoaXMubWFwTGF5ZXJzU2VsZWN0b3IsXG4gICAgICBwcmVwYXJlTGF5ZXJzVG9SZW5kZXJcbiAgICApO1xuICAgIGxheWVyc0ZvckRlY2tTZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yKFxuICAgICAgdGhpcy5sYXllcnNTZWxlY3RvcixcbiAgICAgIHRoaXMubGF5ZXJEYXRhU2VsZWN0b3IsXG4gICAgICBwcmVwYXJlTGF5ZXJzRm9yRGVja1xuICAgICk7XG4gICAgZmlsdGVyc1NlbGVjdG9yID0gcHJvcHMgPT4gcHJvcHMuZmlsdGVycztcbiAgICBwb2x5Z29uRmlsdGVycyA9IGNyZWF0ZVNlbGVjdG9yKHRoaXMuZmlsdGVyc1NlbGVjdG9yLCBmaWx0ZXJzID0+XG4gICAgICBmaWx0ZXJzLmZpbHRlcihmID0+IGYudHlwZSA9PT0gRklMVEVSX1RZUEVTLnBvbHlnb24pXG4gICAgKTtcblxuICAgIG1hcGJveExheWVyc1NlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3IoXG4gICAgICB0aGlzLmxheWVyc1NlbGVjdG9yLFxuICAgICAgdGhpcy5sYXllckRhdGFTZWxlY3RvcixcbiAgICAgIHRoaXMubGF5ZXJPcmRlclNlbGVjdG9yLFxuICAgICAgdGhpcy5sYXllcnNUb1JlbmRlclNlbGVjdG9yLFxuICAgICAgZ2VuZXJhdGVNYXBib3hMYXllcnNcbiAgICApO1xuXG4gICAgLyogY29tcG9uZW50IHByaXZhdGUgZnVuY3Rpb25zICovXG4gICAgX29uQ2xvc2VNYXBQb3BvdmVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5wcm9wcy52aXNTdGF0ZUFjdGlvbnMub25MYXllckNsaWNrKG51bGwpO1xuICAgIH07XG5cbiAgICBfb25MYXllclNldERvbWFpbiA9IChpZHgsIGNvbG9yRG9tYWluKSA9PiB7XG4gICAgICB0aGlzLnByb3BzLnZpc1N0YXRlQWN0aW9ucy5sYXllckNvbmZpZ0NoYW5nZSh0aGlzLnByb3BzLmxheWVyc1tpZHhdLCB7XG4gICAgICAgIGNvbG9yRG9tYWluXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2hhbmRsZU1hcFRvZ2dsZUxheWVyID0gbGF5ZXJJZCA9PiB7XG4gICAgICBjb25zdCB7aW5kZXg6IG1hcEluZGV4ID0gMCwgdmlzU3RhdGVBY3Rpb25zfSA9IHRoaXMucHJvcHM7XG4gICAgICB2aXNTdGF0ZUFjdGlvbnMudG9nZ2xlTGF5ZXJGb3JNYXAobWFwSW5kZXgsIGxheWVySWQpO1xuICAgIH07XG5cbiAgICBfb25NYXBib3hTdHlsZVVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIC8vIGZvcmNlIHJlZnJlc2ggbWFwYm94Z2wgbGF5ZXJzXG4gICAgICB0aGlzLnByZXZpb3VzTGF5ZXJzID0ge307XG4gICAgICB0aGlzLl91cGRhdGVNYXBib3hMYXllcnMoKTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uTWFwU3R5bGVMb2FkZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbk1hcFN0eWxlTG9hZGVkKHRoaXMuX21hcCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9zZXRNYXBib3hNYXAgPSBtYXBib3ggPT4ge1xuICAgICAgaWYgKCF0aGlzLl9tYXAgJiYgbWFwYm94KSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcGJveC5nZXRNYXAoKTtcbiAgICAgICAgLy8gaSBub3RpY2VkIGluIGNlcnRhaW4gY29udGV4dCB3ZSBkb24ndCBhY2Nlc3MgdGhlIGFjdHVhbCBtYXAgZWxlbWVudFxuICAgICAgICBpZiAoIXRoaXMuX21hcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBiaW5kIG1hcGJveGdsIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgIHRoaXMuX21hcC5vbihNQVBCT1hHTF9TVFlMRV9VUERBVEUsIHRoaXMuX29uTWFwYm94U3R5bGVVcGRhdGUpO1xuXG4gICAgICAgIHRoaXMuX21hcC5vbihNQVBCT1hHTF9SRU5ERVIsICgpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMub25NYXBSZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25NYXBSZW5kZXIodGhpcy5fbWFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcm9wcy5nZXRNYXBib3hSZWYpIHtcbiAgICAgICAgLy8gVGhlIHBhcmVudCBjb21wb25lbnQgY2FuIGdhaW4gYWNjZXNzIHRvIG91ciBNYXBib3hHbE1hcCBieVxuICAgICAgICAvLyBwcm92aWRpbmcgdGhpcyBjYWxsYmFjay4gTm90ZSB0aGF0ICdtYXBib3gnIHdpbGwgYmUgbnVsbCB3aGVuIHRoZVxuICAgICAgICAvLyByZWYgaXMgdW5zZXQgKGUuZy4gd2hlbiBhIHNwbGl0IG1hcCBpcyBjbG9zZWQpLlxuICAgICAgICB0aGlzLnByb3BzLmdldE1hcGJveFJlZihtYXBib3gsIHRoaXMucHJvcHMuaW5kZXgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfb25EZWNrSW5pdGlhbGl6ZWQoZ2wpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLm9uRGVja0luaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25EZWNrSW5pdGlhbGl6ZWQodGhpcy5fZGVjaywgZ2wpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9vbkJlZm9yZVJlbmRlciA9ICh7Z2x9KSA9PiB7XG4gICAgICBzZXRMYXllckJsZW5kaW5nKGdsLCB0aGlzLnByb3BzLmxheWVyQmxlbmRpbmcpO1xuICAgIH07XG5cbiAgICBfb25EZWNrRXJyb3IgPSAoZXJyb3IsIGxheWVyKSA9PiB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgQW4gZXJyb3IgaW4gZGVjay5nbDogJHtlcnJvci5tZXNzYWdlfSBpbiAke2xheWVyLmlkfWA7XG4gICAgICBjb25zdCBub3RpZmljYXRpb25JZCA9IGAke2xheWVyLmlkfS0ke2Vycm9yLm1lc3NhZ2V9YDtcblxuICAgICAgLy8gVGhyb3R0bGUgZXJyb3Igbm90aWZpY2F0aW9ucywgYXMgUmVhY3QgZG9lc24ndCBsaWtlIHRvbyBtYW55IHN0YXRlIGNoYW5nZXMgZnJvbSBoZXJlLlxuICAgICAgdGhpcy5fZGVja0dMRXJyb3JzRWxhcHNlZCA9IHRoaXMuX2RlY2tHTEVycm9yc0VsYXBzZWQgfHwge307XG4gICAgICBjb25zdCBsYXN0U2hvd24gPSB0aGlzLl9kZWNrR0xFcnJvcnNFbGFwc2VkW25vdGlmaWNhdGlvbklkXTtcbiAgICAgIGlmICghbGFzdFNob3duIHx8IGxhc3RTaG93biA8IERhdGUubm93KCkgLSBUSFJPVFRMRV9OT1RJRklDQVRJT05fVElNRSkge1xuICAgICAgICB0aGlzLl9kZWNrR0xFcnJvcnNFbGFwc2VkW25vdGlmaWNhdGlvbklkXSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBlcnJvciBub3RpZmljYXRpb24gb3IgdXBkYXRlIGV4aXN0aW5nIG9uZSB3aXRoIHNhbWUgaWQuXG4gICAgICAgIC8vIFVwZGF0ZSBpcyByZXF1aXJlZCB0byBwcmVzZXJ2ZSB0aGUgb3JkZXIgb2Ygbm90aWZpY2F0aW9ucyBhcyB0aGV5IHByb2JhYmx5IGFyZSBnb2luZyB0byBcImp1bXBcIiBiYXNlZCBvbiBvcmRlciBvZiBlcnJvcnMuXG4gICAgICAgIGNvbnN0IHt1aVN0YXRlQWN0aW9uc30gPSB0aGlzLnByb3BzO1xuICAgICAgICB1aVN0YXRlQWN0aW9ucy5hZGROb3RpZmljYXRpb24oXG4gICAgICAgICAgZXJyb3JOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgaWQ6IG5vdGlmaWNhdGlvbklkXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbnMgKi9cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgICBfcmVuZGVyTWFwUG9wb3ZlcihsYXllcnNUb1JlbmRlcikge1xuICAgICAgLy8gVE9ETzogbW92ZSB0aGlzIGludG8gcmVkdWNlciBzbyBpdCBjYW4gYmUgdGVzdGVkXG4gICAgICBjb25zdCB7XG4gICAgICAgIG1hcFN0YXRlLFxuICAgICAgICBob3ZlckluZm8sXG4gICAgICAgIGNsaWNrZWQsXG4gICAgICAgIGRhdGFzZXRzLFxuICAgICAgICBpbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAgICAgbGF5ZXJzLFxuICAgICAgICBtb3VzZVBvczoge21vdXNlUG9zaXRpb24sIGNvb3JkaW5hdGUsIHBpbm5lZH1cbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICBpZiAoIW1vdXNlUG9zaXRpb24gfHwgIWludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxheWVySG92ZXJQcm9wID0gZ2V0TGF5ZXJIb3ZlclByb3Aoe1xuICAgICAgICBpbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAgICAgaG92ZXJJbmZvLFxuICAgICAgICBsYXllcnMsXG4gICAgICAgIGxheWVyc1RvUmVuZGVyLFxuICAgICAgICBkYXRhc2V0c1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNvbXBhcmVNb2RlID0gaW50ZXJhY3Rpb25Db25maWcudG9vbHRpcC5jb25maWdcbiAgICAgICAgPyBpbnRlcmFjdGlvbkNvbmZpZy50b29sdGlwLmNvbmZpZy5jb21wYXJlTW9kZVxuICAgICAgICA6IGZhbHNlO1xuXG4gICAgICBsZXQgcGlubmVkUG9zaXRpb24gPSB7fTtcbiAgICAgIGxldCBsYXllclBpbm5lZFByb3AgPSBudWxsO1xuICAgICAgaWYgKHBpbm5lZCB8fCBjbGlja2VkKSB7XG4gICAgICAgIC8vIHByb2plY3QgbG5nbGF0IHRvIHNjcmVlbiBzbyB0aGF0IHRvb2x0aXAgZm9sbG93cyB0aGUgb2JqZWN0IG9uIHpvb21cbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydChtYXBTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGxuZ0xhdCA9IGNsaWNrZWQgPyBjbGlja2VkLmxuZ0xhdCA6IHBpbm5lZC5jb29yZGluYXRlO1xuICAgICAgICBwaW5uZWRQb3NpdGlvbiA9IHRoaXMuX2dldEhvdmVyWFkodmlld3BvcnQsIGxuZ0xhdCk7XG4gICAgICAgIGxheWVyUGlubmVkUHJvcCA9IGdldExheWVySG92ZXJQcm9wKHtcbiAgICAgICAgICBpbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAgICAgICBob3ZlckluZm86IGNsaWNrZWQsXG4gICAgICAgICAgbGF5ZXJzLFxuICAgICAgICAgIGxheWVyc1RvUmVuZGVyLFxuICAgICAgICAgIGRhdGFzZXRzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobGF5ZXJIb3ZlclByb3AgJiYgbGF5ZXJQaW5uZWRQcm9wKSB7XG4gICAgICAgICAgbGF5ZXJIb3ZlclByb3AucHJpbWFyeURhdGEgPSBsYXllclBpbm5lZFByb3AuZGF0YTtcbiAgICAgICAgICBsYXllckhvdmVyUHJvcC5jb21wYXJlVHlwZSA9IGludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAuY29uZmlnLmNvbXBhcmVUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbW1vblByb3AgPSB7XG4gICAgICAgIG9uQ2xvc2U6IHRoaXMuX29uQ2xvc2VNYXBQb3BvdmVyLFxuICAgICAgICB6b29tOiBtYXBTdGF0ZS56b29tLFxuICAgICAgICBjb250YWluZXI6IHRoaXMuX2RlY2sgPyB0aGlzLl9kZWNrLmNhbnZhcyA6IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPEVycm9yQm91bmRhcnk+XG4gICAgICAgICAge2xheWVyUGlubmVkUHJvcCAmJiAoXG4gICAgICAgICAgICA8TWFwUG9wb3ZlclxuICAgICAgICAgICAgICB7Li4ucGlubmVkUG9zaXRpb259XG4gICAgICAgICAgICAgIHsuLi5jb21tb25Qcm9wfVxuICAgICAgICAgICAgICBsYXllckhvdmVyUHJvcD17bGF5ZXJQaW5uZWRQcm9wfVxuICAgICAgICAgICAgICBjb29yZGluYXRlPXtpbnRlcmFjdGlvbkNvbmZpZy5jb29yZGluYXRlLmVuYWJsZWQgJiYgKHBpbm5lZCB8fCB7fSkuY29vcmRpbmF0ZX1cbiAgICAgICAgICAgICAgZnJvemVuPXt0cnVlfVxuICAgICAgICAgICAgICBpc0Jhc2U9e2NvbXBhcmVNb2RlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApfVxuICAgICAgICAgIHtsYXllckhvdmVyUHJvcCAmJiAoIWxheWVyUGlubmVkUHJvcCB8fCBjb21wYXJlTW9kZSkgJiYgKFxuICAgICAgICAgICAgPE1hcFBvcG92ZXJcbiAgICAgICAgICAgICAgeD17bW91c2VQb3NpdGlvblswXX1cbiAgICAgICAgICAgICAgeT17bW91c2VQb3NpdGlvblsxXX1cbiAgICAgICAgICAgICAgey4uLmNvbW1vblByb3B9XG4gICAgICAgICAgICAgIGxheWVySG92ZXJQcm9wPXtsYXllckhvdmVyUHJvcH1cbiAgICAgICAgICAgICAgZnJvemVuPXtmYWxzZX1cbiAgICAgICAgICAgICAgY29vcmRpbmF0ZT17aW50ZXJhY3Rpb25Db25maWcuY29vcmRpbmF0ZS5lbmFibGVkICYmIGNvb3JkaW5hdGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvRXJyb3JCb3VuZGFyeT5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbiAgICBfZ2V0SG92ZXJYWSh2aWV3cG9ydCwgbG5nTGF0KSB7XG4gICAgICBjb25zdCBzY3JlZW5Db29yZCA9ICF2aWV3cG9ydCB8fCAhbG5nTGF0ID8gbnVsbCA6IHZpZXdwb3J0LnByb2plY3QobG5nTGF0KTtcbiAgICAgIHJldHVybiBzY3JlZW5Db29yZCAmJiB7eDogc2NyZWVuQ29vcmRbMF0sIHk6IHNjcmVlbkNvb3JkWzFdfTtcbiAgICB9XG5cbiAgICBfcmVuZGVyRGVja092ZXJsYXkobGF5ZXJzRm9yRGVjaykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYXBTdGF0ZSxcbiAgICAgICAgbWFwU3R5bGUsXG4gICAgICAgIGxheWVyRGF0YSxcbiAgICAgICAgbGF5ZXJPcmRlcixcbiAgICAgICAgbGF5ZXJzLFxuICAgICAgICB2aXNTdGF0ZUFjdGlvbnMsXG4gICAgICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgICAgICBtYXBib3hBcGlVcmxcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAvLyBpbml0aWFsaXNlIGxheWVycyBmcm9tIHByb3BzIGlmIGV4aXN0c1xuICAgICAgbGV0IGRlY2tHbExheWVycyA9IHRoaXMucHJvcHMuZGVja0dsUHJvcHM/LmxheWVycyB8fCBbXTtcblxuICAgICAgLy8gd2FpdCB1bnRpbCBkYXRhIGlzIHJlYWR5IGJlZm9yZSByZW5kZXIgZGF0YSBsYXllcnNcbiAgICAgIGlmIChsYXllckRhdGEgJiYgbGF5ZXJEYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBsYXN0IGxheWVyIHJlbmRlciBmaXJzdFxuICAgICAgICBjb25zdCBkYXRhTGF5ZXJzID0gbGF5ZXJPcmRlclxuICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgIC5maWx0ZXIoaWR4ID0+IGxheWVyc0ZvckRlY2tbbGF5ZXJzW2lkeF0uaWRdKVxuICAgICAgICAgIC5yZWR1Y2UoKG92ZXJsYXlzLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgICBvblNldExheWVyRG9tYWluOiB2YWwgPT4gdGhpcy5fb25MYXllclNldERvbWFpbihpZHgsIHZhbClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBsYXllck92ZXJsYXkgPSByZW5kZXJEZWNrR2xMYXllcih0aGlzLnByb3BzLCBsYXllckNhbGxiYWNrcywgaWR4KTtcbiAgICAgICAgICAgIHJldHVybiBvdmVybGF5cy5jb25jYXQobGF5ZXJPdmVybGF5IHx8IFtdKTtcbiAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIGRlY2tHbExheWVycyA9IGRlY2tHbExheWVycy5jb25jYXQoZGF0YUxheWVycyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXBTdHlsZS52aXNpYmxlTGF5ZXJHcm91cHNbJzNkIGJ1aWxkaW5nJ10pIHtcbiAgICAgICAgZGVja0dsTGF5ZXJzLnB1c2goXG4gICAgICAgICAgbmV3IFRocmVlREJ1aWxkaW5nTGF5ZXIoe1xuICAgICAgICAgICAgaWQ6ICdfa2VwbGVyZ2xfM2QtYnVpbGRpbmcnLFxuICAgICAgICAgICAgbWFwYm94QXBpQWNjZXNzVG9rZW4sXG4gICAgICAgICAgICBtYXBib3hBcGlVcmwsXG4gICAgICAgICAgICB0aHJlZURCdWlsZGluZ0NvbG9yOiBtYXBTdHlsZS50aHJlZURCdWlsZGluZ0NvbG9yLFxuICAgICAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgICAgICAgZ2V0RmlsbENvbG9yOiBtYXBTdHlsZS50aHJlZURCdWlsZGluZ0NvbG9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPERlY2tHTFxuICAgICAgICAgIHsuLi50aGlzLnByb3BzLmRlY2tHbFByb3BzfVxuICAgICAgICAgIHZpZXdTdGF0ZT17bWFwU3RhdGV9XG4gICAgICAgICAgaWQ9XCJkZWZhdWx0LWRlY2tnbC1vdmVybGF5XCJcbiAgICAgICAgICBsYXllcnM9e2RlY2tHbExheWVyc31cbiAgICAgICAgICBvbkJlZm9yZVJlbmRlcj17dGhpcy5fb25CZWZvcmVSZW5kZXJ9XG4gICAgICAgICAgb25Ib3Zlcj17dmlzU3RhdGVBY3Rpb25zLm9uTGF5ZXJIb3Zlcn1cbiAgICAgICAgICBvbkNsaWNrPXt2aXNTdGF0ZUFjdGlvbnMub25MYXllckNsaWNrfVxuICAgICAgICAgIG9uRXJyb3I9e3RoaXMuX29uRGVja0Vycm9yfVxuICAgICAgICAgIHJlZj17Y29tcCA9PiB7XG4gICAgICAgICAgICBpZiAoY29tcCAmJiBjb21wLmRlY2sgJiYgIXRoaXMuX2RlY2spIHtcbiAgICAgICAgICAgICAgdGhpcy5fZGVjayA9IGNvbXAuZGVjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fVxuICAgICAgICAgIG9uV2ViR0xJbml0aWFsaXplZD17Z2wgPT4gdGhpcy5fb25EZWNrSW5pdGlhbGl6ZWQoZ2wpfVxuICAgICAgICAvPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBfdXBkYXRlTWFwYm94TGF5ZXJzKCkge1xuICAgICAgY29uc3QgbWFwYm94TGF5ZXJzID0gdGhpcy5tYXBib3hMYXllcnNTZWxlY3Rvcih0aGlzLnByb3BzKTtcbiAgICAgIGlmICghT2JqZWN0LmtleXMobWFwYm94TGF5ZXJzKS5sZW5ndGggJiYgIU9iamVjdC5rZXlzKHRoaXMucHJldmlvdXNMYXllcnMpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZU1hcGJveExheWVycyh0aGlzLl9tYXAsIG1hcGJveExheWVycywgdGhpcy5wcmV2aW91c0xheWVycyk7XG5cbiAgICAgIHRoaXMucHJldmlvdXNMYXllcnMgPSBtYXBib3hMYXllcnM7XG4gICAgfVxuXG4gICAgX3JlbmRlck1hcGJveE92ZXJsYXlzKCkge1xuICAgICAgaWYgKHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaXNTdHlsZUxvYWRlZCgpKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU1hcGJveExheWVycygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9vblZpZXdwb3J0Q2hhbmdlID0gdmlld1N0YXRlID0+IHtcbiAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCAuLi5yZXN0Vmlld1N0YXRlfSA9IHZpZXdTdGF0ZTtcbiAgICAgIGNvbnN0IHtwcmltYXJ5fSA9IHRoaXMucHJvcHM7XG4gICAgICAvLyByZWFjdC1tYXAtZ2wgc2VuZHMgMCwwIGRpbWVuc2lvbnMgZHVyaW5nIGluaXRpYWxpemF0aW9uXG4gICAgICAvLyBhZnRlciB3ZSBoYXZlIHJlY2VpdmVkIHByb3BlciBkaW1lbnNpb25zIGZyb20gb2JzZXJ2ZURpbWVuc2lvbnNcbiAgICAgIGNvbnN0IG5leHQgPSB7XG4gICAgICAgIC4uLih3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/IHZpZXdTdGF0ZSA6IHJlc3RWaWV3U3RhdGUpLFxuICAgICAgICAvLyBlbmFibGluZyB0cmFuc2l0aW9uIGluIHR3byBtYXBzIG1heSBsZWFkIHRvIGVuZGxlc3MgdXBkYXRlIGxvb3BzXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogcHJpbWFyeSA/IFRSQU5TSVRJT05fRFVSQVRJT04gOiAwXG4gICAgICB9O1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uVmlld1N0YXRlQ2hhbmdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25WaWV3U3RhdGVDaGFuZ2UobmV4dCk7XG4gICAgICB9XG4gICAgICB0aGlzLnByb3BzLm1hcFN0YXRlQWN0aW9ucy51cGRhdGVNYXAobmV4dCk7XG4gICAgfTtcblxuICAgIF90b2dnbGVNYXBDb250cm9sID0gcGFuZWxJZCA9PiB7XG4gICAgICBjb25zdCB7aW5kZXgsIHVpU3RhdGVBY3Rpb25zfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgIHVpU3RhdGVBY3Rpb25zLnRvZ2dsZU1hcENvbnRyb2wocGFuZWxJZCwgaW5kZXgpO1xuICAgIH07XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4gICAgX3JlbmRlck1hcCgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFwU3RhdGUsXG4gICAgICAgIG1hcFN0eWxlLFxuICAgICAgICBtYXBTdGF0ZUFjdGlvbnMsXG4gICAgICAgIGxheWVycyxcbiAgICAgICAgTWFwQ29tcG9uZW50LFxuICAgICAgICBkYXRhc2V0cyxcbiAgICAgICAgbWFwYm94QXBpQWNjZXNzVG9rZW4sXG4gICAgICAgIG1hcGJveEFwaVVybCxcbiAgICAgICAgbWFwQ29udHJvbHMsXG4gICAgICAgIGlzRXhwb3J0LFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIHVpU3RhdGVBY3Rpb25zLFxuICAgICAgICB2aXNTdGF0ZUFjdGlvbnMsXG4gICAgICAgIGludGVyYWN0aW9uQ29uZmlnLFxuICAgICAgICBlZGl0b3IsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBwcmltYXJ5XG4gICAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgY29uc3QgbGF5ZXJzVG9SZW5kZXIgPSB0aGlzLmxheWVyc1RvUmVuZGVyU2VsZWN0b3IodGhpcy5wcm9wcyk7XG4gICAgICBjb25zdCBsYXllcnNGb3JEZWNrID0gdGhpcy5sYXllcnNGb3JEZWNrU2VsZWN0b3IodGhpcy5wcm9wcyk7XG5cbiAgICAgIGNvbnN0IG1hcFByb3BzID0ge1xuICAgICAgICAuLi5tYXBTdGF0ZSxcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZSxcbiAgICAgICAgbWFwYm94QXBpQWNjZXNzVG9rZW4sXG4gICAgICAgIG1hcGJveEFwaVVybCxcbiAgICAgICAgb25WaWV3cG9ydENoYW5nZTogdGhpcy5fb25WaWV3cG9ydENoYW5nZSxcbiAgICAgICAgdHJhbnNmb3JtUmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgY29uc3QgaXNFZGl0ID0gKG1hcENvbnRyb2xzLm1hcERyYXcgfHwge30pLmFjdGl2ZTtcblxuICAgICAgY29uc3QgaGFzR2VvY29kZXJMYXllciA9IGxheWVycy5maW5kKGwgPT4gbC5pZCA9PT0gR0VPQ09ERVJfTEFZRVJfSUQpO1xuICAgICAgY29uc3QgaXNTcGxpdCA9IEJvb2xlYW4obWFwU3RhdGUuaXNTcGxpdCk7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPE1hcENvbnRyb2xcbiAgICAgICAgICAgIGRhdGFzZXRzPXtkYXRhc2V0c31cbiAgICAgICAgICAgIGF2YWlsYWJsZUxvY2FsZXM9e09iamVjdC5rZXlzKExPQ0FMRV9DT0RFUyl9XG4gICAgICAgICAgICBkcmFnUm90YXRlPXttYXBTdGF0ZS5kcmFnUm90YXRlfVxuICAgICAgICAgICAgaXNTcGxpdD17aXNTcGxpdH1cbiAgICAgICAgICAgIHByaW1hcnk9e3ByaW1hcnl9XG4gICAgICAgICAgICBpc0V4cG9ydD17aXNFeHBvcnR9XG4gICAgICAgICAgICBsYXllcnM9e2xheWVyc31cbiAgICAgICAgICAgIGxheWVyc1RvUmVuZGVyPXtsYXllcnNUb1JlbmRlcn1cbiAgICAgICAgICAgIG1hcEluZGV4PXtpbmRleH1cbiAgICAgICAgICAgIG1hcENvbnRyb2xzPXttYXBDb250cm9sc31cbiAgICAgICAgICAgIHJlYWRPbmx5PXt0aGlzLnByb3BzLnJlYWRPbmx5fVxuICAgICAgICAgICAgc2NhbGU9e21hcFN0YXRlLnNjYWxlIHx8IDF9XG4gICAgICAgICAgICB0b3A9e2ludGVyYWN0aW9uQ29uZmlnLmdlb2NvZGVyICYmIGludGVyYWN0aW9uQ29uZmlnLmdlb2NvZGVyLmVuYWJsZWQgPyA1MiA6IDB9XG4gICAgICAgICAgICBlZGl0b3I9e2VkaXRvcn1cbiAgICAgICAgICAgIGxvY2FsZT17bG9jYWxlfVxuICAgICAgICAgICAgb25Ub2dnbGVQZXJzcGVjdGl2ZT17bWFwU3RhdGVBY3Rpb25zLnRvZ2dsZVBlcnNwZWN0aXZlfVxuICAgICAgICAgICAgb25Ub2dnbGVTcGxpdE1hcD17bWFwU3RhdGVBY3Rpb25zLnRvZ2dsZVNwbGl0TWFwfVxuICAgICAgICAgICAgb25NYXBUb2dnbGVMYXllcj17dGhpcy5faGFuZGxlTWFwVG9nZ2xlTGF5ZXJ9XG4gICAgICAgICAgICBvblRvZ2dsZU1hcENvbnRyb2w9e3RoaXMuX3RvZ2dsZU1hcENvbnRyb2x9XG4gICAgICAgICAgICBvblNldEVkaXRvck1vZGU9e3Zpc1N0YXRlQWN0aW9ucy5zZXRFZGl0b3JNb2RlfVxuICAgICAgICAgICAgb25TZXRMb2NhbGU9e3VpU3RhdGVBY3Rpb25zLnNldExvY2FsZX1cbiAgICAgICAgICAgIG9uVG9nZ2xlRWRpdG9yVmlzaWJpbGl0eT17dmlzU3RhdGVBY3Rpb25zLnRvZ2dsZUVkaXRvclZpc2liaWxpdHl9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8TWFwQ29tcG9uZW50XG4gICAgICAgICAgICB7Li4ubWFwUHJvcHN9XG4gICAgICAgICAgICBrZXk9XCJib3R0b21cIlxuICAgICAgICAgICAgcmVmPXt0aGlzLl9zZXRNYXBib3hNYXB9XG4gICAgICAgICAgICBtYXBTdHlsZT17bWFwU3R5bGUuYm90dG9tTWFwU3R5bGV9XG4gICAgICAgICAgICBnZXRDdXJzb3I9e3RoaXMucHJvcHMuaG92ZXJJbmZvID8gKCkgPT4gJ3BvaW50ZXInIDogdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25Nb3VzZU1vdmU9e3RoaXMucHJvcHMudmlzU3RhdGVBY3Rpb25zLm9uTW91c2VNb3ZlfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt0aGlzLl9yZW5kZXJEZWNrT3ZlcmxheShsYXllcnNGb3JEZWNrKX1cbiAgICAgICAgICAgIHt0aGlzLl9yZW5kZXJNYXBib3hPdmVybGF5cygpfVxuICAgICAgICAgICAgPEVkaXRvclxuICAgICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICAgIGRhdGFzZXRzPXtkYXRhc2V0c31cbiAgICAgICAgICAgICAgZWRpdG9yPXtlZGl0b3J9XG4gICAgICAgICAgICAgIGZpbHRlcnM9e3RoaXMucG9seWdvbkZpbHRlcnModGhpcy5wcm9wcyl9XG4gICAgICAgICAgICAgIGlzRW5hYmxlZD17aXNFZGl0fVxuICAgICAgICAgICAgICBsYXllcnM9e2xheWVyc31cbiAgICAgICAgICAgICAgbGF5ZXJzVG9SZW5kZXI9e2xheWVyc1RvUmVuZGVyfVxuICAgICAgICAgICAgICBvbkRlbGV0ZUZlYXR1cmU9e3Zpc1N0YXRlQWN0aW9ucy5kZWxldGVGZWF0dXJlfVxuICAgICAgICAgICAgICBvblNlbGVjdD17dmlzU3RhdGVBY3Rpb25zLnNldFNlbGVjdGVkRmVhdHVyZX1cbiAgICAgICAgICAgICAgb25VcGRhdGU9e3Zpc1N0YXRlQWN0aW9ucy5zZXRGZWF0dXJlc31cbiAgICAgICAgICAgICAgb25Ub2dnbGVQb2x5Z29uRmlsdGVyPXt2aXNTdGF0ZUFjdGlvbnMuc2V0UG9seWdvbkZpbHRlckxheWVyfVxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IGlzRWRpdCA/ICdhbGwnIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGVkaXRvci52aXNpYmxlID8gJ2Jsb2NrJyA6ICdub25lJ1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L01hcENvbXBvbmVudD5cbiAgICAgICAgICB7bWFwU3R5bGUudG9wTWFwU3R5bGUgfHwgaGFzR2VvY29kZXJMYXllciA/IChcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e01BUF9TVFlMRS50b3B9PlxuICAgICAgICAgICAgICA8TWFwQ29tcG9uZW50IHsuLi5tYXBQcm9wc30ga2V5PVwidG9wXCIgbWFwU3R5bGU9e21hcFN0eWxlLnRvcE1hcFN0eWxlfT5cbiAgICAgICAgICAgICAgICB7dGhpcy5fcmVuZGVyRGVja092ZXJsYXkoe1tHRU9DT0RFUl9MQVlFUl9JRF06IHRydWV9KX1cbiAgICAgICAgICAgICAgPC9NYXBDb21wb25lbnQ+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICB7dGhpcy5fcmVuZGVyTWFwUG9wb3ZlcihsYXllcnNUb1JlbmRlcil9XG4gICAgICAgICAgeyFpc1NwbGl0IHx8IGluZGV4ID09PSAxID8gPEF0dHJpYnV0aW9uIC8+IDogbnVsbH1cbiAgICAgICAgPC8+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgIGNvbnN0IHttYXBTdGF0ZSwgbWFwU3R5bGV9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxTdHlsZWRNYXBDb250YWluZXIgcmVmPXt0aGlzLl9yZWZ9IHN0eWxlPXtNQVBfU1RZTEUuY29udGFpbmVyfSBnbG9iZT17bWFwU3RhdGUuZ2xvYmV9PlxuICAgICAgICAgIHttYXBTdHlsZS5ib3R0b21NYXBTdHlsZSAmJiB0aGlzLl9yZW5kZXJNYXAoKX1cbiAgICAgICAgPC9TdHlsZWRNYXBDb250YWluZXI+XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIE1hcENvbnRhaW5lci5kaXNwbGF5TmFtZSA9ICdNYXBDb250YWluZXInO1xuXG4gIHJldHVybiBNYXBDb250YWluZXI7XG59XG4iXX0=