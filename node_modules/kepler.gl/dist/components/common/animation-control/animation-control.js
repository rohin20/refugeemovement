"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _taggedTemplateLiteral2 = _interopRequireDefault(require("@babel/runtime/helpers/taggedTemplateLiteral"));

var _react = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _slider = _interopRequireDefault(require("../slider/slider"));

var _styledComponents2 = require("../styled-components");

var _playbackControls = _interopRequireDefault(require("./playback-controls"));

var _floatingTimeDisplay = _interopRequireDefault(require("./floating-time-display"));

var _dataUtils = require("../../../utils/data-utils");

var _defaultSettings = require("../../../constants/default-settings");

var _templateObject, _templateObject2, _templateObject3;

var SliderWrapper = _styledComponents["default"].div(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["\n  display: flex;\n  position: relative;\n  flex-grow: 1;\n  margin-right: 24px;\n  margin-left: 24px;\n"])));

var AnimationWidgetInner = _styledComponents["default"].div(_templateObject2 || (_templateObject2 = (0, _taggedTemplateLiteral2["default"])(["\n  position: relative;\n  display: flex;\n  align-items: center;\n  height: 32px;\n\n  .playback-controls {\n    margin-left: -8px;\n    margin-right: 16px;\n  }\n"])));

var StyledDomain = _styledComponents["default"].div.attrs({
  className: 'animation-control__time-domain'
})(_templateObject3 || (_templateObject3 = (0, _taggedTemplateLiteral2["default"])(["\n  color: ", ";\n  font-weight: 400;\n  font-size: 10px;\n"])), function (props) {
  return props.theme.titleTextColor;
});

AnimationControlFactory.deps = [_playbackControls["default"], _floatingTimeDisplay["default"]];

function AnimationControlFactory(PlaybackControls, FloatingTimeDisplay) {
  var AnimationControl = function AnimationControl(_ref) {
    var isAnimatable = _ref.isAnimatable,
        isAnimating = _ref.isAnimating,
        resetAnimation = _ref.resetAnimation,
        toggleAnimation = _ref.toggleAnimation,
        setLayerAnimationTime = _ref.setLayerAnimationTime,
        updateAnimationSpeed = _ref.updateAnimationSpeed,
        animationConfig = _ref.animationConfig;
    var currentTime = animationConfig.currentTime,
        domain = animationConfig.domain,
        speed = animationConfig.speed,
        step = animationConfig.step,
        timeSteps = animationConfig.timeSteps,
        timeFormat = animationConfig.timeFormat,
        timezone = animationConfig.timezone,
        defaultTimeFormat = animationConfig.defaultTimeFormat;
    var onSlider1Change = (0, _react.useCallback)(function (val) {
      if (Array.isArray(timeSteps)) {
        setLayerAnimationTime((0, _dataUtils.snapToMarks)(val, timeSteps)); // TODO: merge slider in to avoid this step
      } else if (val >= domain[0] && val <= domain[1]) {
        setLayerAnimationTime(val);
      }
    }, [domain, timeSteps, setLayerAnimationTime]);
    var dateFunc = (0, _react.useMemo)(function () {
      var hasUserFormat = typeof timeFormat === 'string';
      var currentFormat = (hasUserFormat ? timeFormat : defaultTimeFormat) || _defaultSettings.DEFAULT_TIME_FORMAT;
      return (0, _dataUtils.datetimeFormatter)(timezone)(currentFormat);
    }, [timeFormat, defaultTimeFormat, timezone]);
    var timeStart = (0, _react.useMemo)(function () {
      return domain ? dateFunc(domain[0]) : '';
    }, [domain, dateFunc]);
    var timeEnd = (0, _react.useMemo)(function () {
      return domain ? dateFunc(domain[1]) : '';
    }, [domain, dateFunc]);
    return /*#__PURE__*/_react["default"].createElement(_styledComponents2.BottomWidgetInner, {
      className: "bottom-widget--inner"
    }, /*#__PURE__*/_react["default"].createElement(AnimationWidgetInner, {
      className: "animation-widget--inner"
    }, /*#__PURE__*/_react["default"].createElement(PlaybackControls, {
      className: "animation-control-playpause",
      startAnimation: toggleAnimation,
      isAnimating: isAnimating,
      pauseAnimation: toggleAnimation,
      resetAnimation: resetAnimation,
      speed: speed,
      isAnimatable: isAnimatable,
      updateAnimationSpeed: updateAnimationSpeed
    }), /*#__PURE__*/_react["default"].createElement(StyledDomain, {
      className: "domain-start"
    }, /*#__PURE__*/_react["default"].createElement("span", null, timeStart)), /*#__PURE__*/_react["default"].createElement(SliderWrapper, {
      className: "animation-control__slider"
    }, /*#__PURE__*/_react["default"].createElement(_slider["default"], {
      showValues: false,
      isRanged: false,
      step: step,
      minValue: domain ? domain[0] : 0,
      maxValue: domain ? domain[1] : 1,
      value1: currentTime,
      onSlider1Change: onSlider1Change,
      enableBarDrag: true
    })), /*#__PURE__*/_react["default"].createElement(StyledDomain, {
      className: "domain-end"
    }, /*#__PURE__*/_react["default"].createElement("span", null, timeEnd))), /*#__PURE__*/_react["default"].createElement(FloatingTimeDisplay, {
      currentTime: currentTime,
      defaultTimeFormat: defaultTimeFormat,
      timeFormat: timeFormat,
      timezone: timezone
    }));
  };

  AnimationControl.defaultProps = {
    toggleAnimation: function toggleAnimation() {},
    updateAnimationSpeed: function updateAnimationSpeed() {},
    animationControlProps: {},
    animationConfig: {}
  };
  return AnimationControl;
}

var _default = AnimationControlFactory;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9hbmltYXRpb24tY29udHJvbC9hbmltYXRpb24tY29udHJvbC5qcyJdLCJuYW1lcyI6WyJTbGlkZXJXcmFwcGVyIiwic3R5bGVkIiwiZGl2IiwiQW5pbWF0aW9uV2lkZ2V0SW5uZXIiLCJTdHlsZWREb21haW4iLCJhdHRycyIsImNsYXNzTmFtZSIsInByb3BzIiwidGhlbWUiLCJ0aXRsZVRleHRDb2xvciIsIkFuaW1hdGlvbkNvbnRyb2xGYWN0b3J5IiwiZGVwcyIsIlBsYXliYWNrQ29udHJvbHNGYWN0b3J5IiwiRmxvYXRpbmdUaW1lRGlzcGxheUZhY3RvcnkiLCJQbGF5YmFja0NvbnRyb2xzIiwiRmxvYXRpbmdUaW1lRGlzcGxheSIsIkFuaW1hdGlvbkNvbnRyb2wiLCJpc0FuaW1hdGFibGUiLCJpc0FuaW1hdGluZyIsInJlc2V0QW5pbWF0aW9uIiwidG9nZ2xlQW5pbWF0aW9uIiwic2V0TGF5ZXJBbmltYXRpb25UaW1lIiwidXBkYXRlQW5pbWF0aW9uU3BlZWQiLCJhbmltYXRpb25Db25maWciLCJjdXJyZW50VGltZSIsImRvbWFpbiIsInNwZWVkIiwic3RlcCIsInRpbWVTdGVwcyIsInRpbWVGb3JtYXQiLCJ0aW1lem9uZSIsImRlZmF1bHRUaW1lRm9ybWF0Iiwib25TbGlkZXIxQ2hhbmdlIiwidmFsIiwiQXJyYXkiLCJpc0FycmF5IiwiZGF0ZUZ1bmMiLCJoYXNVc2VyRm9ybWF0IiwiY3VycmVudEZvcm1hdCIsIkRFRkFVTFRfVElNRV9GT1JNQVQiLCJ0aW1lU3RhcnQiLCJ0aW1lRW5kIiwiZGVmYXVsdFByb3BzIiwiYW5pbWF0aW9uQ29udHJvbFByb3BzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBRUEsSUFBTUEsYUFBYSxHQUFHQyw2QkFBT0MsR0FBViwrTEFBbkI7O0FBUUEsSUFBTUMsb0JBQW9CLEdBQUdGLDZCQUFPQyxHQUFWLDRQQUExQjs7QUFZQSxJQUFNRSxZQUFZLEdBQUdILDZCQUFPQyxHQUFQLENBQVdHLEtBQVgsQ0FBaUI7QUFDcENDLEVBQUFBLFNBQVMsRUFBRTtBQUR5QixDQUFqQixDQUFILG9KQUdQLFVBQUFDLEtBQUs7QUFBQSxTQUFJQSxLQUFLLENBQUNDLEtBQU4sQ0FBWUMsY0FBaEI7QUFBQSxDQUhFLENBQWxCOztBQVFBQyx1QkFBdUIsQ0FBQ0MsSUFBeEIsR0FBK0IsQ0FBQ0MsNEJBQUQsRUFBMEJDLCtCQUExQixDQUEvQjs7QUFFQSxTQUFTSCx1QkFBVCxDQUFpQ0ksZ0JBQWpDLEVBQW1EQyxtQkFBbkQsRUFBd0U7QUFDdEUsTUFBTUMsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixPQVFuQjtBQUFBLFFBUEpDLFlBT0ksUUFQSkEsWUFPSTtBQUFBLFFBTkpDLFdBTUksUUFOSkEsV0FNSTtBQUFBLFFBTEpDLGNBS0ksUUFMSkEsY0FLSTtBQUFBLFFBSkpDLGVBSUksUUFKSkEsZUFJSTtBQUFBLFFBSEpDLHFCQUdJLFFBSEpBLHFCQUdJO0FBQUEsUUFGSkMsb0JBRUksUUFGSkEsb0JBRUk7QUFBQSxRQURKQyxlQUNJLFFBREpBLGVBQ0k7QUFBQSxRQUVGQyxXQUZFLEdBVUFELGVBVkEsQ0FFRkMsV0FGRTtBQUFBLFFBR0ZDLE1BSEUsR0FVQUYsZUFWQSxDQUdGRSxNQUhFO0FBQUEsUUFJRkMsS0FKRSxHQVVBSCxlQVZBLENBSUZHLEtBSkU7QUFBQSxRQUtGQyxJQUxFLEdBVUFKLGVBVkEsQ0FLRkksSUFMRTtBQUFBLFFBTUZDLFNBTkUsR0FVQUwsZUFWQSxDQU1GSyxTQU5FO0FBQUEsUUFPRkMsVUFQRSxHQVVBTixlQVZBLENBT0ZNLFVBUEU7QUFBQSxRQVFGQyxRQVJFLEdBVUFQLGVBVkEsQ0FRRk8sUUFSRTtBQUFBLFFBU0ZDLGlCQVRFLEdBVUFSLGVBVkEsQ0FTRlEsaUJBVEU7QUFXSixRQUFNQyxlQUFlLEdBQUcsd0JBQ3RCLFVBQUFDLEdBQUcsRUFBSTtBQUNMLFVBQUlDLEtBQUssQ0FBQ0MsT0FBTixDQUFjUCxTQUFkLENBQUosRUFBOEI7QUFDNUJQLFFBQUFBLHFCQUFxQixDQUFDLDRCQUFZWSxHQUFaLEVBQWlCTCxTQUFqQixDQUFELENBQXJCLENBRDRCLENBRzVCO0FBQ0QsT0FKRCxNQUlPLElBQUlLLEdBQUcsSUFBSVIsTUFBTSxDQUFDLENBQUQsQ0FBYixJQUFvQlEsR0FBRyxJQUFJUixNQUFNLENBQUMsQ0FBRCxDQUFyQyxFQUEwQztBQUMvQ0osUUFBQUEscUJBQXFCLENBQUNZLEdBQUQsQ0FBckI7QUFDRDtBQUNGLEtBVHFCLEVBVXRCLENBQUNSLE1BQUQsRUFBU0csU0FBVCxFQUFvQlAscUJBQXBCLENBVnNCLENBQXhCO0FBYUEsUUFBTWUsUUFBUSxHQUFHLG9CQUFRLFlBQU07QUFDN0IsVUFBTUMsYUFBYSxHQUFHLE9BQU9SLFVBQVAsS0FBc0IsUUFBNUM7QUFDQSxVQUFNUyxhQUFhLEdBQUcsQ0FBQ0QsYUFBYSxHQUFHUixVQUFILEdBQWdCRSxpQkFBOUIsS0FBb0RRLG9DQUExRTtBQUNBLGFBQU8sa0NBQWtCVCxRQUFsQixFQUE0QlEsYUFBNUIsQ0FBUDtBQUNELEtBSmdCLEVBSWQsQ0FBQ1QsVUFBRCxFQUFhRSxpQkFBYixFQUFnQ0QsUUFBaEMsQ0FKYyxDQUFqQjtBQU1BLFFBQU1VLFNBQVMsR0FBRyxvQkFBUTtBQUFBLGFBQU9mLE1BQU0sR0FBR1csUUFBUSxDQUFDWCxNQUFNLENBQUMsQ0FBRCxDQUFQLENBQVgsR0FBeUIsRUFBdEM7QUFBQSxLQUFSLEVBQW1ELENBQUNBLE1BQUQsRUFBU1csUUFBVCxDQUFuRCxDQUFsQjtBQUNBLFFBQU1LLE9BQU8sR0FBRyxvQkFBUTtBQUFBLGFBQU9oQixNQUFNLEdBQUdXLFFBQVEsQ0FBQ1gsTUFBTSxDQUFDLENBQUQsQ0FBUCxDQUFYLEdBQXlCLEVBQXRDO0FBQUEsS0FBUixFQUFtRCxDQUFDQSxNQUFELEVBQVNXLFFBQVQsQ0FBbkQsQ0FBaEI7QUFFQSx3QkFDRSxnQ0FBQyxvQ0FBRDtBQUFtQixNQUFBLFNBQVMsRUFBQztBQUE3QixvQkFDRSxnQ0FBQyxvQkFBRDtBQUFzQixNQUFBLFNBQVMsRUFBQztBQUFoQyxvQkFDRSxnQ0FBQyxnQkFBRDtBQUNFLE1BQUEsU0FBUyxFQUFDLDZCQURaO0FBRUUsTUFBQSxjQUFjLEVBQUVoQixlQUZsQjtBQUdFLE1BQUEsV0FBVyxFQUFFRixXQUhmO0FBSUUsTUFBQSxjQUFjLEVBQUVFLGVBSmxCO0FBS0UsTUFBQSxjQUFjLEVBQUVELGNBTGxCO0FBTUUsTUFBQSxLQUFLLEVBQUVPLEtBTlQ7QUFPRSxNQUFBLFlBQVksRUFBRVQsWUFQaEI7QUFRRSxNQUFBLG9CQUFvQixFQUFFSztBQVJ4QixNQURGLGVBV0UsZ0NBQUMsWUFBRDtBQUFjLE1BQUEsU0FBUyxFQUFDO0FBQXhCLG9CQUNFLDhDQUFPa0IsU0FBUCxDQURGLENBWEYsZUFjRSxnQ0FBQyxhQUFEO0FBQWUsTUFBQSxTQUFTLEVBQUM7QUFBekIsb0JBQ0UsZ0NBQUMsa0JBQUQ7QUFDRSxNQUFBLFVBQVUsRUFBRSxLQURkO0FBRUUsTUFBQSxRQUFRLEVBQUUsS0FGWjtBQUdFLE1BQUEsSUFBSSxFQUFFYixJQUhSO0FBSUUsTUFBQSxRQUFRLEVBQUVGLE1BQU0sR0FBR0EsTUFBTSxDQUFDLENBQUQsQ0FBVCxHQUFlLENBSmpDO0FBS0UsTUFBQSxRQUFRLEVBQUVBLE1BQU0sR0FBR0EsTUFBTSxDQUFDLENBQUQsQ0FBVCxHQUFlLENBTGpDO0FBTUUsTUFBQSxNQUFNLEVBQUVELFdBTlY7QUFPRSxNQUFBLGVBQWUsRUFBRVEsZUFQbkI7QUFRRSxNQUFBLGFBQWEsRUFBRTtBQVJqQixNQURGLENBZEYsZUEwQkUsZ0NBQUMsWUFBRDtBQUFjLE1BQUEsU0FBUyxFQUFDO0FBQXhCLG9CQUNFLDhDQUFPUyxPQUFQLENBREYsQ0ExQkYsQ0FERixlQStCRSxnQ0FBQyxtQkFBRDtBQUNFLE1BQUEsV0FBVyxFQUFFakIsV0FEZjtBQUVFLE1BQUEsaUJBQWlCLEVBQUVPLGlCQUZyQjtBQUdFLE1BQUEsVUFBVSxFQUFFRixVQUhkO0FBSUUsTUFBQSxRQUFRLEVBQUVDO0FBSlosTUEvQkYsQ0FERjtBQXdDRCxHQWpGRDs7QUFtRkFkLEVBQUFBLGdCQUFnQixDQUFDMEIsWUFBakIsR0FBZ0M7QUFDOUJ0QixJQUFBQSxlQUFlLEVBQUUsMkJBQU0sQ0FBRSxDQURLO0FBRTlCRSxJQUFBQSxvQkFBb0IsRUFBRSxnQ0FBTSxDQUFFLENBRkE7QUFHOUJxQixJQUFBQSxxQkFBcUIsRUFBRSxFQUhPO0FBSTlCcEIsSUFBQUEsZUFBZSxFQUFFO0FBSmEsR0FBaEM7QUFPQSxTQUFPUCxnQkFBUDtBQUNEOztlQUVjTix1QiIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBSZWFjdCwge3VzZUNhbGxiYWNrLCB1c2VNZW1vfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJztcblxuaW1wb3J0IFNsaWRlciBmcm9tICdjb21wb25lbnRzL2NvbW1vbi9zbGlkZXIvc2xpZGVyJztcbmltcG9ydCB7Qm90dG9tV2lkZ2V0SW5uZXJ9IGZyb20gJ2NvbXBvbmVudHMvY29tbW9uL3N0eWxlZC1jb21wb25lbnRzJztcbmltcG9ydCBQbGF5YmFja0NvbnRyb2xzRmFjdG9yeSBmcm9tICcuL3BsYXliYWNrLWNvbnRyb2xzJztcbmltcG9ydCBGbG9hdGluZ1RpbWVEaXNwbGF5RmFjdG9yeSBmcm9tICcuL2Zsb2F0aW5nLXRpbWUtZGlzcGxheSc7XG5pbXBvcnQge3NuYXBUb01hcmtzLCBkYXRldGltZUZvcm1hdHRlcn0gZnJvbSAndXRpbHMvZGF0YS11dGlscyc7XG5pbXBvcnQge0RFRkFVTFRfVElNRV9GT1JNQVR9IGZyb20gJ2NvbnN0YW50cy9kZWZhdWx0LXNldHRpbmdzJztcblxuY29uc3QgU2xpZGVyV3JhcHBlciA9IHN0eWxlZC5kaXZgXG4gIGRpc3BsYXk6IGZsZXg7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgZmxleC1ncm93OiAxO1xuICBtYXJnaW4tcmlnaHQ6IDI0cHg7XG4gIG1hcmdpbi1sZWZ0OiAyNHB4O1xuYDtcblxuY29uc3QgQW5pbWF0aW9uV2lkZ2V0SW5uZXIgPSBzdHlsZWQuZGl2YFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGhlaWdodDogMzJweDtcblxuICAucGxheWJhY2stY29udHJvbHMge1xuICAgIG1hcmdpbi1sZWZ0OiAtOHB4O1xuICAgIG1hcmdpbi1yaWdodDogMTZweDtcbiAgfVxuYDtcblxuY29uc3QgU3R5bGVkRG9tYWluID0gc3R5bGVkLmRpdi5hdHRycyh7XG4gIGNsYXNzTmFtZTogJ2FuaW1hdGlvbi1jb250cm9sX190aW1lLWRvbWFpbidcbn0pYFxuICBjb2xvcjogJHtwcm9wcyA9PiBwcm9wcy50aGVtZS50aXRsZVRleHRDb2xvcn07XG4gIGZvbnQtd2VpZ2h0OiA0MDA7XG4gIGZvbnQtc2l6ZTogMTBweDtcbmA7XG5cbkFuaW1hdGlvbkNvbnRyb2xGYWN0b3J5LmRlcHMgPSBbUGxheWJhY2tDb250cm9sc0ZhY3RvcnksIEZsb2F0aW5nVGltZURpc3BsYXlGYWN0b3J5XTtcblxuZnVuY3Rpb24gQW5pbWF0aW9uQ29udHJvbEZhY3RvcnkoUGxheWJhY2tDb250cm9scywgRmxvYXRpbmdUaW1lRGlzcGxheSkge1xuICBjb25zdCBBbmltYXRpb25Db250cm9sID0gKHtcbiAgICBpc0FuaW1hdGFibGUsXG4gICAgaXNBbmltYXRpbmcsXG4gICAgcmVzZXRBbmltYXRpb24sXG4gICAgdG9nZ2xlQW5pbWF0aW9uLFxuICAgIHNldExheWVyQW5pbWF0aW9uVGltZSxcbiAgICB1cGRhdGVBbmltYXRpb25TcGVlZCxcbiAgICBhbmltYXRpb25Db25maWdcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRUaW1lLFxuICAgICAgZG9tYWluLFxuICAgICAgc3BlZWQsXG4gICAgICBzdGVwLFxuICAgICAgdGltZVN0ZXBzLFxuICAgICAgdGltZUZvcm1hdCxcbiAgICAgIHRpbWV6b25lLFxuICAgICAgZGVmYXVsdFRpbWVGb3JtYXRcbiAgICB9ID0gYW5pbWF0aW9uQ29uZmlnO1xuICAgIGNvbnN0IG9uU2xpZGVyMUNoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgICAgdmFsID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGltZVN0ZXBzKSkge1xuICAgICAgICAgIHNldExheWVyQW5pbWF0aW9uVGltZShzbmFwVG9NYXJrcyh2YWwsIHRpbWVTdGVwcykpO1xuXG4gICAgICAgICAgLy8gVE9ETzogbWVyZ2Ugc2xpZGVyIGluIHRvIGF2b2lkIHRoaXMgc3RlcFxuICAgICAgICB9IGVsc2UgaWYgKHZhbCA+PSBkb21haW5bMF0gJiYgdmFsIDw9IGRvbWFpblsxXSkge1xuICAgICAgICAgIHNldExheWVyQW5pbWF0aW9uVGltZSh2YWwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2RvbWFpbiwgdGltZVN0ZXBzLCBzZXRMYXllckFuaW1hdGlvblRpbWVdXG4gICAgKTtcblxuICAgIGNvbnN0IGRhdGVGdW5jID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICBjb25zdCBoYXNVc2VyRm9ybWF0ID0gdHlwZW9mIHRpbWVGb3JtYXQgPT09ICdzdHJpbmcnO1xuICAgICAgY29uc3QgY3VycmVudEZvcm1hdCA9IChoYXNVc2VyRm9ybWF0ID8gdGltZUZvcm1hdCA6IGRlZmF1bHRUaW1lRm9ybWF0KSB8fCBERUZBVUxUX1RJTUVfRk9STUFUO1xuICAgICAgcmV0dXJuIGRhdGV0aW1lRm9ybWF0dGVyKHRpbWV6b25lKShjdXJyZW50Rm9ybWF0KTtcbiAgICB9LCBbdGltZUZvcm1hdCwgZGVmYXVsdFRpbWVGb3JtYXQsIHRpbWV6b25lXSk7XG5cbiAgICBjb25zdCB0aW1lU3RhcnQgPSB1c2VNZW1vKCgpID0+IChkb21haW4gPyBkYXRlRnVuYyhkb21haW5bMF0pIDogJycpLCBbZG9tYWluLCBkYXRlRnVuY10pO1xuICAgIGNvbnN0IHRpbWVFbmQgPSB1c2VNZW1vKCgpID0+IChkb21haW4gPyBkYXRlRnVuYyhkb21haW5bMV0pIDogJycpLCBbZG9tYWluLCBkYXRlRnVuY10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3R0b21XaWRnZXRJbm5lciBjbGFzc05hbWU9XCJib3R0b20td2lkZ2V0LS1pbm5lclwiPlxuICAgICAgICA8QW5pbWF0aW9uV2lkZ2V0SW5uZXIgY2xhc3NOYW1lPVwiYW5pbWF0aW9uLXdpZGdldC0taW5uZXJcIj5cbiAgICAgICAgICA8UGxheWJhY2tDb250cm9sc1xuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYW5pbWF0aW9uLWNvbnRyb2wtcGxheXBhdXNlXCJcbiAgICAgICAgICAgIHN0YXJ0QW5pbWF0aW9uPXt0b2dnbGVBbmltYXRpb259XG4gICAgICAgICAgICBpc0FuaW1hdGluZz17aXNBbmltYXRpbmd9XG4gICAgICAgICAgICBwYXVzZUFuaW1hdGlvbj17dG9nZ2xlQW5pbWF0aW9ufVxuICAgICAgICAgICAgcmVzZXRBbmltYXRpb249e3Jlc2V0QW5pbWF0aW9ufVxuICAgICAgICAgICAgc3BlZWQ9e3NwZWVkfVxuICAgICAgICAgICAgaXNBbmltYXRhYmxlPXtpc0FuaW1hdGFibGV9XG4gICAgICAgICAgICB1cGRhdGVBbmltYXRpb25TcGVlZD17dXBkYXRlQW5pbWF0aW9uU3BlZWR9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8U3R5bGVkRG9tYWluIGNsYXNzTmFtZT1cImRvbWFpbi1zdGFydFwiPlxuICAgICAgICAgICAgPHNwYW4+e3RpbWVTdGFydH08L3NwYW4+XG4gICAgICAgICAgPC9TdHlsZWREb21haW4+XG4gICAgICAgICAgPFNsaWRlcldyYXBwZXIgY2xhc3NOYW1lPVwiYW5pbWF0aW9uLWNvbnRyb2xfX3NsaWRlclwiPlxuICAgICAgICAgICAgPFNsaWRlclxuICAgICAgICAgICAgICBzaG93VmFsdWVzPXtmYWxzZX1cbiAgICAgICAgICAgICAgaXNSYW5nZWQ9e2ZhbHNlfVxuICAgICAgICAgICAgICBzdGVwPXtzdGVwfVxuICAgICAgICAgICAgICBtaW5WYWx1ZT17ZG9tYWluID8gZG9tYWluWzBdIDogMH1cbiAgICAgICAgICAgICAgbWF4VmFsdWU9e2RvbWFpbiA/IGRvbWFpblsxXSA6IDF9XG4gICAgICAgICAgICAgIHZhbHVlMT17Y3VycmVudFRpbWV9XG4gICAgICAgICAgICAgIG9uU2xpZGVyMUNoYW5nZT17b25TbGlkZXIxQ2hhbmdlfVxuICAgICAgICAgICAgICBlbmFibGVCYXJEcmFnPXt0cnVlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L1NsaWRlcldyYXBwZXI+XG4gICAgICAgICAgPFN0eWxlZERvbWFpbiBjbGFzc05hbWU9XCJkb21haW4tZW5kXCI+XG4gICAgICAgICAgICA8c3Bhbj57dGltZUVuZH08L3NwYW4+XG4gICAgICAgICAgPC9TdHlsZWREb21haW4+XG4gICAgICAgIDwvQW5pbWF0aW9uV2lkZ2V0SW5uZXI+XG4gICAgICAgIDxGbG9hdGluZ1RpbWVEaXNwbGF5XG4gICAgICAgICAgY3VycmVudFRpbWU9e2N1cnJlbnRUaW1lfVxuICAgICAgICAgIGRlZmF1bHRUaW1lRm9ybWF0PXtkZWZhdWx0VGltZUZvcm1hdH1cbiAgICAgICAgICB0aW1lRm9ybWF0PXt0aW1lRm9ybWF0fVxuICAgICAgICAgIHRpbWV6b25lPXt0aW1lem9uZX1cbiAgICAgICAgLz5cbiAgICAgIDwvQm90dG9tV2lkZ2V0SW5uZXI+XG4gICAgKTtcbiAgfTtcblxuICBBbmltYXRpb25Db250cm9sLmRlZmF1bHRQcm9wcyA9IHtcbiAgICB0b2dnbGVBbmltYXRpb246ICgpID0+IHt9LFxuICAgIHVwZGF0ZUFuaW1hdGlvblNwZWVkOiAoKSA9PiB7fSxcbiAgICBhbmltYXRpb25Db250cm9sUHJvcHM6IHt9LFxuICAgIGFuaW1hdGlvbkNvbmZpZzoge31cbiAgfTtcblxuICByZXR1cm4gQW5pbWF0aW9uQ29udHJvbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0aW9uQ29udHJvbEZhY3Rvcnk7XG4iXX0=