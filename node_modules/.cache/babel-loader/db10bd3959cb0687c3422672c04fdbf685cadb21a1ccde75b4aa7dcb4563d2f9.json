{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport { getDracoSchema } from './utils/get-draco-schema';\nvar GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\nvar DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\nvar DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\nvar INDEX_ITEM_SIZE = 4;\nvar DracoParser = /*#__PURE__*/function () {\n  function DracoParser(draco) {\n    _classCallCheck(this, DracoParser);\n    _defineProperty(this, \"draco\", void 0);\n    _defineProperty(this, \"decoder\", void 0);\n    _defineProperty(this, \"metadataQuerier\", void 0);\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n  _createClass(DracoParser, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.draco.destroy(this.decoder);\n      this.draco.destroy(this.metadataQuerier);\n    }\n  }, {\n    key: \"parseSync\",\n    value: function parseSync(arrayBuffer) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var buffer = new this.draco.DecoderBuffer();\n      buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n      this._disableAttributeTransforms(options);\n      var geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n      var dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();\n      try {\n        var dracoStatus;\n        switch (geometry_type) {\n          case this.draco.TRIANGULAR_MESH:\n            dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n            break;\n          case this.draco.POINT_CLOUD:\n            dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n            break;\n          default:\n            throw new Error('DRACO: Unknown geometry type.');\n        }\n        if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n          var message = \"DRACO decompression failed: \".concat(dracoStatus.error_msg());\n          throw new Error(message);\n        }\n        var loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n        var geometry = this._getMeshData(dracoGeometry, loaderData, options);\n        var boundingBox = getMeshBoundingBox(geometry.attributes);\n        var schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);\n        var data = _objectSpread(_objectSpread({\n          loader: 'draco',\n          loaderData: loaderData,\n          header: {\n            vertexCount: dracoGeometry.num_points(),\n            boundingBox: boundingBox\n          }\n        }, geometry), {}, {\n          schema: schema\n        });\n        return data;\n      } finally {\n        this.draco.destroy(buffer);\n        if (dracoGeometry) {\n          this.draco.destroy(dracoGeometry);\n        }\n      }\n    }\n  }, {\n    key: \"_getDracoLoaderData\",\n    value: function _getDracoLoaderData(dracoGeometry, geometry_type, options) {\n      var metadata = this._getTopLevelMetadata(dracoGeometry);\n      var attributes = this._getDracoAttributes(dracoGeometry, options);\n      return {\n        geometry_type: geometry_type,\n        num_attributes: dracoGeometry.num_attributes(),\n        num_points: dracoGeometry.num_points(),\n        num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n        metadata: metadata,\n        attributes: attributes\n      };\n    }\n  }, {\n    key: \"_getDracoAttributes\",\n    value: function _getDracoAttributes(dracoGeometry, options) {\n      var dracoAttributes = {};\n      for (var attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n        var dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n        var metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n        dracoAttributes[dracoAttribute.unique_id()] = {\n          unique_id: dracoAttribute.unique_id(),\n          attribute_type: dracoAttribute.attribute_type(),\n          data_type: dracoAttribute.data_type(),\n          num_components: dracoAttribute.num_components(),\n          byte_offset: dracoAttribute.byte_offset(),\n          byte_stride: dracoAttribute.byte_stride(),\n          normalized: dracoAttribute.normalized(),\n          attribute_index: attributeId,\n          metadata: metadata\n        };\n        var quantization = this._getQuantizationTransform(dracoAttribute, options);\n        if (quantization) {\n          dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n        }\n        var octahedron = this._getOctahedronTransform(dracoAttribute, options);\n        if (octahedron) {\n          dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n        }\n      }\n      return dracoAttributes;\n    }\n  }, {\n    key: \"_getMeshData\",\n    value: function _getMeshData(dracoGeometry, loaderData, options) {\n      var attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n      var positionAttribute = attributes.POSITION;\n      if (!positionAttribute) {\n        throw new Error('DRACO: No position attribute found.');\n      }\n      if (dracoGeometry instanceof this.draco.Mesh) {\n        switch (options.topology) {\n          case 'triangle-strip':\n            return {\n              topology: 'triangle-strip',\n              mode: 4,\n              attributes: attributes,\n              indices: {\n                value: this._getTriangleStripIndices(dracoGeometry),\n                size: 1\n              }\n            };\n          case 'triangle-list':\n          default:\n            return {\n              topology: 'triangle-list',\n              mode: 5,\n              attributes: attributes,\n              indices: {\n                value: this._getTriangleListIndices(dracoGeometry),\n                size: 1\n              }\n            };\n        }\n      }\n      return {\n        topology: 'point-list',\n        mode: 0,\n        attributes: attributes\n      };\n    }\n  }, {\n    key: \"_getMeshAttributes\",\n    value: function _getMeshAttributes(loaderData, dracoGeometry, options) {\n      var attributes = {};\n      for (var _i = 0, _Object$values = Object.values(loaderData.attributes); _i < _Object$values.length; _i++) {\n        var loaderAttribute = _Object$values[_i];\n        var attributeName = this._deduceAttributeName(loaderAttribute, options);\n        loaderAttribute.name = attributeName;\n        var _this$_getAttributeVa = this._getAttributeValues(dracoGeometry, loaderAttribute),\n          value = _this$_getAttributeVa.value,\n          size = _this$_getAttributeVa.size;\n        attributes[attributeName] = {\n          value: value,\n          size: size,\n          byteOffset: loaderAttribute.byte_offset,\n          byteStride: loaderAttribute.byte_stride,\n          normalized: loaderAttribute.normalized\n        };\n      }\n      return attributes;\n    }\n  }, {\n    key: \"_getTriangleListIndices\",\n    value: function _getTriangleListIndices(dracoGeometry) {\n      var numFaces = dracoGeometry.num_faces();\n      var numIndices = numFaces * 3;\n      var byteLength = numIndices * INDEX_ITEM_SIZE;\n      var ptr = this.draco._malloc(byteLength);\n      try {\n        this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n        return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n      } finally {\n        this.draco._free(ptr);\n      }\n    }\n  }, {\n    key: \"_getTriangleStripIndices\",\n    value: function _getTriangleStripIndices(dracoGeometry) {\n      var dracoArray = new this.draco.DracoInt32Array();\n      try {\n        this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n        return getUint32Array(dracoArray);\n      } finally {\n        this.draco.destroy(dracoArray);\n      }\n    }\n  }, {\n    key: \"_getAttributeValues\",\n    value: function _getAttributeValues(dracoGeometry, attribute) {\n      var TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n      var numComponents = attribute.num_components;\n      var numPoints = dracoGeometry.num_points();\n      var numValues = numPoints * numComponents;\n      var byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n      var dataType = getDracoDataType(this.draco, TypedArrayCtor);\n      var value;\n      var ptr = this.draco._malloc(byteLength);\n      try {\n        var dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n        this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);\n        value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n      } finally {\n        this.draco._free(ptr);\n      }\n      return {\n        value: value,\n        size: numComponents\n      };\n    }\n  }, {\n    key: \"_deduceAttributeName\",\n    value: function _deduceAttributeName(attribute, options) {\n      var uniqueId = attribute.unique_id;\n      for (var _i2 = 0, _Object$entries = Object.entries(options.extraAttributes || {}); _i2 < _Object$entries.length; _i2++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),\n          attributeName = _Object$entries$_i[0],\n          attributeUniqueId = _Object$entries$_i[1];\n        if (attributeUniqueId === uniqueId) {\n          return attributeName;\n        }\n      }\n      var thisAttributeType = attribute.attribute_type;\n      for (var dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n        var attributeType = this.draco[dracoAttributeConstant];\n        if (attributeType === thisAttributeType) {\n          return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n        }\n      }\n      var entryName = options.attributeNameEntry || 'name';\n      if (attribute.metadata[entryName]) {\n        return attribute.metadata[entryName].string;\n      }\n      return \"CUSTOM_ATTRIBUTE_\".concat(uniqueId);\n    }\n  }, {\n    key: \"_getTopLevelMetadata\",\n    value: function _getTopLevelMetadata(dracoGeometry) {\n      var dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n      return this._getDracoMetadata(dracoMetadata);\n    }\n  }, {\n    key: \"_getAttributeMetadata\",\n    value: function _getAttributeMetadata(dracoGeometry, attributeId) {\n      var dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n      return this._getDracoMetadata(dracoMetadata);\n    }\n  }, {\n    key: \"_getDracoMetadata\",\n    value: function _getDracoMetadata(dracoMetadata) {\n      if (!dracoMetadata || !dracoMetadata.ptr) {\n        return {};\n      }\n      var result = {};\n      var numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n      for (var entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n        var entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n        result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n      }\n      return result;\n    }\n  }, {\n    key: \"_getDracoMetadataField\",\n    value: function _getDracoMetadataField(dracoMetadata, entryName) {\n      var dracoArray = new this.draco.DracoInt32Array();\n      try {\n        this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n        var intArray = getInt32Array(dracoArray);\n        return {\n          int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n          string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n          double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n          intArray: intArray\n        };\n      } finally {\n        this.draco.destroy(dracoArray);\n      }\n    }\n  }, {\n    key: \"_disableAttributeTransforms\",\n    value: function _disableAttributeTransforms(options) {\n      var _options$quantizedAtt = options.quantizedAttributes,\n        quantizedAttributes = _options$quantizedAtt === void 0 ? [] : _options$quantizedAtt,\n        _options$octahedronAt = options.octahedronAttributes,\n        octahedronAttributes = _options$octahedronAt === void 0 ? [] : _options$octahedronAt;\n      var skipAttributes = [].concat(_toConsumableArray(quantizedAttributes), _toConsumableArray(octahedronAttributes));\n      var _iterator = _createForOfIteratorHelper(skipAttributes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dracoAttributeName = _step.value;\n          this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"_getQuantizationTransform\",\n    value: function _getQuantizationTransform(dracoAttribute, options) {\n      var _this = this;\n      var _options$quantizedAtt2 = options.quantizedAttributes,\n        quantizedAttributes = _options$quantizedAtt2 === void 0 ? [] : _options$quantizedAtt2;\n      var attribute_type = dracoAttribute.attribute_type();\n      var skip = quantizedAttributes.map(function (type) {\n        return _this.decoder[type];\n      }).includes(attribute_type);\n      if (skip) {\n        var transform = new this.draco.AttributeQuantizationTransform();\n        try {\n          if (transform.InitFromAttribute(dracoAttribute)) {\n            return {\n              quantization_bits: transform.quantization_bits(),\n              range: transform.range(),\n              min_values: new Float32Array([1, 2, 3]).map(function (i) {\n                return transform.min_value(i);\n              })\n            };\n          }\n        } finally {\n          this.draco.destroy(transform);\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_getOctahedronTransform\",\n    value: function _getOctahedronTransform(dracoAttribute, options) {\n      var _this2 = this;\n      var _options$octahedronAt2 = options.octahedronAttributes,\n        octahedronAttributes = _options$octahedronAt2 === void 0 ? [] : _options$octahedronAt2;\n      var attribute_type = dracoAttribute.attribute_type();\n      var octahedron = octahedronAttributes.map(function (type) {\n        return _this2.decoder[type];\n      }).includes(attribute_type);\n      if (octahedron) {\n        var transform = new this.draco.AttributeQuantizationTransform();\n        try {\n          if (transform.InitFromAttribute(dracoAttribute)) {\n            return {\n              quantization_bits: transform.quantization_bits()\n            };\n          }\n        } finally {\n          this.draco.destroy(transform);\n        }\n      }\n      return null;\n    }\n  }]);\n  return DracoParser;\n}();\nexport { DracoParser as default };\nfunction getDracoDataType(draco, attributeType) {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\nfunction getInt32Array(dracoArray) {\n  var numValues = dracoArray.size();\n  var intArray = new Int32Array(numValues);\n  for (var i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\nfunction getUint32Array(dracoArray) {\n  var numValues = dracoArray.size();\n  var intArray = new Int32Array(numValues);\n  for (var i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}","map":{"version":3,"names":["getMeshBoundingBox","getDracoSchema","GEOMETRY_TYPE","TRIANGULAR_MESH","POINT_CLOUD","DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR","TEX_COORD","DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","INDEX_ITEM_SIZE","DracoParser","draco","_classCallCheck","_defineProperty","decoder","Decoder","metadataQuerier","MetadataQuerier","_createClass","key","value","destroy","parseSync","arrayBuffer","options","arguments","length","undefined","buffer","DecoderBuffer","Init","byteLength","_disableAttributeTransforms","geometry_type","GetEncodedGeometryType","dracoGeometry","Mesh","PointCloud","dracoStatus","DecodeBufferToMesh","DecodeBufferToPointCloud","Error","ok","ptr","message","concat","error_msg","loaderData","_getDracoLoaderData","geometry","_getMeshData","boundingBox","attributes","schema","indices","data","_objectSpread","loader","header","vertexCount","num_points","metadata","_getTopLevelMetadata","_getDracoAttributes","num_attributes","num_faces","dracoAttributes","attributeId","dracoAttribute","GetAttribute","_getAttributeMetadata","unique_id","attribute_type","data_type","num_components","byte_offset","byte_stride","normalized","attribute_index","quantization","_getQuantizationTransform","quantization_transform","octahedron","_getOctahedronTransform","octahedron_transform","_getMeshAttributes","positionAttribute","topology","mode","_getTriangleStripIndices","size","_getTriangleListIndices","_i","_Object$values","Object","values","loaderAttribute","attributeName","_deduceAttributeName","name","_this$_getAttributeVa","_getAttributeValues","byteOffset","byteStride","numFaces","numIndices","_malloc","GetTrianglesUInt32Array","HEAPF32","slice","_free","dracoArray","DracoInt32Array","GetTriangleStripsFromMesh","getUint32Array","attribute","TypedArrayCtor","numComponents","numPoints","numValues","BYTES_PER_ELEMENT","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","uniqueId","_i2","_Object$entries","entries","extraAttributes","_Object$entries$_i","_slicedToArray","attributeUniqueId","thisAttributeType","dracoAttributeConstant","attributeType","entryName","attributeNameEntry","string","dracoMetadata","GetMetadata","_getDracoMetadata","GetAttributeMetadata","result","numEntries","NumEntries","entryIndex","GetEntryName","_getDracoMetadataField","GetIntEntryArray","intArray","getInt32Array","int","GetIntEntry","GetStringEntry","double","GetDoubleEntry","_options$quantizedAtt","quantizedAttributes","_options$octahedronAt","octahedronAttributes","skipAttributes","_toConsumableArray","_iterator","_createForOfIteratorHelper","_step","s","n","done","dracoAttributeName","SkipAttributeTransform","err","e","f","_this","_options$quantizedAtt2","skip","map","type","includes","transform","AttributeQuantizationTransform","InitFromAttribute","quantization_bits","range","min_values","i","min_value","_this2","_options$octahedronAt2","default","DT_FLOAT32","DT_INT8","DT_INT16","DT_INT32","DT_UINT8","DT_UINT16","DT_UINT32","DT_INVALID","GetValue"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/gltf/node_modules/@loaders.gl/draco/src/lib/draco-parser.ts"],"sourcesContent":["/* eslint-disable camelcase */\n\nimport type {TypedArray, MeshAttribute, MeshGeometry} from '@loaders.gl/schema';\n\n// Draco types (input)\nimport type {\n  Draco3D,\n  Decoder,\n  Mesh,\n  PointCloud,\n  PointAttribute,\n  Metadata,\n  MetadataQuerier,\n  DracoInt32Array,\n  draco_DataType\n} from '../draco3d/draco3d-types';\n\n// Parsed data types (output)\nimport type {\n  DracoMesh,\n  DracoLoaderData,\n  DracoAttribute,\n  DracoMetadataEntry,\n  DracoQuantizationTransform,\n  DracoOctahedronTransform\n} from './draco-types';\n\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\nimport {getDracoSchema} from './utils/get-draco-schema';\n\n/**\n * @param topology - How triangle indices should be generated (mesh only)\n * @param attributeNameEntry\n * @param extraAttributes\n * @param quantizedAttributes\n * @param octahedronAttributes\n */\nexport type DracoParseOptions = {\n  topology?: 'triangle-list' | 'triangle-strip';\n  attributeNameEntry?: string;\n  extraAttributes?: {[uniqueId: string]: number};\n  quantizedAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n  octahedronAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n};\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nconst INDEX_ITEM_SIZE = 4;\n\nexport default class DracoParser {\n  draco: Draco3D;\n  decoder: Decoder;\n  metadataQuerier: MetadataQuerier;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  /**\n   * Destroy draco resources\n   */\n  destroy(): void {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  /**\n   * NOTE: caller must call `destroyGeometry` on the return value after using it\n   * @param arrayBuffer\n   * @param options\n   */\n  parseSync(arrayBuffer: ArrayBuffer, options: DracoParseOptions = {}): DracoMesh {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    this._disableAttributeTransforms(options);\n\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry =\n      geometry_type === this.draco.TRIANGULAR_MESH\n        ? new this.draco.Mesh()\n        : new this.draco.PointCloud();\n\n    try {\n      let dracoStatus;\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry as Mesh);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        throw new Error(message);\n      }\n\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n\n      const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);\n\n      const data: DracoMesh = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  // Draco specific \"loader data\"\n\n  /**\n   * Extract\n   * @param dracoGeometry\n   * @param geometry_type\n   * @param options\n   * @returns\n   */\n  _getDracoLoaderData(\n    dracoGeometry: Mesh | PointCloud,\n    geometry_type,\n    options: DracoParseOptions\n  ): DracoLoaderData {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  /**\n   * Extract all draco provided information and metadata for each attribute\n   * @param dracoGeometry\n   * @param options\n   * @returns\n   */\n  _getDracoAttributes(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: DracoAttribute} {\n    const dracoAttributes: {[unique_id: number]: DracoAttribute} = {};\n\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n      // but it does seems to work this way\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n\n        metadata\n      };\n\n      // Add transformation parameters for any attributes app wants untransformed\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n\n    return dracoAttributes;\n  }\n\n  /**\n   * Get standard loaders.gl mesh category data\n   * Extracts the geometry from draco\n   * @param dracoGeometry\n   * @param options\n   */\n  _getMeshData(\n    dracoGeometry: Mesh | PointCloud,\n    loaderData: DracoLoaderData,\n    options: DracoParseOptions\n  ): MeshGeometry {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4, // GL.TRIANGLES\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5, // GL.TRIANGLE_STRIP\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    // PointCloud - must come last as Mesh inherits from PointCloud\n    return {\n      topology: 'point-list',\n      mode: 0, // GL.POINTS\n      attributes\n    };\n  }\n\n  _getMeshAttributes(\n    loaderData: DracoLoaderData,\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[attributeName: string]: MeshAttribute} {\n    const attributes: {[key: string]: MeshAttribute} = {};\n\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n      loaderAttribute.name = attributeName;\n      const {value, size} = this._getAttributeValues(dracoGeometry, loaderAttribute);\n      attributes[attributeName] = {\n        value,\n        size,\n        byteOffset: loaderAttribute.byte_offset,\n        byteStride: loaderAttribute.byte_stride,\n        normalized: loaderAttribute.normalized\n      };\n    }\n\n    return attributes;\n  }\n\n  // MESH INDICES EXTRACTION\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleListIndices(dracoGeometry: Mesh) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleStripIndices(dracoGeometry: Mesh) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  /**\n   *\n   * @param dracoGeometry\n   * @param dracoAttribute\n   * @param attributeName\n   */\n  _getAttributeValues(\n    dracoGeometry: Mesh | PointCloud,\n    attribute: DracoAttribute\n  ): {value: TypedArray; size: number} {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n\n    let value: TypedArray;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        dataType,\n        byteLength,\n        ptr\n      );\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n\n    return {value, size: numComponents};\n  }\n\n  // Attribute names\n\n  /** \n   * DRACO does not store attribute names - We need to deduce an attribute name\n   * for each attribute\n  _getAttributeNames(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: string} {\n    const attributeNames: {[unique_id: number]: string} = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeName = this._deduceAttributeName(dracoAttribute, options);\n      attributeNames[attributeName] = attributeName;\n    }\n    return attributeNames;\n  }\n   */\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param attributeData\n   */\n  _deduceAttributeName(attribute: DracoAttribute, options: DracoParseOptions): string {\n    // Deduce name based on application provided map\n    const uniqueId = attribute.unique_id;\n    for (const [attributeName, attributeUniqueId] of Object.entries(\n      options.extraAttributes || {}\n    )) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    // Deduce name based on attribute type\n    const thisAttributeType = attribute.attribute_type;\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeType === thisAttributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    // Look up in metadata\n    // TODO - shouldn't this have priority?\n    const entryName = options.attributeNameEntry || 'name';\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n  }\n\n  // METADATA EXTRACTION\n\n  /** Get top level metadata */\n  _getTopLevelMetadata(dracoGeometry: Mesh | PointCloud) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /** Get per attribute metadata */\n  _getAttributeMetadata(dracoGeometry: Mesh | PointCloud, attributeId: number) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /**\n   * Extract metadata field values\n   * @param dracoMetadata\n   * @returns\n   */\n  _getDracoMetadata(dracoMetadata: Metadata): {[entry: string]: DracoMetadataEntry} {\n    // The not so wonderful world of undocumented Draco APIs :(\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n    return result;\n  }\n\n  /**\n   * Extracts possible values for one metadata entry by name\n   * @param dracoMetadata\n   * @param entryName\n   */\n  _getDracoMetadataField(dracoMetadata: Metadata, entryName: string): DracoMetadataEntry {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      // Draco metadata fields can hold int32 arrays\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n\n  /** Skip transforms for specific attribute types */\n  _disableAttributeTransforms(options: DracoParseOptions) {\n    const {quantizedAttributes = [], octahedronAttributes = []} = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  /**\n   * Extract (and apply?) Position Transform\n   * @todo not used\n   */\n  _getQuantizationTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoQuantizationTransform | null {\n    const {quantizedAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  _getOctahedronTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoOctahedronTransform | null {\n    const {octahedronAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes\n      .map((type) => this.decoder[type])\n      .includes(attribute_type);\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  // HELPERS\n}\n\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco: Draco3D, attributeType: any): draco_DataType {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n"],"mappings":";;;;;;;AA2BA,SAAQA,kBAAkB,QAAO,oBAAoB;AACrD,SAAQC,cAAc,QAAO,0BAA0B;AAmBvD,IAAMC,aAAa,GAAG;EACpBC,eAAe,EAAE,CAAC;EAClBC,WAAW,EAAE;AACf,CAAC;AAGD,IAAMC,gCAAgC,GAAG;EACvCC,QAAQ,EAAE,UAAU;EACpBC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,SAAS;EAChBC,SAAS,EAAE;AACb,CAAC;AAED,IAAMC,kCAAkC,GAAG;EACzC,CAAC,EAAEC,SAAS;EACZ,CAAC,EAAEC,UAAU;EACb,CAAC,EAAEC,UAAU;EACb,CAAC,EAAEC,WAAW;EACd,CAAC,EAAEC,UAAU;EACb,CAAC,EAAEC,WAAW;EACd,CAAC,EAAEC;AACL,CAAC;AAED,IAAMC,eAAe,GAAG,CAAC;AAAA,IAEJC,WAAW;EAM9B,SAAAA,YAAYC,KAAc,EAAE;IAAAC,eAAA,OAAAF,WAAA;IAAAG,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAC1B,IAAI,CAACF,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACG,OAAO,GAAG,IAAI,IAAI,CAACH,KAAK,CAACI,OAAO,EAAE;IACvC,IAAI,CAACC,eAAe,GAAG,IAAI,IAAI,CAACL,KAAK,CAACM,eAAe,EAAE;EACzD;EAAAC,YAAA,CAAAR,WAAA;IAAAS,GAAA;IAAAC,KAAA,EAKA,SAAAC,QAAA,EAAgB;MACd,IAAI,CAACV,KAAK,CAACU,OAAO,CAAC,IAAI,CAACP,OAAO,CAAC;MAChC,IAAI,CAACH,KAAK,CAACU,OAAO,CAAC,IAAI,CAACL,eAAe,CAAC;IAC1C;EAAA;IAAAG,GAAA;IAAAC,KAAA,EAOA,SAAAE,UAAUC,WAAwB,EAA8C;MAAA,IAA5CC,OAA0B,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;MACjE,IAAMG,MAAM,GAAG,IAAI,IAAI,CAACjB,KAAK,CAACkB,aAAa,EAAE;MAC7CD,MAAM,CAACE,IAAI,CAAC,IAAI5B,SAAS,CAACqB,WAAW,CAAC,EAAEA,WAAW,CAACQ,UAAU,CAAC;MAE/D,IAAI,CAACC,2BAA2B,CAACR,OAAO,CAAC;MAEzC,IAAMS,aAAa,GAAG,IAAI,CAACnB,OAAO,CAACoB,sBAAsB,CAACN,MAAM,CAAC;MACjE,IAAMO,aAAa,GACjBF,aAAa,KAAK,IAAI,CAACtB,KAAK,CAACjB,eAAe,GACxC,IAAI,IAAI,CAACiB,KAAK,CAACyB,IAAI,EAAE,GACrB,IAAI,IAAI,CAACzB,KAAK,CAAC0B,UAAU,EAAE;MAEjC,IAAI;QACF,IAAIC,WAAW;QACf,QAAQL,aAAa;UACnB,KAAK,IAAI,CAACtB,KAAK,CAACjB,eAAe;YAC7B4C,WAAW,GAAG,IAAI,CAACxB,OAAO,CAACyB,kBAAkB,CAACX,MAAM,EAAEO,aAAa,CAAS;YAC5E;UAEF,KAAK,IAAI,CAACxB,KAAK,CAAChB,WAAW;YACzB2C,WAAW,GAAG,IAAI,CAACxB,OAAO,CAAC0B,wBAAwB,CAACZ,MAAM,EAAEO,aAAa,CAAC;YAC1E;UAEF;YACE,MAAM,IAAIM,KAAK,CAAC,+BAA+B,CAAC;QAAA;QAGpD,IAAI,CAACH,WAAW,CAACI,EAAE,EAAE,IAAI,CAACP,aAAa,CAACQ,GAAG,EAAE;UAC3C,IAAMC,OAAO,kCAAAC,MAAA,CAAkCP,WAAW,CAACQ,SAAS,EAAE,CAAE;UAExE,MAAM,IAAIL,KAAK,CAACG,OAAO,CAAC;QAC1B;QAEA,IAAMG,UAAU,GAAG,IAAI,CAACC,mBAAmB,CAACb,aAAa,EAAEF,aAAa,EAAET,OAAO,CAAC;QAElF,IAAMyB,QAAQ,GAAG,IAAI,CAACC,YAAY,CAACf,aAAa,EAAEY,UAAU,EAAEvB,OAAO,CAAC;QAEtE,IAAM2B,WAAW,GAAG5D,kBAAkB,CAAC0D,QAAQ,CAACG,UAAU,CAAC;QAE3D,IAAMC,MAAM,GAAG7D,cAAc,CAACyD,QAAQ,CAACG,UAAU,EAAEL,UAAU,EAAEE,QAAQ,CAACK,OAAO,CAAC;QAEhF,IAAMC,IAAe,GAAAC,aAAA,CAAAA,aAAA;UACnBC,MAAM,EAAE,OAAO;UACfV,UAAU,EAAVA,UAAU;UACVW,MAAM,EAAE;YACNC,WAAW,EAAExB,aAAa,CAACyB,UAAU,EAAE;YACvCT,WAAA,EAAAA;UACF;QAAC,GACEF,QAAQ;UACXI,MAAA,EAAAA;QAAA,EACD;QACD,OAAOE,IAAI;MACb,CAAC,SAAS;QACR,IAAI,CAAC5C,KAAK,CAACU,OAAO,CAACO,MAAM,CAAC;QAC1B,IAAIO,aAAa,EAAE;UACjB,IAAI,CAACxB,KAAK,CAACU,OAAO,CAACc,aAAa,CAAC;QACnC;MACF;IACF;EAAA;IAAAhB,GAAA;IAAAC,KAAA,EAWA,SAAA4B,oBACEb,aAAgC,EAChCF,aAAa,EACbT,OAA0B,EACT;MACjB,IAAMqC,QAAQ,GAAG,IAAI,CAACC,oBAAoB,CAAC3B,aAAa,CAAC;MACzD,IAAMiB,UAAU,GAAG,IAAI,CAACW,mBAAmB,CAAC5B,aAAa,EAAEX,OAAO,CAAC;MAEnE,OAAO;QACLS,aAAa,EAAbA,aAAa;QACb+B,cAAc,EAAE7B,aAAa,CAAC6B,cAAc,EAAE;QAC9CJ,UAAU,EAAEzB,aAAa,CAACyB,UAAU,EAAE;QACtCK,SAAS,EAAE9B,aAAa,YAAY,IAAI,CAACxB,KAAK,CAACyB,IAAI,GAAGD,aAAa,CAAC8B,SAAS,EAAE,GAAG,CAAC;QACnFJ,QAAQ,EAARA,QAAQ;QACRT,UAAA,EAAAA;MACF,CAAC;IACH;EAAA;IAAAjC,GAAA;IAAAC,KAAA,EAQA,SAAA2C,oBACE5B,aAAgC,EAChCX,OAA0B,EACa;MACvC,IAAM0C,eAAsD,GAAG,CAAC,CAAC;MAEjE,KAAK,IAAIC,WAAW,GAAG,CAAC,EAAEA,WAAW,GAAGhC,aAAa,CAAC6B,cAAc,EAAE,EAAEG,WAAW,EAAE,EAAE;QAGrF,IAAMC,cAAc,GAAG,IAAI,CAACtD,OAAO,CAACuD,YAAY,CAAClC,aAAa,EAAEgC,WAAW,CAAC;QAE5E,IAAMN,QAAQ,GAAG,IAAI,CAACS,qBAAqB,CAACnC,aAAa,EAAEgC,WAAW,CAAC;QAEvED,eAAe,CAACE,cAAc,CAACG,SAAS,EAAE,CAAC,GAAG;UAC5CA,SAAS,EAAEH,cAAc,CAACG,SAAS,EAAE;UACrCC,cAAc,EAAEJ,cAAc,CAACI,cAAc,EAAE;UAC/CC,SAAS,EAAEL,cAAc,CAACK,SAAS,EAAE;UACrCC,cAAc,EAAEN,cAAc,CAACM,cAAc,EAAE;UAE/CC,WAAW,EAAEP,cAAc,CAACO,WAAW,EAAE;UACzCC,WAAW,EAAER,cAAc,CAACQ,WAAW,EAAE;UACzCC,UAAU,EAAET,cAAc,CAACS,UAAU,EAAE;UACvCC,eAAe,EAAEX,WAAW;UAE5BN,QAAA,EAAAA;QACF,CAAC;QAGD,IAAMkB,YAAY,GAAG,IAAI,CAACC,yBAAyB,CAACZ,cAAc,EAAE5C,OAAO,CAAC;QAC5E,IAAIuD,YAAY,EAAE;UAChBb,eAAe,CAACE,cAAc,CAACG,SAAS,EAAE,CAAC,CAACU,sBAAsB,GAAGF,YAAY;QACnF;QAEA,IAAMG,UAAU,GAAG,IAAI,CAACC,uBAAuB,CAACf,cAAc,EAAE5C,OAAO,CAAC;QACxE,IAAI0D,UAAU,EAAE;UACdhB,eAAe,CAACE,cAAc,CAACG,SAAS,EAAE,CAAC,CAACa,oBAAoB,GAAGF,UAAU;QAC/E;MACF;MAEA,OAAOhB,eAAe;IACxB;EAAA;IAAA/C,GAAA;IAAAC,KAAA,EAQA,SAAA8B,aACEf,aAAgC,EAChCY,UAA2B,EAC3BvB,OAA0B,EACZ;MACd,IAAM4B,UAAU,GAAG,IAAI,CAACiC,kBAAkB,CAACtC,UAAU,EAAEZ,aAAa,EAAEX,OAAO,CAAC;MAE9E,IAAM8D,iBAAiB,GAAGlC,UAAU,CAACvD,QAAQ;MAC7C,IAAI,CAACyF,iBAAiB,EAAE;QACtB,MAAM,IAAI7C,KAAK,CAAC,qCAAqC,CAAC;MACxD;MAGA,IAAIN,aAAa,YAAY,IAAI,CAACxB,KAAK,CAACyB,IAAI,EAAE;QAC5C,QAAQZ,OAAO,CAAC+D,QAAQ;UACtB,KAAK,gBAAgB;YACnB,OAAO;cACLA,QAAQ,EAAE,gBAAgB;cAC1BC,IAAI,EAAE,CAAC;cACPpC,UAAU,EAAVA,UAAU;cACVE,OAAO,EAAE;gBACPlC,KAAK,EAAE,IAAI,CAACqE,wBAAwB,CAACtD,aAAa,CAAC;gBACnDuD,IAAI,EAAE;cACR;YACF,CAAC;UACH,KAAK,eAAe;UACpB;YACE,OAAO;cACLH,QAAQ,EAAE,eAAe;cACzBC,IAAI,EAAE,CAAC;cACPpC,UAAU,EAAVA,UAAU;cACVE,OAAO,EAAE;gBACPlC,KAAK,EAAE,IAAI,CAACuE,uBAAuB,CAACxD,aAAa,CAAC;gBAClDuD,IAAI,EAAE;cACR;YACF,CAAC;QAAA;MAEP;MAGA,OAAO;QACLH,QAAQ,EAAE,YAAY;QACtBC,IAAI,EAAE,CAAC;QACPpC,UAAA,EAAAA;MACF,CAAC;IACH;EAAA;IAAAjC,GAAA;IAAAC,KAAA,EAEA,SAAAiE,mBACEtC,UAA2B,EAC3BZ,aAAgC,EAChCX,OAA0B,EACgB;MAC1C,IAAM4B,UAA0C,GAAG,CAAC,CAAC;MAErD,SAAAwC,EAAA,MAAAC,cAAA,GAA8BC,MAAM,CAACC,MAAM,CAAChD,UAAU,CAACK,UAAU,CAAC,EAAAwC,EAAA,GAAAC,cAAA,CAAAnE,MAAA,EAAAkE,EAAA,IAAE;QAA/D,IAAMI,eAAe,GAAAH,cAAA,CAAAD,EAAA;QACxB,IAAMK,aAAa,GAAG,IAAI,CAACC,oBAAoB,CAACF,eAAe,EAAExE,OAAO,CAAC;QACzEwE,eAAe,CAACG,IAAI,GAAGF,aAAa;QACpC,IAAAG,qBAAA,GAAsB,IAAI,CAACC,mBAAmB,CAAClE,aAAa,EAAE6D,eAAe,CAAC;UAAvE5E,KAAK,GAAAgF,qBAAA,CAALhF,KAAK;UAAEsE,IAAA,GAAAU,qBAAA,CAAAV,IAAA;QACdtC,UAAU,CAAC6C,aAAa,CAAC,GAAG;UAC1B7E,KAAK,EAALA,KAAK;UACLsE,IAAI,EAAJA,IAAI;UACJY,UAAU,EAAEN,eAAe,CAACrB,WAAW;UACvC4B,UAAU,EAAEP,eAAe,CAACpB,WAAW;UACvCC,UAAU,EAAEmB,eAAe,CAACnB;QAC9B,CAAC;MACH;MAEA,OAAOzB,UAAU;IACnB;EAAA;IAAAjC,GAAA;IAAAC,KAAA,EAQA,SAAAuE,wBAAwBxD,aAAmB,EAAE;MAE3C,IAAMqE,QAAQ,GAAGrE,aAAa,CAAC8B,SAAS,EAAE;MAC1C,IAAMwC,UAAU,GAAGD,QAAQ,GAAG,CAAC;MAC/B,IAAMzE,UAAU,GAAG0E,UAAU,GAAGhG,eAAe;MAE/C,IAAMkC,GAAG,GAAG,IAAI,CAAChC,KAAK,CAAC+F,OAAO,CAAC3E,UAAU,CAAC;MAC1C,IAAI;QACF,IAAI,CAACjB,OAAO,CAAC6F,uBAAuB,CAACxE,aAAa,EAAEJ,UAAU,EAAEY,GAAG,CAAC;QACpE,OAAO,IAAIpC,WAAW,CAAC,IAAI,CAACI,KAAK,CAACiG,OAAO,CAAChF,MAAM,EAAEe,GAAG,EAAE8D,UAAU,CAAC,CAACI,KAAK,EAAE;MAC5E,CAAC,SAAS;QACR,IAAI,CAAClG,KAAK,CAACmG,KAAK,CAACnE,GAAG,CAAC;MACvB;IACF;EAAA;IAAAxB,GAAA;IAAAC,KAAA,EAMA,SAAAqE,yBAAyBtD,aAAmB,EAAE;MAC5C,IAAM4E,UAAU,GAAG,IAAI,IAAI,CAACpG,KAAK,CAACqG,eAAe,EAAE;MACnD,IAAI;QACsB,IAAI,CAAClG,OAAO,CAACmG,yBAAyB,CAAC9E,aAAa,EAAE4E,UAAU,CAAC;QACzF,OAAOG,cAAc,CAACH,UAAU,CAAC;MACnC,CAAC,SAAS;QACR,IAAI,CAACpG,KAAK,CAACU,OAAO,CAAC0F,UAAU,CAAC;MAChC;IACF;EAAA;IAAA5F,GAAA;IAAAC,KAAA,EAQA,SAAAiF,oBACElE,aAAgC,EAChCgF,SAAyB,EACU;MACnC,IAAMC,cAAc,GAAGnH,kCAAkC,CAACkH,SAAS,CAAC1C,SAAS,CAAC;MAC9E,IAAM4C,aAAa,GAAGF,SAAS,CAACzC,cAAc;MAC9C,IAAM4C,SAAS,GAAGnF,aAAa,CAACyB,UAAU,EAAE;MAC5C,IAAM2D,SAAS,GAAGD,SAAS,GAAGD,aAAa;MAE3C,IAAMtF,UAAU,GAAGwF,SAAS,GAAGH,cAAc,CAACI,iBAAiB;MAC/D,IAAMC,QAAQ,GAAGC,gBAAgB,CAAC,IAAI,CAAC/G,KAAK,EAAEyG,cAAc,CAAC;MAE7D,IAAIhG,KAAiB;MAErB,IAAMuB,GAAG,GAAG,IAAI,CAAChC,KAAK,CAAC+F,OAAO,CAAC3E,UAAU,CAAC;MAC1C,IAAI;QACF,IAAMqC,cAAc,GAAG,IAAI,CAACtD,OAAO,CAACuD,YAAY,CAAClC,aAAa,EAAEgF,SAAS,CAACrC,eAAe,CAAC;QAC1F,IAAI,CAAChE,OAAO,CAAC6G,iCAAiC,CAC5CxF,aAAa,EACbiC,cAAc,EACdqD,QAAQ,EACR1F,UAAU,EACVY,GAAG,CACJ;QACDvB,KAAK,GAAG,IAAIgG,cAAc,CAAC,IAAI,CAACzG,KAAK,CAACiG,OAAO,CAAChF,MAAM,EAAEe,GAAG,EAAE4E,SAAS,CAAC,CAACV,KAAK,EAAE;MAC/E,CAAC,SAAS;QACR,IAAI,CAAClG,KAAK,CAACmG,KAAK,CAACnE,GAAG,CAAC;MACvB;MAEA,OAAO;QAACvB,KAAK,EAALA,KAAK;QAAEsE,IAAI,EAAE2B;MAAa,CAAC;IACrC;EAAA;IAAAlG,GAAA;IAAAC,KAAA,EA4BA,SAAA8E,qBAAqBiB,SAAyB,EAAE3F,OAA0B,EAAU;MAElF,IAAMoG,QAAQ,GAAGT,SAAS,CAAC5C,SAAS;MACpC,SAAAsD,GAAA,MAAAC,eAAA,GAAiDhC,MAAM,CAACiC,OAAO,CAC7DvG,OAAO,CAACwG,eAAe,IAAI,CAAC,CAAC,CAC9B,EAAAH,GAAA,GAAAC,eAAA,CAAApG,MAAA,EAAAmG,GAAA,IAAE;QAFE,IAAAI,kBAAA,GAAAC,cAAA,CAAAJ,eAAA,CAAAD,GAAA;UAAO5B,aAAa,GAAAgC,kBAAA;UAAEE,iBAAiB,GAAAF,kBAAA;QAG1C,IAAIE,iBAAiB,KAAKP,QAAQ,EAAE;UAClC,OAAO3B,aAAa;QACtB;MACF;MAGA,IAAMmC,iBAAiB,GAAGjB,SAAS,CAAC3C,cAAc;MAClD,KAAK,IAAM6D,sBAAsB,IAAIzI,gCAAgC,EAAE;QACrE,IAAM0I,aAAa,GAAG,IAAI,CAAC3H,KAAK,CAAC0H,sBAAsB,CAAC;QACxD,IAAIC,aAAa,KAAKF,iBAAiB,EAAE;UAGvC,OAAOxI,gCAAgC,CAACyI,sBAAsB,CAAC;QACjE;MACF;MAIA,IAAME,SAAS,GAAG/G,OAAO,CAACgH,kBAAkB,IAAI,MAAM;MACtD,IAAIrB,SAAS,CAACtD,QAAQ,CAAC0E,SAAS,CAAC,EAAE;QACjC,OAAOpB,SAAS,CAACtD,QAAQ,CAAC0E,SAAS,CAAC,CAACE,MAAM;MAC7C;MAGA,2BAAA5F,MAAA,CAA2B+E,QAAQ;IACrC;EAAA;IAAAzG,GAAA;IAAAC,KAAA,EAKA,SAAA0C,qBAAqB3B,aAAgC,EAAE;MACrD,IAAMuG,aAAa,GAAG,IAAI,CAAC5H,OAAO,CAAC6H,WAAW,CAACxG,aAAa,CAAC;MAC7D,OAAO,IAAI,CAACyG,iBAAiB,CAACF,aAAa,CAAC;IAC9C;EAAA;IAAAvH,GAAA;IAAAC,KAAA,EAGA,SAAAkD,sBAAsBnC,aAAgC,EAAEgC,WAAmB,EAAE;MAC3E,IAAMuE,aAAa,GAAG,IAAI,CAAC5H,OAAO,CAAC+H,oBAAoB,CAAC1G,aAAa,EAAEgC,WAAW,CAAC;MACnF,OAAO,IAAI,CAACyE,iBAAiB,CAACF,aAAa,CAAC;IAC9C;EAAA;IAAAvH,GAAA;IAAAC,KAAA,EAOA,SAAAwH,kBAAkBF,aAAuB,EAAyC;MAEhF,IAAI,CAACA,aAAa,IAAI,CAACA,aAAa,CAAC/F,GAAG,EAAE;QACxC,OAAO,CAAC,CAAC;MACX;MACA,IAAMmG,MAAM,GAAG,CAAC,CAAC;MACjB,IAAMC,UAAU,GAAG,IAAI,CAAC/H,eAAe,CAACgI,UAAU,CAACN,aAAa,CAAC;MACjE,KAAK,IAAIO,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAGF,UAAU,EAAEE,UAAU,EAAE,EAAE;QAC9D,IAAMV,SAAS,GAAG,IAAI,CAACvH,eAAe,CAACkI,YAAY,CAACR,aAAa,EAAEO,UAAU,CAAC;QAC9EH,MAAM,CAACP,SAAS,CAAC,GAAG,IAAI,CAACY,sBAAsB,CAACT,aAAa,EAAEH,SAAS,CAAC;MAC3E;MACA,OAAOO,MAAM;IACf;EAAA;IAAA3H,GAAA;IAAAC,KAAA,EAOA,SAAA+H,uBAAuBT,aAAuB,EAAEH,SAAiB,EAAsB;MACrF,IAAMxB,UAAU,GAAG,IAAI,IAAI,CAACpG,KAAK,CAACqG,eAAe,EAAE;MACnD,IAAI;QAEF,IAAI,CAAChG,eAAe,CAACoI,gBAAgB,CAACV,aAAa,EAAEH,SAAS,EAAExB,UAAU,CAAC;QAC3E,IAAMsC,QAAQ,GAAGC,aAAa,CAACvC,UAAU,CAAC;QAC1C,OAAO;UACLwC,GAAG,EAAE,IAAI,CAACvI,eAAe,CAACwI,WAAW,CAACd,aAAa,EAAEH,SAAS,CAAC;UAC/DE,MAAM,EAAE,IAAI,CAACzH,eAAe,CAACyI,cAAc,CAACf,aAAa,EAAEH,SAAS,CAAC;UACrEmB,MAAM,EAAE,IAAI,CAAC1I,eAAe,CAAC2I,cAAc,CAACjB,aAAa,EAAEH,SAAS,CAAC;UACrEc,QAAA,EAAAA;QACF,CAAC;MACH,CAAC,SAAS;QACR,IAAI,CAAC1I,KAAK,CAACU,OAAO,CAAC0F,UAAU,CAAC;MAChC;IACF;EAAA;IAAA5F,GAAA;IAAAC,KAAA,EAKA,SAAAY,4BAA4BR,OAA0B,EAAE;MACtD,IAAAoI,qBAAA,GAA8DpI,OAAO,CAA9DqI,mBAAmB;QAAnBA,mBAAmB,GAAAD,qBAAA,cAAG,EAAE,GAAAA,qBAAA;QAAAE,qBAAA,GAA+BtI,OAAO,CAApCuI,oBAAoB;QAApBA,oBAAoB,GAAAD,qBAAA,cAAG,KAAAA,qBAAA;MACxD,IAAME,cAAc,MAAAnH,MAAA,CAAAoH,kBAAA,CAAOJ,mBAAmB,GAAAI,kBAAA,CAAKF,oBAAoB,EAAC;MAAA,IAAAG,SAAA,GAAAC,0BAAA,CACvCH,cAAc;QAAAI,KAAA;MAAA;QAA/C,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAiD;UAAA,IAAtCC,kBAAkB,GAAAJ,KAAA,CAAAhJ,KAAA;UAC3B,IAAI,CAACN,OAAO,CAAC2J,sBAAsB,CAAC,IAAI,CAAC9J,KAAK,CAAC6J,kBAAkB,CAAC,CAAC;QACrE;MAAA,SAAAE,GAAA;QAAAR,SAAA,CAAAS,CAAA,CAAAD,GAAA;MAAA;QAAAR,SAAA,CAAAU,CAAA;MAAA;IACF;EAAA;IAAAzJ,GAAA;IAAAC,KAAA,EAMA,SAAA4D,0BACEZ,cAA8B,EAC9B5C,OAA0B,EACS;MAAA,IAAAqJ,KAAA;MACnC,IAAAC,sBAAA,GAAmCtJ,OAAO,CAAnCqI,mBAAmB;QAAnBA,mBAAmB,GAAAiB,sBAAA,cAAG,KAAAA,sBAAA;MAC7B,IAAMtG,cAAc,GAAGJ,cAAc,CAACI,cAAc,EAAE;MACtD,IAAMuG,IAAI,GAAGlB,mBAAmB,CAACmB,GAAG,CAAE,UAAAC,IAAI;QAAA,OAAKJ,KAAI,CAAC/J,OAAO,CAACmK,IAAI,CAAC;MAAA,EAAC,CAACC,QAAQ,CAAC1G,cAAc,CAAC;MAC3F,IAAIuG,IAAI,EAAE;QACR,IAAMI,SAAS,GAAG,IAAI,IAAI,CAACxK,KAAK,CAACyK,8BAA8B,EAAE;QACjE,IAAI;UACF,IAAID,SAAS,CAACE,iBAAiB,CAACjH,cAAc,CAAC,EAAE;YAC/C,OAAO;cACLkH,iBAAiB,EAAEH,SAAS,CAACG,iBAAiB,EAAE;cAChDC,KAAK,EAAEJ,SAAS,CAACI,KAAK,EAAE;cACxBC,UAAU,EAAE,IAAIhL,YAAY,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAACwK,GAAG,CAAE,UAAAS,CAAC;gBAAA,OAAKN,SAAS,CAACO,SAAS,CAACD,CAAC,CAAC;cAAA;YAC3E,CAAC;UACH;QACF,CAAC,SAAS;UACR,IAAI,CAAC9K,KAAK,CAACU,OAAO,CAAC8J,SAAS,CAAC;QAC/B;MACF;MACA,OAAO,IAAI;IACb;EAAA;IAAAhK,GAAA;IAAAC,KAAA,EAEA,SAAA+D,wBACEf,cAA8B,EAC9B5C,OAA0B,EACO;MAAA,IAAAmK,MAAA;MACjC,IAAAC,sBAAA,GAAoCpK,OAAO,CAApCuI,oBAAoB;QAApBA,oBAAoB,GAAA6B,sBAAA,cAAG,KAAAA,sBAAA;MAC9B,IAAMpH,cAAc,GAAGJ,cAAc,CAACI,cAAc,EAAE;MACtD,IAAMU,UAAU,GAAG6E,oBAAoB,CACpCiB,GAAG,CAAE,UAAAC,IAAI;QAAA,OAAKU,MAAI,CAAC7K,OAAO,CAACmK,IAAI,CAAC;MAAA,EAAC,CACjCC,QAAQ,CAAC1G,cAAc,CAAC;MAC3B,IAAIU,UAAU,EAAE;QACd,IAAMiG,SAAS,GAAG,IAAI,IAAI,CAACxK,KAAK,CAACyK,8BAA8B,EAAE;QACjE,IAAI;UACF,IAAID,SAAS,CAACE,iBAAiB,CAACjH,cAAc,CAAC,EAAE;YAC/C,OAAO;cACLkH,iBAAiB,EAAEH,SAAS,CAACG,iBAAiB;YAChD,CAAC;UACH;QACF,CAAC,SAAS;UACR,IAAI,CAAC3K,KAAK,CAACU,OAAO,CAAC8J,SAAS,CAAC;QAC/B;MACF;MACA,OAAO,IAAI;IACb;EAAA;EAAA,OAAAzK,WAAA;AAAA;AAAA,SApemBA,WAAW,IAAAmL,OAAA;AA8ehC,SAASnE,gBAAgBA,CAAC/G,KAAc,EAAE2H,aAAkB,EAAkB;EAC5E,QAAQA,aAAa;IACnB,KAAK9H,YAAY;MACf,OAAOG,KAAK,CAACmL,UAAU;IACzB,KAAK5L,SAAS;MACZ,OAAOS,KAAK,CAACoL,OAAO;IACtB,KAAK3L,UAAU;MACb,OAAOO,KAAK,CAACqL,QAAQ;IACvB,KAAK1L,UAAU;MACb,OAAOK,KAAK,CAACsL,QAAQ;IACvB,KAAK9L,UAAU;MACb,OAAOQ,KAAK,CAACuL,QAAQ;IACvB,KAAK7L,WAAW;MACd,OAAOM,KAAK,CAACwL,SAAS;IACxB,KAAK5L,WAAW;MACd,OAAOI,KAAK,CAACyL,SAAS;IACxB;MACE,OAAOzL,KAAK,CAAC0L,UAAU;EAAA;AAE7B;AAKA,SAAS/C,aAAaA,CAACvC,UAA2B,EAAc;EAC9D,IAAMQ,SAAS,GAAGR,UAAU,CAACrB,IAAI,EAAE;EACnC,IAAM2D,QAAQ,GAAG,IAAI/I,UAAU,CAACiH,SAAS,CAAC;EAC1C,KAAK,IAAIkE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlE,SAAS,EAAEkE,CAAC,EAAE,EAAE;IAClCpC,QAAQ,CAACoC,CAAC,CAAC,GAAG1E,UAAU,CAACuF,QAAQ,CAACb,CAAC,CAAC;EACtC;EACA,OAAOpC,QAAQ;AACjB;AAKA,SAASnC,cAAcA,CAACH,UAA2B,EAAc;EAC/D,IAAMQ,SAAS,GAAGR,UAAU,CAACrB,IAAI,EAAE;EACnC,IAAM2D,QAAQ,GAAG,IAAI/I,UAAU,CAACiH,SAAS,CAAC;EAC1C,KAAK,IAAIkE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlE,SAAS,EAAEkE,CAAC,EAAE,EAAE;IAClCpC,QAAQ,CAACoC,CAAC,CAAC,GAAG1E,UAAU,CAACuF,QAAQ,CAACb,CAAC,CAAC;EACtC;EACA,OAAOpC,QAAQ;AACjB"},"metadata":{},"sourceType":"module","externalDependencies":[]}