{"ast":null,"code":"import _regeneratorRuntime from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Vector3, Matrix3, Matrix4, Quaternion } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { GL } from '@loaders.gl/math';\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport { parse3DTileHeaderSync } from './helpers/parse-3d-tile-header';\nimport { parse3DTileTablesHeaderSync, parse3DTileTablesSync } from './helpers/parse-3d-tile-tables';\nimport { parse3DTileGLTFViewSync, extractGLTF } from './helpers/parse-3d-tile-gltf-view';\nexport function parseInstancedModel3DTile(_x, _x2, _x3, _x4, _x5) {\n  return _parseInstancedModel3DTile.apply(this, arguments);\n}\nfunction _parseInstancedModel3DTile() {\n  _parseInstancedModel3DTile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tile, arrayBuffer, byteOffset, options, context) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);\n          _context.next = 3;\n          return extractGLTF(tile, tile.gltfFormat, options, context);\n        case 3:\n          return _context.abrupt(\"return\", byteOffset);\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _parseInstancedModel3DTile.apply(this, arguments);\n}\nfunction parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  if (tile.version !== 1) {\n    throw new Error(\"Instanced 3D Model version \".concat(tile.version, \" is not supported\"));\n  }\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n  var view = new DataView(arrayBuffer);\n  tile.gltfFormat = view.getUint32(byteOffset, true);\n  byteOffset += 4;\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n  if (tile.featureTableJsonByteLength === 0) {\n    throw new Error('i3dm parser: featureTableJsonByteLength is zero.');\n  }\n  var featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n  var instancesLength = featureTable.getGlobalProperty('INSTANCES_LENGTH');\n  featureTable.featuresLength = instancesLength;\n  if (!Number.isFinite(instancesLength)) {\n    throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');\n  }\n  tile.eastNorthUp = featureTable.getGlobalProperty('EAST_NORTH_UP');\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n  var batchTable = new Tile3DBatchTable(tile.batchTableJson, tile.batchTableBinary, instancesLength);\n  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);\n  return byteOffset;\n}\nfunction extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {\n  var collectionOptions = {\n    instances: new Array(instancesLength),\n    batchTable: tile._batchTable,\n    cull: false,\n    url: undefined,\n    gltf: undefined,\n    basePath: undefined,\n    incrementallyLoadTextures: false,\n    forwardAxis: [1, 0, 0]\n  };\n  var instances = collectionOptions.instances;\n  var instancePosition = new Vector3();\n  var instanceNormalRight = new Vector3();\n  var instanceNormalUp = new Vector3();\n  var instanceNormalForward = new Vector3();\n  var instanceRotation = new Matrix3();\n  var instanceQuaternion = new Quaternion();\n  var instanceScale = new Vector3();\n  var instanceTranslationRotationScale = {};\n  var instanceTransform = new Matrix4();\n  var scratch1 = [];\n  var scratch2 = [];\n  var scratchVector1 = new Vector3();\n  var scratchVector2 = new Vector3();\n  for (var i = 0; i < instancesLength; i++) {\n    var position = void 0;\n    if (featureTable.hasProperty('POSITION')) {\n      position = featureTable.getProperty('POSITION', GL.FLOAT, 3, i, instancePosition);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      position = featureTable.getProperty('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3, i, instancePosition);\n      var quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL.FLOAT, 3, scratchVector1);\n      if (!quantizedVolumeOffset) {\n        throw new Error('i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n      var quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL.FLOAT, 3, scratchVector2);\n      if (!quantizedVolumeScale) {\n        throw new Error('i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n      var MAX_UNSIGNED_SHORT = 65535.0;\n      for (var j = 0; j < 3; j++) {\n        position[j] = position[j] / MAX_UNSIGNED_SHORT * quantizedVolumeScale[j] + quantizedVolumeOffset[j];\n      }\n    }\n    if (!position) {\n      throw new Error('i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.');\n    }\n    instancePosition.copy(position);\n    instanceTranslationRotationScale.translation = instancePosition;\n    tile.normalUp = featureTable.getProperty('NORMAL_UP', GL.FLOAT, 3, i, scratch1);\n    tile.normalRight = featureTable.getProperty('NORMAL_RIGHT', GL.FLOAT, 3, i, scratch2);\n    var hasCustomOrientation = false;\n    if (tile.normalUp) {\n      if (!tile.normalRight) {\n        throw new Error('i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.');\n      }\n      tile.hasCustomOrientation = true;\n    } else {\n      tile.octNormalUp = featureTable.getProperty('NORMAL_UP_OCT32P', GL.UNSIGNED_SHORT, 2, scratch1);\n      tile.octNormalRight = featureTable.getProperty('NORMAL_RIGHT_OCT32P', GL.UNSIGNED_SHORT, 2, scratch2);\n      if (tile.octNormalUp) {\n        if (!tile.octNormalRight) {\n          throw new Error('i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P');\n        }\n        throw new Error('i3dm: oct-encoded orientation not implemented');\n      } else if (tile.eastNorthUp) {\n        Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);\n        instanceTransform.getRotationMatrix3(instanceRotation);\n      } else {\n        instanceRotation.identity();\n      }\n    }\n    if (hasCustomOrientation) {\n      instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();\n      instanceRotation.setColumn(0, instanceNormalRight);\n      instanceRotation.setColumn(1, instanceNormalUp);\n      instanceRotation.setColumn(2, instanceNormalForward);\n    }\n    instanceQuaternion.fromMatrix3(instanceRotation);\n    instanceTranslationRotationScale.rotation = instanceQuaternion;\n    instanceScale.set(1.0, 1.0, 1.0);\n    var scale = featureTable.getProperty('SCALE', GL.FLOAT, 1, i);\n    if (Number.isFinite(scale)) {\n      instanceScale.multiplyByScalar(scale);\n    }\n    var nonUniformScale = featureTable.getProperty('SCALE_NON_UNIFORM', GL.FLOAT, 3, i, scratch1);\n    if (nonUniformScale) {\n      instanceScale.scale(nonUniformScale);\n    }\n    instanceTranslationRotationScale.scale = instanceScale;\n    var batchId = featureTable.getProperty('BATCH_ID', GL.UNSIGNED_SHORT, 1, i);\n    if (batchId === undefined) {\n      batchId = i;\n    }\n    var rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);\n    instanceTransform.identity();\n    instanceTransform.translate(instanceTranslationRotationScale.translation);\n    instanceTransform.multiplyRight(rotationMatrix);\n    instanceTransform.scale(instanceTranslationRotationScale.scale);\n    var modelMatrix = instanceTransform.clone();\n    instances[i] = {\n      modelMatrix: modelMatrix,\n      batchId: batchId\n    };\n  }\n  tile.instances = instances;\n}","map":{"version":3,"names":["Vector3","Matrix3","Matrix4","Quaternion","Ellipsoid","GL","Tile3DFeatureTable","Tile3DBatchTable","parse3DTileHeaderSync","parse3DTileTablesHeaderSync","parse3DTileTablesSync","parse3DTileGLTFViewSync","extractGLTF","parseInstancedModel3DTile","_x","_x2","_x3","_x4","_x5","_parseInstancedModel3DTile","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","tile","arrayBuffer","byteOffset","options","context","wrap","_callee$","_context","prev","next","parseInstancedModel","gltfFormat","abrupt","stop","version","Error","concat","view","DataView","getUint32","featureTableJsonByteLength","featureTable","featureTableJson","featureTableBinary","instancesLength","getGlobalProperty","featuresLength","Number","isFinite","eastNorthUp","rtcCenter","FLOAT","batchTable","batchTableJson","batchTableBinary","extractInstancedAttributes","collectionOptions","instances","Array","_batchTable","cull","url","undefined","gltf","basePath","incrementallyLoadTextures","forwardAxis","instancePosition","instanceNormalRight","instanceNormalUp","instanceNormalForward","instanceRotation","instanceQuaternion","instanceScale","instanceTranslationRotationScale","instanceTransform","scratch1","scratch2","scratchVector1","scratchVector2","i","position","hasProperty","getProperty","UNSIGNED_SHORT","quantizedVolumeOffset","quantizedVolumeScale","MAX_UNSIGNED_SHORT","j","copy","translation","normalUp","normalRight","hasCustomOrientation","octNormalUp","octNormalRight","WGS84","eastNorthUpToFixedFrame","getRotationMatrix3","identity","cross","normalize","setColumn","fromMatrix3","rotation","set","scale","multiplyByScalar","nonUniformScale","batchId","rotationMatrix","fromQuaternion","translate","multiplyRight","modelMatrix","clone"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/geo-layers/node_modules/@loaders.gl/3d-tiles/src/lib/parsers/parse-3d-tile-instanced-model.ts"],"sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3, Matrix4, Quaternion} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {GL} from '@loaders.gl/math'; // 'math.gl/geometry';\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\n\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\nimport {parse3DTileTablesHeaderSync, parse3DTileTablesSync} from './helpers/parse-3d-tile-tables';\nimport {parse3DTileGLTFViewSync, extractGLTF} from './helpers/parse-3d-tile-gltf-view';\n\nexport async function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);\n  await extractGLTF(tile, tile.gltfFormat, options, context);\n  return byteOffset;\n}\n\nfunction parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  if (tile.version !== 1) {\n    throw new Error(`Instanced 3D Model version ${tile.version} is not supported`);\n  }\n\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n\n  const view = new DataView(arrayBuffer);\n\n  tile.gltfFormat = view.getUint32(byteOffset, true);\n  byteOffset += 4;\n\n  // PARSE FEATURE TABLE\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n\n  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n\n  // TODO - Is the feature table sometimes optional or can check be moved into table header parser?\n  if (tile.featureTableJsonByteLength === 0) {\n    throw new Error('i3dm parser: featureTableJsonByteLength is zero.');\n  }\n\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n\n  const instancesLength = featureTable.getGlobalProperty('INSTANCES_LENGTH');\n  featureTable.featuresLength = instancesLength;\n\n  if (!Number.isFinite(instancesLength)) {\n    throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');\n  }\n\n  tile.eastNorthUp = featureTable.getGlobalProperty('EAST_NORTH_UP');\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n\n  const batchTable = new Tile3DBatchTable(\n    tile.batchTableJson,\n    tile.batchTableBinary,\n    instancesLength\n  );\n\n  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);\n\n  return byteOffset;\n}\n\n// eslint-disable-next-line max-statements, complexity\nfunction extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {\n  // Create model instance collection\n  const collectionOptions = {\n    instances: new Array(instancesLength),\n    batchTable: tile._batchTable,\n    cull: false, // Already culled by 3D Tiles\n    url: undefined,\n    // requestType: RequestType.TILES3D,\n    gltf: undefined,\n    basePath: undefined,\n    incrementallyLoadTextures: false,\n    // TODO - tileset is not available at this stage, tile is parsed independently\n    // upAxis: (tileset && tileset._gltfUpAxis) || [0, 1, 0],\n    forwardAxis: [1, 0, 0]\n  };\n\n  const instances = collectionOptions.instances;\n  const instancePosition = new Vector3();\n  const instanceNormalRight = new Vector3();\n  const instanceNormalUp = new Vector3();\n  const instanceNormalForward = new Vector3();\n  const instanceRotation = new Matrix3();\n  const instanceQuaternion = new Quaternion();\n  const instanceScale = new Vector3();\n  const instanceTranslationRotationScale = {};\n  const instanceTransform = new Matrix4();\n  const scratch1 = [];\n  const scratch2 = [];\n  const scratchVector1 = new Vector3();\n  const scratchVector2 = new Vector3();\n\n  for (let i = 0; i < instancesLength; i++) {\n    let position;\n\n    // Get the instance position\n    if (featureTable.hasProperty('POSITION')) {\n      position = featureTable.getProperty('POSITION', GL.FLOAT, 3, i, instancePosition);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      position = featureTable.getProperty(\n        'POSITION_QUANTIZED',\n        GL.UNSIGNED_SHORT,\n        3,\n        i,\n        instancePosition\n      );\n\n      const quantizedVolumeOffset = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_OFFSET',\n        GL.FLOAT,\n        3,\n        scratchVector1\n      );\n      if (!quantizedVolumeOffset) {\n        throw new Error(\n          'i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.'\n        );\n      }\n\n      const quantizedVolumeScale = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_SCALE',\n        GL.FLOAT,\n        3,\n        scratchVector2\n      );\n      if (!quantizedVolumeScale) {\n        throw new Error(\n          'i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.'\n        );\n      }\n\n      const MAX_UNSIGNED_SHORT = 65535.0;\n      for (let j = 0; j < 3; j++) {\n        position[j] =\n          (position[j] / MAX_UNSIGNED_SHORT) * quantizedVolumeScale[j] + quantizedVolumeOffset[j];\n      }\n    }\n\n    if (!position) {\n      throw new Error('i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.');\n    }\n\n    instancePosition.copy(position);\n    // @ts-expect-error\n    instanceTranslationRotationScale.translation = instancePosition;\n\n    // Get the instance rotation\n    tile.normalUp = featureTable.getProperty('NORMAL_UP', GL.FLOAT, 3, i, scratch1);\n    tile.normalRight = featureTable.getProperty('NORMAL_RIGHT', GL.FLOAT, 3, i, scratch2);\n\n    const hasCustomOrientation = false;\n    if (tile.normalUp) {\n      if (!tile.normalRight) {\n        throw new Error('i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.');\n      }\n      // Vector3.unpack(normalUp, 0, instanceNormalUp);\n      // Vector3.unpack(normalRight, 0, instanceNormalRight);\n      tile.hasCustomOrientation = true;\n    } else {\n      tile.octNormalUp = featureTable.getProperty(\n        'NORMAL_UP_OCT32P',\n        GL.UNSIGNED_SHORT,\n        2,\n        scratch1\n      );\n      tile.octNormalRight = featureTable.getProperty(\n        'NORMAL_RIGHT_OCT32P',\n        GL.UNSIGNED_SHORT,\n        2,\n        scratch2\n      );\n\n      if (tile.octNormalUp) {\n        if (!tile.octNormalRight) {\n          throw new Error(\n            'i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P'\n          );\n        }\n\n        throw new Error('i3dm: oct-encoded orientation not implemented');\n        /*\n        AttributeCompression.octDecodeInRange(octNormalUp[0], octNormalUp[1], 65535, instanceNormalUp);\n        AttributeCompression.octDecodeInRange(octNormalRight[0], octNormalRight[1], 65535, instanceNormalRight);\n        hasCustomOrientation = true;\n        */\n      } else if (tile.eastNorthUp) {\n        Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);\n        instanceTransform.getRotationMatrix3(instanceRotation);\n      } else {\n        instanceRotation.identity();\n      }\n    }\n\n    if (hasCustomOrientation) {\n      instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();\n      instanceRotation.setColumn(0, instanceNormalRight);\n      instanceRotation.setColumn(1, instanceNormalUp);\n      instanceRotation.setColumn(2, instanceNormalForward);\n    }\n\n    instanceQuaternion.fromMatrix3(instanceRotation);\n    // @ts-expect-error\n    instanceTranslationRotationScale.rotation = instanceQuaternion;\n\n    // Get the instance scale\n    instanceScale.set(1.0, 1.0, 1.0);\n    const scale = featureTable.getProperty('SCALE', GL.FLOAT, 1, i);\n    if (Number.isFinite(scale)) {\n      instanceScale.multiplyByScalar(scale);\n    }\n    const nonUniformScale = featureTable.getProperty('SCALE_NON_UNIFORM', GL.FLOAT, 3, i, scratch1);\n    if (nonUniformScale) {\n      instanceScale.scale(nonUniformScale);\n    }\n\n    // @ts-expect-error\n    instanceTranslationRotationScale.scale = instanceScale;\n\n    // Get the batchId\n    let batchId = featureTable.getProperty('BATCH_ID', GL.UNSIGNED_SHORT, 1, i);\n    if (batchId === undefined) {\n      // If BATCH_ID semantic is undefined, batchId is just the instance number\n      batchId = i;\n    }\n\n    // @ts-expect-error\n    const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);\n\n    // Create the model matrix and the instance\n    instanceTransform.identity();\n    // @ts-expect-error\n    instanceTransform.translate(instanceTranslationRotationScale.translation);\n    instanceTransform.multiplyRight(rotationMatrix);\n    // @ts-expect-error\n    instanceTransform.scale(instanceTranslationRotationScale.scale);\n\n    const modelMatrix = instanceTransform.clone();\n    instances[i] = {\n      modelMatrix,\n      batchId\n    };\n  }\n\n  tile.instances = instances;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}