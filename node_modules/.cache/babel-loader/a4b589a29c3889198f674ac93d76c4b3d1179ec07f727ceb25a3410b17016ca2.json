{"ast":null,"code":"import _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nexport var TypedArrayManager = /*#__PURE__*/function () {\n  function TypedArrayManager() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, TypedArrayManager);\n    _defineProperty(this, \"_pool\", []);\n    _defineProperty(this, \"opts\", {\n      overAlloc: 2,\n      poolSize: 100\n    });\n    this.setOptions(options);\n  }\n  _createClass(TypedArrayManager, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      Object.assign(this.opts, options);\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(typedArray, count, _ref) {\n      var _ref$size = _ref.size,\n        size = _ref$size === void 0 ? 1 : _ref$size,\n        type = _ref.type,\n        _ref$padding = _ref.padding,\n        padding = _ref$padding === void 0 ? 0 : _ref$padding,\n        _ref$copy = _ref.copy,\n        copy = _ref$copy === void 0 ? false : _ref$copy,\n        _ref$initialize = _ref.initialize,\n        initialize = _ref$initialize === void 0 ? false : _ref$initialize,\n        maxCount = _ref.maxCount;\n      var Type = type || typedArray && typedArray.constructor || Float32Array;\n      var newSize = count * size + padding;\n      if (ArrayBuffer.isView(typedArray)) {\n        if (newSize <= typedArray.length) {\n          return typedArray;\n        }\n        if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n          return new Type(typedArray.buffer, 0, newSize);\n        }\n      }\n      var maxSize = Infinity;\n      if (maxCount) {\n        maxSize = maxCount * size + padding;\n      }\n      var newArray = this._allocate(Type, newSize, initialize, maxSize);\n      if (typedArray && copy) {\n        newArray.set(typedArray);\n      } else if (!initialize) {\n        newArray.fill(0, 0, 4);\n      }\n      this._release(typedArray);\n      return newArray;\n    }\n  }, {\n    key: \"release\",\n    value: function release(typedArray) {\n      this._release(typedArray);\n    }\n  }, {\n    key: \"_allocate\",\n    value: function _allocate(Type, size, initialize, maxSize) {\n      var sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);\n      if (sizeToAllocate > maxSize) {\n        sizeToAllocate = maxSize;\n      }\n      var pool = this._pool;\n      var byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n      var i = pool.findIndex(function (b) {\n        return b.byteLength >= byteLength;\n      });\n      if (i >= 0) {\n        var array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n        if (initialize) {\n          array.fill(0);\n        }\n        return array;\n      }\n      return new Type(sizeToAllocate);\n    }\n  }, {\n    key: \"_release\",\n    value: function _release(typedArray) {\n      if (!ArrayBuffer.isView(typedArray)) {\n        return;\n      }\n      var pool = this._pool;\n      var buffer = typedArray.buffer;\n      var byteLength = buffer.byteLength;\n      var i = pool.findIndex(function (b) {\n        return b.byteLength >= byteLength;\n      });\n      if (i < 0) {\n        pool.push(buffer);\n      } else if (i > 0 || pool.length < this.opts.poolSize) {\n        pool.splice(i, 0, buffer);\n      }\n      if (pool.length > this.opts.poolSize) {\n        pool.shift();\n      }\n    }\n  }]);\n  return TypedArrayManager;\n}();\nexport default new TypedArrayManager();","map":{"version":3,"names":["TypedArrayManager","options","arguments","length","undefined","_classCallCheck","_defineProperty","overAlloc","poolSize","setOptions","_createClass","key","value","Object","assign","opts","allocate","typedArray","count","_ref","_ref$size","size","type","_ref$padding","padding","_ref$copy","copy","_ref$initialize","initialize","maxCount","Type","constructor","Float32Array","newSize","ArrayBuffer","isView","BYTES_PER_ELEMENT","buffer","byteLength","maxSize","Infinity","newArray","_allocate","set","fill","_release","release","sizeToAllocate","Math","max","ceil","pool","_pool","i","findIndex","b","array","splice","push","shift"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/core/src/utils/typed-array-manager.ts"],"sourcesContent":["import {TypedArray, TypedArrayConstructor} from '../types/types';\n\nexport type TypedArrayManagerOptions = {\n  overAlloc?: number;\n  poolSize?: number;\n};\n\nexport class TypedArrayManager {\n  private _pool: ArrayBuffer[] = [];\n  opts: {\n    overAlloc: number;\n    poolSize: number;\n  } = {overAlloc: 2, poolSize: 100};\n\n  constructor(options: TypedArrayManagerOptions = {}) {\n    this.setOptions(options);\n  }\n\n  setOptions(options: TypedArrayManagerOptions) {\n    Object.assign(this.opts, options);\n  }\n\n  allocate<T extends TypedArray>(\n    typedArray: T | null | undefined,\n    count: number,\n    {\n      size = 1,\n      type,\n      padding = 0,\n      copy = false,\n      initialize = false,\n      maxCount\n    }: {\n      size?: number;\n      type?: TypedArrayConstructor;\n      padding?: number;\n      copy?: boolean;\n      initialize?: boolean;\n      maxCount?: number;\n    }\n  ): T {\n    const Type =\n      type || (typedArray && (typedArray.constructor as TypedArrayConstructor)) || Float32Array;\n\n    const newSize = count * size + padding;\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize) as T;\n      }\n    }\n\n    let maxSize: number = Infinity;\n    if (maxCount) {\n      maxSize = maxCount * size + padding;\n    }\n\n    const newArray = this._allocate(Type, newSize, initialize, maxSize);\n\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else if (!initialize) {\n      // Hack - always initialize the first 4 elements. NaNs crash the Attribute validation\n      newArray.fill(0, 0, 4);\n    }\n\n    this._release(typedArray);\n    return newArray as T;\n  }\n\n  release(typedArray: TypedArray | null | undefined) {\n    this._release(typedArray);\n  }\n\n  private _allocate(\n    Type: TypedArrayConstructor,\n    size: number,\n    initialize: boolean,\n    maxSize: number\n  ): TypedArray {\n    // Allocate at least one element to ensure a valid buffer\n    let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);\n    // Don't over allocate after certain specified number of elements\n    if (sizeToAllocate > maxSize) {\n      sizeToAllocate = maxSize;\n    }\n\n    // Check if available in pool\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i >= 0) {\n      // Create a new array using an existing buffer\n      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n      if (initialize) {\n        // Viewing a buffer with a different type may create NaNs\n        array.fill(0);\n      }\n      return array;\n    }\n    return new Type(sizeToAllocate);\n  }\n\n  private _release(typedArray: TypedArray | null | undefined): void {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n    const pool = this._pool;\n    const {buffer} = typedArray;\n    // Save the buffer of the released array into the pool\n    // Sort buffers by size\n    // TODO - implement binary search?\n    const {byteLength} = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.opts.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n    if (pool.length > this.opts.poolSize) {\n      // Drop the smallest one\n      pool.shift();\n    }\n  }\n}\n\nexport default new TypedArrayManager();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}