{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { earcut } from '@math.gl/polygon';\nexport function flatGeojsonToBinary(features, geometryInfo, options) {\n  var propArrayTypes = extractNumericPropTypes(features);\n  var numericPropKeys = Object.keys(propArrayTypes).filter(function (k) {\n    return propArrayTypes[k] !== Array;\n  });\n  return fillArrays(features, _objectSpread({\n    propArrayTypes: propArrayTypes\n  }, geometryInfo), {\n    numericPropKeys: options && options.numericPropKeys || numericPropKeys,\n    PositionDataType: options ? options.PositionDataType : Float32Array\n  });\n}\nexport var TEST_EXPORTS = {\n  extractNumericPropTypes: extractNumericPropTypes\n};\nfunction extractNumericPropTypes(features) {\n  var propArrayTypes = {};\n  var _iterator = _createForOfIteratorHelper(features),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var feature = _step.value;\n      if (feature.properties) {\n        for (var key in feature.properties) {\n          var val = feature.properties[key];\n          propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return propArrayTypes;\n}\nfunction fillArrays(features, geometryInfo, options) {\n  var pointPositionsCount = geometryInfo.pointPositionsCount,\n    pointFeaturesCount = geometryInfo.pointFeaturesCount,\n    linePositionsCount = geometryInfo.linePositionsCount,\n    linePathsCount = geometryInfo.linePathsCount,\n    lineFeaturesCount = geometryInfo.lineFeaturesCount,\n    polygonPositionsCount = geometryInfo.polygonPositionsCount,\n    polygonObjectsCount = geometryInfo.polygonObjectsCount,\n    polygonRingsCount = geometryInfo.polygonRingsCount,\n    polygonFeaturesCount = geometryInfo.polygonFeaturesCount,\n    propArrayTypes = geometryInfo.propArrayTypes,\n    coordLength = geometryInfo.coordLength;\n  var _options$numericPropK = options.numericPropKeys,\n    numericPropKeys = _options$numericPropK === void 0 ? [] : _options$numericPropK,\n    _options$PositionData = options.PositionDataType,\n    PositionDataType = _options$PositionData === void 0 ? Float32Array : _options$PositionData;\n  var hasGlobalId = features[0] && 'id' in features[0];\n  var GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  var points = {\n    type: 'Point',\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  var lines = {\n    type: 'LineString',\n    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  var polygons = {\n    type: 'Polygon',\n    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    triangles: [],\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  for (var _i = 0, _arr = [points, lines, polygons]; _i < _arr.length; _i++) {\n    var object = _arr[_i];\n    var _iterator2 = _createForOfIteratorHelper(numericPropKeys),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var propName = _step2.value;\n        var T = propArrayTypes[propName];\n        object.numericProps[propName] = new T(object.positions.length / coordLength);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n  var indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n  var _iterator3 = _createForOfIteratorHelper(features),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var feature = _step3.value;\n      var geometry = feature.geometry;\n      var properties = feature.properties || {};\n      switch (geometry.type) {\n        case 'Point':\n          handlePoint(geometry, points, indexMap, coordLength, properties);\n          points.properties.push(keepStringProperties(properties, numericPropKeys));\n          if (hasGlobalId) {\n            points.fields.push({\n              id: feature.id\n            });\n          }\n          indexMap.pointFeature++;\n          break;\n        case 'LineString':\n          handleLineString(geometry, lines, indexMap, coordLength, properties);\n          lines.properties.push(keepStringProperties(properties, numericPropKeys));\n          if (hasGlobalId) {\n            lines.fields.push({\n              id: feature.id\n            });\n          }\n          indexMap.lineFeature++;\n          break;\n        case 'Polygon':\n          handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n          polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n          if (hasGlobalId) {\n            polygons.fields.push({\n              id: feature.id\n            });\n          }\n          indexMap.polygonFeature++;\n          break;\n        default:\n          throw new Error('Invalid geometry type');\n      }\n      indexMap.feature++;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\nfunction handlePoint(geometry, points, indexMap, coordLength, properties) {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n  var nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  indexMap.pointPosition += nPositions;\n}\nfunction handleLineString(geometry, lines, indexMap, coordLength, properties) {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n  var nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);\n  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);\n  for (var i = 0, il = geometry.indices.length; i < il; ++i) {\n    var start = geometry.indices[i];\n    var end = i === il - 1 ? geometry.data.length : geometry.indices[i + 1];\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\nfunction handlePolygon(geometry, polygons, indexMap, coordLength, properties) {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n  var nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n  for (var l = 0, ll = geometry.indices.length; l < ll; ++l) {\n    var startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n    var areas = geometry.areas[l];\n    var indices = geometry.indices[l];\n    var nextIndices = geometry.indices[l + 1];\n    for (var i = 0, il = indices.length; i < il; ++i) {\n      var start = indices[i];\n      var end = i === il - 1 ? nextIndices === undefined ? geometry.data.length : nextIndices[0] : indices[i + 1];\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n    var endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, indices, {\n      startPosition: startPosition,\n      endPosition: endPosition,\n      coordLength: coordLength\n    });\n  }\n}\nfunction triangulatePolygon(polygons, areas, indices, _ref) {\n  var startPosition = _ref.startPosition,\n    endPosition = _ref.endPosition,\n    coordLength = _ref.coordLength;\n  var start = startPosition * coordLength;\n  var end = endPosition * coordLength;\n  var polygonPositions = polygons.positions.subarray(start, end);\n  var offset = indices[0];\n  var holes = indices.slice(1).map(function (n) {\n    return (n - offset) / coordLength;\n  });\n  var triangles = earcut(polygonPositions, holes, coordLength, areas);\n  for (var t = 0, tl = triangles.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + triangles[t]);\n  }\n}\nfunction wrapProps(obj, size) {\n  var returnObj = {};\n  for (var key in obj) {\n    returnObj[key] = {\n      value: obj[key],\n      size: size\n    };\n  }\n  return returnObj;\n}\nfunction makeAccessorObjects(points, lines, polygons, coordLength) {\n  return {\n    points: _objectSpread(_objectSpread({}, points), {}, {\n      positions: {\n        value: points.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: points.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: points.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(points.numericProps, 1)\n    }),\n    lines: _objectSpread(_objectSpread({}, lines), {}, {\n      positions: {\n        value: lines.positions,\n        size: coordLength\n      },\n      pathIndices: {\n        value: lines.pathIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: lines.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: lines.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(lines.numericProps, 1)\n    }),\n    polygons: _objectSpread(_objectSpread({}, polygons), {}, {\n      positions: {\n        value: polygons.positions,\n        size: coordLength\n      },\n      polygonIndices: {\n        value: polygons.polygonIndices,\n        size: 1\n      },\n      primitivePolygonIndices: {\n        value: polygons.primitivePolygonIndices,\n        size: 1\n      },\n      triangles: {\n        value: new Uint32Array(polygons.triangles),\n        size: 1\n      },\n      globalFeatureIds: {\n        value: polygons.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: polygons.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(polygons.numericProps, 1)\n    })\n  };\n}\nfunction fillNumericProperties(object, properties, index, length) {\n  for (var numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      var value = properties[numericPropName];\n      object.numericProps[numericPropName].fill(value, index, index + length);\n    }\n  }\n}\nfunction keepStringProperties(properties, numericKeys) {\n  var props = {};\n  for (var key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n  return props;\n}\nfunction deduceArrayType(x, constructor) {\n  if (constructor === Array || !Number.isFinite(x)) {\n    return Array;\n  }\n  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}","map":{"version":3,"names":["earcut","flatGeojsonToBinary","features","geometryInfo","options","propArrayTypes","extractNumericPropTypes","numericPropKeys","Object","keys","filter","k","Array","fillArrays","_objectSpread","PositionDataType","Float32Array","TEST_EXPORTS","_iterator","_createForOfIteratorHelper","_step","s","n","done","feature","value","properties","key","val","deduceArrayType","err","e","f","pointPositionsCount","pointFeaturesCount","linePositionsCount","linePathsCount","lineFeaturesCount","polygonPositionsCount","polygonObjectsCount","polygonRingsCount","polygonFeaturesCount","coordLength","_options$numericPropK","_options$PositionData","hasGlobalId","GlobalFeatureIdsDataType","length","Uint32Array","Uint16Array","points","type","positions","globalFeatureIds","featureIds","numericProps","fields","lines","pathIndices","polygons","polygonIndices","primitivePolygonIndices","triangles","_i","_arr","object","_iterator2","_step2","propName","T","indexMap","pointPosition","pointFeature","linePosition","linePath","lineFeature","polygonPosition","polygonObject","polygonRing","polygonFeature","_iterator3","_step3","geometry","handlePoint","push","keepStringProperties","id","handleLineString","handlePolygon","Error","makeAccessorObjects","set","data","nPositions","fillNumericProperties","fill","i","il","indices","start","end","l","ll","startPosition","areas","nextIndices","undefined","endPosition","triangulatePolygon","_ref","polygonPositions","subarray","offset","holes","slice","map","t","tl","wrapProps","obj","size","returnObj","index","numericPropName","numericKeys","props","includes","x","constructor","Number","isFinite","Float64Array","Math","fround"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/gis/src/lib/flat-geojson-to-binary.ts"],"sourcesContent":["/* eslint-disable indent */\nimport {earcut} from '@math.gl/polygon';\nimport type {\n  BinaryAttribute,\n  BinaryFeatures,\n  FlatFeature,\n  FlatPoint,\n  FlatLineString,\n  FlatPolygon,\n  GeojsonGeometryInfo,\n  TypedArray\n} from '@loaders.gl/schema';\nimport {PropArrayConstructor, Lines, Points, Polygons} from './flat-geojson-to-binary-types';\n\n/**\n * Convert binary features to flat binary arrays. Similar to\n * `geojsonToBinary` helper function, except that it expects\n * a binary representation of the feature data, which enables\n * 2X-3X speed increase in parse speed, compared to using\n * geoJSON. See `binary-vector-tile/VectorTileFeature` for\n * data format detais\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns filled arrays\n */\nexport function flatGeojsonToBinary(\n  features: FlatFeature[],\n  geometryInfo: GeojsonGeometryInfo,\n  options?: FlatGeojsonToBinaryOptions\n) {\n  const propArrayTypes = extractNumericPropTypes(features);\n  const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);\n  return fillArrays(\n    features,\n    {\n      propArrayTypes,\n      ...geometryInfo\n    },\n    {\n      numericPropKeys: (options && options.numericPropKeys) || numericPropKeys,\n      PositionDataType: options ? options.PositionDataType : Float32Array\n    }\n  );\n}\n\n/**\n * Options for `flatGeojsonToBinary`\n */\nexport type FlatGeojsonToBinaryOptions = {\n  numericPropKeys?: string[];\n  PositionDataType?: Float32ArrayConstructor | Float64ArrayConstructor;\n};\n\nexport const TEST_EXPORTS = {\n  extractNumericPropTypes\n};\n\n/**\n * Extracts properties that are always numeric\n *\n * @param features\n * @returns object with numeric types\n */\nfunction extractNumericPropTypes(features: FlatFeature[]): {\n  [key: string]: PropArrayConstructor;\n} {\n  const propArrayTypes = {};\n  for (const feature of features) {\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        // If property has not been seen before, or if property has been numeric\n        // in all previous features, check if numeric in this feature\n        // If not numeric, Array is stored to prevent rechecking in the future\n        // Additionally, detects if 64 bit precision is required\n        const val = feature.properties[key];\n        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n      }\n    }\n  }\n\n  return propArrayTypes;\n}\n\n/**\n * Fills coordinates into pre-allocated typed arrays\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns an accessor object with value and size keys\n */\n// eslint-disable-next-line complexity\nfunction fillArrays(\n  features: FlatFeature[],\n  geometryInfo: GeojsonGeometryInfo & {\n    propArrayTypes: {[key: string]: PropArrayConstructor};\n  },\n  options: FlatGeojsonToBinaryOptions\n) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount,\n    propArrayTypes,\n    coordLength\n  } = geometryInfo;\n  const {numericPropKeys = [], PositionDataType = Float32Array} = options;\n  const hasGlobalId = features[0] && 'id' in features[0];\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points: Points = {\n    type: 'Point',\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds:\n      pointFeaturesCount > 65535\n        ? new Uint32Array(pointPositionsCount)\n        : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const lines: Lines = {\n    type: 'LineString',\n    pathIndices:\n      linePositionsCount > 65535\n        ? new Uint32Array(linePathsCount + 1)\n        : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds:\n      lineFeaturesCount > 65535\n        ? new Uint32Array(linePositionsCount)\n        : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const polygons: Polygons = {\n    type: 'Polygon',\n    polygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonObjectsCount + 1)\n        : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonRingsCount + 1)\n        : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    triangles: [],\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds:\n      polygonFeaturesCount > 65535\n        ? new Uint32Array(polygonPositionsCount)\n        : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n\n  // Instantiate numeric properties arrays; one value per vertex\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys) {\n      // If property has been numeric in all previous features in which the property existed, check\n      // if numeric in this feature\n      const T = propArrayTypes[propName];\n      object.numericProps[propName] = new T(object.positions.length / coordLength) as TypedArray;\n    }\n  }\n\n  // Set last element of path/polygon indices as positions length\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties = feature.properties || {};\n\n    switch (geometry.type) {\n      case 'Point':\n        handlePoint(geometry, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          points.fields.push({id: feature.id});\n        }\n        indexMap.pointFeature++;\n        break;\n      case 'LineString':\n        handleLineString(geometry, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          lines.fields.push({id: feature.id});\n        }\n        indexMap.lineFeature++;\n        break;\n      case 'Polygon':\n        handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          polygons.fields.push({id: feature.id});\n        }\n        indexMap.polygonFeature++;\n        break;\n      default:\n        throw new Error('Invalid geometry type');\n    }\n\n    indexMap.feature++;\n  }\n\n  // Wrap each array in an accessor object with value and size keys\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\n/**\n * Fills (Multi)Point coordinates into points object of arrays\n *\n * @param geometry\n * @param points\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePoint(\n  geometry: FlatPoint,\n  points: Points,\n  indexMap: {\n    pointPosition: number;\n    pointFeature: number;\n    linePosition?: number;\n    linePath?: number;\n    lineFeature?: number;\n    polygonPosition?: number;\n    polygonObject?: number;\n    polygonRing?: number;\n    polygonFeature?: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.pointPosition,\n    indexMap.pointPosition + nPositions\n  );\n  points.featureIds.fill(\n    indexMap.pointFeature,\n    indexMap.pointPosition,\n    indexMap.pointPosition + nPositions\n  );\n\n  indexMap.pointPosition += nPositions;\n}\n\n/**\n * Fills (Multi)LineString coordinates into lines object of arrays\n *\n * @param geometry\n * @param lines\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handleLineString(\n  geometry: FlatLineString,\n  lines: Lines,\n  indexMap: {\n    pointPosition?: number;\n    pointFeature?: number;\n    linePosition: number;\n    linePath: number;\n    lineFeature: number;\n    polygonPosition?: number;\n    polygonObject?: number;\n    polygonRing?: number;\n    polygonFeature?: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n\n  lines.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.linePosition,\n    indexMap.linePosition + nPositions\n  );\n  lines.featureIds.fill(\n    indexMap.lineFeature,\n    indexMap.linePosition,\n    indexMap.linePosition + nPositions\n  );\n\n  for (let i = 0, il = geometry.indices.length; i < il; ++i) {\n    // Extract range of data we are working with, defined by start\n    // and end indices (these index into the geometry.data array)\n    const start = geometry.indices[i];\n    const end =\n      i === il - 1\n        ? geometry.data.length // last line, so read to end of data\n        : geometry.indices[i + 1]; // start index for next line\n\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\n\n/**\n * Fills (Multi)Polygon coordinates into polygons object of arrays\n *\n * @param geometry\n * @param polygons\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePolygon(\n  geometry: FlatPolygon,\n  polygons: Polygons,\n  indexMap: {\n    pointPosition?: number;\n    pointFeature?: number;\n    linePosition?: number;\n    linePath?: number;\n    lineFeature?: number;\n    polygonPosition: number;\n    polygonObject: number;\n    polygonRing: number;\n    polygonFeature: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.polygonPosition,\n    indexMap.polygonPosition + nPositions\n  );\n  polygons.featureIds.fill(\n    indexMap.polygonFeature,\n    indexMap.polygonPosition,\n    indexMap.polygonPosition + nPositions\n  );\n\n  // Unlike Point & LineString geometry.indices is a 2D array\n  for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {\n    const startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n\n    const areas = geometry.areas[l];\n    const indices = geometry.indices[l];\n    const nextIndices = geometry.indices[l + 1];\n\n    for (let i = 0, il = indices.length; i < il; ++i) {\n      const start = indices[i];\n      const end =\n        i === il - 1\n          ? // last line, so either read to:\n            nextIndices === undefined\n            ? geometry.data.length // end of data (no next indices)\n            : nextIndices[0] // start of first line in nextIndices\n          : indices[i + 1]; // start index for next line\n\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n\n    const endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, indices, {startPosition, endPosition, coordLength});\n  }\n}\n\n/**\n * Triangulate polygon using earcut\n *\n * @param polygons\n * @param areas\n * @param indices\n * @param param3\n */\nfunction triangulatePolygon(\n  polygons: Polygons,\n  areas: number[],\n  indices: number[],\n  {\n    startPosition,\n    endPosition,\n    coordLength\n  }: {startPosition: number; endPosition: number; coordLength: number}\n): void {\n  const start = startPosition * coordLength;\n  const end = endPosition * coordLength;\n\n  // Extract positions and holes for just this polygon\n  const polygonPositions = polygons.positions.subarray(start, end);\n\n  // Holes are referenced relative to outer polygon\n  const offset = indices[0];\n  const holes = indices.slice(1).map((n: number) => (n - offset) / coordLength);\n\n  // Compute triangulation\n  // @ts-expect-error TODO can earcut handle binary arrays? Add tests?\n  const triangles = earcut(polygonPositions, holes, coordLength, areas);\n\n  // Indices returned by triangulation are relative to start\n  // of polygon, so we need to offset\n  for (let t = 0, tl = triangles.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + triangles[t]);\n  }\n}\n\n/**\n * Wraps an object containing array into accessors\n *\n * @param obj\n * @param size\n */\nfunction wrapProps(\n  obj: {[key: string]: TypedArray},\n  size: number\n): {[key: string]: BinaryAttribute} {\n  const returnObj = {};\n  for (const key in obj) {\n    returnObj[key] = {value: obj[key], size};\n  }\n  return returnObj;\n}\n\n/**\n * Wrap each array in an accessor object with value and size keys\n *\n * @param points\n * @param lines\n * @param polygons\n * @param coordLength\n * @returns object\n */\nfunction makeAccessorObjects(\n  points: Points,\n  lines: Lines,\n  polygons: Polygons,\n  coordLength: number\n): BinaryFeatures {\n  return {\n    points: {\n      ...points,\n      positions: {value: points.positions, size: coordLength},\n      globalFeatureIds: {value: points.globalFeatureIds, size: 1},\n      featureIds: {value: points.featureIds, size: 1},\n      numericProps: wrapProps(points.numericProps, 1)\n    },\n    lines: {\n      ...lines,\n      positions: {value: lines.positions, size: coordLength},\n      pathIndices: {value: lines.pathIndices, size: 1},\n      globalFeatureIds: {value: lines.globalFeatureIds, size: 1},\n      featureIds: {value: lines.featureIds, size: 1},\n      numericProps: wrapProps(lines.numericProps, 1)\n    },\n    polygons: {\n      ...polygons,\n      positions: {value: polygons.positions, size: coordLength},\n      polygonIndices: {value: polygons.polygonIndices, size: 1},\n      primitivePolygonIndices: {value: polygons.primitivePolygonIndices, size: 1},\n      triangles: {value: new Uint32Array(polygons.triangles), size: 1},\n      globalFeatureIds: {value: polygons.globalFeatureIds, size: 1},\n      featureIds: {value: polygons.featureIds, size: 1},\n      numericProps: wrapProps(polygons.numericProps, 1)\n    }\n  };\n}\n\n/**\n * Add numeric properties to object\n *\n * @param object\n * @param properties\n * @param index\n * @param length\n */\nfunction fillNumericProperties(\n  object: Points | Lines | Polygons,\n  properties: {[x: string]: string | number | boolean | null},\n  index: number,\n  length: number\n): void {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      const value = properties[numericPropName] as number;\n      object.numericProps[numericPropName].fill(value, index, index + length);\n    }\n  }\n}\n\n/**\n * Keep string properties in object\n *\n * @param properties\n * @param numericKeys\n * @returns object\n */\nfunction keepStringProperties(\n  properties: {[x: string]: string | number | boolean | null},\n  numericKeys: string[]\n) {\n  const props = {};\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n  return props;\n}\n\n/**\n *\n * Deduce correct array constructor to use for a given value\n *\n * @param x value to test\n * @param constructor previous constructor deduced\n * @returns PropArrayConstructor\n */\nfunction deduceArrayType(x: any, constructor: PropArrayConstructor): PropArrayConstructor {\n  if (constructor === Array || !Number.isFinite(x)) {\n    return Array;\n  }\n\n  // If this or previous value required 64bits use Float64Array\n  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}