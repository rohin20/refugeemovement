{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport CollectionView from './CollectionView';\nimport _calculateSizeAndPositionData from './utils/calculateSizeAndPositionData';\nimport getUpdatedOffsetForIndex from '../utils/getUpdatedOffsetForIndex';\n\n/**\n * Renders scattered or non-linear data.\n * Unlike Grid, which renders checkerboard data, Collection can render arbitrarily positioned- even overlapping- data.\n */\nvar Collection = /*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(Collection, _React$PureComponent);\n  function Collection(props, context) {\n    var _this;\n    _classCallCheck(this, Collection);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Collection).call(this, props, context));\n    _this._cellMetadata = [];\n    _this._lastRenderedCellIndices = []; // Cell cache during scroll (for performance)\n\n    _this._cellCache = [];\n    _this._isScrollingChange = _this._isScrollingChange.bind(_assertThisInitialized(_this));\n    _this._setCollectionViewRef = _this._setCollectionViewRef.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  _createClass(Collection, [{\n    key: \"forceUpdate\",\n    value: function forceUpdate() {\n      if (this._collectionView !== undefined) {\n        this._collectionView.forceUpdate();\n      }\n    }\n    /** See Collection#recomputeCellSizesAndPositions */\n  }, {\n    key: \"recomputeCellSizesAndPositions\",\n    value: function recomputeCellSizesAndPositions() {\n      this._cellCache = [];\n      this._collectionView.recomputeCellSizesAndPositions();\n    }\n    /** React lifecycle methods */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var props = _extends({}, this.props);\n      return React.createElement(CollectionView, _extends({\n        cellLayoutManager: this,\n        isScrollingChange: this._isScrollingChange,\n        ref: this._setCollectionViewRef\n      }, props));\n    }\n    /** CellLayoutManager interface */\n  }, {\n    key: \"calculateSizeAndPositionData\",\n    value: function calculateSizeAndPositionData() {\n      var _this$props = this.props,\n        cellCount = _this$props.cellCount,\n        cellSizeAndPositionGetter = _this$props.cellSizeAndPositionGetter,\n        sectionSize = _this$props.sectionSize;\n      var data = _calculateSizeAndPositionData({\n        cellCount: cellCount,\n        cellSizeAndPositionGetter: cellSizeAndPositionGetter,\n        sectionSize: sectionSize\n      });\n      this._cellMetadata = data.cellMetadata;\n      this._sectionManager = data.sectionManager;\n      this._height = data.height;\n      this._width = data.width;\n    }\n    /**\n     * Returns the most recently rendered set of cell indices.\n     */\n  }, {\n    key: \"getLastRenderedIndices\",\n    value: function getLastRenderedIndices() {\n      return this._lastRenderedCellIndices;\n    }\n    /**\n     * Calculates the minimum amount of change from the current scroll position to ensure the specified cell is (fully) visible.\n     */\n  }, {\n    key: \"getScrollPositionForCell\",\n    value: function getScrollPositionForCell(_ref) {\n      var align = _ref.align,\n        cellIndex = _ref.cellIndex,\n        height = _ref.height,\n        scrollLeft = _ref.scrollLeft,\n        scrollTop = _ref.scrollTop,\n        width = _ref.width;\n      var cellCount = this.props.cellCount;\n      if (cellIndex >= 0 && cellIndex < cellCount) {\n        var cellMetadata = this._cellMetadata[cellIndex];\n        scrollLeft = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.x,\n          cellSize: cellMetadata.width,\n          containerSize: width,\n          currentOffset: scrollLeft,\n          targetIndex: cellIndex\n        });\n        scrollTop = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.y,\n          cellSize: cellMetadata.height,\n          containerSize: height,\n          currentOffset: scrollTop,\n          targetIndex: cellIndex\n        });\n      }\n      return {\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      };\n    }\n  }, {\n    key: \"getTotalSize\",\n    value: function getTotalSize() {\n      return {\n        height: this._height,\n        width: this._width\n      };\n    }\n  }, {\n    key: \"cellRenderers\",\n    value: function cellRenderers(_ref2) {\n      var _this2 = this;\n      var height = _ref2.height,\n        isScrolling = _ref2.isScrolling,\n        width = _ref2.width,\n        x = _ref2.x,\n        y = _ref2.y;\n      var _this$props2 = this.props,\n        cellGroupRenderer = _this$props2.cellGroupRenderer,\n        cellRenderer = _this$props2.cellRenderer; // Store for later calls to getLastRenderedIndices()\n\n      this._lastRenderedCellIndices = this._sectionManager.getCellIndices({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      });\n      return cellGroupRenderer({\n        cellCache: this._cellCache,\n        cellRenderer: cellRenderer,\n        cellSizeAndPositionGetter: function cellSizeAndPositionGetter(_ref3) {\n          var index = _ref3.index;\n          return _this2._sectionManager.getCellMetadata({\n            index: index\n          });\n        },\n        indices: this._lastRenderedCellIndices,\n        isScrolling: isScrolling\n      });\n    }\n  }, {\n    key: \"_isScrollingChange\",\n    value: function _isScrollingChange(isScrolling) {\n      if (!isScrolling) {\n        this._cellCache = [];\n      }\n    }\n  }, {\n    key: \"_setCollectionViewRef\",\n    value: function _setCollectionViewRef(ref) {\n      this._collectionView = ref;\n    }\n  }]);\n  return Collection;\n}(React.PureComponent);\n_defineProperty(Collection, \"defaultProps\", {\n  'aria-label': 'grid',\n  cellGroupRenderer: defaultCellGroupRenderer\n});\nexport { Collection as default };\nCollection.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': PropTypes.string,\n  /**\n   * Number of cells in Collection.\n   */\n  cellCount: PropTypes.number.isRequired,\n  /**\n   * Responsible for rendering a group of cells given their indices.\n   * Should implement the following interface: ({\n   *   cellSizeAndPositionGetter:Function,\n   *   indices: Array<number>,\n   *   cellRenderer: Function\n   * }): Array<PropTypes.node>\n   */\n  cellGroupRenderer: PropTypes.func.isRequired,\n  /**\n   * Responsible for rendering a cell given an row and column index.\n   * Should implement the following interface: ({ index: number, key: string, style: object }): PropTypes.element\n   */\n  cellRenderer: PropTypes.func.isRequired,\n  /**\n   * Callback responsible for returning size and offset/position information for a given cell (index).\n   * ({ index: number }): { height: number, width: number, x: number, y: number }\n   */\n  cellSizeAndPositionGetter: PropTypes.func.isRequired,\n  /**\n   * Optionally override the size of the sections a Collection's cells are split into.\n   */\n  sectionSize: PropTypes.number\n} : {};\nfunction defaultCellGroupRenderer(_ref4) {\n  var cellCache = _ref4.cellCache,\n    cellRenderer = _ref4.cellRenderer,\n    cellSizeAndPositionGetter = _ref4.cellSizeAndPositionGetter,\n    indices = _ref4.indices,\n    isScrolling = _ref4.isScrolling;\n  return indices.map(function (index) {\n    var cellMetadata = cellSizeAndPositionGetter({\n      index: index\n    });\n    var cellRendererProps = {\n      index: index,\n      isScrolling: isScrolling,\n      key: index,\n      style: {\n        height: cellMetadata.height,\n        left: cellMetadata.x,\n        position: 'absolute',\n        top: cellMetadata.y,\n        width: cellMetadata.width\n      }\n    }; // Avoid re-creating cells while scrolling.\n    // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n    // If a scroll is in progress- cache and reuse cells.\n    // This cache will be thrown away once scrolling complets.\n\n    if (isScrolling) {\n      if (!(index in cellCache)) {\n        cellCache[index] = cellRenderer(cellRendererProps);\n      }\n      return cellCache[index];\n    } else {\n      return cellRenderer(cellRendererProps);\n    }\n  }).filter(function (renderedCell) {\n    return !!renderedCell;\n  });\n}\nimport { bpfrpt_proptype_ScrollPosition } from \"./types\";\nimport { bpfrpt_proptype_SizeInfo } from \"./types\";","map":{"version":3,"names":["_extends","_classCallCheck","_createClass","_possibleConstructorReturn","_getPrototypeOf","_assertThisInitialized","_inherits","_defineProperty","PropTypes","React","CollectionView","_calculateSizeAndPositionData","getUpdatedOffsetForIndex","Collection","_React$PureComponent","props","context","_this","call","_cellMetadata","_lastRenderedCellIndices","_cellCache","_isScrollingChange","bind","_setCollectionViewRef","key","value","forceUpdate","_collectionView","undefined","recomputeCellSizesAndPositions","render","createElement","cellLayoutManager","isScrollingChange","ref","calculateSizeAndPositionData","_this$props","cellCount","cellSizeAndPositionGetter","sectionSize","data","cellMetadata","_sectionManager","sectionManager","_height","height","_width","width","getLastRenderedIndices","getScrollPositionForCell","_ref","align","cellIndex","scrollLeft","scrollTop","cellOffset","x","cellSize","containerSize","currentOffset","targetIndex","y","getTotalSize","cellRenderers","_ref2","_this2","isScrolling","_this$props2","cellGroupRenderer","cellRenderer","getCellIndices","cellCache","_ref3","index","getCellMetadata","indices","PureComponent","defaultCellGroupRenderer","default","propTypes","process","env","NODE_ENV","string","number","isRequired","func","_ref4","map","cellRendererProps","style","left","position","top","filter","renderedCell","bpfrpt_proptype_ScrollPosition","bpfrpt_proptype_SizeInfo"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/react-virtualized/dist/es/Collection/Collection.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport CollectionView from './CollectionView';\nimport _calculateSizeAndPositionData from './utils/calculateSizeAndPositionData';\nimport getUpdatedOffsetForIndex from '../utils/getUpdatedOffsetForIndex';\n\n/**\n * Renders scattered or non-linear data.\n * Unlike Grid, which renders checkerboard data, Collection can render arbitrarily positioned- even overlapping- data.\n */\nvar Collection =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(Collection, _React$PureComponent);\n\n  function Collection(props, context) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Collection).call(this, props, context));\n    _this._cellMetadata = [];\n    _this._lastRenderedCellIndices = []; // Cell cache during scroll (for performance)\n\n    _this._cellCache = [];\n    _this._isScrollingChange = _this._isScrollingChange.bind(_assertThisInitialized(_this));\n    _this._setCollectionViewRef = _this._setCollectionViewRef.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"forceUpdate\",\n    value: function forceUpdate() {\n      if (this._collectionView !== undefined) {\n        this._collectionView.forceUpdate();\n      }\n    }\n    /** See Collection#recomputeCellSizesAndPositions */\n\n  }, {\n    key: \"recomputeCellSizesAndPositions\",\n    value: function recomputeCellSizesAndPositions() {\n      this._cellCache = [];\n\n      this._collectionView.recomputeCellSizesAndPositions();\n    }\n    /** React lifecycle methods */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var props = _extends({}, this.props);\n\n      return React.createElement(CollectionView, _extends({\n        cellLayoutManager: this,\n        isScrollingChange: this._isScrollingChange,\n        ref: this._setCollectionViewRef\n      }, props));\n    }\n    /** CellLayoutManager interface */\n\n  }, {\n    key: \"calculateSizeAndPositionData\",\n    value: function calculateSizeAndPositionData() {\n      var _this$props = this.props,\n          cellCount = _this$props.cellCount,\n          cellSizeAndPositionGetter = _this$props.cellSizeAndPositionGetter,\n          sectionSize = _this$props.sectionSize;\n\n      var data = _calculateSizeAndPositionData({\n        cellCount: cellCount,\n        cellSizeAndPositionGetter: cellSizeAndPositionGetter,\n        sectionSize: sectionSize\n      });\n\n      this._cellMetadata = data.cellMetadata;\n      this._sectionManager = data.sectionManager;\n      this._height = data.height;\n      this._width = data.width;\n    }\n    /**\n     * Returns the most recently rendered set of cell indices.\n     */\n\n  }, {\n    key: \"getLastRenderedIndices\",\n    value: function getLastRenderedIndices() {\n      return this._lastRenderedCellIndices;\n    }\n    /**\n     * Calculates the minimum amount of change from the current scroll position to ensure the specified cell is (fully) visible.\n     */\n\n  }, {\n    key: \"getScrollPositionForCell\",\n    value: function getScrollPositionForCell(_ref) {\n      var align = _ref.align,\n          cellIndex = _ref.cellIndex,\n          height = _ref.height,\n          scrollLeft = _ref.scrollLeft,\n          scrollTop = _ref.scrollTop,\n          width = _ref.width;\n      var cellCount = this.props.cellCount;\n\n      if (cellIndex >= 0 && cellIndex < cellCount) {\n        var cellMetadata = this._cellMetadata[cellIndex];\n        scrollLeft = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.x,\n          cellSize: cellMetadata.width,\n          containerSize: width,\n          currentOffset: scrollLeft,\n          targetIndex: cellIndex\n        });\n        scrollTop = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.y,\n          cellSize: cellMetadata.height,\n          containerSize: height,\n          currentOffset: scrollTop,\n          targetIndex: cellIndex\n        });\n      }\n\n      return {\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      };\n    }\n  }, {\n    key: \"getTotalSize\",\n    value: function getTotalSize() {\n      return {\n        height: this._height,\n        width: this._width\n      };\n    }\n  }, {\n    key: \"cellRenderers\",\n    value: function cellRenderers(_ref2) {\n      var _this2 = this;\n\n      var height = _ref2.height,\n          isScrolling = _ref2.isScrolling,\n          width = _ref2.width,\n          x = _ref2.x,\n          y = _ref2.y;\n      var _this$props2 = this.props,\n          cellGroupRenderer = _this$props2.cellGroupRenderer,\n          cellRenderer = _this$props2.cellRenderer; // Store for later calls to getLastRenderedIndices()\n\n      this._lastRenderedCellIndices = this._sectionManager.getCellIndices({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      });\n      return cellGroupRenderer({\n        cellCache: this._cellCache,\n        cellRenderer: cellRenderer,\n        cellSizeAndPositionGetter: function cellSizeAndPositionGetter(_ref3) {\n          var index = _ref3.index;\n          return _this2._sectionManager.getCellMetadata({\n            index: index\n          });\n        },\n        indices: this._lastRenderedCellIndices,\n        isScrolling: isScrolling\n      });\n    }\n  }, {\n    key: \"_isScrollingChange\",\n    value: function _isScrollingChange(isScrolling) {\n      if (!isScrolling) {\n        this._cellCache = [];\n      }\n    }\n  }, {\n    key: \"_setCollectionViewRef\",\n    value: function _setCollectionViewRef(ref) {\n      this._collectionView = ref;\n    }\n  }]);\n\n  return Collection;\n}(React.PureComponent);\n\n_defineProperty(Collection, \"defaultProps\", {\n  'aria-label': 'grid',\n  cellGroupRenderer: defaultCellGroupRenderer\n});\n\nexport { Collection as default };\nCollection.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': PropTypes.string,\n\n  /**\n   * Number of cells in Collection.\n   */\n  cellCount: PropTypes.number.isRequired,\n\n  /**\n   * Responsible for rendering a group of cells given their indices.\n   * Should implement the following interface: ({\n   *   cellSizeAndPositionGetter:Function,\n   *   indices: Array<number>,\n   *   cellRenderer: Function\n   * }): Array<PropTypes.node>\n   */\n  cellGroupRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Responsible for rendering a cell given an row and column index.\n   * Should implement the following interface: ({ index: number, key: string, style: object }): PropTypes.element\n   */\n  cellRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Callback responsible for returning size and offset/position information for a given cell (index).\n   * ({ index: number }): { height: number, width: number, x: number, y: number }\n   */\n  cellSizeAndPositionGetter: PropTypes.func.isRequired,\n\n  /**\n   * Optionally override the size of the sections a Collection's cells are split into.\n   */\n  sectionSize: PropTypes.number\n} : {};\n\nfunction defaultCellGroupRenderer(_ref4) {\n  var cellCache = _ref4.cellCache,\n      cellRenderer = _ref4.cellRenderer,\n      cellSizeAndPositionGetter = _ref4.cellSizeAndPositionGetter,\n      indices = _ref4.indices,\n      isScrolling = _ref4.isScrolling;\n  return indices.map(function (index) {\n    var cellMetadata = cellSizeAndPositionGetter({\n      index: index\n    });\n    var cellRendererProps = {\n      index: index,\n      isScrolling: isScrolling,\n      key: index,\n      style: {\n        height: cellMetadata.height,\n        left: cellMetadata.x,\n        position: 'absolute',\n        top: cellMetadata.y,\n        width: cellMetadata.width\n      }\n    }; // Avoid re-creating cells while scrolling.\n    // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n    // If a scroll is in progress- cache and reuse cells.\n    // This cache will be thrown away once scrolling complets.\n\n    if (isScrolling) {\n      if (!(index in cellCache)) {\n        cellCache[index] = cellRenderer(cellRendererProps);\n      }\n\n      return cellCache[index];\n    } else {\n      return cellRenderer(cellRendererProps);\n    }\n  }).filter(function (renderedCell) {\n    return !!renderedCell;\n  });\n}\n\nimport { bpfrpt_proptype_ScrollPosition } from \"./types\";\nimport { bpfrpt_proptype_SizeInfo } from \"./types\";"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}