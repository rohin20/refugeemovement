{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _window = _interopRequireDefault(require(\"global/window\"));\nvar _document = _interopRequireDefault(require(\"global/document\"));\nvar _console = _interopRequireDefault(require(\"global/console\"));\nvar _miniSvgDataUri = _interopRequireDefault(require(\"mini-svg-data-uri\"));\nvar _constants = require(\"@kepler.gl/constants\");\nvar _domUtils = require(\"./dom-utils\"); /**\n                                        * This file is copied from https://github.com/tsayen/dom-to-image\n                                        * Modified by heshan0131 to allow loading external stylesheets and inline webfonts\n                                        */\nvar inliner = newInliner();\nvar fontFaces = newFontFaces();\nvar images = newImages(); // Default impl options\n\nvar defaultOptions = {\n  // Default is to fail on error, no placeholder\n  imagePlaceholder: undefined,\n  // Default cache bust is false, it will use the cache\n  cacheBust: false\n};\nvar domtoimage = {\n  toSvg: toSvg,\n  toPng: toPng,\n  toJpeg: toJpeg,\n  toBlob: toBlob,\n  toPixelData: toPixelData,\n  impl: {\n    fontFaces: fontFaces,\n    images: images,\n    inliner: inliner,\n    options: {}\n  }\n};\n/**\n   * @param {Node} node - The DOM Node object to render\n   * @param {Object} options - Rendering options\n   * @param {Function} [options.filter] - Should return true if passed node should be included in the output\n   *          (excluding node means excluding it's children as well). Not called on the root node.\n   * @param {String} [options.bgcolor] - color for the background, any valid CSS color value.\n   * @param {Number} [options.width] - width to be applied to node before rendering.\n   * @param {Number} [options.height] - height to be applied to node before rendering.\n   * @param {Object} [options.style] - an object whose properties to be copied to node's style before rendering.\n   * @param {Number} [options.quality] - a Number between 0 and 1 indicating image quality (applicable to JPEG only),\n              defaults to 1.0.\n    * @param {String} [options.imagePlaceholder] - dataURL to use as a placeholder for failed images, default behaviour is to fail fast on images we can't fetch\n    * @param {Boolean} [options.cacheBust] - set to true to cache bust by appending the time to the request url\n    * @return {Promise} - A promise that is fulfilled with a SVG image data URL\n    * */\n\nfunction toSvg(node, options) {\n  options = options || {};\n  copyOptions(options);\n  return Promise.resolve(node).then(function (nd) {\n    return cloneNode(nd, options.filter, true);\n  }).then(embedFonts).then(inlineImages).then(applyOptions).then(function (clone) {\n    return makeSvgDataUri(clone, options.width || (0, _domUtils.getWidth)(node), options.height || (0, _domUtils.getHeight)(node));\n  });\n  function applyOptions(clone) {\n    if (options.bgcolor) clone.style.backgroundColor = options.bgcolor;\n    if (options.width) clone.style.width = \"\".concat(options.width, \"px\");\n    if (options.height) clone.style.height = \"\".concat(options.height, \"px\");\n    if (options.style) Object.keys(options.style).forEach(function (property) {\n      clone.style[property] = options.style[property];\n    });\n    return clone;\n  }\n}\n/**\n * @param {Node} node - The DOM Node object to render\n * @param {Object} options - Rendering options\n * @return {Promise} - A promise that is fulfilled with a Uint8Array containing RGBA pixel data.\n * */\n\nfunction toPixelData(node, options) {\n  return draw(node, options || {}).then(function (canvas) {\n    return canvas.getContext('2d').getImageData(0, 0, (0, _domUtils.getWidth)(node), (0, _domUtils.getHeight)(node)).data;\n  });\n}\n/**\n * @param {Node} node - The DOM Node object to render\n * @param {Object} options - Rendering options\n * @return {Promise} - A promise that is fulfilled with a PNG image data URL\n * */\n\nfunction toPng(node, options) {\n  return draw(node, options || {}).then(function (canvas) {\n    return canvas.toDataURL();\n  });\n}\n/**\n * @param {Node} node - The DOM Node object to render\n * @param {Object} options - Rendering options\n * @return {Promise} - A promise that is fulfilled with a JPEG image data URL\n * */\n\nfunction toJpeg(node, options) {\n  options = options || {};\n  return draw(node, options).then(function (canvas) {\n    return canvas.toDataURL('image/jpeg', options.quality || 1.0);\n  });\n}\n/**\n * @param {Node} node - The DOM Node object to render\n * @param {Object} options - Rendering options\n * @return {Promise} - A promise that is fulfilled with a PNG image blob\n * */\n\nfunction toBlob(node, options) {\n  return draw(node, options || {}).then(_domUtils.canvasToBlob);\n}\nfunction copyOptions(options) {\n  // Copy options to impl options for use in impl\n  if (typeof options.imagePlaceholder === 'undefined') {\n    domtoimage.impl.options.imagePlaceholder = defaultOptions.imagePlaceholder;\n  } else {\n    domtoimage.impl.options.imagePlaceholder = options.imagePlaceholder;\n  }\n  if (typeof options.cacheBust === 'undefined') {\n    domtoimage.impl.options.cacheBust = defaultOptions.cacheBust;\n  } else {\n    domtoimage.impl.options.cacheBust = options.cacheBust;\n  }\n}\nfunction draw(domNode, options) {\n  return toSvg(domNode, options).then(_domUtils.makeImage).then((0, _domUtils.delay)(100)).then(function (image) {\n    var canvas = newCanvas(domNode);\n    canvas.getContext('2d').drawImage(image, 0, 0);\n    return canvas;\n  });\n  function newCanvas(dNode) {\n    var canvas = _document[\"default\"].createElement('canvas');\n    canvas.width = options.width || (0, _domUtils.getWidth)(dNode);\n    canvas.height = options.height || (0, _domUtils.getHeight)(dNode);\n    if (options.bgcolor) {\n      var ctx = canvas.getContext('2d');\n      ctx.fillStyle = options.bgcolor;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    return canvas;\n  }\n}\nfunction cloneNode(node, filter, root) {\n  if (!root && filter && !filter(node)) {\n    return Promise.resolve();\n  }\n  return Promise.resolve(node).then(makeNodeCopy).then(function (clone) {\n    return cloneChildren(node, clone, filter);\n  }).then(function (clone) {\n    return (0, _domUtils.processClone)(node, clone);\n  });\n  function makeNodeCopy(nd) {\n    if (nd instanceof _window[\"default\"].HTMLCanvasElement) {\n      return (0, _domUtils.makeImage)(nd.toDataURL());\n    }\n    return nd.cloneNode(false);\n  }\n  function cloneChildrenInOrder(parent, arrChildren, flt) {\n    var done = Promise.resolve();\n    arrChildren.forEach(function (child) {\n      done = done.then(function () {\n        return cloneNode(child, flt, null);\n      }).then(function (childClone) {\n        if (childClone) {\n          parent.appendChild(childClone);\n        }\n      });\n    });\n    return done;\n  }\n  function cloneChildren(original, clone, flt) {\n    var children = original.childNodes;\n    if (children.length === 0) {\n      return Promise.resolve(clone);\n    }\n    return cloneChildrenInOrder(clone, (0, _domUtils.asArray)(children), flt).then(function () {\n      return clone;\n    });\n  }\n}\nfunction embedFonts(node) {\n  return fontFaces.resolveAll().then(function (cssText) {\n    var styleNode = _document[\"default\"].createElement('style');\n    node.appendChild(styleNode);\n    styleNode.appendChild(_document[\"default\"].createTextNode(cssText));\n    return node;\n  });\n}\nfunction inlineImages(node) {\n  return images.inlineAll(node).then(function () {\n    return node;\n  });\n}\nfunction makeSvgDataUri(node, width, height) {\n  return Promise.resolve(node).then(function (nd) {\n    nd.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');\n    var serializedString = new _window[\"default\"].XMLSerializer().serializeToString(nd);\n    var xhtml = (0, _domUtils.escapeXhtml)(serializedString);\n    var foreignObject = \"<foreignObject x=\\\"0\\\" y=\\\"0\\\" width=\\\"100%\\\" height=\\\"100%\\\">\".concat(xhtml, \"</foreignObject>\");\n    var svgStr = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"\".concat(width, \"\\\" height=\\\"\").concat(height, \"\\\">\").concat(foreignObject, \"</svg>\"); // Optimizing SVGs in data URIs\n    // see https://codepen.io/tigt/post/optimizing-svgs-in-data-uris\n    // the best way of encoding SVG in a data: URI is data:image/svg+xml,[actual data].\n    // We don’t need the ;charset=utf-8 parameter because the given SVG is ASCII.\n\n    return (0, _miniSvgDataUri[\"default\"])(svgStr);\n  });\n}\nfunction newInliner() {\n  var URL_REGEX = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n  return {\n    inlineAll: inlineAll,\n    shouldProcess: shouldProcess,\n    impl: {\n      readUrls: readUrls,\n      inline: inline\n    }\n  };\n  function shouldProcess(string) {\n    return string.search(URL_REGEX) !== -1;\n  }\n  function readUrls(string) {\n    var result = [];\n    var match;\n    while ((match = URL_REGEX.exec(string)) !== null) {\n      result.push(match[1]);\n    }\n    return result.filter(function (url) {\n      return !(0, _domUtils.isDataUrl)(url);\n    });\n  }\n  function urlAsRegex(url0) {\n    return new RegExp(\"(url\\\\(['\\\"]?)(\".concat((0, _domUtils.escape)(url0), \")(['\\\"]?\\\\))\"), 'g');\n  }\n  function inline(string, url, baseUrl, get) {\n    return Promise.resolve(url).then(function (ul) {\n      return baseUrl ? (0, _domUtils.resolveUrl)(ul, baseUrl) : ul;\n    }).then(function (ul) {\n      return typeof get === 'function' ? get(ul) : (0, _domUtils.getAndEncode)(ul, domtoimage.impl.options);\n    }).then(function (data) {\n      return (0, _domUtils.dataAsUrl)(data, (0, _domUtils.mimeType)(url));\n    }).then(function (dataUrl) {\n      return string.replace(urlAsRegex(url), \"$1\".concat(dataUrl, \"$3\"));\n    });\n  }\n  function inlineAll(string, baseUrl, get) {\n    if (!shouldProcess(string) || (0, _domUtils.isSrcAsDataUrl)(string)) {\n      return Promise.resolve(string);\n    }\n    return Promise.resolve(string).then(readUrls).then(function (urls) {\n      var done = Promise.resolve(string);\n      urls.forEach(function (url) {\n        done = done.then(function (str) {\n          return inline(str, url, baseUrl, get);\n        });\n      });\n      return done;\n    });\n  }\n}\nfunction newFontFaces() {\n  return {\n    resolveAll: resolveAll,\n    impl: {\n      readAll: readAll\n    }\n  };\n  function resolveAll() {\n    return readAll().then(function (webFonts) {\n      return Promise.all(webFonts.map(function (webFont) {\n        return webFont.resolve();\n      }));\n    }).then(function (cssStrings) {\n      return cssStrings.join('\\n');\n    });\n  }\n  function readAll() {\n    return Promise.resolve((0, _domUtils.asArray)(_document[\"default\"].styleSheets)).then(loadExternalStyleSheets).then(getCssRules).then(selectWebFontRules).then(function (rules) {\n      return rules.map(newWebFont);\n    });\n    function selectWebFontRules(cssRules) {\n      return cssRules.filter(function (rule) {\n        return rule.type === _window[\"default\"].CSSRule.FONT_FACE_RULE;\n      }).filter(function (rule) {\n        return inliner.shouldProcess(rule.style.getPropertyValue('src'));\n      });\n    }\n    function loadExternalStyleSheets(styleSheets) {\n      return Promise.all(styleSheets.map(function (sheet) {\n        if (sheet.href) {\n          // cloudfont doesn't have allow origin header properly set\n          // error response will remain in cache\n          var cache = sheet.href.includes('uber-fonts') ? 'no-cache' : 'default';\n          return _window[\"default\"].fetch(sheet.href, {\n            credentials: 'omit',\n            cache: cache\n          }).then(function (response) {\n            return response.text();\n          }).then(setBaseHref(sheet.href)).then(toStyleSheet)[\"catch\"](function (err) {\n            // Handle any error that occurred in any of the previous\n            // promises in the chain. stylesheet failed to load should not stop\n            // the process, hence result in only a warning, instead of reject\n            _console[\"default\"].warn(_constants.IMAGE_EXPORT_ERRORS.styleSheet, sheet.href);\n            _console[\"default\"].log(err);\n            return;\n          });\n        }\n        return Promise.resolve(sheet);\n      }));\n      function setBaseHref(base) {\n        base = base.split('/');\n        base.pop();\n        base = base.join('/');\n        function addBaseHrefToUrl(match, p1) {\n          var url = /^http/i.test(p1) ? p1 : concatAndResolveUrl(base, p1);\n          return \"url('\".concat(url, \"')\");\n        } // Source: http://stackoverflow.com/a/2676231/3786856\n\n        function concatAndResolveUrl(url, concat) {\n          var url1 = url.split('/');\n          var url2 = concat.split('/');\n          var url3 = [];\n          for (var i = 0, l = url1.length; i < l; i++) {\n            if (url1[i] === '..') {\n              url3.pop();\n            } else if (url1[i] !== '.') {\n              url3.push(url1[i]);\n            }\n          }\n          for (var _i = 0, _l = url2.length; _i < _l; _i++) {\n            if (url2[_i] === '..') {\n              url3.pop();\n            } else if (url2[_i] !== '.') {\n              url3.push(url2[_i]);\n            }\n          }\n          return url3.join('/');\n        }\n        return function (text) {\n          return (0, _domUtils.isSrcAsDataUrl)(text) ? text : text.replace(/url\\(['\"]?([^'\"]+?)['\"]?\\)/g, addBaseHrefToUrl);\n        };\n      }\n      function toStyleSheet(text) {\n        var doc = _document[\"default\"].implementation.createHTMLDocument('');\n        var styleElement = _document[\"default\"].createElement('style');\n        styleElement.textContent = text;\n        doc.body.appendChild(styleElement);\n        return styleElement.sheet;\n      }\n    }\n    function getCssRules(styleSheets) {\n      var cssRules = [];\n      styleSheets.forEach(function (sheet) {\n        // try...catch because browser may not able to enumerate rules for cross-domain sheets\n        if (!sheet) {\n          return;\n        }\n        var rules;\n        try {\n          rules = sheet.rules || sheet.cssRules;\n        } catch (e) {\n          _console[\"default\"].log(\"'Can't read the css rules of: \".concat(sheet.href), e);\n          return;\n        }\n        if (rules && (0, _typeof2[\"default\"])(rules) === 'object') {\n          try {\n            (0, _domUtils.asArray)(rules || []).forEach(cssRules.push.bind(cssRules));\n          } catch (e) {\n            _console[\"default\"].log(\"Error while reading CSS rules from \".concat(sheet.href), e);\n            return;\n          }\n        } else {\n          _console[\"default\"].log('getCssRules can not find cssRules');\n          return;\n        }\n      });\n      return cssRules;\n    }\n    function newWebFont(webFontRule) {\n      return {\n        resolve: function resolve() {\n          var baseUrl = (webFontRule.parentStyleSheet || {}).href;\n          return inliner.inlineAll(webFontRule.cssText, baseUrl, null);\n        },\n        src: function src() {\n          return webFontRule.style.getPropertyValue('src');\n        }\n      };\n    }\n  }\n}\nfunction newImages() {\n  return {\n    inlineAll: inlineAll,\n    impl: {\n      newImage: newImage\n    }\n  };\n  function newImage(element) {\n    function inline(get) {\n      if ((0, _domUtils.isDataUrl)(element.src)) {\n        return Promise.resolve();\n      }\n      return Promise.resolve(element.src).then(function (ul) {\n        return typeof get === 'function' ? get(ul) : (0, _domUtils.getAndEncode)(ul, domtoimage.impl.options);\n      }).then(function (data) {\n        return (0, _domUtils.dataAsUrl)(data, (0, _domUtils.mimeType)(element.src));\n      }).then(function (dataUrl) {\n        return new Promise(function (resolve, reject) {\n          element.onload = resolve;\n          element.onerror = reject;\n          element.src = dataUrl;\n        });\n      });\n    }\n    return {\n      inline: inline\n    };\n  }\n  function inlineAll(node) {\n    if (!(node instanceof Element)) {\n      return Promise.resolve(node);\n    }\n    return inlineBackground(node).then(function () {\n      if (node instanceof HTMLImageElement) {\n        return newImage(node).inline(null);\n      }\n      return Promise.all((0, _domUtils.asArray)(node.childNodes).map(function (child) {\n        return inlineAll(child);\n      }));\n    });\n    function inlineBackground(nd) {\n      var background = nd.style.getPropertyValue('background');\n      if (!background) {\n        return Promise.resolve(nd);\n      }\n      return inliner.inlineAll(background, null, null).then(function (inlined) {\n        nd.style.setProperty('background', inlined, nd.style.getPropertyPriority('background'));\n      }).then(function () {\n        return nd;\n      });\n    }\n  }\n}\nvar _default = domtoimage;\nexports[\"default\"] = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","_typeof2","_interopRequireDefault","require","_window","_document","_console","_miniSvgDataUri","_constants","_domUtils","inliner","newInliner","fontFaces","newFontFaces","images","newImages","defaultOptions","imagePlaceholder","undefined","cacheBust","domtoimage","toSvg","toPng","toJpeg","toBlob","toPixelData","impl","options","node","copyOptions","Promise","resolve","then","nd","cloneNode","filter","embedFonts","inlineImages","applyOptions","clone","makeSvgDataUri","width","getWidth","height","getHeight","style","concat","keys","forEach","property","canvas","getContext","getImageData","data","toDataURL","draw","quality","domNode","newCanvas","drawImage","image","dNode","bgcolor","ctx","fillStyle","fillRect","root","makeNodeCopy","processClone","makeImage","cloneChildrenInOrder","parent","arrChildren","flt","child","done","childClone","appendChild","cloneChildren","original","children","length","asArray","styleNode","createElement","setAttribute","serializedString","XMLSerializer","serializeToString","xhtml","escapeXhtml","foreignObject","svgStr","inlineAll","shouldProcess","readUrls","inline","string","match","URL_REGEX","exec","result","url","urlAsRegex","url0","baseUrl","get","resolveUrl","ul","getAndEncode","dataAsUrl","mimeType","dataUrl","replace","urls","str","resolveAll","readAll","all","webFonts","map","webFont","cssStrings","join","rules","newWebFont","selectWebFontRules","cssRules","rule","type","CSSRule","FONT_FACE_RULE","getPropertyValue","loadExternalStyleSheets","styleSheets","sheet","href","cache","includes","fetch","credentials","response","text","setBaseHref","toStyleSheet","err","warn","IMAGE_EXPORT_ERRORS","styleSheet","log","base","pop","addBaseHrefToUrl","p1","url2","split","url3","i","l","url1","push","_i","_l","styleElement","textContent","getCssRules","e","bind","webFontRule","parentStyleSheet","cssText","src","newImage","element","isDataUrl","reject","onload","onerror","inlineBackground","childNodes","background","inlined","_default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/utils/src/dom-to-image.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * This file is copied from https://github.com/tsayen/dom-to-image\n * Modified by heshan0131 to allow loading external stylesheets and inline webfonts\n */\n\nimport window from 'global/window';\nimport document from 'global/document';\nimport Console from 'global/console';\nimport svgToMiniDataURI from 'mini-svg-data-uri';\nimport {IMAGE_EXPORT_ERRORS} from '@kepler.gl/constants';\nimport {\n  canvasToBlob,\n  escape,\n  escapeXhtml,\n  delay,\n  processClone,\n  asArray,\n  makeImage,\n  mimeType,\n  dataAsUrl,\n  isDataUrl,\n  isSrcAsDataUrl,\n  resolveUrl,\n  getWidth,\n  getHeight,\n  getAndEncode\n} from './dom-utils';\n\nconst inliner = newInliner();\nconst fontFaces = newFontFaces();\nconst images = newImages();\n// Default impl options\nconst defaultOptions = {\n  // Default is to fail on error, no placeholder\n  imagePlaceholder: undefined,\n  // Default cache bust is false, it will use the cache\n  cacheBust: false\n};\n\nconst domtoimage = {\n  toSvg,\n  toPng,\n  toJpeg,\n  toBlob,\n  toPixelData,\n  impl: {\n    fontFaces,\n    images,\n    inliner,\n    options: {} as any\n  }\n};\n\n/**\n   * @param {Node} node - The DOM Node object to render\n   * @param {Object} options - Rendering options\n   * @param {Function} [options.filter] - Should return true if passed node should be included in the output\n   *          (excluding node means excluding it's children as well). Not called on the root node.\n   * @param {String} [options.bgcolor] - color for the background, any valid CSS color value.\n   * @param {Number} [options.width] - width to be applied to node before rendering.\n   * @param {Number} [options.height] - height to be applied to node before rendering.\n   * @param {Object} [options.style] - an object whose properties to be copied to node's style before rendering.\n   * @param {Number} [options.quality] - a Number between 0 and 1 indicating image quality (applicable to JPEG only),\n              defaults to 1.0.\n    * @param {String} [options.imagePlaceholder] - dataURL to use as a placeholder for failed images, default behaviour is to fail fast on images we can't fetch\n    * @param {Boolean} [options.cacheBust] - set to true to cache bust by appending the time to the request url\n    * @return {Promise} - A promise that is fulfilled with a SVG image data URL\n    * */\nfunction toSvg(node, options) {\n  options = options || {};\n  copyOptions(options);\n  return Promise.resolve(node)\n    .then(nd => cloneNode(nd, options.filter, true))\n    .then(embedFonts)\n    .then(inlineImages)\n    .then(applyOptions)\n    .then(clone =>\n      makeSvgDataUri(clone, options.width || getWidth(node), options.height || getHeight(node))\n    );\n\n  function applyOptions(clone) {\n    if (options.bgcolor) clone.style.backgroundColor = options.bgcolor;\n\n    if (options.width) clone.style.width = `${options.width}px`;\n    if (options.height) clone.style.height = `${options.height}px`;\n\n    if (options.style)\n      Object.keys(options.style).forEach(property => {\n        clone.style[property] = options.style[property];\n      });\n\n    return clone;\n  }\n}\n\n/**\n * @param {Node} node - The DOM Node object to render\n * @param {Object} options - Rendering options\n * @return {Promise} - A promise that is fulfilled with a Uint8Array containing RGBA pixel data.\n * */\nfunction toPixelData(node, options) {\n  return draw(node, options || {}).then(\n    canvas => canvas.getContext('2d').getImageData(0, 0, getWidth(node), getHeight(node)).data\n  );\n}\n\n/**\n * @param {Node} node - The DOM Node object to render\n * @param {Object} options - Rendering options\n * @return {Promise} - A promise that is fulfilled with a PNG image data URL\n * */\nfunction toPng(node, options) {\n  return draw(node, options || {}).then(canvas => canvas.toDataURL());\n}\n\n/**\n * @param {Node} node - The DOM Node object to render\n * @param {Object} options - Rendering options\n * @return {Promise} - A promise that is fulfilled with a JPEG image data URL\n * */\nfunction toJpeg(node, options) {\n  options = options || {};\n  return draw(node, options).then(canvas => canvas.toDataURL('image/jpeg', options.quality || 1.0));\n}\n\n/**\n * @param {Node} node - The DOM Node object to render\n * @param {Object} options - Rendering options\n * @return {Promise} - A promise that is fulfilled with a PNG image blob\n * */\nfunction toBlob(node, options) {\n  return draw(node, options || {}).then(canvasToBlob);\n}\n\nfunction copyOptions(options) {\n  // Copy options to impl options for use in impl\n  if (typeof options.imagePlaceholder === 'undefined') {\n    domtoimage.impl.options.imagePlaceholder = defaultOptions.imagePlaceholder;\n  } else {\n    domtoimage.impl.options.imagePlaceholder = options.imagePlaceholder;\n  }\n\n  if (typeof options.cacheBust === 'undefined') {\n    domtoimage.impl.options.cacheBust = defaultOptions.cacheBust;\n  } else {\n    domtoimage.impl.options.cacheBust = options.cacheBust;\n  }\n}\n\nfunction draw(domNode, options) {\n  return toSvg(domNode, options)\n    .then(makeImage)\n    .then(delay(100))\n    .then(image => {\n      const canvas = newCanvas(domNode);\n      canvas.getContext('2d').drawImage(image, 0, 0);\n      return canvas;\n    });\n\n  function newCanvas(dNode) {\n    const canvas = document.createElement('canvas');\n    canvas.width = options.width || getWidth(dNode);\n    canvas.height = options.height || getHeight(dNode);\n\n    if (options.bgcolor) {\n      const ctx = canvas.getContext('2d');\n      ctx.fillStyle = options.bgcolor;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    return canvas;\n  }\n}\n\nfunction cloneNode(node, filter, root) {\n  if (!root && filter && !filter(node)) {\n    return Promise.resolve();\n  }\n\n  return Promise.resolve(node)\n    .then(makeNodeCopy)\n    .then(clone => cloneChildren(node, clone, filter))\n    .then(clone => processClone(node, clone));\n\n  function makeNodeCopy(nd) {\n    if (nd instanceof window.HTMLCanvasElement) {\n      return makeImage(nd.toDataURL());\n    }\n    return nd.cloneNode(false);\n  }\n\n  function cloneChildrenInOrder(parent, arrChildren, flt) {\n    let done = Promise.resolve();\n    arrChildren.forEach(child => {\n      done = done\n        .then(() => cloneNode(child, flt, null))\n        .then(childClone => {\n          if (childClone) {\n            parent.appendChild(childClone);\n          }\n        });\n    });\n    return done;\n  }\n\n  function cloneChildren(original, clone, flt) {\n    const children = original.childNodes;\n    if (children.length === 0) {\n      return Promise.resolve(clone);\n    }\n\n    return cloneChildrenInOrder(clone, asArray(children), flt).then(() => clone);\n  }\n}\n\nfunction embedFonts(node) {\n  return fontFaces.resolveAll().then(cssText => {\n    const styleNode = document.createElement('style');\n    node.appendChild(styleNode);\n    styleNode.appendChild(document.createTextNode(cssText));\n    return node;\n  });\n}\n\nfunction inlineImages(node) {\n  return images.inlineAll(node).then(() => node);\n}\n\nfunction makeSvgDataUri(node, width, height) {\n  return Promise.resolve(node).then(nd => {\n    nd.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');\n    const serializedString = new window.XMLSerializer().serializeToString(nd);\n\n    const xhtml = escapeXhtml(serializedString);\n    const foreignObject = `<foreignObject x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">${xhtml}</foreignObject>`;\n    const svgStr = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\">${foreignObject}</svg>`;\n\n    // Optimizing SVGs in data URIs\n    // see https://codepen.io/tigt/post/optimizing-svgs-in-data-uris\n    // the best way of encoding SVG in a data: URI is data:image/svg+xml,[actual data].\n    // We don’t need the ;charset=utf-8 parameter because the given SVG is ASCII.\n    return svgToMiniDataURI(svgStr);\n  });\n}\n\nfunction newInliner() {\n  const URL_REGEX = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n\n  return {\n    inlineAll,\n    shouldProcess,\n    impl: {\n      readUrls,\n      inline\n    }\n  };\n\n  function shouldProcess(string) {\n    return string.search(URL_REGEX) !== -1;\n  }\n\n  function readUrls(string) {\n    const result: string[] = [];\n    let match: null | RegExpExecArray;\n    while ((match = URL_REGEX.exec(string)) !== null) {\n      result.push(match[1]);\n    }\n    return result.filter(url => {\n      return !isDataUrl(url);\n    });\n  }\n\n  function urlAsRegex(url0) {\n    return new RegExp(`(url\\\\([\\'\"]?)(${escape(url0)})([\\'\"]?\\\\))`, 'g');\n  }\n\n  function inline(string, url, baseUrl, get) {\n    return Promise.resolve(url)\n      .then(ul => (baseUrl ? resolveUrl(ul, baseUrl) : ul))\n      .then(ul => (typeof get === 'function' ? get(ul) : getAndEncode(ul, domtoimage.impl.options)))\n      .then(data => dataAsUrl(data, mimeType(url)))\n      .then(dataUrl => string.replace(urlAsRegex(url), `$1${dataUrl}$3`));\n  }\n\n  function inlineAll(string, baseUrl, get) {\n    if (!shouldProcess(string) || isSrcAsDataUrl(string)) {\n      return Promise.resolve(string);\n    }\n    return Promise.resolve(string)\n      .then(readUrls)\n      .then(urls => {\n        let done = Promise.resolve(string);\n        urls.forEach(url => {\n          done = done.then(str => inline(str, url, baseUrl, get));\n        });\n        return done;\n      });\n  }\n}\n\nfunction newFontFaces() {\n  return {\n    resolveAll,\n    impl: {readAll}\n  };\n\n  function resolveAll() {\n    return readAll()\n      .then(webFonts => {\n        return Promise.all(webFonts.map(webFont => webFont.resolve()));\n      })\n      .then(cssStrings => cssStrings.join('\\n'));\n  }\n\n  function readAll() {\n    return Promise.resolve(asArray(document.styleSheets))\n      .then(loadExternalStyleSheets)\n      .then(getCssRules)\n      .then(selectWebFontRules)\n      .then(rules => rules.map(newWebFont));\n\n    function selectWebFontRules(cssRules) {\n      return cssRules\n        .filter(rule => rule.type === window.CSSRule.FONT_FACE_RULE)\n        .filter(rule => inliner.shouldProcess(rule.style.getPropertyValue('src')));\n    }\n\n    function loadExternalStyleSheets(styleSheets) {\n      return Promise.all(\n        styleSheets.map(sheet => {\n          if (sheet.href) {\n            // cloudfont doesn't have allow origin header properly set\n            // error response will remain in cache\n            const cache = sheet.href.includes('uber-fonts') ? 'no-cache' : 'default';\n            return window\n              .fetch(sheet.href, {credentials: 'omit', cache})\n              .then(response => response.text())\n              .then(setBaseHref(sheet.href))\n              .then(toStyleSheet)\n              .catch(err => {\n                // Handle any error that occurred in any of the previous\n                // promises in the chain. stylesheet failed to load should not stop\n                // the process, hence result in only a warning, instead of reject\n                Console.warn(IMAGE_EXPORT_ERRORS.styleSheet, sheet.href);\n                Console.log(err);\n                return;\n              });\n          }\n          return Promise.resolve(sheet);\n        })\n      );\n\n      function setBaseHref(base) {\n        base = base.split('/');\n        base.pop();\n        base = base.join('/');\n\n        function addBaseHrefToUrl(match, p1) {\n          const url = /^http/i.test(p1) ? p1 : concatAndResolveUrl(base, p1);\n          return `url('${url}')`;\n        }\n\n        // Source: http://stackoverflow.com/a/2676231/3786856\n        function concatAndResolveUrl(url, concat) {\n          const url1: string[] = url.split('/');\n          const url2: string[] = concat.split('/');\n          const url3: string[] = [];\n          for (let i = 0, l = url1.length; i < l; i++) {\n            if (url1[i] === '..') {\n              url3.pop();\n            } else if (url1[i] !== '.') {\n              url3.push(url1[i]);\n            }\n          }\n          for (let i = 0, l = url2.length; i < l; i++) {\n            if (url2[i] === '..') {\n              url3.pop();\n            } else if (url2[i] !== '.') {\n              url3.push(url2[i]);\n            }\n          }\n          return url3.join('/');\n        }\n\n        return text => {\n          return isSrcAsDataUrl(text)\n            ? text\n            : text.replace(/url\\(['\"]?([^'\"]+?)['\"]?\\)/g, addBaseHrefToUrl);\n        };\n      }\n\n      function toStyleSheet(text) {\n        const doc = document.implementation.createHTMLDocument('');\n        const styleElement = document.createElement('style');\n\n        styleElement.textContent = text;\n        doc.body.appendChild(styleElement);\n\n        return styleElement.sheet;\n      }\n    }\n\n    function getCssRules(styleSheets) {\n      const cssRules: any[] = [];\n      styleSheets.forEach(sheet => {\n        // try...catch because browser may not able to enumerate rules for cross-domain sheets\n        if (!sheet) {\n          return;\n        }\n        let rules;\n        try {\n          rules = sheet.rules || sheet.cssRules;\n        } catch (e) {\n          Console.log(`'Can't read the css rules of: ${sheet.href}`, e);\n          return;\n        }\n\n        if (rules && typeof rules === 'object') {\n          try {\n            asArray(rules || []).forEach(cssRules.push.bind(cssRules));\n          } catch (e) {\n            Console.log(`Error while reading CSS rules from ${sheet.href}`, e);\n            return;\n          }\n        } else {\n          Console.log('getCssRules can not find cssRules');\n          return;\n        }\n      });\n\n      return cssRules;\n    }\n\n    function newWebFont(webFontRule) {\n      return {\n        resolve: () => {\n          const baseUrl = (webFontRule.parentStyleSheet || {}).href;\n          return inliner.inlineAll(webFontRule.cssText, baseUrl, null);\n        },\n        src: () => webFontRule.style.getPropertyValue('src')\n      };\n    }\n  }\n}\n\nfunction newImages() {\n  return {\n    inlineAll,\n    impl: {\n      newImage\n    }\n  };\n\n  function newImage(element) {\n    function inline(get) {\n      if (isDataUrl(element.src)) {\n        return Promise.resolve();\n      }\n      return Promise.resolve(element.src)\n        .then(ul =>\n          typeof get === 'function' ? get(ul) : getAndEncode(ul, domtoimage.impl.options)\n        )\n        .then(data => dataAsUrl(data, mimeType(element.src)))\n        .then(\n          dataUrl =>\n            new Promise((resolve, reject) => {\n              element.onload = resolve;\n              element.onerror = reject;\n              element.src = dataUrl;\n            })\n        );\n    }\n\n    return {\n      inline\n    };\n  }\n\n  function inlineAll(node) {\n    if (!(node instanceof Element)) {\n      return Promise.resolve(node);\n    }\n\n    return inlineBackground(node).then(() => {\n      if (node instanceof HTMLImageElement) {\n        return newImage(node).inline(null);\n      }\n      return Promise.all(asArray(node.childNodes).map(child => inlineAll(child)));\n    });\n\n    function inlineBackground(nd) {\n      const background = nd.style.getPropertyValue('background');\n\n      if (!background) {\n        return Promise.resolve(nd);\n      }\n\n      return inliner\n        .inlineAll(background, null, null)\n        .then(inlined => {\n          nd.style.setProperty('background', inlined, nd.style.getPropertyPriority('background'));\n        })\n        .then(() => nd);\n    }\n  }\n}\n\nexport default domtoimage;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}