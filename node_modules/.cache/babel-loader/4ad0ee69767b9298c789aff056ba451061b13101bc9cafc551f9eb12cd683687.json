{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.featureResolver = exports.featureAccessor = exports.geoJsonRequiredColumns = exports.tripVisConfigs = exports.defaultLineWidth = exports.defaultThickness = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.memoize\"));\nvar _lodash2 = _interopRequireDefault(require(\"lodash.uniq\"));\nvar _baseLayer = _interopRequireDefault(require(\"../base-layer\"));\nvar _geoLayers = require(\"@deck.gl/geo-layers\");\nvar _constants = require(\"@kepler.gl/constants\");\nvar _tripLayerIcon = _interopRequireDefault(require(\"./trip-layer-icon\"));\nvar _geojsonUtils = require(\"../geojson-layer/geojson-utils\");\nvar _tripUtils = require(\"./trip-utils\");\nvar _tripInfoModal = _interopRequireDefault(require(\"./trip-info-modal\"));\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar zoomFactorValue = 8;\nvar defaultThickness = 0.5;\nexports.defaultThickness = defaultThickness;\nvar defaultLineWidth = 1;\nexports.defaultLineWidth = defaultLineWidth;\nvar tripVisConfigs = {\n  opacity: 'opacity',\n  thickness: {\n    type: 'number',\n    defaultValue: defaultThickness,\n    label: 'Stroke Width',\n    isRanged: false,\n    range: [0, 100],\n    step: 0.1,\n    group: 'stroke',\n    property: 'thickness'\n  },\n  colorRange: 'colorRange',\n  trailLength: 'trailLength',\n  sizeRange: 'strokeWidthRange'\n};\nexports.tripVisConfigs = tripVisConfigs;\nvar geoJsonRequiredColumns = ['geojson'];\nexports.geoJsonRequiredColumns = geoJsonRequiredColumns;\nvar featureAccessor = function featureAccessor(_ref) {\n  var geojson = _ref.geojson;\n  return function (dc) {\n    return function (d) {\n      return dc.valueAt(d.index, geojson.fieldIdx);\n    };\n  };\n};\nexports.featureAccessor = featureAccessor;\nvar featureResolver = function featureResolver(_ref2) {\n  var geojson = _ref2.geojson;\n  return geojson.fieldIdx;\n};\nexports.featureResolver = featureResolver;\nvar TripLayer = /*#__PURE__*/function (_Layer) {\n  (0, _inherits2[\"default\"])(TripLayer, _Layer);\n  var _super = _createSuper(TripLayer);\n  function TripLayer(props) {\n    var _this;\n    (0, _classCallCheck2[\"default\"])(this, TripLayer);\n    _this = _super.call(this, props);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"dataToFeature\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"dataToTimeStamp\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"getFeature\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_layerInfoModal\", void 0);\n    _this.dataToFeature = [];\n    _this.dataToTimeStamp = [];\n    _this.registerVisConfig(tripVisConfigs);\n    _this.getFeature = (0, _lodash[\"default\"])(featureAccessor, featureResolver);\n    _this._layerInfoModal = (0, _tripInfoModal[\"default\"])();\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(TripLayer, [{\n    key: \"type\",\n    get: function get() {\n      return TripLayer.type;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'Trip';\n    }\n  }, {\n    key: \"layerIcon\",\n    get: function get() {\n      return _tripLayerIcon[\"default\"];\n    }\n  }, {\n    key: \"columnPairs\",\n    get: function get() {\n      return this.defaultPointColumnPairs;\n    }\n  }, {\n    key: \"requiredLayerColumns\",\n    get: function get() {\n      return geoJsonRequiredColumns;\n    }\n  }, {\n    key: \"visualChannels\",\n    get: function get() {\n      var visualChannels = (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(TripLayer.prototype), \"visualChannels\", this);\n      return _objectSpread(_objectSpread({}, visualChannels), {}, {\n        color: _objectSpread(_objectSpread({}, visualChannels.color), {}, {\n          accessor: 'getColor',\n          nullValue: visualChannels.color.nullValue,\n          getAttributeValue: function getAttributeValue(config) {\n            return function (d) {\n              return d.properties.lineColor || config.color;\n            };\n          },\n          // used this to get updateTriggers\n          defaultValue: function defaultValue(config) {\n            return config.color;\n          }\n        }),\n        size: _objectSpread(_objectSpread({}, visualChannels.size), {}, {\n          property: 'stroke',\n          accessor: 'getWidth',\n          condition: function condition(config) {\n            return config.visConfig.stroked;\n          },\n          nullValue: 0,\n          getAttributeValue: function getAttributeValue() {\n            return function (d) {\n              return d.properties.lineWidth || defaultLineWidth;\n            };\n          }\n        })\n      });\n    }\n  }, {\n    key: \"animationDomain\",\n    get: function get() {\n      return this.config.animation.domain;\n    }\n  }, {\n    key: \"layerInfoModal\",\n    get: function get() {\n      return {\n        id: 'iconInfo',\n        template: this._layerInfoModal,\n        modalProps: {\n          title: 'modal.tripInfo.title'\n        }\n      };\n    }\n  }, {\n    key: \"getPositionAccessor\",\n    value: function getPositionAccessor(dataContainer) {\n      return this.getFeature(this.config.columns)(dataContainer);\n    }\n  }, {\n    key: \"getDefaultLayerConfig\",\n    value: function getDefaultLayerConfig(props) {\n      return _objectSpread(_objectSpread({}, (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(TripLayer.prototype), \"getDefaultLayerConfig\", this).call(this, props)), {}, {\n        animation: {\n          enabled: true,\n          domain: null\n        }\n      });\n    }\n  }, {\n    key: \"getHoverData\",\n    value: function getHoverData(object, dataContainer) {\n      // index for dataContainer is saved to feature.properties\n      return dataContainer.row(object.properties.index);\n    }\n  }, {\n    key: \"calculateDataAttribute\",\n    value: function calculateDataAttribute(_ref3, getPosition) {\n      var _this2 = this;\n      var dataContainer = _ref3.dataContainer,\n        filteredIndex = _ref3.filteredIndex;\n      return filteredIndex.map(function (i) {\n        return _this2.dataToFeature[i];\n      }).filter(function (d) {\n        return d && d.geometry.type === 'LineString';\n      });\n    }\n  }, {\n    key: \"formatLayerData\",\n    value: function formatLayerData(datasets, oldLayerData) {\n      var _this3 = this;\n      if (this.config.dataId === null) {\n        return {};\n      } // to-do: parse segment from dataContainer\n\n      var _datasets$this$config = datasets[this.config.dataId],\n        dataContainer = _datasets$this$config.dataContainer,\n        gpuFilter = _datasets$this$config.gpuFilter;\n      var _this$updateData = this.updateData(datasets, oldLayerData),\n        data = _this$updateData.data;\n      var customFilterValueAccessor = function customFilterValueAccessor(dc, f, fieldIndex) {\n        return dc.valueAt(f.properties.index, fieldIndex);\n      };\n      var indexAccessor = function indexAccessor(f) {\n        return f.properties.index;\n      };\n      var dataAccessor = function dataAccessor(dc) {\n        return function (d) {\n          return {\n            index: d.properties.index\n          };\n        };\n      };\n      var accessors = this.getAttributeAccessors({\n        dataAccessor: dataAccessor,\n        dataContainer: dataContainer\n      });\n      return _objectSpread({\n        data: data,\n        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(indexAccessor, customFilterValueAccessor),\n        getPath: function getPath(d) {\n          return d.geometry.coordinates;\n        },\n        getTimestamps: function getTimestamps(d) {\n          return _this3.dataToTimeStamp[d.properties.index];\n        }\n      }, accessors);\n    }\n  }, {\n    key: \"updateAnimationDomain\",\n    value: function updateAnimationDomain(domain) {\n      this.updateLayerConfig({\n        animation: _objectSpread(_objectSpread({}, this.config.animation), {}, {\n          domain: domain\n        })\n      });\n    }\n  }, {\n    key: \"updateLayerMeta\",\n    value: function updateLayerMeta(dataContainer) {\n      var getFeature = this.getPositionAccessor(dataContainer);\n      if (getFeature === this.meta.getFeature) {\n        // TODO: revisit this after gpu filtering\n        return;\n      }\n      this.dataToFeature = (0, _geojsonUtils.getGeojsonDataMaps)(dataContainer, getFeature);\n      var _parseTripGeoJsonTime = (0, _tripUtils.parseTripGeoJsonTimestamp)(this.dataToFeature),\n        dataToTimeStamp = _parseTripGeoJsonTime.dataToTimeStamp,\n        animationDomain = _parseTripGeoJsonTime.animationDomain;\n      this.dataToTimeStamp = dataToTimeStamp;\n      this.updateAnimationDomain(animationDomain); // get bounds from features\n\n      var bounds = (0, _geojsonUtils.getGeojsonBounds)(this.dataToFeature); // keep a record of what type of geometry the collection has\n\n      var featureTypes = (0, _geojsonUtils.getGeojsonFeatureTypes)(this.dataToFeature);\n      this.updateMeta({\n        bounds: bounds,\n        featureTypes: featureTypes,\n        getFeature: getFeature\n      });\n    }\n  }, {\n    key: \"setInitialLayerConfig\",\n    value: function setInitialLayerConfig(_ref4) {\n      var dataContainer = _ref4.dataContainer;\n      if (!dataContainer.numRows()) {\n        return this;\n      }\n      this.updateLayerMeta(dataContainer);\n      return this;\n    }\n  }, {\n    key: \"renderLayer\",\n    value: function renderLayer(opts) {\n      var _animationConfig$doma;\n      var data = opts.data,\n        gpuFilter = opts.gpuFilter,\n        mapState = opts.mapState,\n        animationConfig = opts.animationConfig;\n      var visConfig = this.config.visConfig;\n      var zoomFactor = this.getZoomFactor(mapState);\n      var isValidTime = animationConfig && Array.isArray(animationConfig.domain) && animationConfig.domain.every(Number.isFinite) && Number.isFinite(animationConfig.currentTime);\n      if (!isValidTime) {\n        return [];\n      }\n      var domain0 = (_animationConfig$doma = animationConfig.domain) === null || _animationConfig$doma === void 0 ? void 0 : _animationConfig$doma[0];\n      var updateTriggers = _objectSpread(_objectSpread({}, this.getVisualChannelUpdateTriggers()), {}, {\n        getTimestamps: {\n          columns: this.config.columns,\n          domain0: domain0\n        },\n        getFilterValue: gpuFilter.filterValueUpdateTriggers\n      });\n      var defaultLayerProps = this.getDefaultDeckLayerProps(opts);\n      return [new _geoLayers.TripsLayer(_objectSpread(_objectSpread(_objectSpread({}, defaultLayerProps), data), {}, {\n        getTimestamps: function getTimestamps(d) {\n          return (data.getTimestamps(d) || []).map(function (ts) {\n            return ts - domain0;\n          });\n        },\n        widthScale: this.config.visConfig.thickness * zoomFactor * zoomFactorValue,\n        capRounded: true,\n        jointRounded: true,\n        wrapLongitude: false,\n        parameters: {\n          depthTest: mapState.dragRotate,\n          depthMask: false\n        },\n        trailLength: visConfig.trailLength * 1000,\n        currentTime: animationConfig.currentTime - domain0,\n        updateTriggers: updateTriggers\n      }))];\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'trip';\n    }\n  }, {\n    key: \"findDefaultLayerProps\",\n    value: function findDefaultLayerProps(_ref5, foundLayers) {\n      var _this4 = this;\n      var label = _ref5.label,\n        _ref5$fields = _ref5.fields,\n        fields = _ref5$fields === void 0 ? [] : _ref5$fields,\n        dataContainer = _ref5.dataContainer,\n        id = _ref5.id;\n      var geojsonColumns = fields.filter(function (f) {\n        return f.type === 'geojson';\n      }).map(function (f) {\n        return f.name;\n      });\n      var defaultColumns = {\n        geojson: (0, _lodash2[\"default\"])([].concat((0, _toConsumableArray2[\"default\"])(_constants.GEOJSON_FIELDS.geojson), (0, _toConsumableArray2[\"default\"])(geojsonColumns)))\n      };\n      var geoJsonColumns = this.findDefaultColumnField(defaultColumns, fields);\n      var tripGeojsonColumns = (geoJsonColumns || []).filter(function (col) {\n        return (0, _tripUtils.isTripGeoJsonField)(dataContainer, fields[col.geojson.fieldIdx]);\n      });\n      if (tripGeojsonColumns.length) {\n        return {\n          props: tripGeojsonColumns.map(function (columns) {\n            return {\n              label: typeof label === 'string' && label.replace(/\\.[^/.]+$/, '') || _this4.type,\n              columns: columns,\n              isVisible: true\n            };\n          }),\n          // if a geojson layer is created from this column, delete it\n          foundLayers: foundLayers.filter(function (prop) {\n            return prop.type !== 'geojson' || prop.dataId !== id || !tripGeojsonColumns.find(function (c) {\n              return prop.columns.geojson.name === c.geojson.name;\n            });\n          })\n        };\n      }\n      return {\n        props: []\n      };\n    }\n  }]);\n  return TripLayer;\n}(_baseLayer[\"default\"]);\nexports[\"default\"] = TripLayer;","map":{"version":3,"names":["exports","featureResolver","featureAccessor","geoJsonRequiredColumns","tripVisConfigs","defaultLineWidth","defaultThickness","_toConsumableArray2","_interopRequireDefault","require","_classCallCheck2","_createClass2","_assertThisInitialized2","_get2","_inherits2","_possibleConstructorReturn2","_getPrototypeOf2","_geoLayers","_geojsonUtils","_tripUtils","_tripInfoModal","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty2","getOwnPropertyDescriptors","defineProperties","defineProperty","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","trailLength","sham","Proxy","Boolean","prototype","valueOf","call","e","zoomFactorValue","opacity","thickness","type","defaultValue","label","isRanged","range","colorRange","sizeRange","d","dc","valueAt","index","geojson","fieldIdx","_ref2","TripLayer","_Layer","_this","registerVisConfig","get","_tripLayerIcon","defaultPointColumnPairs","visualChannels","color","accessor","nullValue","getAttributeValue","config","properties","lineColor","condition","visConfig","stroked","lineWidth","animation","domain","id","template","_layerInfoModal","getFeature","columns","dataContainer","value","getDefaultLayerConfig","props","enabled","getHoverData","row","_this2","_ref3","filteredIndex","map","dataToFeature","geometry","formatLayerData","datasets","oldLayerData","_this3","dataId","_datasets$this$config","_this$updateData","updateData","data","customFilterValueAccessor","f","fieldIndex","indexAccessor","coordinates","dataAccessor","accessors","getAttributeAccessors","gpuFilter","filterValueAccessor","getPath","getTimestamps","dataToTimeStamp","updateAnimationDomain","updateLayerConfig","updateLayerMeta","updateMeta","getPositionAccessor","meta","getGeojsonDataMaps","_parseTripGeoJsonTime","animationDomain","bounds","getGeojsonBounds","setInitialLayerConfig","_ref4","numRows","renderLayer","opts","_animationConfig$doma","mapState","animationConfig","zoomFactor","getZoomFactor","isValidTime","Array","isArray","every","Number","isFinite","currentTime","domain0","updateTriggers","getVisualChannelUpdateTriggers","getFilterValue","filterValueUpdateTriggers","ts","capRounded","wrapLongitude","parameters","depthTest","dragRotate","depthMask","_this4","_ref5","_ref5$fields","fields","geojsonColumns","name","defaultColumns","_lodash2","concat","_constants","GEOJSON_FIELDS","geoJsonColumns","findDefaultColumnField","tripGeojsonColumns","col"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/layers/src/trip-layer/trip-layer.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport memoize from 'lodash.memoize';\nimport uniq from 'lodash.uniq';\nimport Layer, {LayerBaseConfig, LayerColumn} from '../base-layer';\nimport {TripsLayer as DeckGLTripsLayer} from '@deck.gl/geo-layers';\n\nimport {GEOJSON_FIELDS, ColorRange} from '@kepler.gl/constants';\nimport TripLayerIcon from './trip-layer-icon';\n\nimport {\n  getGeojsonDataMaps,\n  getGeojsonBounds,\n  getGeojsonFeatureTypes,\n  GeojsonDataMaps\n} from '../geojson-layer/geojson-utils';\n\nimport {isTripGeoJsonField, parseTripGeoJsonTimestamp} from './trip-utils';\nimport TripInfoModalFactory from './trip-info-modal';\nimport {Merge, VisConfigColorRange, VisConfigNumber, VisConfigRange} from '@kepler.gl/types';\nimport {default as KeplerTable} from '@kepler.gl/table';\nimport {DataContainerInterface} from '@kepler.gl/utils';\n\nexport type TripLayerVisConfigSettings = {\n  opacity: VisConfigNumber;\n  thickness: VisConfigNumber;\n  colorRange: VisConfigColorRange;\n  trailLength: VisConfigNumber;\n  sizeRange: VisConfigRange;\n};\n\nexport type TripLayerColumnsConfig = {\n  geojson: LayerColumn;\n};\n\nexport type TripLayerVisConfig = {\n  opacity: number;\n  thickness: number;\n  colorRange: ColorRange;\n  trailLength: number;\n  sizeRange: [number, number];\n};\n\nexport type TripLayerConfig = Merge<\n  LayerBaseConfig,\n  {columns: TripLayerColumnsConfig; visConfig: TripLayerVisConfig}\n>;\n\nexport type TripLayerMeta = {\n  getFeature: any;\n};\n\nconst zoomFactorValue = 8;\n\nexport const defaultThickness = 0.5;\nexport const defaultLineWidth = 1;\n\nexport const tripVisConfigs: {\n  opacity: 'opacity';\n  thickness: VisConfigNumber;\n  colorRange: 'colorRange';\n  trailLength: 'trailLength';\n  sizeRange: 'strokeWidthRange';\n} = {\n  opacity: 'opacity',\n  thickness: {\n    type: 'number',\n    defaultValue: defaultThickness,\n    label: 'Stroke Width',\n    isRanged: false,\n    range: [0, 100],\n    step: 0.1,\n    group: 'stroke',\n    property: 'thickness'\n  },\n  colorRange: 'colorRange',\n  trailLength: 'trailLength',\n  sizeRange: 'strokeWidthRange'\n};\n\nexport const geoJsonRequiredColumns: ['geojson'] = ['geojson'];\nexport const featureAccessor = ({geojson}: TripLayerColumnsConfig) => (\n  dc: DataContainerInterface\n) => d => dc.valueAt(d.index, geojson.fieldIdx);\nexport const featureResolver = ({geojson}: TripLayerColumnsConfig) => geojson.fieldIdx;\n\nexport default class TripLayer extends Layer {\n  declare visConfigSettings: TripLayerVisConfigSettings;\n  declare config: TripLayerConfig;\n  declare meta: TripLayerMeta;\n\n  dataToFeature: GeojsonDataMaps;\n  dataToTimeStamp: {}[];\n  getFeature: (columns: TripLayerColumnsConfig) => (dataContainer: DataContainerInterface) => any;\n  _layerInfoModal: () => JSX.Element;\n\n  constructor(props) {\n    super(props);\n\n    this.dataToFeature = [];\n    this.dataToTimeStamp = [];\n    this.registerVisConfig(tripVisConfigs);\n    this.getFeature = memoize(featureAccessor, featureResolver);\n    this._layerInfoModal = TripInfoModalFactory();\n  }\n\n  static get type(): 'trip' {\n    return 'trip';\n  }\n  get type() {\n    return TripLayer.type;\n  }\n\n  get name(): 'Trip' {\n    return 'Trip';\n  }\n\n  get layerIcon() {\n    return TripLayerIcon;\n  }\n\n  get columnPairs() {\n    return this.defaultPointColumnPairs;\n  }\n\n  get requiredLayerColumns() {\n    return geoJsonRequiredColumns;\n  }\n\n  get visualChannels() {\n    const visualChannels = super.visualChannels;\n\n    return {\n      ...visualChannels,\n      color: {\n        ...visualChannels.color,\n        accessor: 'getColor',\n        nullValue: visualChannels.color.nullValue,\n        getAttributeValue: config => d => d.properties.lineColor || config.color,\n        // used this to get updateTriggers\n        defaultValue: config => config.color\n      },\n      size: {\n        ...visualChannels.size,\n        property: 'stroke',\n        accessor: 'getWidth',\n        condition: config => config.visConfig.stroked,\n        nullValue: 0,\n        getAttributeValue: () => d => d.properties.lineWidth || defaultLineWidth\n      }\n    };\n  }\n\n  get animationDomain() {\n    return this.config.animation.domain;\n  }\n\n  get layerInfoModal() {\n    return {\n      id: 'iconInfo',\n      template: this._layerInfoModal,\n      modalProps: {\n        title: 'modal.tripInfo.title'\n      }\n    };\n  }\n\n  getPositionAccessor(dataContainer: DataContainerInterface) {\n    return this.getFeature(this.config.columns)(dataContainer);\n  }\n\n  static findDefaultLayerProps(\n    {label, fields = [], dataContainer, id}: KeplerTable,\n    foundLayers: any[]\n  ) {\n    const geojsonColumns = fields.filter(f => f.type === 'geojson').map(f => f.name);\n\n    const defaultColumns = {\n      geojson: uniq([...GEOJSON_FIELDS.geojson, ...geojsonColumns])\n    };\n\n    const geoJsonColumns = this.findDefaultColumnField(defaultColumns, fields);\n\n    const tripGeojsonColumns = (geoJsonColumns || []).filter(col =>\n      isTripGeoJsonField(dataContainer, fields[col.geojson.fieldIdx])\n    );\n\n    if (tripGeojsonColumns.length) {\n      return {\n        props: tripGeojsonColumns.map(columns => ({\n          label: (typeof label === 'string' && label.replace(/\\.[^/.]+$/, '')) || this.type,\n          columns,\n          isVisible: true\n        })),\n\n        // if a geojson layer is created from this column, delete it\n        foundLayers: foundLayers.filter(\n          prop =>\n            prop.type !== 'geojson' ||\n            prop.dataId !== id ||\n            !tripGeojsonColumns.find(c => prop.columns.geojson.name === c.geojson.name)\n        )\n      };\n    }\n\n    return {props: []};\n  }\n\n  getDefaultLayerConfig(props) {\n    return {\n      ...super.getDefaultLayerConfig(props),\n      animation: {\n        enabled: true,\n        domain: null\n      }\n    };\n  }\n\n  getHoverData(object, dataContainer) {\n    // index for dataContainer is saved to feature.properties\n    return dataContainer.row(object.properties.index);\n  }\n\n  calculateDataAttribute({dataContainer, filteredIndex}, getPosition) {\n    return filteredIndex\n      .map(i => this.dataToFeature[i])\n      .filter(d => d && d.geometry.type === 'LineString');\n  }\n\n  formatLayerData(datasets, oldLayerData) {\n    if (this.config.dataId === null) {\n      return {};\n    }\n    // to-do: parse segment from dataContainer\n    const {dataContainer, gpuFilter} = datasets[this.config.dataId];\n    const {data} = this.updateData(datasets, oldLayerData);\n\n    const customFilterValueAccessor = (dc, f, fieldIndex) => {\n      return dc.valueAt(f.properties.index, fieldIndex);\n    };\n    const indexAccessor = f => f.properties.index;\n\n    const dataAccessor = dc => d => ({index: d.properties.index});\n    const accessors = this.getAttributeAccessors({dataAccessor, dataContainer});\n\n    return {\n      data,\n      getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(\n        indexAccessor,\n        customFilterValueAccessor\n      ),\n      getPath: d => d.geometry.coordinates,\n      getTimestamps: d => this.dataToTimeStamp[d.properties.index],\n      ...accessors\n    };\n  }\n\n  updateAnimationDomain(domain) {\n    this.updateLayerConfig({\n      animation: {\n        ...this.config.animation,\n        domain\n      }\n    });\n  }\n\n  updateLayerMeta(dataContainer) {\n    const getFeature = this.getPositionAccessor(dataContainer);\n    if (getFeature === this.meta.getFeature) {\n      // TODO: revisit this after gpu filtering\n      return;\n    }\n\n    this.dataToFeature = getGeojsonDataMaps(dataContainer, getFeature);\n\n    const {dataToTimeStamp, animationDomain} = parseTripGeoJsonTimestamp(this.dataToFeature);\n\n    this.dataToTimeStamp = dataToTimeStamp;\n    this.updateAnimationDomain(animationDomain);\n\n    // get bounds from features\n    const bounds = getGeojsonBounds(this.dataToFeature);\n\n    // keep a record of what type of geometry the collection has\n    const featureTypes = getGeojsonFeatureTypes(this.dataToFeature);\n\n    this.updateMeta({bounds, featureTypes, getFeature});\n  }\n\n  setInitialLayerConfig({dataContainer}) {\n    if (!dataContainer.numRows()) {\n      return this;\n    }\n    this.updateLayerMeta(dataContainer);\n    return this;\n  }\n\n  renderLayer(opts) {\n    const {data, gpuFilter, mapState, animationConfig} = opts;\n    const {visConfig} = this.config;\n    const zoomFactor = this.getZoomFactor(mapState);\n    const isValidTime =\n      animationConfig &&\n      Array.isArray(animationConfig.domain) &&\n      animationConfig.domain.every(Number.isFinite) &&\n      Number.isFinite(animationConfig.currentTime);\n\n    if (!isValidTime) {\n      return [];\n    }\n\n    const domain0 = animationConfig.domain?.[0];\n\n    const updateTriggers = {\n      ...this.getVisualChannelUpdateTriggers(),\n      getTimestamps: {\n        columns: this.config.columns,\n        domain0\n      },\n      getFilterValue: gpuFilter.filterValueUpdateTriggers\n    };\n    const defaultLayerProps = this.getDefaultDeckLayerProps(opts);\n\n    return [\n      new DeckGLTripsLayer({\n        ...defaultLayerProps,\n        ...data,\n        getTimestamps: d => (data.getTimestamps(d) || []).map(ts => ts - domain0),\n        widthScale: this.config.visConfig.thickness * zoomFactor * zoomFactorValue,\n        capRounded: true,\n        jointRounded: true,\n        wrapLongitude: false,\n        parameters: {\n          depthTest: mapState.dragRotate,\n          depthMask: false\n        },\n        trailLength: visConfig.trailLength * 1000,\n        currentTime: animationConfig.currentTime - domain0,\n        updateTriggers\n      })\n    ];\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAoBAA,OAAA,cAAAA,OAAA,CAAAC,eAAA,GAAAD,OAAA,CAAAE,eAAA,GAAAF,OAAA,CAAAG,sBAAA,GAAAH,OAAA,CAAAI,cAAA,GAAAJ,OAAA,CAAAK,gBAAA,GAAAL,OAAA,CAAAM,gBAAA;AACA,IAAAC,mBAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,gBAAA,GAAAF,sBAAA,CAAAC,OAAA;AACA,IAAAE,aAAA,GAAAH,sBAAA,CAAAC,OAAA;AAEA,IAAAG,uBAAA,GAAAJ,sBAAA,CAAAC,OAAA;AACA,IAAAI,KAAA,GAAAL,sBAAA,CAAAC,OAAA;AAEA,IAAAK,UAAA,GAAAN,sBAAA,CAAAC,OAAA;AAOA,IAAAM,2BAAA,GAAAP,sBAAA,CAAAC,OAAA;AACA,IAAAO,gBAAA,GAAAR,sBAAA,CAAAC,OAAA;;;;;AAkCA,IAAMQ,UAAA,GAAAR,OAAN;;;AAYE,IAAAS,aAAS,GADPT,OAAA;AAGA,IAAAU,UAAM,GAAAV,OADG;AAGT,IAAAW,cAAO,GAAAZ,sBAHE,CAAAC,OAAA;AAKT,SAAKY,OAAMA,CAAAC,MALF,EAAAC,cAAA;EAAA,IAAAC,IAAA,GAAAC,MAAA,CAAAD,IAAA,CAAAF,MAAA;EAAA,IAAAG,MAAA,CAAAC,qBAAA;IAAA,IAAAC,OAAA,GAAAF,MAAA,CAAAC,qBAAA,CAAAJ,MAAA;IAAA,IAAAC,cAAA,EAAAI,OAAA,GAAAA,OAAA,CAAAC,MAAA,WAAAC,GAAA;MAAA,OAAAJ,MAAA,CAAAK,wBAAA,CAAAR,MAAA,EAAAO,GAAA,EAAAE,UAAA;IAAA;IAAAP,IAAA,CAAAQ,IAAA,CAAAC,KAAA,CAAAT,IAAA,EAAAG,OAAA;EAAA;EAAA,OAAAH,IAAA;AAAA;AAOT,SAAKU,aAPIA,CAAAC,MAAA;EAAA,SAAAC,CAAA,MAAAA,CAAA,GAAAC,SAAA,CAAAC,MAAA,EAAAF,CAAA;IAAA,IAAAG,MAAA,GAAAF,SAAA,CAAAD,CAAA,YAAAC,SAAA,CAAAD,CAAA;IAAA,IAAAA,CAAA;MAAAf,OAAA,CAAAI,MAAA,CAAAc,MAAA,SAAAC,OAAA,WAAAC,GAAA;QAAA,IAAAC,gBAAA,aAAAP,MAAA,EAAAM,GAAA,EAAAF,MAAA,CAAAE,GAAA;MAAA;IAAA,WAAAhB,MAAA,CAAAkB,yBAAA;MAAAlB,MAAA,CAAAmB,gBAAA,CAAAT,MAAA,EAAAV,MAAA,CAAAkB,yBAAA,CAAAJ,MAAA;IAAA;MAAAlB,OAAA,CAAAI,MAAA,CAAAc,MAAA,GAAAC,OAAA,WAAAC,GAAA;QAAAhB,MAAA,CAAAoB,cAAA,CAAAV,MAAA,EAAAM,GAAA,EAAAhB,MAAA,CAAAK,wBAAA,CAAAS,MAAA,EAAAE,GAAA;MAAA;IAAA;EAAA;EAAA,OAAAN,MAAA;AAAA;AAAA,SAFTW,aAAAC,OAAA;EAAA,IAAAC,yBAAA,GAAAC,yBAAA;EAAA,gBAAAC,qBAAA;IAAA,IAAAC,KAAA,OAAAnC,gBAAA,aAAA+B,OAAA;MAAAK,MAAA;IAAA,IAAAJ,yBAAA;MAAA,IAAAK,SAAA,OAAArC,gBAAA,mBAAAsC,WAAA;MAAAF,MAAA,GAAAG,OAAA,CAAAC,SAAA,CAAAL,KAAA,EAAAd,SAAA,EAAAgB,SAAA;IAAA;MAAAD,MAAA,GAAAD,KAAA,CAAAlB,KAAA,OAAAI,SAAA;IAAA;IAAA,WAAAtB,2BAAA,mBAAAqC,MAAA;EAAA;AAAA;AAaF,SAAAH,yBAbEQ,CAAA;EAAA,WAAAF,OAAA,qBAAAA,OAAA,CAAAC,SAAA;EAAA,IAAAD,OAAA,CAAAC,SAAA,CAAAE,IAAA;EAAA,WAAAC,KAAA;EAAA;IAAAC,OAAA,CAAAC,SAAA,CAAAC,OAAA,CAAAC,IAAA,CAAAR,OAAA,CAAAC,SAAA,CAAAI,OAAA;IAAA;EAAA,SAAAI,CAAA;IAAA;EAAA;AAAA;AAAA,IANGC,eAAA;;AAuBAjE,OAAM,CAAAM,gBAAA,GAAmCA,gBAAzC;;;AACA,IAAMF,cAAA,GAAe;EAAG8D,OAAE,WAAF;EAAAC,SAAuC;IAAAC,IAAA,UAEjE;IAACC,YAAO,EAAA/D,gBAAiB;IAAxBgE,KAFgE;IAAvCC,QAAA;IAAxBC,KAAA;;;;EAGA;EAAwBC,UAAE,EAAF,YAAE;EAAFhB,WAAuC,eAAvC;EAAxBiB,SAAA;;;;OAEc,CAAAvE,sB;;;;IAUnB,iBAAYwE,CAAA;MAAO,OAAAC,EAAA,CAAAC,OAAA,CAAAF,CAAA,CAAAG,KAAA,EAAAC,OAAA,CAAAC,QAAA;;EAAA;AACjB;AADiBhF,OAAA,CAAAE,eAAA,GAAAA,eAAA;AAAA,IAAAD,eAAA,YAAAA,gBAAAgF,KAAA;EAGjB,IAAAF,OAAK,GAAAE,KAAA,CAAAF,OAAL;EACA,OAAAA,OAAK,CAAAC,QAAL;;;AAGA,IAAAE,SAAK,gBAAkB,UAAAC,MAAA;EAPN,IAAArE,UAAA,aAAAoE,SAAA,EAAAC,MAAA;;;aAanB;IAEC,IAAAzE,gBAAA,mBAAAwE,SAAA;;;wBAEkB,iBAAAtE,uBAAA,aAAAwE,KAAA;IACjB,IAAA1C,gBAAA,iBAAA9B,uBAAA,aAAAwE,KAAA;IACD,IAAA1C,gBAAA,iBAAA9B,uBAAA,aAAAwE,KAAA;;;IAGCA,KAAA,CAAAC,iBAAO,CAAAjF,cAAP;;;WAGFgF,KAAA;EACE;;;SAGF,SAAAE,IAAA,EAA2B;MACzB,OAAOJ,SAAA,CAAAd,IAAA;IACR;;;SAED,SAAAkB,IAAA,EAAqB;MACnB,OAAM;IAEN;EAEE;IAEE7C,GAAA,aAAU;IACV6C,GAAA,WAAAA,GAAWA,CAAA;MACX,OAAAC,cAAiB,UAAE;IAAM;EAAK;IAAA9C,GAAA,eAAL;IAAA6C,GAAA,WAJtBA,IAAA;MAKH,YAAAE,uBAAA;IACA;EAAoB;IAAA/C,GAAA;IANjB6C,GAAA,WAFPA,IAAA;MAUE,OAAInF,sBAAA;IAEF;EACA;IACAsC,GAAA,kBAAW;IAAM6C,GAAA,WAAAA,GAAIA,CAAA;MAAJ,IAAAG,cAJf,OAAA5E,KAAA,iBAAAG,gBAAA,aAAAkE,SAAA,CAAArB,SAAA;MAKF,OAAA3B,aALE,CAAAA,aAAA,KAAAuD,cAAA;QAMFC,KAAA,EAAAxD,aAAiB,CAAEA,aAAA,KAAAuD,cAAA,CAAAC,KAAA;UAAAC,QAAA,EAAM,UAAC;UAAAC,SAAA,EAAIH,cAAa,CAAAC,KAAA,CAAAE,SAAa;UAA9BC,iBAAP,WAAAA,kBAAAC,MAAA;YAAA,iBAAAnB,CAAA;cANjB,OAAAA,CAAA,CAAAoB,UAAA,CAAAC,SAAA,IAAAF,MAAA,CAAAJ,KAAA;YAVN;UAmBD;;;YAED,OAAAI,MAAsB,CAAAJ,KAAA;UACpB;QACD;;;UAEDC,QAAA,YAAqB;UACnBM,SAAO,WAAAA,UAAAH,MAAA;YACD,OAAAA,MADC,CAAAI,SAAA,CAAAC,OAAA;UAEL;UACAP,SAAU,EAAE;UACVC,iBAAO,WAAAA,kBAAA;YADG,iBAAAlB,CAAA;cAHd,OAAAA,CAAA,CAAAoB,UAAA,CAAAK,SAAA,IAAA/F,gBAAA;YAOD;;;;IAGC;EACD;;;aAuCD,KAAAyF,MAAA,CAAAO,SAAA,CAAAC,MAAA;IACE;EAEE;IACE7D,GAAA,kBADS;IAET6C,GAAA,WAAQA,IAAA;MAFC;QAFbiB,EAAA;QAODC,QAAA,OAAAC,eAAA;;;;MAGC;IACA;EACD;;;aAED,KAAAC,UAAA,MAAAZ,MAAA,CAAAa,OAAA,EAAuDC,aAAa;IAAA;;IAAAnE,GAAA,yBAA5C;IAA4CoE,KAAA,EAA7B,SAAAC,sBAAAC,KAA6B;MAClE,OAAO7E,aAAa,CACjBA,aAAI,EAAC,OAAArB,KAAA,iBAAAG,gBAAA,aAAAkE,SAAA,CAAArB,SAAA,kCAAAE,IAAA,OAAAgD,KAAA;QAAAV,SAAI;UACTW,OAAO;UAACV,MAAK;QAFhB;MAGD;;;uBAED;IAAwCO,KAAA,WAAAI,aAAA3F,MAAA,EAAAsF,aAAA;;MACtC,OAAIA,aAAY,CAAAM,GAAZ,CAAA5F,MAAJ,CAAAyE,UAAiC,CAAAjB,KAAA;IAC/B;EACD;;;MAHqC,IAAAqC,MAAA;MAAA,IAKhBP,aALgB,GAAAQ,KAAA,CAAAR,aAKhB;;MALgB,OAAAS,aAAA,CAAAC,GAMvB,WAAKlF,CAAA,EAAL;QANuB,OAAA+E,MAAA,CAAAI,aAM/B,CAAAnF,CAAA,CAN+B;;QAQtC,OAAMuC,CAAA,IAAAA,CAAA,CAAA6C,QAAA,CAAApD,IAAyB,KAAG,YAA5B;MACJ;IACD;;IACD3B,GAAA,mBAAsB;IAACoE,KAAA,WAAMY,eAAN1B,CAAA2B,QAAA,EAAAC,YAAA;MAAA,IAAvBC,MAAA;MAEA,IAAM,KAAA9B,MAAA,CAAY+B,MAAG,SAAf;QAAiB,OAAI;MAAC;;MAAA,IAALC,qBAAA,GAAAJ,QAAA,MAAA5B,MAAA,CAAA+B,MAAA;QAAvBjB,aAAA,GAAAkB,qBAAA,CAAAlB,aAAA;;MAC8C,IAAAmB,gBAAA,QAADC,UAAA,CAAAN,QAAA,EAAAC,YAAA;QAAeM,IAAA,GAAAF,gBAAA,CAAAE,IAAA;MAE5D,IAAAC,yBAAA,YAAAA,0BAAAtD,EAAA,EAAAuD,CAAA,EAAAC,UAAA;QACE,OAAAxD,EAAA,CADFC,OAAA,CAAAsD,CAAA,CAAApC,UAAA,CAAAjB,KAAA,EAAAsD,UAAA;MAEE;MAIU,IAAAC,aAAM,YAASA,aAAfC,CAAAH,CAAA;QAAA,OANZA,CAAA,CAAApC,UAAA,CAAAjB,KAAA;MAOE;MAAgB,IAAAyD,YAAA,YAAAA,aAAA3D,EAAA;QAPlB,OAQK,UARLD,CAAA;UAUD;;;;MAGC;MAGI,IAAA6D,SAAA,QAAAC,qBAAA;QAFOF,YAAA,EAAAA,YAAA;QADX3B,aAAA,EAAAA;MAMD;;;sBAED,EAAA8B,SAAA,CAAAC,mBAA+B,CAAA/B,aAAA,EAAAyB,aAAA,EAAAH,yBAAA;QAC7BU,OAAM,WAAaA,OAAKA,CAAAjE,CAAA;;QACxB;QACEkE,aAAA,WAAAA,cAAAlE,CAAA;UACA,OAAAiD,MAAA,CAAAkB,eAAA,CAAAnE,CAAA,CAAAoB,UAAA,CAAAjB,KAAA;QACD;;IAED;;IAP6BrC,GAAA;IAAAoE,KAAA,EAStB,SAAAkC,qBATsBD,CAAAxC,MAAA,EAStB;MATsB,IASL,CAAA0C,iBATK;;UAW7B1C,MAAK,EAAAA;QACL;;IAGA;;IAGA7D,GAAA,mBAAqB;IAErBoE,KAAA,EAAK,SAAAoC,eAAWC,CAAAtC,aAAA;MAAC,IAAAF,UAAA,GAAD,KAAAyC,mBAAA,CAAAvC,aAAA;MAAuB,IAAAF,UAAA,UAAA0C,IAAA,CAAA1C,UAAA;QAAvC;QACD;;WAEDa,aAAA,OAAArG,aAAA,CAAAmI,kBAAuC,EAAAzC,aAAA,EAAAF,UAAA;;QACjCoC,eAAe,GAAAQ,qBAAW,CAAAR,eAAA;QAC5BS,eAAA,GAAAD,qBAAA,CAAAC,eAAA;;MAEF,KAAKR,qBAAgB,CAAAQ,eAArB;;MAED,IAAAC,MAAA,OAAAtI,aAAA,CAAAuI,gBAAA,OAAAlC,aAAA;;;WAED2B,UAAA;QAAkBM,MAAA,EAAAA,MAAA;;QAAA9C,UACqC,EAAAA;MADrC;IAAA;EAAA;IAAAjE,GAAA,yBAES;IACzBoE,KAAA,EAAM,SAAU6C,qBAAGA,CAAmBC,KAAA;MACtC,IAAM/C,aAAW,GACf+C,KAAA,CAAA/C,aACA;MAIF,IAAI,CAACA,aAAa,CAAAgD,OAAA;QAChB,OAAO,IAAP;MACD;MAED,IAAM,CAAAX,eAAO,CAAArC,aAAA;;IAEb;EAEE;IACEnE,GAAA,eAAS;IACToE,KAAA,WAAAgD,YAAAC,IAAA;MAFa,IAFGC,qBAAA;MAAA,IAApB9B,IAAA,GAAA6B,IAAA,CAAA7B,IAAA;;QAQM+B,QAAA,GAAAF,IAAA,CAAAE,QAAoB;QAE1BC,eACM,GAAAH,IAAA,CAAAG,eAAJ;MAGE,IAAA/D,SAAA,GAAa,IAAE,CAAAJ,MAAA,CAAAI,SAAA;MAAC,IAAAgE,UAAK,GAAK,KAAAC,aAAL,CAAAH,QAAD,CAAkC;MAAE,IAAAI,WAAM,GAAGH,eAAT,IAAAI,KAAA,CAAAC,OAAA,CAAAL,eAAA,CAAA3D,MAAA,KAAA2D,eAAA,CAAA3D,MAAA,CAAAiE,KAAA,CAAAC,MAAA,CAAAC,QAAA,KAAAD,MAAA,CAAAC,QAAA,CAAAR,eAAA,CAAAS,WAAA;MAAxC,IAHlB,CAAAN,WAAA;QAIE;MACA;MAEA,IAAAO,OAAA,IAAaZ,qBAPf,GAAAE,eAAA,CAAA3D,MAAA,cAAAyD,qBAAA,uBAAAA,qBAAA;MASI,IAAAa,cAAW,GAAA1I,aADD,CAAAA,aAAA,UAAA2I,8BAAA;QAEVhC,aAAW;UAVflC,OAAA,OAAAb,MAAA,CAAAa,OAAA;UAYEgE,OAAA,EAAWA;QACX;QACAG,cAAc,EAAdpC,SAAA,CAAAqC;MAdF;;;qBA1NJ,WAA0BlC,cAAAlE,CAAA;UACxB,OAAO,CAAAsD,IAAP,CAAAY,aAAA,CAAAlE,CAAA,SAAA2C,GAAA,WAAA0D,EAAA;YACD,OAAAA,EAAA,GAAAL,OAAA;;;kBA+DD,OAAA7E,MAAA,CAAAI,SAAA,CAAA/B,SAEE,GAAA+F,UACA,GAAAjG,eAAA;QAAAgH,UAAA;;QAAAC,aAAA,OAFC;QAEDC,UAAA;UAFQC,SAER,EAAApB,QAAA,CAAAqB,UAAA;UAFqBC,SAAA;QAErB;QACA7H,WAAM,EAAAyC,SAAiB,CAAAzC,WAAc;QAACiH,WAAM,EAAFT,eAAJ,CAAAS,WAAA,GAAAC,OAAA;QAAfC,cAA6C,EAACA;MAAA;IAAA;EAErE;IACEnI,GAAA,QAAO;IADc6C,GAAvB,WAAAA,IAAA;MAIA,OAAM;IAEN;EAA4D;IAAA7C,GAAjC,EAA3B;;MAIA,IAAI8I,MAAA;MAEA,IAAAjH,KAAK,GAAEkH,KAAA,CAAAlH,KAAA;QAA8BmH,YAAK,GAAAD,KAAA,CAAAE,MAAA;QACxCA,MAAA,GAAKD,YAAU,KAAP,KAAiB,MAAjB,GAA6BA,YAAM;QAC3C7E,aAAA,GAAA4E,KAFwC,CAAA5E,aAAA;QAGxCL,EAAA,GAAAiF,KAAA,CAAAjF,EAAS;MAH+B,IAAAoF,cAAL,GAAAD,MAAA,CAAA9J,MAAA,WAAAuG,CAAA;QAAA,OADhCA,CAAA,CAAA/D,IAAA;MAOL,GAAAkD,GAAA,WAAAa,CAAA;QACA,OAAAA,CAAA,CAAAyD,IAAW;MACL;MAGwB,IAAAC,cAAI,GAAK;QAAT9G,OAHxB,MAAA+G,QAAA,gBAAAC,MAAA,KAAAxL,mBAAA,aAAAyL,UAAA,CAAAC,cAAA,CAAAlH,OAAA,OAAAxE,mBAAA,aAAAoL,cAAA;MAAA;MATD,IAAPO,cAAA,QAAAC,sBAAA,CAAAN,cAAA,EAAAH,MAAA;MAeD,IAAAU,kBAAA,IAAAF,cAAA,QAAAtK,MAAA,WAAAyK,GAAA;;MAED;MAAO,IAAPD,kBAAA,CAAA9J,MAAA;QACD;;;cAxHoCgC,KAAA,S"},"metadata":{},"sourceType":"script","externalDependencies":[]}