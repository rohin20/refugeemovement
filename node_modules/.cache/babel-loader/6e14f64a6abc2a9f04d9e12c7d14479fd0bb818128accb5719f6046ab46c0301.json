{"ast":null,"code":"import _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { clip } from './clip';\nimport { createFeature } from './feature';\nexport function wrap(features, options) {\n  var buffer = options.buffer / options.extent;\n  var merged = features;\n  var left = clip(features, 1, -1 - buffer, buffer, 0, -1, 2, options);\n  var right = clip(features, 1, 1 - buffer, 2 + buffer, 0, -1, 2, options);\n  if (left || right) {\n    merged = clip(features, 1, -buffer, 1 + buffer, 0, -1, 2, options) || [];\n    if (left) {\n      merged = shiftFeatureCoords(left, 1).concat(merged);\n    }\n    if (right) {\n      merged = merged.concat(shiftFeatureCoords(right, -1));\n    }\n  }\n  return merged;\n}\nfunction shiftFeatureCoords(features, offset) {\n  var newFeatures = [];\n  for (var i = 0; i < features.length; i++) {\n    var feature = features[i];\n    var type = feature.type;\n    var newGeometry = void 0;\n    if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {\n      newGeometry = shiftCoords(feature.geometry, offset);\n    } else if (type === 'MultiLineString' || type === 'Polygon') {\n      newGeometry = [];\n      var _iterator = _createForOfIteratorHelper(feature.geometry),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var line = _step.value;\n          newGeometry.push(shiftCoords(line, offset));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } else if (type === 'MultiPolygon') {\n      newGeometry = [];\n      var _iterator2 = _createForOfIteratorHelper(feature.geometry),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var polygon = _step2.value;\n          var newPolygon = [];\n          var _iterator3 = _createForOfIteratorHelper(polygon),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _line = _step3.value;\n              newPolygon.push(shiftCoords(_line, offset));\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          newGeometry.push(newPolygon);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    newFeatures.push(createFeature(feature.id, type, newGeometry, feature.tags));\n  }\n  return newFeatures;\n}\nvar Points = /*#__PURE__*/function (_Array) {\n  _inherits(Points, _Array);\n  var _super = _createSuper(Points);\n  function Points() {\n    var _this;\n    _classCallCheck(this, Points);\n    _this = _super.apply(this, arguments);\n    _defineProperty(_assertThisInitialized(_this), \"size\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"start\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"end\", void 0);\n    return _this;\n  }\n  return _createClass(Points);\n}( /*#__PURE__*/_wrapNativeSuper(Array));\nfunction shiftCoords(points, offset) {\n  var newPoints = [];\n  newPoints.size = points.size;\n  if (points.start !== undefined) {\n    newPoints.start = points.start;\n    newPoints.end = points.end;\n  }\n  for (var i = 0; i < points.length; i += 3) {\n    newPoints.push(points[i] + offset, points[i + 1], points[i + 2]);\n  }\n  return newPoints;\n}","map":{"version":3,"names":["clip","createFeature","wrap","features","options","buffer","extent","merged","left","right","shiftFeatureCoords","concat","offset","newFeatures","i","length","feature","type","newGeometry","shiftCoords","geometry","_iterator","_createForOfIteratorHelper","_step","s","n","done","line","value","push","err","e","f","_iterator2","_step2","polygon","newPolygon","_iterator3","_step3","id","tags","Points","_Array","_inherits","_super","_createSuper","_this","_classCallCheck","apply","arguments","_defineProperty","_assertThisInitialized","_createClass","_wrapNativeSuper","Array","points","newPoints","size","start","undefined","end"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/mvt/src/lib/geojson-tiler/wrap.ts"],"sourcesContent":["// loaders.gl, MIT license\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\n\nimport type {GeoJSONTileFeature} from './tile';\nimport {clip} from './clip';\nimport {createFeature} from './feature';\n\n/**\n * Options for wrap()\n */\nexport type WrapOptions = {\n  buffer: number /** number of pixels of buffer for the tile */;\n  extent: number /** extent of each tile */;\n  lineMetrics: boolean;\n};\n\n/**\n * Wrap across antemeridian, by clipping into two tiles, shifting the overflowing x coordinates\n * @param features list of features to be wrapped\n * @param options buffer and extent\n * @returns\n */\nexport function wrap(features: GeoJSONTileFeature[], options: WrapOptions) {\n  const buffer = options.buffer / options.extent;\n  let merged: GeoJSONTileFeature[] = features;\n  const left = clip(features, 1, -1 - buffer, buffer, 0, -1, 2, options); // left world copy\n  const right = clip(features, 1, 1 - buffer, 2 + buffer, 0, -1, 2, options); // right world copy\n\n  if (left || right) {\n    merged = clip(features, 1, -buffer, 1 + buffer, 0, -1, 2, options) || []; // center world copy\n\n    if (left) {\n      merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center\n    }\n    if (right) {\n      merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center\n    }\n  }\n\n  return merged;\n}\n\n/**\n * Shift the x coordinates of a list of features\n * @param features list of features to shift x coordinates for\n * @param offset\n * @returns\n */\nfunction shiftFeatureCoords(features: GeoJSONTileFeature[], offset: number): GeoJSONTileFeature[] {\n  const newFeatures: GeoJSONTileFeature[] = [];\n\n  for (let i = 0; i < features.length; i++) {\n    const feature = features[i];\n    const type = feature.type;\n\n    let newGeometry;\n\n    if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {\n      newGeometry = shiftCoords(feature.geometry, offset);\n    } else if (type === 'MultiLineString' || type === 'Polygon') {\n      newGeometry = [];\n      for (const line of feature.geometry) {\n        newGeometry.push(shiftCoords(line, offset));\n      }\n    } else if (type === 'MultiPolygon') {\n      newGeometry = [];\n      for (const polygon of feature.geometry) {\n        const newPolygon: Points = [];\n        for (const line of polygon) {\n          // @ts-expect-error TODO\n          newPolygon.push(shiftCoords(line, offset));\n        }\n        newGeometry.push(newPolygon);\n      }\n    }\n\n    newFeatures.push(createFeature(feature.id, type, newGeometry, feature.tags));\n  }\n\n  return newFeatures;\n}\n\nclass Points extends Array<number> {\n  size?: number;\n  start?: number;\n  end?: number;\n}\n\n/**\n * Shift the x coordinate of every point\n * @param points\n * @param offset\n * @returns\n */\nfunction shiftCoords(points: Points, offset: number): Points {\n  const newPoints: Points = [];\n  newPoints.size = points.size;\n\n  if (points.start !== undefined) {\n    newPoints.start = points.start;\n    newPoints.end = points.end;\n  }\n\n  for (let i = 0; i < points.length; i += 3) {\n    newPoints.push(points[i] + offset, points[i + 1], points[i + 2]);\n  }\n  return newPoints;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}