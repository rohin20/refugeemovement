{"ast":null,"code":"import _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION } from '../utils/aggregation-operation-utils';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport { pointToDensityGridDataCPU } from './../cpu-grid-layer/grid-aggregator';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getBoundingBox, getGridParams } from '../utils/grid-aggregation-utils';\nvar defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  colorAggregation: 'SUM',\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  elevationAggregation: 'SUM',\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  cellSize: {\n    type: 'number',\n    min: 1,\n    max: 1000,\n    value: 1000\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  extruded: false,\n  material: true\n};\nvar DIMENSIONS = {\n  data: {\n    props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n  }\n};\nvar POSITION_ATTRIBUTE_NAME = 'positions';\nvar GPUGridLayer = /*#__PURE__*/function (_GridAggregationLayer) {\n  _inherits(GPUGridLayer, _GridAggregationLayer);\n  var _super = _createSuper(GPUGridLayer);\n  function GPUGridLayer() {\n    _classCallCheck(this, GPUGridLayer);\n    return _super.apply(this, arguments);\n  }\n  _createClass(GPUGridLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _attributeManager$add;\n      var gl = this.context.gl;\n      var isSupported = GPUGridAggregator.isSupported(gl);\n      if (!isSupported) {\n        log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n      }\n      _get(_getPrototypeOf(GPUGridLayer.prototype), \"initializeState\", this).call(this, {\n        dimensions: DIMENSIONS\n      });\n      this.setState({\n        gpuAggregation: true,\n        projectPoints: false,\n        isSupported: isSupported,\n        weights: {\n          color: {\n            needMin: true,\n            needMax: true,\n            combineMaxMin: true,\n            maxMinBuffer: new Buffer(gl, {\n              byteLength: 4 * 4,\n              accessor: {\n                size: 4,\n                type: 5126,\n                divisor: 1\n              }\n            })\n          },\n          elevation: {\n            needMin: true,\n            needMax: true,\n            combineMaxMin: true,\n            maxMinBuffer: new Buffer(gl, {\n              byteLength: 4 * 4,\n              accessor: {\n                size: 4,\n                type: 5126,\n                divisor: 1\n              }\n            })\n          }\n        },\n        positionAttributeName: 'positions'\n      });\n      var attributeManager = this.getAttributeManager();\n      attributeManager.add((_attributeManager$add = {}, _defineProperty(_attributeManager$add, POSITION_ATTRIBUTE_NAME, {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      }), _defineProperty(_attributeManager$add, \"color\", {\n        size: 3,\n        accessor: 'getColorWeight'\n      }), _defineProperty(_attributeManager$add, \"elevation\", {\n        size: 3,\n        accessor: 'getElevationWeight'\n      }), _attributeManager$add));\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts) {\n      if (this.state.isSupported === false) {\n        return;\n      }\n      _get(_getPrototypeOf(GPUGridLayer.prototype), \"updateState\", this).call(this, opts);\n      var aggregationDirty = this.state.aggregationDirty;\n      if (aggregationDirty) {\n        this.setState({\n          gridHash: null\n        });\n      }\n    }\n  }, {\n    key: \"getHashKeyForIndex\",\n    value: function getHashKeyForIndex(index) {\n      var _this$state = this.state,\n        numRow = _this$state.numRow,\n        numCol = _this$state.numCol,\n        boundingBox = _this$state.boundingBox,\n        gridOffset = _this$state.gridOffset;\n      var gridSize = [numCol, numRow];\n      var gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n      var cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n      var yIndex = Math.floor(index / gridSize[0]);\n      var xIndex = index - yIndex * gridSize[0];\n      var latIdx = Math.floor((yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]);\n      var lonIdx = Math.floor((xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]);\n      return \"\".concat(latIdx, \"-\").concat(lonIdx);\n    }\n  }, {\n    key: \"getPositionForIndex\",\n    value: function getPositionForIndex(index) {\n      var _this$state2 = this.state,\n        numRow = _this$state2.numRow,\n        numCol = _this$state2.numCol,\n        boundingBox = _this$state2.boundingBox,\n        gridOffset = _this$state2.gridOffset;\n      var gridSize = [numCol, numRow];\n      var gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n      var cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n      var yIndex = Math.floor(index / gridSize[0]);\n      var xIndex = index - yIndex * gridSize[0];\n      var yPos = yIndex * cellSize[1] + gridOrigin[1];\n      var xPos = xIndex * cellSize[0] + gridOrigin[0];\n      return [xPos, yPos];\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref) {\n      var info = _ref.info,\n        mode = _ref.mode;\n      var index = info.index;\n      var object = null;\n      if (index >= 0) {\n        var gpuGridAggregator = this.state.gpuGridAggregator;\n        var position = this.getPositionForIndex(index);\n        var colorInfo = GPUGridAggregator.getAggregationData(_objectSpread({\n          pixelIndex: index\n        }, gpuGridAggregator.getData('color')));\n        var elevationInfo = GPUGridAggregator.getAggregationData(_objectSpread({\n          pixelIndex: index\n        }, gpuGridAggregator.getData('elevation')));\n        object = {\n          colorValue: colorInfo.cellWeight,\n          elevationValue: elevationInfo.cellWeight,\n          count: colorInfo.cellCount || elevationInfo.cellCount,\n          position: position,\n          totalCount: colorInfo.totalCount || elevationInfo.totalCount\n        };\n        if (mode !== 'hover') {\n          var props = this.props;\n          var gridHash = this.state.gridHash;\n          if (!gridHash) {\n            var _this$state3 = this.state,\n              gridOffset = _this$state3.gridOffset,\n              translation = _this$state3.translation,\n              boundingBox = _this$state3.boundingBox;\n            var viewport = this.context.viewport;\n            var attributes = this.getAttributes();\n            var cpuAggregation = pointToDensityGridDataCPU(props, {\n              gridOffset: gridOffset,\n              attributes: attributes,\n              viewport: viewport,\n              translation: translation,\n              boundingBox: boundingBox\n            });\n            gridHash = cpuAggregation.gridHash;\n            this.setState({\n              gridHash: gridHash\n            });\n          }\n          var key = this.getHashKeyForIndex(index);\n          var cpuAggregationData = gridHash[key];\n          Object.assign(object, cpuAggregationData);\n        }\n      }\n      info.picked = Boolean(object);\n      info.object = object;\n      return info;\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      if (!this.state.isSupported) {\n        return null;\n      }\n      var _this$props = this.props,\n        elevationScale = _this$props.elevationScale,\n        extruded = _this$props.extruded,\n        cellSizeMeters = _this$props.cellSize,\n        coverage = _this$props.coverage,\n        material = _this$props.material,\n        elevationRange = _this$props.elevationRange,\n        colorDomain = _this$props.colorDomain,\n        elevationDomain = _this$props.elevationDomain;\n      var _this$state4 = this.state,\n        weights = _this$state4.weights,\n        numRow = _this$state4.numRow,\n        numCol = _this$state4.numCol,\n        gridOrigin = _this$state4.gridOrigin,\n        gridOffset = _this$state4.gridOffset;\n      var color = weights.color,\n        elevation = weights.elevation;\n      var colorRange = colorRangeToFlatArray(this.props.colorRange);\n      var SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n      return new SubLayerClass({\n        gridSize: [numCol, numRow],\n        gridOrigin: gridOrigin,\n        gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n        colorRange: colorRange,\n        elevationRange: elevationRange,\n        colorDomain: colorDomain,\n        elevationDomain: elevationDomain,\n        cellSize: cellSizeMeters,\n        coverage: coverage,\n        material: material,\n        elevationScale: elevationScale,\n        extruded: extruded\n      }, this.getSubLayerProps({\n        id: 'gpu-grid-cell'\n      }), {\n        data: {\n          attributes: {\n            colors: color.aggregationBuffer,\n            elevations: elevation.aggregationBuffer\n          }\n        },\n        colorMaxMinBuffer: color.maxMinBuffer,\n        elevationMaxMinBuffer: elevation.maxMinBuffer,\n        numInstances: numCol * numRow\n      });\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      var _this$state$weights = this.state.weights,\n        color = _this$state$weights.color,\n        elevation = _this$state$weights.elevation;\n      [color, elevation].forEach(function (weight) {\n        var aggregationBuffer = weight.aggregationBuffer,\n          maxMinBuffer = weight.maxMinBuffer;\n        maxMinBuffer.delete();\n        aggregationBuffer === null || aggregationBuffer === void 0 ? void 0 : aggregationBuffer.delete();\n      });\n      _get(_getPrototypeOf(GPUGridLayer.prototype), \"finalizeState\", this).call(this);\n    }\n  }, {\n    key: \"updateAggregationState\",\n    value: function updateAggregationState(opts) {\n      var props = opts.props,\n        oldProps = opts.oldProps;\n      var cellSize = props.cellSize,\n        coordinateSystem = props.coordinateSystem;\n      var viewport = this.context.viewport;\n      var cellSizeChanged = oldProps.cellSize !== cellSize;\n      var dimensions = this.state.dimensions;\n      var positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n      var attributesChanged = positionsChanged || this.isAttributeChanged();\n      var boundingBox = this.state.boundingBox;\n      if (positionsChanged) {\n        boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n        this.setState({\n          boundingBox: boundingBox\n        });\n      }\n      if (positionsChanged || cellSizeChanged) {\n        var _getGridParams = getGridParams(boundingBox, cellSize, viewport, coordinateSystem),\n          gridOffset = _getGridParams.gridOffset,\n          translation = _getGridParams.translation,\n          width = _getGridParams.width,\n          height = _getGridParams.height,\n          numCol = _getGridParams.numCol,\n          numRow = _getGridParams.numRow;\n        this.allocateResources(numRow, numCol);\n        this.setState({\n          gridOffset: gridOffset,\n          translation: translation,\n          gridOrigin: [-1 * translation[0], -1 * translation[1]],\n          width: width,\n          height: height,\n          numCol: numCol,\n          numRow: numRow\n        });\n      }\n      var aggregationDataDirty = attributesChanged || this.isAggregationDirty(opts, {\n        dimension: dimensions.data,\n        compareAll: true\n      });\n      if (aggregationDataDirty) {\n        this._updateAccessors(opts);\n      }\n      this.setState({\n        aggregationDataDirty: aggregationDataDirty\n      });\n    }\n  }, {\n    key: \"_updateAccessors\",\n    value: function _updateAccessors(opts) {\n      var _opts$props = opts.props,\n        colorAggregation = _opts$props.colorAggregation,\n        elevationAggregation = _opts$props.elevationAggregation;\n      var _this$state$weights2 = this.state.weights,\n        color = _this$state$weights2.color,\n        elevation = _this$state$weights2.elevation;\n      color.operation = AGGREGATION_OPERATION[colorAggregation];\n      elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n    }\n  }]);\n  return GPUGridLayer;\n}(GridAggregationLayer);\nexport { GPUGridLayer as default };\nGPUGridLayer.layerName = 'GPUGridLayer';\nGPUGridLayer.defaultProps = defaultProps;","map":{"version":3,"names":["Buffer","log","GPUGridAggregator","AGGREGATION_OPERATION","defaultColorRange","colorRangeToFlatArray","GPUGridCellLayer","pointToDensityGridDataCPU","GridAggregationLayer","getBoundingBox","getGridParams","defaultProps","colorDomain","colorRange","getColorWeight","type","value","colorAggregation","elevationDomain","elevationRange","getElevationWeight","elevationAggregation","elevationScale","min","cellSize","max","coverage","getPosition","x","position","extruded","material","DIMENSIONS","data","props","POSITION_ATTRIBUTE_NAME","GPUGridLayer","_GridAggregationLayer","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","initializeState","_attributeManager$add","gl","context","isSupported","error","_get","_getPrototypeOf","prototype","call","dimensions","setState","gpuAggregation","projectPoints","weights","color","needMin","needMax","combineMaxMin","maxMinBuffer","byteLength","accessor","size","divisor","elevation","positionAttributeName","attributeManager","getAttributeManager","add","_defineProperty","fp64","use64bitPositions","updateState","opts","state","aggregationDirty","gridHash","getHashKeyForIndex","index","_this$state","numRow","numCol","boundingBox","gridOffset","gridSize","gridOrigin","xMin","yMin","xOffset","yOffset","yIndex","Math","floor","xIndex","latIdx","lonIdx","concat","getPositionForIndex","_this$state2","yPos","xPos","getPickingInfo","_ref","info","mode","object","gpuGridAggregator","colorInfo","getAggregationData","_objectSpread","pixelIndex","getData","elevationInfo","colorValue","cellWeight","elevationValue","count","cellCount","totalCount","_this$state3","translation","viewport","attributes","getAttributes","cpuAggregation","cpuAggregationData","Object","assign","picked","Boolean","renderLayers","_this$props","cellSizeMeters","_this$state4","SubLayerClass","getSubLayerClass","getSubLayerProps","id","colors","aggregationBuffer","elevations","colorMaxMinBuffer","elevationMaxMinBuffer","numInstances","finalizeState","_this$state$weights","forEach","weight","delete","updateAggregationState","oldProps","coordinateSystem","cellSizeChanged","positionsChanged","isAttributeChanged","attributesChanged","getNumInstances","_getGridParams","width","height","allocateResources","aggregationDataDirty","isAggregationDirty","dimension","compareAll","_updateAccessors","_opts$props","_this$state$weights2","operation","default","layerName"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/aggregation-layers/src/gpu-grid-layer/gpu-grid-layer.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Buffer} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport {log} from '@deck.gl/core';\n\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION} from '../utils/aggregation-operation-utils';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport {pointToDensityGridDataCPU} from './../cpu-grid-layer/grid-aggregator';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport {getBoundingBox, getGridParams} from '../utils/grid-aggregation-utils';\n\nconst defaultProps = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  // grid\n  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  getPosition: {type: 'accessor', value: x => x.position},\n  extruded: false,\n\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\n// This layer only perform GPU aggregation, no need to seperate data and weight props\n// aggregation will be dirty when any of the props are changed.\n\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n  }\n  // rest of the changes are detected by `state.attributesChanged`\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\n\nexport default class GPUGridLayer extends GridAggregationLayer {\n  initializeState() {\n    const {gl} = this.context;\n    const isSupported = GPUGridAggregator.isSupported(gl);\n    if (!isSupported) {\n      log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n    }\n    super.initializeState({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      gpuAggregation: true,\n      projectPoints: false, // aggregation in world space\n      isSupported,\n      weights: {\n        color: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {size: 4, type: GL.FLOAT, divisor: 1}\n          })\n        },\n        elevation: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {size: 4, type: GL.FLOAT, divisor: 1}\n          })\n        }\n      },\n      positionAttributeName: 'positions'\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      color: {size: 3, accessor: 'getColorWeight'},\n      elevation: {size: 3, accessor: 'getElevationWeight'}\n    });\n  }\n\n  updateState(opts) {\n    if (this.state.isSupported === false) {\n      // Skip update, layer not supported\n      return;\n    }\n    super.updateState(opts);\n    const {aggregationDirty} = this.state;\n    if (aggregationDirty) {\n      // reset cached CPU Aggregation results (used for picking)\n      this.setState({\n        gridHash: null\n      });\n    }\n  }\n\n  getHashKeyForIndex(index) {\n    const {numRow, numCol, boundingBox, gridOffset} = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    // This will match the index to the hash-key to access aggregation data from CPU aggregation results.\n    const latIdx = Math.floor(\n      (yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]\n    );\n    const lonIdx = Math.floor(\n      (xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]\n    );\n    return `${latIdx}-${lonIdx}`;\n  }\n\n  getPositionForIndex(index) {\n    const {numRow, numCol, boundingBox, gridOffset} = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const yPos = yIndex * cellSize[1] + gridOrigin[1];\n    const xPos = xIndex * cellSize[0] + gridOrigin[0];\n    return [xPos, yPos];\n  }\n\n  getPickingInfo({info, mode}) {\n    const {index} = info;\n    let object = null;\n    if (index >= 0) {\n      const {gpuGridAggregator} = this.state;\n      const position = this.getPositionForIndex(index);\n      const colorInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('color')\n      });\n      const elevationInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('elevation')\n      });\n\n      object = {\n        colorValue: colorInfo.cellWeight,\n        elevationValue: elevationInfo.cellWeight,\n        count: colorInfo.cellCount || elevationInfo.cellCount,\n        position,\n        totalCount: colorInfo.totalCount || elevationInfo.totalCount\n      };\n      if (mode !== 'hover') {\n        // perform CPU aggregation for full list of points for each cell\n        const {props} = this;\n        let {gridHash} = this.state;\n        if (!gridHash) {\n          const {gridOffset, translation, boundingBox} = this.state;\n          const {viewport} = this.context;\n          const attributes = this.getAttributes();\n          const cpuAggregation = pointToDensityGridDataCPU(props, {\n            gridOffset,\n            attributes,\n            viewport,\n            translation,\n            boundingBox\n          });\n          gridHash = cpuAggregation.gridHash;\n          this.setState({gridHash});\n        }\n        const key = this.getHashKeyForIndex(index);\n        const cpuAggregationData = gridHash[key];\n        Object.assign(object, cpuAggregationData);\n      }\n    }\n\n    // override object with picked cell\n    info.picked = Boolean(object);\n    info.object = object;\n\n    return info;\n  }\n\n  renderLayers() {\n    if (!this.state.isSupported) {\n      return null;\n    }\n    const {\n      elevationScale,\n      extruded,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationRange,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n\n    const {weights, numRow, numCol, gridOrigin, gridOffset} = this.state;\n    const {color, elevation} = weights;\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n\n    const SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n\n    return new SubLayerClass(\n      {\n        gridSize: [numCol, numRow],\n        gridOrigin,\n        gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n        colorRange,\n        elevationRange,\n        colorDomain,\n        elevationDomain,\n\n        cellSize: cellSizeMeters,\n        coverage,\n        material,\n        elevationScale,\n        extruded\n      },\n      this.getSubLayerProps({\n        id: 'gpu-grid-cell'\n      }),\n      {\n        data: {\n          attributes: {\n            colors: color.aggregationBuffer,\n            elevations: elevation.aggregationBuffer\n          }\n        },\n        colorMaxMinBuffer: color.maxMinBuffer,\n        elevationMaxMinBuffer: elevation.maxMinBuffer,\n        numInstances: numCol * numRow\n      }\n    );\n  }\n\n  finalizeState() {\n    const {color, elevation} = this.state.weights;\n    [color, elevation].forEach(weight => {\n      const {aggregationBuffer, maxMinBuffer} = weight;\n      maxMinBuffer.delete();\n      aggregationBuffer?.delete();\n    });\n    super.finalizeState();\n  }\n\n  // Aggregation Overrides\n\n  updateAggregationState(opts) {\n    const {props, oldProps} = opts;\n    const {cellSize, coordinateSystem} = props;\n    const {viewport} = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    const {dimensions} = this.state;\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    // any attribute changed\n    const attributesChanged = positionsChanged || this.isAttributeChanged();\n\n    let {boundingBox} = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({boundingBox});\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {gridOffset, translation, width, height, numCol, numRow} = getGridParams(\n        boundingBox,\n        cellSize,\n        viewport,\n        coordinateSystem\n      );\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        translation,\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty =\n      attributesChanged ||\n      this.isAggregationDirty(opts, {\n        dimension: dimensions.data,\n        compareAll: true\n      });\n\n    if (aggregationDataDirty) {\n      this._updateAccessors(opts);\n    }\n    this.setState({\n      aggregationDataDirty\n    });\n  }\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {colorAggregation, elevationAggregation} = opts.props;\n    const {color, elevation} = this.state.weights;\n    color.operation = AGGREGATION_OPERATION[colorAggregation];\n    elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n  }\n}\n\nGPUGridLayer.layerName = 'GPUGridLayer';\nGPUGridLayer.defaultProps = defaultProps;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}