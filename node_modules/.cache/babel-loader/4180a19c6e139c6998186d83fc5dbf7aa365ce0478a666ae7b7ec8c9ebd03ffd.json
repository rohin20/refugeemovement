{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport { AsyncQueue, TableBatchBuilder, RowTableBatch } from '@loaders.gl/tables';\nimport Papa from './libs/papaparse';\nimport AsyncIteratorStreamer from './lib/async-iterator-streamer';\nvar VERSION = typeof \"2.3.13\" !== 'undefined' ? \"2.3.13\" : 'latest';\nvar CSVLoaderOptions = {\n  csv: {\n    TableBatch: RowTableBatch,\n    batchSize: 10,\n    optimizeMemoryUsage: false,\n    header: 'auto',\n    rowFormat: 'auto',\n    columnPrefix: 'column',\n    quoteChar: '\"',\n    escapeChar: '\"',\n    dynamicTyping: true,\n    comments: false,\n    skipEmptyLines: false,\n    delimitersToGuess: [',', '\\t', '|', ';']\n  }\n};\nexport default {\n  id: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv'],\n  mimeTypes: ['text/csv'],\n  category: 'table',\n  parse: function () {\n    var _parse = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(arrayBuffer, options) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", parseCSV(new TextDecoder().decode(arrayBuffer), options));\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    function parse(_x, _x2) {\n      return _parse.apply(this, arguments);\n    }\n    return parse;\n  }(),\n  parseText: parseCSV,\n  parseInBatches: parseCSVInBatches,\n  testText: null,\n  options: CSVLoaderOptions\n};\nfunction parseCSV(_x3, _x4) {\n  return _parseCSV.apply(this, arguments);\n}\nfunction _parseCSV() {\n  _parseCSV = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(csvText, options) {\n    var header, config, result;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _objectSpread(_objectSpread({}, CSVLoaderOptions), options);\n            options.csv = _objectSpread(_objectSpread({}, CSVLoaderOptions.csv), options.csv);\n            _context2.next = 4;\n            return hasHeader(csvText, options);\n          case 4:\n            header = _context2.sent;\n            config = _objectSpread(_objectSpread({\n              dynamicTyping: true\n            }, options.csv), {}, {\n              header: header,\n              download: false,\n              error: function error(e) {\n                throw new Error(e);\n              }\n            });\n            result = Papa.parse(csvText, config);\n            return _context2.abrupt(\"return\", result.data);\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _parseCSV.apply(this, arguments);\n}\nfunction parseCSVInBatches(asyncIterator, options) {\n  options = _objectSpread(_objectSpread({}, CSVLoaderOptions), options);\n  options.csv = _objectSpread(_objectSpread({}, CSVLoaderOptions.csv), options.csv);\n  var _options$csv = options.csv,\n    batchSize = _options$csv.batchSize,\n    optimizeMemoryUsage = _options$csv.optimizeMemoryUsage;\n  var TableBatchType = options.csv.TableBatch;\n  var asyncQueue = new AsyncQueue();\n  var convertToObject = options.csv.rowFormat === 'object';\n  var isFirstRow = true;\n  var headerRow = null;\n  var tableBatchBuilder = null;\n  var schema = null;\n  var config = _objectSpread(_objectSpread({\n    dynamicTyping: true\n  }, options.csv), {}, {\n    header: false,\n    download: false,\n    step: function step(results, parser) {\n      var row = results.data;\n      var bytesUsed = results.meta.cursor;\n      if (isFirstRow && !headerRow) {\n        var header = isHeaderRow(row, options);\n        if (header) {\n          headerRow = row;\n          return;\n        }\n      }\n      if (isFirstRow) {\n        isFirstRow = false;\n        if (!headerRow) {\n          headerRow = [];\n          for (var i = 0; i < row.length; i++) {\n            headerRow[i] = \"\".concat(options.csv.columnPrefix).concat(i + 1);\n          }\n        }\n        schema = deduceSchema(row, headerRow);\n      }\n      tableBatchBuilder = tableBatchBuilder || new TableBatchBuilder(TableBatchType, schema, {\n        batchSize: batchSize,\n        convertToObject: convertToObject,\n        optimizeMemoryUsage: optimizeMemoryUsage\n      });\n      tableBatchBuilder.addRow(row);\n      if (tableBatchBuilder.isFull()) {\n        asyncQueue.enqueue(tableBatchBuilder.getBatch({\n          bytesUsed: bytesUsed\n        }));\n      }\n    },\n    complete: function complete(results, file) {\n      var bytesUsed = results.meta.cursor;\n      var batch = tableBatchBuilder.getBatch({\n        bytesUsed: bytesUsed\n      });\n      if (batch) {\n        asyncQueue.enqueue(batch);\n      }\n      asyncQueue.close();\n    }\n  });\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n  return asyncQueue;\n}\nfunction isHeaderRow(row, options) {\n  if (options && options.csv.header !== 'auto') {\n    return Boolean(options.csv.header);\n  }\n  return row.every(function (value) {\n    return typeof value === 'string';\n  });\n}\nfunction hasHeader(_x5, _x6) {\n  return _hasHeader.apply(this, arguments);\n}\nfunction _hasHeader() {\n  _hasHeader = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(csvText, options) {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(options.csv.header !== 'auto')) {\n              _context3.next = 2;\n              break;\n            }\n            return _context3.abrupt(\"return\", Boolean(options.csv.header));\n          case 2:\n            _context3.next = 4;\n            return new Promise(function (resolve, reject) {\n              Papa.parse(csvText, {\n                download: false,\n                dynamicTyping: true,\n                step: function step(results, parser) {\n                  parser.abort();\n                  var row = results.data;\n                  resolve(isHeaderRow(row));\n                },\n                error: function error(e) {\n                  reject(new Error(e));\n                }\n              });\n            });\n          case 4:\n            return _context3.abrupt(\"return\", _context3.sent);\n          case 5:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _hasHeader.apply(this, arguments);\n}\nfunction deduceSchema(row, headerRow) {\n  var schema = headerRow ? {} : [];\n  for (var i = 0; i < row.length; i++) {\n    var columnName = headerRow && headerRow[i] || i;\n    var value = row[i];\n    switch (_typeof(value)) {\n      case 'number':\n      case 'boolean':\n        schema[columnName] = {\n          name: String(columnName),\n          index: i,\n          type: Float32Array\n        };\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {\n          name: String(columnName),\n          index: i,\n          type: Array\n        };\n    }\n  }\n  return schema;\n}","map":{"version":3,"names":["AsyncQueue","TableBatchBuilder","RowTableBatch","Papa","AsyncIteratorStreamer","VERSION","CSVLoaderOptions","csv","TableBatch","batchSize","optimizeMemoryUsage","header","rowFormat","columnPrefix","quoteChar","escapeChar","dynamicTyping","comments","skipEmptyLines","delimitersToGuess","id","name","version","extensions","mimeTypes","category","parse","_parse","_asyncToGenerator","_regeneratorRuntime","mark","_callee","arrayBuffer","options","wrap","_callee$","_context","prev","next","abrupt","parseCSV","TextDecoder","decode","stop","_x","_x2","apply","arguments","parseText","parseInBatches","parseCSVInBatches","testText","_callee2","csvText","config","result","_callee2$","_context2","_objectSpread","hasHeader","sent","download","error","e","Error","data","asyncIterator","_options$csv","TableBatchType","asyncQueue","convertToObject","isFirstRow","headerRow","tableBatchBuilder","schema","step","results","parser","row","bytesUsed","meta","cursor","isHeaderRow","i","length","concat","deduceSchema","addRow","isFull","enqueue","getBatch","complete","file","batch","close","Boolean","every","value","_callee3","_callee3$","_context3","Promise","resolve","reject","abort","columnName","_typeof","String","index","type","Float32Array","Array"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/csv/src/csv-loader.js"],"sourcesContent":["/* global TextDecoder */\nimport {AsyncQueue, TableBatchBuilder, RowTableBatch} from '@loaders.gl/tables';\nimport Papa from './libs/papaparse';\nimport AsyncIteratorStreamer from './lib/async-iterator-streamer';\n/** @typedef {import('@loaders.gl/loader-utils').LoaderObject} LoaderObject */\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nconst CSVLoaderOptions = {\n  csv: {\n    TableBatch: RowTableBatch,\n    batchSize: 10,\n    optimizeMemoryUsage: false,\n    // CSV options\n    header: 'auto',\n    rowFormat: 'auto',\n    columnPrefix: 'column',\n    // delimiter: auto\n    // newline: auto\n    quoteChar: '\"',\n    escapeChar: '\"',\n    dynamicTyping: true,\n    comments: false,\n    skipEmptyLines: false,\n    // transform: null?\n    delimitersToGuess: [',', '\\t', '|', ';']\n    // fastMode: auto\n  }\n};\n\n/** @type {LoaderObject} */\nexport default {\n  id: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv'],\n  mimeTypes: ['text/csv'],\n  category: 'table',\n  parse: async (arrayBuffer, options) => parseCSV(new TextDecoder().decode(arrayBuffer), options),\n  parseText: parseCSV,\n  parseInBatches: parseCSVInBatches,\n  testText: null,\n  options: CSVLoaderOptions\n};\n\nasync function parseCSV(csvText, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...CSVLoaderOptions, ...options};\n  options.csv = {...CSVLoaderOptions.csv, ...options.csv};\n\n  const header = await hasHeader(csvText, options);\n\n  const config = {\n    dynamicTyping: true, // Convert numbers and boolean values in rows from strings\n    ...options.csv,\n    header,\n    download: false, // We handle loading, no need for papaparse to do it for us\n    error: e => {\n      throw new Error(e);\n    }\n  };\n\n  const result = Papa.parse(csvText, config);\n  return result.data;\n}\n\n// TODO - support batch size 0 = no batching/single batch?\nfunction parseCSVInBatches(asyncIterator, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...CSVLoaderOptions, ...options};\n  options.csv = {...CSVLoaderOptions.csv, ...options.csv};\n\n  const {batchSize, optimizeMemoryUsage} = options.csv;\n  const TableBatchType = options.csv.TableBatch;\n\n  const asyncQueue = new AsyncQueue();\n\n  const convertToObject = options.csv.rowFormat === 'object';\n\n  let isFirstRow = true;\n  let headerRow = null;\n  let tableBatchBuilder = null;\n  let schema = null;\n\n  const config = {\n    dynamicTyping: true, // Convert numbers and boolean values in rows from strings,\n    ...options.csv,\n    header: false, // Unfortunately, header detection is not automatic and does not infer types\n    download: false, // We handle loading, no need for papaparse to do it for us\n    // chunk(results, parser) {\n    //   // TODO batch before adding to queue.\n    //   console.log('Chunk:', results, parser);\n    //   asyncQueue.enqueue(results.data);\n    // },\n\n    // step is called on every row\n    step(results, parser) {\n      const row = results.data;\n      const bytesUsed = results.meta.cursor;\n\n      // Check if we need to save a header row\n      if (isFirstRow && !headerRow) {\n        // Auto detects or can be forced with options.csv.header\n        const header = isHeaderRow(row, options);\n        if (header) {\n          headerRow = row;\n          return;\n        }\n      }\n\n      // If first data row, we can deduce the schema\n      if (isFirstRow) {\n        isFirstRow = false;\n        if (!headerRow) {\n          headerRow = [];\n          for (let i = 0; i < row.length; i++) {\n            headerRow[i] = `${options.csv.columnPrefix}${i + 1}`;\n          }\n        }\n        schema = deduceSchema(row, headerRow);\n      }\n\n      // Add the row\n      tableBatchBuilder =\n        tableBatchBuilder ||\n        new TableBatchBuilder(TableBatchType, schema, {\n          batchSize,\n          convertToObject,\n          optimizeMemoryUsage\n        });\n\n      tableBatchBuilder.addRow(row);\n      // If a batch has been completed, emit it\n      if (tableBatchBuilder.isFull()) {\n        asyncQueue.enqueue(tableBatchBuilder.getBatch({bytesUsed}));\n      }\n    },\n\n    // complete is called when all rows have been read\n    complete(results, file) {\n      const bytesUsed = results.meta.cursor;\n      // Ensure any final (partial) batch gets emitted\n      const batch = tableBatchBuilder.getBatch({bytesUsed});\n      if (batch) {\n        asyncQueue.enqueue(batch);\n      }\n      asyncQueue.close();\n    }\n  };\n\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n\n  // TODO - Does it matter if we return asyncIterable or asyncIterator\n  // return asyncQueue[Symbol.asyncIterator]();\n  return asyncQueue;\n}\n\nfunction isHeaderRow(row, options) {\n  if (options && options.csv.header !== 'auto') {\n    return Boolean(options.csv.header);\n  }\n\n  return row.every(value => typeof value === 'string');\n}\n\nasync function hasHeader(csvText, options) {\n  if (options.csv.header !== 'auto') {\n    return Boolean(options.csv.header);\n  }\n\n  return await new Promise((resolve, reject) => {\n    Papa.parse(csvText, {\n      download: false,\n      dynamicTyping: true,\n      step: (results, parser) => {\n        parser.abort();\n        const row = results.data;\n        // Test the row\n        resolve(isHeaderRow(row));\n      },\n      error: e => {\n        reject(new Error(e));\n      }\n    });\n  });\n}\n\nfunction deduceSchema(row, headerRow) {\n  const schema = headerRow ? {} : [];\n  for (let i = 0; i < row.length; i++) {\n    const columnName = (headerRow && headerRow[i]) || i;\n    const value = row[i];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n  }\n  return schema;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}