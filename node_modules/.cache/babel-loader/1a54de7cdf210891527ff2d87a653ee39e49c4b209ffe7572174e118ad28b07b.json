{"ast":null,"code":"import { bitCode, intersect } from './lineclip';\nimport { getPointAtIndex, copy, push } from './utils';\nexport function cutPolylineByGrid(positions, options) {\n  var _ref = options || {},\n    _ref$size = _ref.size,\n    size = _ref$size === void 0 ? 2 : _ref$size,\n    _ref$broken = _ref.broken,\n    broken = _ref$broken === void 0 ? false : _ref$broken,\n    _ref$gridResolution = _ref.gridResolution,\n    gridResolution = _ref$gridResolution === void 0 ? 10 : _ref$gridResolution,\n    _ref$gridOffset = _ref.gridOffset,\n    gridOffset = _ref$gridOffset === void 0 ? [0, 0] : _ref$gridOffset,\n    _ref$startIndex = _ref.startIndex,\n    startIndex = _ref$startIndex === void 0 ? 0 : _ref$startIndex,\n    _ref$endIndex = _ref.endIndex,\n    endIndex = _ref$endIndex === void 0 ? positions.length : _ref$endIndex;\n  var numPoints = (endIndex - startIndex) / size;\n  var part = [];\n  var result = [part];\n  var a = getPointAtIndex(positions, 0, size, startIndex);\n  var b;\n  var codeB;\n  var cell = getGridCell(a, gridResolution, gridOffset, []);\n  var scratchPoint = [];\n  push(part, a);\n  for (var i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n    while (codeB) {\n      intersect(a, b, codeB, cell, scratchPoint);\n      var codeAlt = bitCode(scratchPoint, cell);\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n      push(part, scratchPoint);\n      copy(a, scratchPoint);\n      moveToNeighborCell(cell, gridResolution, codeB);\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n      codeB = bitCode(b, cell);\n    }\n    push(part, b);\n    copy(a, b);\n  }\n  return broken ? result : result[0];\n}\nvar TYPE_INSIDE = 0;\nvar TYPE_BORDER = 1;\nfunction concatInPlace(arr1, arr2) {\n  for (var i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n  return arr1;\n}\nexport function cutPolygonByGrid(positions) {\n  var holeIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var options = arguments.length > 2 ? arguments[2] : undefined;\n  if (!positions.length) {\n    return [];\n  }\n  var _ref2 = options || {},\n    _ref2$size = _ref2.size,\n    size = _ref2$size === void 0 ? 2 : _ref2$size,\n    _ref2$gridResolution = _ref2.gridResolution,\n    gridResolution = _ref2$gridResolution === void 0 ? 10 : _ref2$gridResolution,\n    _ref2$gridOffset = _ref2.gridOffset,\n    gridOffset = _ref2$gridOffset === void 0 ? [0, 0] : _ref2$gridOffset,\n    _ref2$edgeTypes = _ref2.edgeTypes,\n    edgeTypes = _ref2$edgeTypes === void 0 ? false : _ref2$edgeTypes;\n  var result = [];\n  var queue = [{\n    pos: positions,\n    types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,\n    holes: holeIndices || []\n  }];\n  var bbox = [[], []];\n  var cell = [];\n  while (queue.length) {\n    var _queue$shift = queue.shift(),\n      pos = _queue$shift.pos,\n      types = _queue$shift.types,\n      holes = _queue$shift.holes;\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    var code = bitCode(bbox[1], cell);\n    if (code) {\n      var parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      var polygonLow = {\n        pos: parts[0].pos,\n        types: parts[0].types,\n        holes: []\n      };\n      var polygonHigh = {\n        pos: parts[1].pos,\n        types: parts[1].types,\n        holes: []\n      };\n      queue.push(polygonLow, polygonHigh);\n      for (var i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      var polygon = {\n        positions: pos\n      };\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n      result.push(polygon);\n    }\n  }\n  return result;\n}\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  var numPoints = (endIndex - startIndex) / size;\n  var resultLow = [];\n  var resultHigh = [];\n  var typesLow = [];\n  var typesHigh = [];\n  var scratchPoint = [];\n  var p;\n  var side;\n  var type;\n  var prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  var prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  var prevType = edgeTypes && edgeTypes[numPoints - 1];\n  var lowPointCount = 0;\n  var highPointCount = 0;\n  for (var i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n  return [lowPointCount ? {\n    pos: resultLow,\n    types: edgeTypes && typesLow\n  } : null, highPointCount ? {\n    pos: resultHigh,\n    types: edgeTypes && typesHigh\n  } : null];\n}\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  var left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  var bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\nfunction getBoundingBox(positions, size, endIndex, out) {\n  var minX = Infinity;\n  var maxX = -Infinity;\n  var minY = Infinity;\n  var maxY = -Infinity;\n  for (var i = 0; i < endIndex; i += size) {\n    var x = positions[i];\n    var y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}","map":{"version":3,"names":["bitCode","intersect","getPointAtIndex","copy","push","cutPolylineByGrid","positions","options","_ref","_ref$size","size","_ref$broken","broken","_ref$gridResolution","gridResolution","_ref$gridOffset","gridOffset","_ref$startIndex","startIndex","_ref$endIndex","endIndex","length","numPoints","part","result","a","b","codeB","cell","getGridCell","scratchPoint","i","codeAlt","moveToNeighborCell","TYPE_INSIDE","TYPE_BORDER","concatInPlace","arr1","arr2","cutPolygonByGrid","holeIndices","arguments","undefined","_ref2","_ref2$size","_ref2$gridResolution","_ref2$gridOffset","_ref2$edgeTypes","edgeTypes","queue","pos","types","Array","fill","holes","bbox","_queue$shift","shift","getBoundingBox","code","parts","bisectPolygon","polygonLow","polygonHigh","polygon","edge","resultLow","resultHigh","typesLow","typesHigh","p","side","type","prev","prevSide","Math","sign","prevType","lowPointCount","highPointCount","out","left","floor","bottom","minX","Infinity","maxX","minY","maxY","x","y"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@math.gl/polygon/src/cut-by-grid.ts"],"sourcesContent":["/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\nimport {bitCode, intersect, BoundingBox} from './lineclip';\nimport {getPointAtIndex, copy, push} from './utils';\n\nimport type {NumericArray} from '@math.gl/core';\n\nexport type Polygon = {\n  positions: Readonly<NumericArray>;\n  holeIndices?: Readonly<NumericArray>;\n  edgeTypes?: Readonly<NumericArray>;\n};\n\nexport function cutPolylineByGrid(\n  positions: NumericArray,\n  options?: {\n    size?: number;\n    broken?: boolean;\n    gridResolution?: number;\n    gridOffset?: [number, number];\n    startIndex?: number;\n    endIndex?: number;\n  }\n): number[] | number[][] {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  let part: number[] = [];\n  const result: number[][] = [part];\n  const a: number[] = getPointAtIndex(positions, 0, size, startIndex);\n  let b: number[];\n  let codeB: number;\n  const cell: BoundingBox = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint: number[] = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      // find the intersection with the current cell\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n      push(part, scratchPoint);\n      // move to the next cell\n      copy(a, scratchPoint);\n\n      moveToNeighborCell(cell, gridResolution, codeB);\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\n\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nfunction concatInPlace(arr1: number[], arr2: number[]): number[] {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n  return arr1;\n}\n\nexport function cutPolygonByGrid(\n  positions: Readonly<NumericArray>,\n  holeIndices: Readonly<NumericArray> | null = null,\n  options?: {\n    size?: number;\n    gridResolution?: number;\n    gridOffset?: [number, number];\n    edgeTypes?: boolean;\n  }\n): Polygon[] {\n  if (!positions.length) {\n    // input is empty\n    return [];\n  }\n  const {size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false} = options || {};\n  const result: Polygon[] = [];\n  const queue: {pos: Readonly<NumericArray>; types: number[]; holes: Readonly<NumericArray>}[] = [\n    {\n      pos: positions,\n      types: edgeTypes ? (new Array(positions.length / size).fill(TYPE_BORDER) as number[]) : null,\n      holes: holeIndices || []\n    }\n  ];\n  const bbox: number[][] = [[], []];\n  // @ts-ignore\n  let cell: BoundingBox = [];\n\n  // Recursively bisect polygon until every part fit in a single grid cell\n  while (queue.length) {\n    const {pos, types, holes} = queue.shift();\n\n    // Get the bounding box of the outer polygon\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      // Split the outer ring at the boundary\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {pos: parts[0].pos, types: parts[0].types, holes: []};\n      const polygonHigh = {pos: parts[1].pos, types: parts[1].types, holes: []};\n      queue.push(polygonLow, polygonHigh);\n\n      // Split each hole at the boundary\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      // Polygon fits in a single cell, no more processing required\n      const polygon: Polygon = {positions: pos};\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n  return result;\n}\n\n// edgeTypes:\n// TYPE_BORDER - edge from the original polygon\n// TYPE_INSIDE - inside the original polygon\n// eslint-disable-next-line max-params\nfunction bisectPolygon(\n  positions: Readonly<NumericArray>,\n  edgeTypes: number[] | undefined,\n  size: number,\n  startIndex: number,\n  endIndex: number,\n  bbox: BoundingBox,\n  edge: number\n): {\n  pos: number[];\n  types?: number[];\n}[] {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow: number[] = [];\n  const resultHigh: number[] = [];\n  const typesLow: number[] = [];\n  const typesHigh: number[] = [];\n  const scratchPoint: number[] = [];\n\n  let p: number[];\n  let side: number;\n  let type: number;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    // if segment goes through the boundary, add an intersection\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [\n    lowPointCount ? {pos: resultLow, types: edgeTypes && typesLow} : null,\n    highPointCount ? {pos: resultHigh, types: edgeTypes && typesHigh} : null\n  ];\n}\n\nfunction getGridCell(\n  p: number[],\n  gridResolution: number,\n  gridOffset: [number, number],\n  out: number[]\n): BoundingBox {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom =\n    Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out as BoundingBox;\n}\n\nfunction moveToNeighborCell(cell: number[], gridResolution: number, edge: number): void {\n  if (edge & 8) {\n    // top\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    // bottom\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    // right\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    // left\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(\n  positions: Readonly<NumericArray>,\n  size: number,\n  endIndex: number,\n  out: number[][]\n): number[][] {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}