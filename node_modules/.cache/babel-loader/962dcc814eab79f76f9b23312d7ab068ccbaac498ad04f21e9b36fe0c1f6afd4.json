{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _wrapAsyncGenerator from \"@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport _awaitAsyncGenerator from \"@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _asyncIterator from \"@babel/runtime/helpers/esm/asyncIterator\";\nimport _asyncGeneratorDelegate from \"@babel/runtime/helpers/esm/asyncGeneratorDelegate\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport { assert } from '@loaders.gl/loader-utils';\nimport { concatenateChunksAsync, makeTransformIterator } from '@loaders.gl/loader-utils';\nimport { isLoaderObject } from '../loader-utils/normalize-loader';\nimport { normalizeOptions } from '../loader-utils/option-utils';\nimport { getLoaderContext } from '../loader-utils/context-utils';\nimport { getAsyncIteratorFromData, getReadableStream } from '../loader-utils/get-data';\nimport { getResourceUrlAndType } from '../utils/resource-utils';\nimport { selectLoader } from './select-loader';\nimport { parse } from './parse';\nexport function parseInBatches(_x2, _x3, _x4, _x5) {\n  return _parseInBatches.apply(this, arguments);\n}\nfunction _parseInBatches() {\n  _parseInBatches = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(data, loaders, options, context) {\n    var _getResourceUrlAndTyp, url, loader;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            assert(!context || typeof context !== 'string', 'parseInBatches no longer accepts final url');\n            if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n              context = options;\n              options = loaders;\n              loaders = null;\n            }\n            _context.next = 4;\n            return data;\n          case 4:\n            data = _context.sent;\n            options = options || {};\n            _getResourceUrlAndTyp = getResourceUrlAndType(data), url = _getResourceUrlAndTyp.url;\n            _context.next = 9;\n            return selectLoader(data, loaders, options);\n          case 9:\n            loader = _context.sent;\n            if (loader) {\n              _context.next = 12;\n              break;\n            }\n            return _context.abrupt(\"return\", null);\n          case 12:\n            options = normalizeOptions(options, loader, loaders, url);\n            context = getLoaderContext({\n              url: url,\n              parseInBatches: parseInBatches,\n              parse: parse,\n              loaders: loaders\n            }, options, context);\n            _context.next = 16;\n            return parseWithLoaderInBatches(loader, data, options, context);\n          case 16:\n            return _context.abrupt(\"return\", _context.sent);\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parseInBatches.apply(this, arguments);\n}\nfunction parseWithLoaderInBatches(_x6, _x7, _x8, _x9) {\n  return _parseWithLoaderInBatches.apply(this, arguments);\n}\nfunction _parseWithLoaderInBatches() {\n  _parseWithLoaderInBatches = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(loader, data, options, context) {\n    var outputIterator, metadataBatch, makeMetadataBatchIterator, _makeMetadataBatchIterator;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _makeMetadataBatchIterator = function _makeMetadataBatchIte2() {\n              _makeMetadataBatchIterator = _wrapAsyncGenerator(_regeneratorRuntime.mark(function _callee2(iterator) {\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.next = 2;\n                        return metadataBatch;\n                      case 2:\n                        return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(iterator), _awaitAsyncGenerator), \"t0\", 3);\n                      case 3:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n              return _makeMetadataBatchIterator.apply(this, arguments);\n            };\n            makeMetadataBatchIterator = function _makeMetadataBatchIte(_x) {\n              return _makeMetadataBatchIterator.apply(this, arguments);\n            };\n            _context3.next = 4;\n            return parseToOutputIterator(loader, data, options, context);\n          case 4:\n            outputIterator = _context3.sent;\n            if (options.metadata) {\n              _context3.next = 7;\n              break;\n            }\n            return _context3.abrupt(\"return\", outputIterator);\n          case 7:\n            metadataBatch = {\n              batchType: 'metadata',\n              metadata: {\n                _loader: loader,\n                _context: context\n              },\n              data: [],\n              bytesUsed: 0\n            };\n            return _context3.abrupt(\"return\", makeMetadataBatchIterator(outputIterator));\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _parseWithLoaderInBatches.apply(this, arguments);\n}\nfunction parseToOutputIterator(_x10, _x11, _x12, _x13) {\n  return _parseToOutputIterator.apply(this, arguments);\n}\nfunction _parseToOutputIterator() {\n  _parseToOutputIterator = _asyncToGenerator(_regeneratorRuntime.mark(function _callee5(loader, data, options, context) {\n    var inputIterator, iteratorChain, stream, parseChunkInBatches, _parseChunkInBatches;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _parseChunkInBatches = function _parseChunkInBatches3() {\n              _parseChunkInBatches = _wrapAsyncGenerator(_regeneratorRuntime.mark(function _callee4() {\n                var inputIterator, arrayBuffer;\n                return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                  while (1) {\n                    switch (_context4.prev = _context4.next) {\n                      case 0:\n                        _context4.next = 2;\n                        return _awaitAsyncGenerator(getAsyncIteratorFromData(data));\n                      case 2:\n                        inputIterator = _context4.sent;\n                        _context4.next = 5;\n                        return _awaitAsyncGenerator(concatenateChunksAsync(inputIterator));\n                      case 5:\n                        arrayBuffer = _context4.sent;\n                        _context4.next = 8;\n                        return loader.parse(arrayBuffer, options, context, loader);\n                      case 8:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }\n                }, _callee4);\n              }));\n              return _parseChunkInBatches.apply(this, arguments);\n            };\n            parseChunkInBatches = function _parseChunkInBatches2() {\n              return _parseChunkInBatches.apply(this, arguments);\n            };\n            if (!loader.parseInBatches) {\n              _context5.next = 10;\n              break;\n            }\n            _context5.next = 5;\n            return getAsyncIteratorFromData(data);\n          case 5:\n            inputIterator = _context5.sent;\n            iteratorChain = applyInputTransforms(inputIterator, options);\n            _context5.next = 9;\n            return loader.parseInBatches(iteratorChain, options, context, loader);\n          case 9:\n            return _context5.abrupt(\"return\", _context5.sent);\n          case 10:\n            if (!loader.parseStreamInBatches) {\n              _context5.next = 17;\n              break;\n            }\n            _context5.next = 13;\n            return getReadableStream(data);\n          case 13:\n            stream = _context5.sent;\n            if (!stream) {\n              _context5.next = 17;\n              break;\n            }\n            if (options.transforms) {\n              console.warn('options.transforms not implemented for loaders that use `parseStreamInBatches`');\n            }\n            return _context5.abrupt(\"return\", loader.parseStreamInBatches(stream, options, context));\n          case 17:\n            _context5.next = 19;\n            return parseChunkInBatches();\n          case 19:\n            return _context5.abrupt(\"return\", _context5.sent);\n          case 20:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _parseToOutputIterator.apply(this, arguments);\n}\nfunction applyInputTransforms(inputIterator, options) {\n  var iteratorChain = inputIterator;\n  var _iterator = _createForOfIteratorHelper(options.transforms || []),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var Transform = _step.value;\n      iteratorChain = makeTransformIterator(iteratorChain, Transform, options);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return iteratorChain;\n}","map":{"version":3,"names":["assert","concatenateChunksAsync","makeTransformIterator","isLoaderObject","normalizeOptions","getLoaderContext","getAsyncIteratorFromData","getReadableStream","getResourceUrlAndType","selectLoader","parse","parseInBatches","_x2","_x3","_x4","_x5","_parseInBatches","apply","arguments","_callee","data","loaders","options","context","_getResourceUrlAndTyp","url","loader","_regeneratorRuntime","wrap","_callee$","_context","prev","next","Array","isArray","sent","abrupt","parseWithLoaderInBatches","stop","_callee3","outputIterator","metadataBatch","makeMetadataBatchIterator","_makeMetadataBatchIterator","_callee3$","_context3","_makeMetadataBatchIte2","_wrapAsyncGenerator","mark","_callee2","iterator","_callee2$","_context2","delegateYield","_asyncGeneratorDelegate","_asyncIterator","_awaitAsyncGenerator","_makeMetadataBatchIte","_x","parseToOutputIterator","metadata","batchType","_loader","bytesUsed","_callee5","inputIterator","iteratorChain","stream","parseChunkInBatches","_parseChunkInBatches","_callee5$","_context5","_parseChunkInBatches3","_callee4","arrayBuffer","_callee4$","_context4","_parseChunkInBatches2","applyInputTransforms","parseStreamInBatches","transforms","console","warn","_iterator","_createForOfIteratorHelper","_step","s","n","done","Transform","value","err","e","f"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/kepler.gl/node_modules/@loaders.gl/core/src/lib/api/parse-in-batches.js"],"sourcesContent":["import {assert} from '@loaders.gl/loader-utils';\nimport {concatenateChunksAsync, makeTransformIterator} from '@loaders.gl/loader-utils';\nimport {isLoaderObject} from '../loader-utils/normalize-loader';\nimport {normalizeOptions} from '../loader-utils/option-utils';\nimport {getLoaderContext} from '../loader-utils/context-utils';\nimport {getAsyncIteratorFromData, getReadableStream} from '../loader-utils/get-data';\nimport {getResourceUrlAndType} from '../utils/resource-utils';\nimport {selectLoader} from './select-loader';\n\n// Ensure `parse` is available in context if loader falls back to `parse`\nimport {parse} from './parse';\n\nexport async function parseInBatches(data, loaders, options, context) {\n  assert(!context || typeof context !== 'string', 'parseInBatches no longer accepts final url');\n\n  // Signature: parseInBatches(data, options, url) - Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = options;\n    options = loaders;\n    loaders = null;\n  }\n\n  data = await data; // Resolve any promise\n  options = options || {};\n\n  // Extract a url for auto detection\n  const {url} = getResourceUrlAndType(data);\n\n  // Chooses a loader and normalizes it\n  // Note - only uses URL and contentType for streams and iterator inputs\n  const loader = await selectLoader(data, loaders, options);\n  // Note: if options.nothrow was set, it is possible that no loader was found, if so just return null\n  if (!loader) {\n    return null;\n  }\n\n  // Normalize options\n  options = normalizeOptions(options, loader, loaders, url);\n  context = getLoaderContext({url, parseInBatches, parse, loaders}, options, context);\n\n  return await parseWithLoaderInBatches(loader, data, options, context);\n}\n\n/**\n * Loader has beens selected and context has been prepared, see if we need to emit a metadata batch\n */\nasync function parseWithLoaderInBatches(loader, data, options, context) {\n  const outputIterator = await parseToOutputIterator(loader, data, options, context);\n\n  // Generate metadata batch if requested\n  if (!options.metadata) {\n    return outputIterator;\n  }\n\n  const metadataBatch = {\n    batchType: 'metadata',\n    metadata: {\n      _loader: loader,\n      _context: context\n    },\n    // Populate with some default fields to avoid crashing\n    data: [],\n    bytesUsed: 0\n  };\n\n  async function* makeMetadataBatchIterator(iterator) {\n    yield metadataBatch;\n    yield* iterator;\n  }\n\n  return makeMetadataBatchIterator(outputIterator);\n}\n\n/**\n * Prep work is done, now it is time to start parsing into an output operator\n * The approach depends on which parse function the loader exposes\n * `parseInBatches` (preferred), `parseStreamInBatches` (limited), `parse` (fallback)\n */\nasync function parseToOutputIterator(loader, data, options, context) {\n  if (loader.parseInBatches) {\n    const inputIterator = await getAsyncIteratorFromData(data);\n\n    const iteratorChain = applyInputTransforms(inputIterator, options);\n\n    return await loader.parseInBatches(iteratorChain, options, context, loader);\n  }\n\n  if (loader.parseStreamInBatches) {\n    const stream = await getReadableStream(data);\n    if (stream) {\n      if (options.transforms) {\n        // eslint-disable-next-line\n        console.warn(\n          'options.transforms not implemented for loaders that use `parseStreamInBatches`'\n        );\n      }\n      return loader.parseStreamInBatches(stream, options, context);\n    }\n  }\n\n  // Fallback: load atomically using `parse` concatenating input iterator into single chunk\n  async function* parseChunkInBatches() {\n    const inputIterator = await getAsyncIteratorFromData(data);\n    const arrayBuffer = await concatenateChunksAsync(inputIterator);\n    // yield a single batch, the output from loader.parse()\n    yield loader.parse(arrayBuffer, options, context, loader);\n  }\n\n  return await parseChunkInBatches();\n}\n\n/**\n * Create an iterator chain with any transform iterators (crypto, decompression)\n * @param inputIterator\n * @param options\n */\nfunction applyInputTransforms(inputIterator, options) {\n  let iteratorChain = inputIterator;\n  for (const Transform of options.transforms || []) {\n    // @ts-ignore\n    iteratorChain = makeTransformIterator(iteratorChain, Transform, options);\n  }\n  return iteratorChain;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAQA,MAAR,QAAqB,0BAArB;AACA,SAAQC,sBAAR,EAAgCC,qBAAhC,QAA4D,0BAA5D;AACA,SAAQC,cAAR,QAA6B,kCAA7B;AACA,SAAQC,gBAAR,QAA+B,8BAA/B;AACA,SAAQC,gBAAR,QAA+B,+BAA/B;AACA,SAAQC,wBAAR,EAAkCC,iBAAlC,QAA0D,0BAA1D;AACA,SAAQC,qBAAR,QAAoC,yBAApC;AACA,SAAQC,YAAR,QAA2B,iBAA3B;AAGA,SAAQC,KAAR,QAAoB,SAApB;AAEA,gBAAsBC,cAAtBA,CAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,eAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;;+DAAO,SAAAC,QAA8BC,IAA9B,EAAoCC,OAApC,EAA6CC,OAA7C,EAAsDC,OAAtD;IAAA,IAAAC,qBAAA,EAAAC,GAAA,EAAAC,MAAA;IAAA,OAAAC,mBAAA,CAAAC,IAAA,UAAAC,SAAAC,QAAA;MAAA;QAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;UAAA;YACLhC,MAAM,CAAC,CAACuB,OAAD,IAAY,OAAOA,OAAP,KAAmB,QAAhC,EAA0C,4CAA1C,CAAN;YAGA,IAAI,CAACU,KAAK,CAACC,OAAN,CAAcb,OAAd,CAAD,IAA2B,CAAClB,cAAc,CAACkB,OAAD,CAA9C,EAAyD;cACvDE,OAAO,GAAGD,OAAV;cACAA,OAAO,GAAGD,OAAV;cACAA,OAAO,GAAG,IAAV;YACD;YARIS,QAAA,CAAAE,IAAA;YAAA,OAUQZ,IAVR;UAAA;YAULA,IAVK,GAAAU,QAAA,CAAAK,IAAA;YAWLb,OAAO,GAAGA,OAAO,IAAI,EAArB;YAXKE,qBAAA,GAcShB,qBAAqB,CAACY,IAAD,CAd9B,EAcEK,GAdF,GAAAD,qBAAA,CAcEC,GAdF;YAAAK,QAAA,CAAAE,IAAA;YAAA,OAkBgBvB,YAAY,CAACW,IAAD,EAAOC,OAAP,EAAgBC,OAAhB,CAlB5B;UAAA;YAkBCI,MAlBD,GAAAI,QAAA,CAAAK,IAAA;YAAA,IAoBAT,MApBA;cAAAI,QAAA,CAAAE,IAAA;cAAA;YAAA;YAAA,OAAAF,QAAA,CAAAM,MAAA,WAqBI,IArBJ;UAAA;YAyBLd,OAAO,GAAGlB,gBAAgB,CAACkB,OAAD,EAAUI,MAAV,EAAkBL,OAAlB,EAA2BI,GAA3B,CAA1B;YACAF,OAAO,GAAGlB,gBAAgB,CAAC;cAACoB,GAAG,EAAHA,GAAD;cAAMd,cAAc,EAAdA,cAAN;cAAsBD,KAAK,EAALA,KAAtB;cAA6BW,OAAO,EAAPA;YAA7B,CAAD,EAAwCC,OAAxC,EAAiDC,OAAjD,CAA1B;YA1BKO,QAAA,CAAAE,IAAA;YAAA,OA4BQK,wBAAwB,CAACX,MAAD,EAASN,IAAT,EAAeE,OAAf,EAAwBC,OAAxB,CA5BhC;UAAA;YAAA,OAAAO,QAAA,CAAAM,MAAA,WAAAN,QAAA,CAAAK,IAAA;UAAA;UAAA;YAAA,OAAAL,QAAA,CAAAQ,IAAA;QAAA;MAAA;IAAA,GAAAnB,OAAA;EAAA,C;;;SAkCQkB,wB;;;;yEAAf,SAAAE,SAAwCb,MAAxC,EAAgDN,IAAhD,EAAsDE,OAAtD,EAA+DC,OAA/D;IAAA,IAAAiB,cAAA,EAAAC,aAAA,EAmBkBC,yBAnBlB,EAAAC,0BAAA;IAAA,OAAAhB,mBAAA,CAAAC,IAAA,UAAAgB,UAAAC,SAAA;MAAA;QAAA,QAAAA,SAAA,CAAAd,IAAA,GAAAc,SAAA,CAAAb,IAAA;UAAA;YAAAW,0BAAA,YAAAG,uBAAA;cAAAH,0BAAA,GAAAI,mBAAA,CAAApB,mBAAA,CAAAqB,IAAA,CAmBE,SAAAC,SAA0CC,QAA1C;gBAAA,OAAAvB,mBAAA,CAAAC,IAAA,UAAAuB,UAAAC,SAAA;kBAAA;oBAAA,QAAAA,SAAA,CAAArB,IAAA,GAAAqB,SAAA,CAAApB,IAAA;sBAAA;wBAAAoB,SAAA,CAAApB,IAAA;wBACE,OAAMS,aAAN;sBADF;wBAEE,OAAAW,SAAA,CAAAC,aAAA,CAAAC,uBAAA,CAAAC,cAAA,CAAOL,QAAP,GAAAM,oBAAA;sBAFF;sBAAA;wBAAA,OAAAJ,SAAA,CAAAd,IAAA;oBAAA;kBAAA;gBAAA,GAAAW,QAAA;cAAA,CAnBF;cAAA,OAAAN,0BAAA,CAAA1B,KAAA,OAAAC,SAAA;YAAA;YAmBkBwB,yBAnBlB,YAAAe,sBAAAC,EAAA;cAAA,OAAAf,0BAAA,CAAA1B,KAAA,OAAAC,SAAA;YAAA;YAAA2B,SAAA,CAAAb,IAAA;YAAA,OAC+B2B,qBAAqB,CAACjC,MAAD,EAASN,IAAT,EAAeE,OAAf,EAAwBC,OAAxB,CADpD;UAAA;YACQiB,cADR,GAAAK,SAAA,CAAAV,IAAA;YAAA,IAIOb,OAAO,CAACsC,QAJf;cAAAf,SAAA,CAAAb,IAAA;cAAA;YAAA;YAAA,OAAAa,SAAA,CAAAT,MAAA,WAKWI,cALX;UAAA;YAQQC,aARR,GAQwB;cACpBoB,SAAS,EAAE,UADS;cAEpBD,QAAQ,EAAE;gBACRE,OAAO,EAAEpC,MADD;gBAERI,QAAQ,EAAEP;cAFF,CAFU;cAOpBH,IAAI,EAAE,EAPc;cAQpB2C,SAAS,EAAE;YARS,CARxB;YAAA,OAAAlB,SAAA,CAAAT,MAAA,WAwBSM,yBAAyB,CAACF,cAAD,CAxBlC;UAAA;UAAA;YAAA,OAAAK,SAAA,CAAAP,IAAA;QAAA;MAAA;IAAA,GAAAC,QAAA;EAAA,C;;;SAgCeoB,qB;;;;sEAAf,SAAAK,SAAqCtC,MAArC,EAA6CN,IAA7C,EAAmDE,OAAnD,EAA4DC,OAA5D;IAAA,IAAA0C,aAAA,EAAAC,aAAA,EAAAC,MAAA,EAuBkBC,mBAvBlB,EAAAC,oBAAA;IAAA,OAAA1C,mBAAA,CAAAC,IAAA,UAAA0C,UAAAC,SAAA;MAAA;QAAA,QAAAA,SAAA,CAAAxC,IAAA,GAAAwC,SAAA,CAAAvC,IAAA;UAAA;YAAAqC,oBAAA,YAAAG,sBAAA;cAAAH,oBAAA,GAAAtB,mBAAA,CAAApB,mBAAA,CAAAqB,IAAA,CAuBE,SAAAyB,SAAA;gBAAA,IAAAR,aAAA,EAAAS,WAAA;gBAAA,OAAA/C,mBAAA,CAAAC,IAAA,UAAA+C,UAAAC,SAAA;kBAAA;oBAAA,QAAAA,SAAA,CAAA7C,IAAA,GAAA6C,SAAA,CAAA5C,IAAA;sBAAA;wBAAA4C,SAAA,CAAA5C,IAAA;wBAAA,OAAAwB,oBAAA,CAC8BlD,wBAAwB,CAACc,IAAD,CADtD;sBAAA;wBACQ6C,aADR,GAAAW,SAAA,CAAAzC,IAAA;wBAAAyC,SAAA,CAAA5C,IAAA;wBAAA,OAAAwB,oBAAA,CAE4BvD,sBAAsB,CAACgE,aAAD,CAFlD;sBAAA;wBAEQS,WAFR,GAAAE,SAAA,CAAAzC,IAAA;wBAAAyC,SAAA,CAAA5C,IAAA;wBAIE,OAAMN,MAAM,CAAChB,KAAP,CAAagE,WAAb,EAA0BpD,OAA1B,EAAmCC,OAAnC,EAA4CG,MAA5C,CAAN;sBAJF;sBAAA;wBAAA,OAAAkD,SAAA,CAAAtC,IAAA;oBAAA;kBAAA;gBAAA,GAAAmC,QAAA;cAAA,CAvBF;cAAA,OAAAJ,oBAAA,CAAApD,KAAA,OAAAC,SAAA;YAAA;YAuBkBkD,mBAvBlB,YAAAS,sBAAA;cAAA,OAAAR,oBAAA,CAAApD,KAAA,OAAAC,SAAA;YAAA;YAAA,KACMQ,MAAM,CAACf,cADb;cAAA4D,SAAA,CAAAvC,IAAA;cAAA;YAAA;YAAAuC,SAAA,CAAAvC,IAAA;YAAA,OAEgC1B,wBAAwB,CAACc,IAAD,CAFxD;UAAA;YAEU6C,aAFV,GAAAM,SAAA,CAAApC,IAAA;YAIU+B,aAJV,GAI0BY,oBAAoB,CAACb,aAAD,EAAgB3C,OAAhB,CAJ9C;YAAAiD,SAAA,CAAAvC,IAAA;YAAA,OAMiBN,MAAM,CAACf,cAAP,CAAsBuD,aAAtB,EAAqC5C,OAArC,EAA8CC,OAA9C,EAAuDG,MAAvD,CANjB;UAAA;YAAA,OAAA6C,SAAA,CAAAnC,MAAA,WAAAmC,SAAA,CAAApC,IAAA;UAAA;YAAA,KASMT,MAAM,CAACqD,oBATb;cAAAR,SAAA,CAAAvC,IAAA;cAAA;YAAA;YAAAuC,SAAA,CAAAvC,IAAA;YAAA,OAUyBzB,iBAAiB,CAACa,IAAD,CAV1C;UAAA;YAUU+C,MAVV,GAAAI,SAAA,CAAApC,IAAA;YAAA,KAWQgC,MAXR;cAAAI,SAAA,CAAAvC,IAAA;cAAA;YAAA;YAYM,IAAIV,OAAO,CAAC0D,UAAZ,EAAwB;cAEtBC,OAAO,CAACC,IAAR,CACE,gFADF;YAGD;YAjBP,OAAAX,SAAA,CAAAnC,MAAA,WAkBaV,MAAM,CAACqD,oBAAP,CAA4BZ,MAA5B,EAAoC7C,OAApC,EAA6CC,OAA7C,CAlBb;UAAA;YAAAgD,SAAA,CAAAvC,IAAA;YAAA,OA8BeoC,mBAAmB,EA9BlC;UAAA;YAAA,OAAAG,SAAA,CAAAnC,MAAA,WAAAmC,SAAA,CAAApC,IAAA;UAAA;UAAA;YAAA,OAAAoC,SAAA,CAAAjC,IAAA;QAAA;MAAA;IAAA,GAAA0B,QAAA;EAAA,C;;;AAsCA,SAASc,oBAATA,CAA8Bb,aAA9B,EAA6C3C,OAA7C,EAAsD;EACpD,IAAI4C,aAAa,GAAGD,aAApB;EADoD,IAAAkB,SAAA,GAAAC,0BAAA,CAE5B9D,OAAO,CAAC0D,UAAR,IAAsB,EAFM;IAAAK,KAAA;EAAA;IAEpD,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAkD;MAAA,IAAvCC,SAAuC,GAAAJ,KAAA,CAAAK,KAAA;MAEhDxB,aAAa,GAAGhE,qBAAqB,CAACgE,aAAD,EAAgBuB,SAAhB,EAA2BnE,OAA3B,CAArC;IACD;EALmD,SAAAqE,GAAA;IAAAR,SAAA,CAAAS,CAAA,CAAAD,GAAA;EAAA;IAAAR,SAAA,CAAAU,CAAA;EAAA;EAMpD,OAAO3B,aAAP;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}