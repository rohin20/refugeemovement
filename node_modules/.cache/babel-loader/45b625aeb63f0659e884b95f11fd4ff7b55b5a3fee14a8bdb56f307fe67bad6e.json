{"ast":null,"code":"import Buffer from './buffer';\nimport Framebuffer from './framebuffer';\nimport Texture from './texture';\nimport { assertWebGL2Context, withParameters, log } from '@luma.gl/gltools';\nimport { flipRows, scalePixels } from '../webgl-utils/typed-array-utils';\nimport { getTypedArrayFromGLType, getGLTypeFromTypedArray } from '../webgl-utils/typed-array-utils';\nimport { glFormatToComponents, glTypeToBytes } from '../webgl-utils/format-utils';\nimport { toFramebuffer } from '../webgl-utils/texture-utils';\nimport { assert } from '../utils/assert';\nexport function readPixelsToArray(source) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$sourceX = options.sourceX,\n    sourceX = _options$sourceX === void 0 ? 0 : _options$sourceX,\n    _options$sourceY = options.sourceY,\n    sourceY = _options$sourceY === void 0 ? 0 : _options$sourceY,\n    _options$sourceFormat = options.sourceFormat,\n    sourceFormat = _options$sourceFormat === void 0 ? 6408 : _options$sourceFormat;\n  var _options$sourceAttach = options.sourceAttachment,\n    sourceAttachment = _options$sourceAttach === void 0 ? 36064 : _options$sourceAttach,\n    _options$target = options.target,\n    target = _options$target === void 0 ? null : _options$target,\n    sourceWidth = options.sourceWidth,\n    sourceHeight = options.sourceHeight,\n    sourceType = options.sourceType;\n  var _getFramebuffer = getFramebuffer(source),\n    framebuffer = _getFramebuffer.framebuffer,\n    deleteFramebuffer = _getFramebuffer.deleteFramebuffer;\n  assert(framebuffer);\n  var gl = framebuffer.gl,\n    handle = framebuffer.handle,\n    attachments = framebuffer.attachments;\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n  if (sourceAttachment === 36064 && handle === null) {\n    sourceAttachment = 1028;\n  }\n  assert(attachments[sourceAttachment]);\n  sourceType = sourceType || attachments[sourceAttachment].type;\n  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);\n  sourceType = sourceType || getGLTypeFromTypedArray(target);\n  var prevHandle = gl.bindFramebuffer(36160, handle);\n  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);\n  gl.bindFramebuffer(36160, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return target;\n}\nexport function readPixelsToBuffer(source, _ref) {\n  var _ref$sourceX = _ref.sourceX,\n    sourceX = _ref$sourceX === void 0 ? 0 : _ref$sourceX,\n    _ref$sourceY = _ref.sourceY,\n    sourceY = _ref$sourceY === void 0 ? 0 : _ref$sourceY,\n    _ref$sourceFormat = _ref.sourceFormat,\n    sourceFormat = _ref$sourceFormat === void 0 ? 6408 : _ref$sourceFormat,\n    _ref$target = _ref.target,\n    target = _ref$target === void 0 ? null : _ref$target,\n    _ref$targetByteOffset = _ref.targetByteOffset,\n    targetByteOffset = _ref$targetByteOffset === void 0 ? 0 : _ref$targetByteOffset,\n    sourceWidth = _ref.sourceWidth,\n    sourceHeight = _ref.sourceHeight,\n    sourceType = _ref.sourceType;\n  var _getFramebuffer2 = getFramebuffer(source),\n    framebuffer = _getFramebuffer2.framebuffer,\n    deleteFramebuffer = _getFramebuffer2.deleteFramebuffer;\n  assert(framebuffer);\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n  var gl2 = assertWebGL2Context(framebuffer.gl);\n  sourceType = sourceType || (target ? target.type : 5121);\n  if (!target) {\n    var components = glFormatToComponents(sourceFormat);\n    var byteCount = glTypeToBytes(sourceType);\n    var byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;\n    target = new Buffer(gl2, {\n      byteLength: byteLength,\n      accessor: {\n        type: sourceType,\n        size: components\n      }\n    });\n  }\n  target.bind({\n    target: 35051\n  });\n  withParameters(gl2, {\n    framebuffer: framebuffer\n  }, function () {\n    gl2.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);\n  });\n  target.unbind({\n    target: 35051\n  });\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return target;\n}\nexport function copyToDataUrl(source) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref2$sourceAttachmen = _ref2.sourceAttachment,\n    sourceAttachment = _ref2$sourceAttachmen === void 0 ? 36064 : _ref2$sourceAttachmen,\n    _ref2$targetMaxHeight = _ref2.targetMaxHeight,\n    targetMaxHeight = _ref2$targetMaxHeight === void 0 ? Number.MAX_SAFE_INTEGER : _ref2$targetMaxHeight;\n  var data = readPixelsToArray(source, {\n    sourceAttachment: sourceAttachment\n  });\n  var width = source.width,\n    height = source.height;\n  while (height > targetMaxHeight) {\n    var _scalePixels = scalePixels({\n      data: data,\n      width: width,\n      height: height\n    });\n    data = _scalePixels.data;\n    width = _scalePixels.width;\n    height = _scalePixels.height;\n  }\n  flipRows({\n    data: data,\n    width: width,\n    height: height\n  });\n  var canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  var context = canvas.getContext('2d');\n  var imageData = context.createImageData(width, height);\n  imageData.data.set(data);\n  context.putImageData(imageData, 0, 0);\n  return canvas.toDataURL();\n}\nexport function copyToImage(source) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref3$sourceAttachmen = _ref3.sourceAttachment,\n    sourceAttachment = _ref3$sourceAttachmen === void 0 ? 36064 : _ref3$sourceAttachmen,\n    _ref3$targetImage = _ref3.targetImage,\n    targetImage = _ref3$targetImage === void 0 ? null : _ref3$targetImage;\n  var dataUrl = copyToDataUrl(source, {\n    sourceAttachment: sourceAttachment\n  });\n  targetImage = targetImage || new Image();\n  targetImage.src = dataUrl;\n  return targetImage;\n}\nexport function copyToTexture(source, target) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$sourceX2 = options.sourceX,\n    sourceX = _options$sourceX2 === void 0 ? 0 : _options$sourceX2,\n    _options$sourceY2 = options.sourceY,\n    sourceY = _options$sourceY2 === void 0 ? 0 : _options$sourceY2,\n    _options$targetMipmap = options.targetMipmaplevel,\n    targetMipmaplevel = _options$targetMipmap === void 0 ? 0 : _options$targetMipmap,\n    _options$targetIntern = options.targetInternalFormat,\n    targetInternalFormat = _options$targetIntern === void 0 ? 6408 : _options$targetIntern;\n  var targetX = options.targetX,\n    targetY = options.targetY,\n    targetZ = options.targetZ,\n    width = options.width,\n    height = options.height;\n  var _getFramebuffer3 = getFramebuffer(source),\n    framebuffer = _getFramebuffer3.framebuffer,\n    deleteFramebuffer = _getFramebuffer3.deleteFramebuffer;\n  assert(framebuffer);\n  var gl = framebuffer.gl,\n    handle = framebuffer.handle;\n  var isSubCopy = typeof targetX !== 'undefined' || typeof targetY !== 'undefined' || typeof targetZ !== 'undefined';\n  targetX = targetX || 0;\n  targetY = targetY || 0;\n  targetZ = targetZ || 0;\n  var prevHandle = gl.bindFramebuffer(36160, handle);\n  assert(target);\n  var texture = null;\n  if (target instanceof Texture) {\n    texture = target;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    target = texture.target;\n  }\n  if (!isSubCopy) {\n    gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);\n  } else {\n    switch (target) {\n      case 3553:\n      case 34067:\n        gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);\n        break;\n      case 35866:\n      case 32879:\n        var gl2 = assertWebGL2Context(gl);\n        gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);\n        break;\n      default:\n    }\n  }\n  if (texture) {\n    texture.unbind();\n  }\n  gl.bindFramebuffer(36160, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return texture;\n}\nexport function blit(source, target) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$sourceX3 = options.sourceX0,\n    sourceX0 = _options$sourceX3 === void 0 ? 0 : _options$sourceX3,\n    _options$sourceY3 = options.sourceY0,\n    sourceY0 = _options$sourceY3 === void 0 ? 0 : _options$sourceY3,\n    _options$targetX = options.targetX0,\n    targetX0 = _options$targetX === void 0 ? 0 : _options$targetX,\n    _options$targetY = options.targetY0,\n    targetY0 = _options$targetY === void 0 ? 0 : _options$targetY,\n    _options$color = options.color,\n    color = _options$color === void 0 ? true : _options$color,\n    _options$depth = options.depth,\n    depth = _options$depth === void 0 ? false : _options$depth,\n    _options$stencil = options.stencil,\n    stencil = _options$stencil === void 0 ? false : _options$stencil,\n    _options$filter = options.filter,\n    filter = _options$filter === void 0 ? 9728 : _options$filter;\n  var sourceX1 = options.sourceX1,\n    sourceY1 = options.sourceY1,\n    targetX1 = options.targetX1,\n    targetY1 = options.targetY1,\n    _options$sourceAttach2 = options.sourceAttachment,\n    sourceAttachment = _options$sourceAttach2 === void 0 ? 36064 : _options$sourceAttach2,\n    _options$mask = options.mask,\n    mask = _options$mask === void 0 ? 0 : _options$mask;\n  var _getFramebuffer4 = getFramebuffer(source),\n    srcFramebuffer = _getFramebuffer4.framebuffer,\n    deleteSrcFramebuffer = _getFramebuffer4.deleteFramebuffer;\n  var _getFramebuffer5 = getFramebuffer(target),\n    dstFramebuffer = _getFramebuffer5.framebuffer,\n    deleteDstFramebuffer = _getFramebuffer5.deleteFramebuffer;\n  assert(srcFramebuffer);\n  assert(dstFramebuffer);\n  var gl = dstFramebuffer.gl,\n    handle = dstFramebuffer.handle,\n    width = dstFramebuffer.width,\n    height = dstFramebuffer.height,\n    readBuffer = dstFramebuffer.readBuffer;\n  var gl2 = assertWebGL2Context(gl);\n  if (!srcFramebuffer.handle && sourceAttachment === 36064) {\n    sourceAttachment = 1028;\n  }\n  if (color) {\n    mask |= 16384;\n  }\n  if (depth) {\n    mask |= 256;\n  }\n  if (stencil) {\n    mask |= 1024;\n  }\n  if (deleteSrcFramebuffer || deleteDstFramebuffer) {\n    if (mask & (256 | 1024)) {\n      mask = 16384;\n      log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();\n    }\n  }\n  assert(mask);\n  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;\n  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;\n  targetX1 = targetX1 === undefined ? width : targetX1;\n  targetY1 = targetY1 === undefined ? height : targetY1;\n  var prevDrawHandle = gl.bindFramebuffer(36009, handle);\n  var prevReadHandle = gl.bindFramebuffer(36008, srcFramebuffer.handle);\n  gl2.readBuffer(sourceAttachment);\n  gl2.blitFramebuffer(sourceX0, sourceY0, sourceX1, sourceY1, targetX0, targetY0, targetX1, targetY1, mask, filter);\n  gl2.readBuffer(readBuffer);\n  gl2.bindFramebuffer(36008, prevReadHandle || null);\n  gl2.bindFramebuffer(36009, prevDrawHandle || null);\n  if (deleteSrcFramebuffer) {\n    srcFramebuffer.delete();\n  }\n  if (deleteDstFramebuffer) {\n    dstFramebuffer.delete();\n  }\n  return dstFramebuffer;\n}\nfunction getFramebuffer(source) {\n  if (!(source instanceof Framebuffer)) {\n    return {\n      framebuffer: toFramebuffer(source),\n      deleteFramebuffer: true\n    };\n  }\n  return {\n    framebuffer: source,\n    deleteFramebuffer: false\n  };\n}\nfunction getPixelArray(pixelArray, type, format, width, height) {\n  if (pixelArray) {\n    return pixelArray;\n  }\n  type = type || 5121;\n  var ArrayType = getTypedArrayFromGLType(type, {\n    clamped: false\n  });\n  var components = glFormatToComponents(format);\n  return new ArrayType(width * height * components);\n}","map":{"version":3,"names":["Buffer","Framebuffer","Texture","assertWebGL2Context","withParameters","log","flipRows","scalePixels","getTypedArrayFromGLType","getGLTypeFromTypedArray","glFormatToComponents","glTypeToBytes","toFramebuffer","assert","readPixelsToArray","source","options","arguments","length","undefined","_options$sourceX","sourceX","_options$sourceY","sourceY","_options$sourceFormat","sourceFormat","_options$sourceAttach","sourceAttachment","_options$target","target","sourceWidth","sourceHeight","sourceType","_getFramebuffer","getFramebuffer","framebuffer","deleteFramebuffer","gl","handle","attachments","width","height","type","getPixelArray","prevHandle","bindFramebuffer","readPixels","delete","readPixelsToBuffer","_ref","_ref$sourceX","_ref$sourceY","_ref$sourceFormat","_ref$target","_ref$targetByteOffset","targetByteOffset","_getFramebuffer2","gl2","components","byteCount","byteLength","accessor","size","bind","unbind","copyToDataUrl","_ref2","_ref2$sourceAttachmen","_ref2$targetMaxHeight","targetMaxHeight","Number","MAX_SAFE_INTEGER","data","_scalePixels","canvas","document","createElement","context","getContext","imageData","createImageData","set","putImageData","toDataURL","copyToImage","_ref3","_ref3$sourceAttachmen","_ref3$targetImage","targetImage","dataUrl","Image","src","copyToTexture","_options$sourceX2","_options$sourceY2","_options$targetMipmap","targetMipmaplevel","_options$targetIntern","targetInternalFormat","targetX","targetY","targetZ","_getFramebuffer3","isSubCopy","texture","isFinite","copyTexImage2D","copyTexSubImage2D","copyTexSubImage3D","blit","_options$sourceX3","sourceX0","_options$sourceY3","sourceY0","_options$targetX","targetX0","_options$targetY","targetY0","_options$color","color","_options$depth","depth","_options$stencil","stencil","_options$filter","filter","sourceX1","sourceY1","targetX1","targetY1","_options$sourceAttach2","_options$mask","mask","_getFramebuffer4","srcFramebuffer","deleteSrcFramebuffer","_getFramebuffer5","dstFramebuffer","deleteDstFramebuffer","readBuffer","warn","prevDrawHandle","prevReadHandle","blitFramebuffer","pixelArray","format","ArrayType","clamped"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@luma.gl/webgl/src/classes/copy-and-blit.js"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport Buffer from './buffer';\nimport Framebuffer from './framebuffer';\nimport Texture from './texture';\nimport {assertWebGL2Context, withParameters, log} from '@luma.gl/gltools';\nimport {flipRows, scalePixels} from '../webgl-utils/typed-array-utils';\nimport {getTypedArrayFromGLType, getGLTypeFromTypedArray} from '../webgl-utils/typed-array-utils';\nimport {glFormatToComponents, glTypeToBytes} from '../webgl-utils/format-utils';\nimport {toFramebuffer} from '../webgl-utils/texture-utils';\nimport {assert} from '../utils/assert';\n\n// NOTE: Slow requires roundtrip to GPU\n// Copies data from a Framebuffer or a Texture object into ArrayBuffer object.\n// App can provide targetPixelArray or have it auto allocated by this method\n// @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,\n//  newly allocated by this method unless provided by app.\nexport function readPixelsToArray(source, options = {}) {\n  const {sourceX = 0, sourceY = 0, sourceFormat = GL.RGBA} = options;\n  let {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    target = null,\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  } = options;\n\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const {gl, handle, attachments} = framebuffer;\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // TODO - Set and unset gl.readBuffer\n  if (sourceAttachment === GL.COLOR_ATTACHMENT0 && handle === null) {\n    sourceAttachment = GL.FRONT;\n  }\n\n  assert(attachments[sourceAttachment]);\n\n  // Deduce the type from color attachment if not provided.\n  sourceType = sourceType || attachments[sourceAttachment].type;\n\n  // Deduce type and allocated pixelArray if needed\n  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);\n\n  // Pixel array available, if necessary, deduce type from it.\n  sourceType = sourceType || getGLTypeFromTypedArray(target);\n\n  const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);\n  // @ts-ignore\n  gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return target;\n}\n\n// NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.\n// Copies data from a Framebuffer or a Texture object into a Buffer object.\nexport function readPixelsToBuffer(\n  source,\n  {\n    sourceX = 0,\n    sourceY = 0,\n    sourceFormat = GL.RGBA,\n    target = null, // A new Buffer object is created when not provided.\n    targetByteOffset = 0, // byte offset in buffer object\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  }\n) {\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // Asynchronus read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n  const gl2 = assertWebGL2Context(framebuffer.gl);\n\n  // deduce type if not available.\n  sourceType = sourceType || (target ? target.type : GL.UNSIGNED_BYTE);\n\n  if (!target) {\n    // Create new buffer with enough size\n    const components = glFormatToComponents(sourceFormat);\n    const byteCount = glTypeToBytes(sourceType);\n    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;\n    target = new Buffer(gl2, {byteLength, accessor: {type: sourceType, size: components}});\n  }\n\n  target.bind({target: GL.PIXEL_PACK_BUFFER});\n  withParameters(gl2, {framebuffer}, () => {\n    gl2.readPixels(\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      sourceFormat,\n      sourceType,\n      targetByteOffset\n    );\n  });\n  target.unbind({target: GL.PIXEL_PACK_BUFFER});\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n\n  return target;\n}\n\n// Reads pixels from a Framebuffer or Texture object to a dataUrl\nexport function copyToDataUrl(\n  source,\n  {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMaxHeight = Number.MAX_SAFE_INTEGER\n  } = {}\n) {\n  let data = readPixelsToArray(source, {sourceAttachment});\n\n  // Scale down\n  let {width, height} = source;\n  while (height > targetMaxHeight) {\n    ({data, width, height} = scalePixels({data, width, height}));\n  }\n\n  // Flip to top down coordinate system\n  flipRows({data, width, height});\n\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d');\n\n  // Copy the pixels to a 2D canvas\n  const imageData = context.createImageData(width, height);\n  imageData.data.set(data);\n  context.putImageData(imageData, 0, 0);\n\n  return canvas.toDataURL();\n}\n\n// Reads pixels from a Framebuffer or Texture object into an HTML Image\nexport function copyToImage(\n  source,\n  {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetImage = null\n  } = {}\n) {\n  const dataUrl = copyToDataUrl(source, {sourceAttachment});\n  targetImage = targetImage || new Image();\n  targetImage.src = dataUrl;\n  return targetImage;\n}\n\n// Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)\n// eslint-disable-next-line complexity, max-statements\nexport function copyToTexture(source, target, options = {}) {\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    // attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMipmaplevel = 0,\n    targetInternalFormat = GL.RGBA\n  } = options;\n  let {\n    targetX,\n    targetY,\n    targetZ,\n    width, // defaults to target width\n    height // defaults to target height\n  } = options;\n\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const {gl, handle} = framebuffer;\n  const isSubCopy =\n    typeof targetX !== 'undefined' ||\n    typeof targetY !== 'undefined' ||\n    typeof targetZ !== 'undefined';\n  targetX = targetX || 0;\n  targetY = targetY || 0;\n  targetZ = targetZ || 0;\n  const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  // TODO - support gl.readBuffer (WebGL2 only)\n  // const prevBuffer = gl.readBuffer(attachment);\n  assert(target);\n  let texture = null;\n  if (target instanceof Texture) {\n    texture = target;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    target = texture.target;\n  }\n\n  if (!isSubCopy) {\n    gl.copyTexImage2D(\n      target,\n      targetMipmaplevel,\n      targetInternalFormat,\n      sourceX,\n      sourceY,\n      width,\n      height,\n      0 /* border must be 0 */\n    );\n  } else {\n    switch (target) {\n      case GL.TEXTURE_2D:\n      case GL.TEXTURE_CUBE_MAP:\n        gl.copyTexSubImage2D(\n          target,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      case GL.TEXTURE_2D_ARRAY:\n      case GL.TEXTURE_3D:\n        const gl2 = assertWebGL2Context(gl);\n        gl2.copyTexSubImage3D(\n          target,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          targetZ,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      default:\n    }\n  }\n  if (texture) {\n    texture.unbind();\n  }\n  // @ts-ignore\n  gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return texture;\n}\n\n// NOTE: WEBLG2 only\n// Copies a rectangle of pixels between Framebuffer or Texture objects\n// eslint-disable-next-line max-statements, complexity\nexport function blit(source, target, options = {}) {\n  const {\n    sourceX0 = 0,\n    sourceY0 = 0,\n    targetX0 = 0,\n    targetY0 = 0,\n    color = true,\n    depth = false,\n    stencil = false,\n    filter = GL.NEAREST\n  } = options;\n\n  let {\n    sourceX1,\n    sourceY1,\n    targetX1,\n    targetY1,\n    sourceAttachment = GL.COLOR_ATTACHMENT0,\n    mask = 0\n  } = options;\n\n  const {framebuffer: srcFramebuffer, deleteFramebuffer: deleteSrcFramebuffer} = getFramebuffer(\n    source\n  );\n  const {framebuffer: dstFramebuffer, deleteFramebuffer: deleteDstFramebuffer} = getFramebuffer(\n    target\n  );\n\n  assert(srcFramebuffer);\n  assert(dstFramebuffer);\n  // @ts-ignore\n  const {gl, handle, width, height, readBuffer} = dstFramebuffer;\n  const gl2 = assertWebGL2Context(gl);\n\n  if (!srcFramebuffer.handle && sourceAttachment === GL.COLOR_ATTACHMENT0) {\n    sourceAttachment = GL.FRONT;\n  }\n\n  if (color) {\n    mask |= GL.COLOR_BUFFER_BIT;\n  }\n  if (depth) {\n    mask |= GL.DEPTH_BUFFER_BIT;\n  }\n  if (stencil) {\n    mask |= GL.STENCIL_BUFFER_BIT;\n  }\n\n  if (deleteSrcFramebuffer || deleteDstFramebuffer) {\n    // Either source or destiantion was a texture object, which is wrapped in a Framebuffer objecgt as color attachment.\n    // Overwrite the mask to `COLOR_BUFFER_BIT`\n    if (mask & (GL.DEPTH_BUFFER_BIT | GL.STENCIL_BUFFER_BIT)) {\n      mask = GL.COLOR_BUFFER_BIT;\n      log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();\n    }\n  }\n  assert(mask);\n\n  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;\n  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;\n  targetX1 = targetX1 === undefined ? width : targetX1;\n  targetY1 = targetY1 === undefined ? height : targetY1;\n\n  const prevDrawHandle = gl.bindFramebuffer(GL.DRAW_FRAMEBUFFER, handle);\n  const prevReadHandle = gl.bindFramebuffer(GL.READ_FRAMEBUFFER, srcFramebuffer.handle);\n  gl2.readBuffer(sourceAttachment);\n  gl2.blitFramebuffer(\n    sourceX0,\n    sourceY0,\n    sourceX1,\n    sourceY1,\n    targetX0,\n    targetY0,\n    targetX1,\n    targetY1,\n    mask,\n    filter\n  );\n  gl2.readBuffer(readBuffer);\n  // @ts-ignore\n  gl2.bindFramebuffer(GL.READ_FRAMEBUFFER, prevReadHandle || null);\n  // @ts-ignore\n  gl2.bindFramebuffer(GL.DRAW_FRAMEBUFFER, prevDrawHandle || null);\n  if (deleteSrcFramebuffer) {\n    srcFramebuffer.delete();\n  }\n  if (deleteDstFramebuffer) {\n    dstFramebuffer.delete();\n  }\n\n  return dstFramebuffer;\n}\n\n// Helper methods\n\nfunction getFramebuffer(source) {\n  if (!(source instanceof Framebuffer)) {\n    return {framebuffer: toFramebuffer(source), deleteFramebuffer: true};\n  }\n  return {framebuffer: source, deleteFramebuffer: false};\n}\n\nfunction getPixelArray(pixelArray, type, format, width, height) {\n  if (pixelArray) {\n    return pixelArray;\n  }\n  // Allocate pixel array if not already available, using supplied type\n  type = type || GL.UNSIGNED_BYTE;\n  const ArrayType = getTypedArrayFromGLType(type, {clamped: false});\n  const components = glFormatToComponents(format);\n  // TODO - check for composite type (components = 1).\n  return new ArrayType(width * height * components);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}