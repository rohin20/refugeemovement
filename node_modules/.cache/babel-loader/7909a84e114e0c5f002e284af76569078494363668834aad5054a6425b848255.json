{"ast":null,"code":"import _defineProperty2 from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { hasFeature, FEATURES, Buffer } from '@luma.gl/core';\nimport ShaderAttribute from './shader-attribute';\nimport { glArrayFromType } from './gl-utils';\nimport typedArrayManager from '../../utils/typed-array-manager';\nimport { toDoublePrecisionArray } from '../../utils/math-utils';\nimport log from '../../utils/log';\nfunction getStride(accessor) {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\nfunction resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n  var stride = getStride(baseAccessor);\n  var vertexOffset = shaderAttributeOptions.vertexOffset !== undefined ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;\n  var elementOffset = shaderAttributeOptions.elementOffset || 0;\n  var offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);\n  return _objectSpread(_objectSpread({}, shaderAttributeOptions), {}, {\n    offset: offset,\n    stride: stride\n  });\n}\nfunction resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {\n  var resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n  return {\n    high: resolvedOptions,\n    low: _objectSpread(_objectSpread({}, resolvedOptions), {}, {\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    })\n  };\n}\nvar DataColumn = /*#__PURE__*/function () {\n  function DataColumn(gl, opts, state) {\n    _classCallCheck(this, DataColumn);\n    _defineProperty(this, \"gl\", void 0);\n    _defineProperty(this, \"id\", void 0);\n    _defineProperty(this, \"size\", void 0);\n    _defineProperty(this, \"settings\", void 0);\n    _defineProperty(this, \"value\", void 0);\n    _defineProperty(this, \"doublePrecision\", void 0);\n    _defineProperty(this, \"_buffer\", void 0);\n    _defineProperty(this, \"state\", void 0);\n    this.gl = gl;\n    this.id = opts.id || '';\n    this.size = opts.size || 1;\n    var logicalType = opts.logicalType || opts.type;\n    var doublePrecision = logicalType === 5130;\n    var defaultValue = opts.defaultValue;\n    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);\n    var bufferType;\n    if (doublePrecision) {\n      bufferType = 5126;\n    } else if (!logicalType && opts.isIndexed) {\n      bufferType = gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;\n    } else {\n      bufferType = logicalType || 5126;\n    }\n    var defaultType = glArrayFromType(logicalType || bufferType || 5126);\n    this.doublePrecision = doublePrecision;\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n    this.value = null;\n    this.settings = _objectSpread(_objectSpread({}, opts), {}, {\n      defaultType: defaultType,\n      defaultValue: defaultValue,\n      logicalType: logicalType,\n      type: bufferType,\n      size: this.size,\n      bytesPerElement: defaultType.BYTES_PER_ELEMENT\n    });\n    this.state = _objectSpread(_objectSpread({}, state), {}, {\n      externalBuffer: null,\n      bufferAccessor: this.settings,\n      allocatedValue: null,\n      numInstances: 0,\n      bounds: null,\n      constant: false\n    });\n    this._buffer = null;\n  }\n  _createClass(DataColumn, [{\n    key: \"isConstant\",\n    get: function get() {\n      return this.state.constant;\n    }\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      if (!this._buffer) {\n        var _this$settings = this.settings,\n          isIndexed = _this$settings.isIndexed,\n          type = _this$settings.type;\n        this._buffer = new Buffer(this.gl, {\n          id: this.id,\n          target: isIndexed ? 34963 : 34962,\n          accessor: {\n            type: type\n          }\n        });\n      }\n      return this._buffer;\n    }\n  }, {\n    key: \"byteOffset\",\n    get: function get() {\n      var accessor = this.getAccessor();\n      if (accessor.vertexOffset) {\n        return accessor.vertexOffset * getStride(accessor);\n      }\n      return 0;\n    }\n  }, {\n    key: \"numInstances\",\n    get: function get() {\n      return this.state.numInstances;\n    },\n    set: function set(n) {\n      this.state.numInstances = n;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      if (this._buffer) {\n        this._buffer.delete();\n        this._buffer = null;\n      }\n      typedArrayManager.release(this.state.allocatedValue);\n    }\n  }, {\n    key: \"getShaderAttributes\",\n    value: function getShaderAttributes(id, options) {\n      if (this.doublePrecision) {\n        var shaderAttributes = {};\n        var isBuffer64Bit = this.value instanceof Float64Array;\n        var doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});\n        shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);\n        shaderAttributes[\"\".concat(id, \"64Low\")] = isBuffer64Bit ? new ShaderAttribute(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);\n        return shaderAttributes;\n      }\n      if (options) {\n        var shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n        return _defineProperty2({}, id, new ShaderAttribute(this, shaderAttributeDef));\n      }\n      return _defineProperty2({}, id, this);\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer() {\n      if (this.state.constant) {\n        return null;\n      }\n      return this.state.externalBuffer || this._buffer;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      if (this.state.constant) {\n        return this.value;\n      }\n      return [this.getBuffer(), this.getAccessor()];\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor() {\n      return this.state.bufferAccessor;\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds() {\n      if (this.state.bounds) {\n        return this.state.bounds;\n      }\n      var result = null;\n      if (this.state.constant && this.value) {\n        var min = Array.from(this.value);\n        result = [min, min];\n      } else {\n        var value = this.value,\n          numInstances = this.numInstances,\n          size = this.size;\n        var len = numInstances * size;\n        if (value && len && value.length >= len) {\n          var _min = new Array(size).fill(Infinity);\n          var max = new Array(size).fill(-Infinity);\n          for (var i = 0; i < len;) {\n            for (var j = 0; j < size; j++) {\n              var v = value[i++];\n              if (v < _min[j]) _min[j] = v;\n              if (v > max[j]) max[j] = v;\n            }\n          }\n          result = [_min, max];\n        }\n      }\n      this.state.bounds = result;\n      return result;\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      var state = this.state;\n      var opts;\n      if (ArrayBuffer.isView(data)) {\n        opts = {\n          value: data\n        };\n      } else if (data instanceof Buffer) {\n        opts = {\n          buffer: data\n        };\n      } else {\n        opts = data;\n      }\n      var accessor = _objectSpread(_objectSpread({}, this.settings), opts);\n      state.bufferAccessor = accessor;\n      state.bounds = null;\n      if (opts.constant) {\n        var value = opts.value;\n        value = this._normalizeValue(value, [], 0);\n        if (this.settings.normalized) {\n          value = this.normalizeConstant(value);\n        }\n        var hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n        if (!hasChanged) {\n          return false;\n        }\n        state.externalBuffer = null;\n        state.constant = true;\n        this.value = value;\n      } else if (opts.buffer) {\n        var buffer = opts.buffer;\n        state.externalBuffer = buffer;\n        state.constant = false;\n        this.value = opts.value || null;\n        var isBuffer64Bit = opts.value instanceof Float64Array;\n        accessor.type = opts.type || buffer.accessor.type;\n        accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);\n        accessor.stride = getStride(accessor);\n      } else if (opts.value) {\n        this._checkExternalBuffer(opts);\n        var _value = opts.value;\n        state.externalBuffer = null;\n        state.constant = false;\n        this.value = _value;\n        accessor.bytesPerElement = _value.BYTES_PER_ELEMENT;\n        accessor.stride = getStride(accessor);\n        var _buffer = this.buffer,\n          byteOffset = this.byteOffset;\n        if (this.doublePrecision && _value instanceof Float64Array) {\n          _value = toDoublePrecisionArray(_value, accessor);\n        }\n        var requiredBufferSize = _value.byteLength + byteOffset + accessor.stride * 2;\n        if (_buffer.byteLength < requiredBufferSize) {\n          _buffer.reallocate(requiredBufferSize);\n        }\n        _buffer.setAccessor(null);\n        _buffer.subData({\n          data: _value,\n          offset: byteOffset\n        });\n        accessor.type = opts.type || _buffer.accessor.type;\n      }\n      return true;\n    }\n  }, {\n    key: \"updateSubBuffer\",\n    value: function updateSubBuffer() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.state.bounds = null;\n      var value = this.value;\n      var _opts$startOffset = opts.startOffset,\n        startOffset = _opts$startOffset === void 0 ? 0 : _opts$startOffset,\n        endOffset = opts.endOffset;\n      this.buffer.subData({\n        data: this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {\n          size: this.size,\n          startIndex: startOffset,\n          endIndex: endOffset\n        }) : value.subarray(startOffset, endOffset),\n        offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset\n      });\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(numInstances) {\n      var copy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var state = this.state;\n      var oldValue = state.allocatedValue;\n      var value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n        size: this.size,\n        type: this.settings.defaultType,\n        copy: copy\n      });\n      this.value = value;\n      var buffer = this.buffer,\n        byteOffset = this.byteOffset;\n      if (buffer.byteLength < value.byteLength + byteOffset) {\n        buffer.reallocate(value.byteLength + byteOffset);\n        if (copy && oldValue) {\n          buffer.subData({\n            data: oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,\n            offset: byteOffset\n          });\n        }\n      }\n      state.allocatedValue = value;\n      state.constant = false;\n      state.externalBuffer = null;\n      state.bufferAccessor = this.settings;\n      return true;\n    }\n  }, {\n    key: \"_checkExternalBuffer\",\n    value: function _checkExternalBuffer(opts) {\n      var value = opts.value;\n      if (!ArrayBuffer.isView(value)) {\n        throw new Error(\"Attribute \".concat(this.id, \" value is not TypedArray\"));\n      }\n      var ArrayType = this.settings.defaultType;\n      var illegalArrayType = false;\n      if (this.doublePrecision) {\n        illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n      }\n      if (illegalArrayType) {\n        throw new Error(\"Attribute \".concat(this.id, \" does not support \").concat(value.constructor.name));\n      }\n      if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n        log.warn(\"Attribute \".concat(this.id, \" is normalized\"))();\n      }\n    }\n  }, {\n    key: \"normalizeConstant\",\n    value: function normalizeConstant(value) {\n      switch (this.settings.type) {\n        case 5120:\n          return new Float32Array(value).map(function (x) {\n            return (x + 128) / 255 * 2 - 1;\n          });\n        case 5122:\n          return new Float32Array(value).map(function (x) {\n            return (x + 32768) / 65535 * 2 - 1;\n          });\n        case 5121:\n          return new Float32Array(value).map(function (x) {\n            return x / 255;\n          });\n        case 5123:\n          return new Float32Array(value).map(function (x) {\n            return x / 65535;\n          });\n        default:\n          return value;\n      }\n    }\n  }, {\n    key: \"_normalizeValue\",\n    value: function _normalizeValue(value, out, start) {\n      var _this$settings2 = this.settings,\n        defaultValue = _this$settings2.defaultValue,\n        size = _this$settings2.size;\n      if (Number.isFinite(value)) {\n        out[start] = value;\n        return out;\n      }\n      if (!value) {\n        out[start] = defaultValue[0];\n        return out;\n      }\n      switch (size) {\n        case 4:\n          out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n        case 3:\n          out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n        case 2:\n          out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n        case 1:\n          out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n          break;\n        default:\n          var i = size;\n          while (--i >= 0) {\n            out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n          }\n      }\n      return out;\n    }\n  }, {\n    key: \"_areValuesEqual\",\n    value: function _areValuesEqual(value1, value2) {\n      if (!value1 || !value2) {\n        return false;\n      }\n      var size = this.size;\n      for (var i = 0; i < size; i++) {\n        if (value1[i] !== value2[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }]);\n  return DataColumn;\n}();\nexport { DataColumn as default };","map":{"version":3,"names":["hasFeature","FEATURES","Buffer","ShaderAttribute","glArrayFromType","typedArrayManager","toDoublePrecisionArray","log","getStride","accessor","stride","size","bytesPerElement","resolveShaderAttribute","baseAccessor","shaderAttributeOptions","offset","removed","vertexOffset","undefined","elementOffset","_objectSpread","resolveDoublePrecisionShaderAttributes","resolvedOptions","high","low","DataColumn","gl","opts","state","_classCallCheck","_defineProperty","id","logicalType","type","doublePrecision","defaultValue","Number","isFinite","Array","fill","bufferType","isIndexed","ELEMENT_INDEX_UINT32","defaultType","fp64","Float32Array","value","settings","BYTES_PER_ELEMENT","externalBuffer","bufferAccessor","allocatedValue","numInstances","bounds","constant","_buffer","_createClass","key","get","_this$settings","target","getAccessor","set","n","_delete","delete","release","getShaderAttributes","options","shaderAttributes","isBuffer64Bit","Float64Array","doubleShaderAttributeDefs","concat","shaderAttributeDef","_defineProperty2","getBuffer","getValue","getBounds","result","min","from","len","length","Infinity","max","i","j","v","setData","data","ArrayBuffer","isView","buffer","_normalizeValue","normalized","normalizeConstant","hasChanged","_areValuesEqual","_checkExternalBuffer","byteOffset","requiredBufferSize","byteLength","reallocate","setAccessor","subData","updateSubBuffer","arguments","_opts$startOffset","startOffset","endOffset","startIndex","endIndex","subarray","allocate","copy","oldValue","Error","ArrayType","illegalArrayType","constructor","name","warn","map","x","out","start","_this$settings2","value1","value2","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/core/src/lib/attribute/data-column.ts"],"sourcesContent":["/* eslint-disable complexity */\nimport GL from '@luma.gl/constants';\nimport {hasFeature, FEATURES, Buffer} from '@luma.gl/core';\nimport ShaderAttribute, {IShaderAttribute} from './shader-attribute';\nimport {glArrayFromType} from './gl-utils';\nimport typedArrayManager from '../../utils/typed-array-manager';\nimport {toDoublePrecisionArray} from '../../utils/math-utils';\nimport log from '../../utils/log';\n\nimport type {Buffer as LumaBuffer} from '@luma.gl/webgl';\nimport type {TypedArray, NumericArray, TypedArrayConstructor} from '../../types/types';\n\nexport type BufferAccessor = {\n  /** A WebGL data type, see [vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer#parameters). */\n  type?: number;\n  /** The number of elements per vertex attribute. */\n  size?: number;\n  /** 1 if instanced. */\n  divisor?: number;\n  /** Offset of the first vertex attribute into the buffer, in bytes. */\n  offset?: number;\n  /** The offset between the beginning of consecutive vertex attributes, in bytes. */\n  stride?: number;\n  /** Whether data values should be normalized. Note that all color attributes in deck.gl layers are normalized by default. */\n  normalized?: boolean;\n  integer?: boolean;\n};\n\nexport type ShaderAttributeOptions = Partial<BufferAccessor> & {\n  offset: number;\n  stride: number;\n  vertexOffset?: number;\n  elementOffset?: number;\n};\n\nfunction getStride(accessor: DataColumnSettings<any>): number {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\n\nfunction resolveShaderAttribute(\n  baseAccessor: DataColumnSettings<any>,\n  shaderAttributeOptions: Partial<ShaderAttributeOptions>\n): ShaderAttributeOptions {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n\n  // All shader attributes share the parent's stride\n  const stride = getStride(baseAccessor);\n  // `vertexOffset` is used to access the neighboring vertex's value\n  // e.g. `nextPositions` in polygon\n  const vertexOffset =\n    shaderAttributeOptions.vertexOffset !== undefined\n      ? shaderAttributeOptions.vertexOffset\n      : baseAccessor.vertexOffset || 0;\n  // `elementOffset` is defined when shader attribute's size is smaller than the parent's\n  // e.g. `translations` in transform matrix\n  const elementOffset = shaderAttributeOptions.elementOffset || 0;\n  const offset =\n    // offsets defined by the attribute\n    vertexOffset * stride +\n    elementOffset * baseAccessor.bytesPerElement +\n    // offsets defined by external buffers if any\n    (baseAccessor.offset || 0);\n\n  return {\n    ...shaderAttributeOptions,\n    offset,\n    stride\n  };\n}\n\nfunction resolveDoublePrecisionShaderAttributes(\n  baseAccessor: DataColumnSettings<any>,\n  shaderAttributeOptions: Partial<ShaderAttributeOptions>\n): {\n  high: ShaderAttributeOptions;\n  low: ShaderAttributeOptions;\n} {\n  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n\n  return {\n    high: resolvedOptions,\n    low: {\n      ...resolvedOptions,\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    }\n  };\n}\n\nexport type DataColumnOptions<Options> = Options &\n  BufferAccessor & {\n    id?: string;\n    vertexOffset?: number;\n    fp64?: boolean;\n    logicalType?: number;\n    isIndexed?: boolean;\n    defaultValue?: number | number[];\n  };\n\ntype DataColumnSettings<Options> = DataColumnOptions<Options> & {\n  type: number;\n  size: number;\n  logicalType?: number;\n  bytesPerElement: number;\n  defaultValue: number[];\n  defaultType: TypedArrayConstructor;\n};\n\ntype DataColumnInternalState<Options, State> = State & {\n  externalBuffer: LumaBuffer | null;\n  bufferAccessor: DataColumnSettings<Options>;\n  allocatedValue: TypedArray | null;\n  numInstances: number;\n  bounds: [number[], number[]] | null;\n  constant: boolean;\n};\n\nexport default class DataColumn<Options, State> implements IShaderAttribute {\n  gl: WebGLRenderingContext;\n  id: string;\n  size: number;\n  settings: DataColumnSettings<Options>;\n  value: NumericArray | null;\n  doublePrecision: boolean;\n\n  protected _buffer: LumaBuffer | null;\n  protected state: DataColumnInternalState<Options, State>;\n\n  /* eslint-disable max-statements */\n  constructor(gl: WebGLRenderingContext, opts: DataColumnOptions<Options>, state: State) {\n    this.gl = gl;\n    this.id = opts.id || '';\n    this.size = opts.size || 1;\n\n    const logicalType = opts.logicalType || opts.type;\n    const doublePrecision = logicalType === GL.DOUBLE;\n\n    let {defaultValue} = opts;\n    defaultValue = Number.isFinite(defaultValue)\n      ? [defaultValue]\n      : defaultValue || new Array(this.size).fill(0);\n\n    let bufferType: number;\n    if (doublePrecision) {\n      bufferType = GL.FLOAT;\n    } else if (!logicalType && opts.isIndexed) {\n      bufferType =\n        gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? GL.UNSIGNED_INT : GL.UNSIGNED_SHORT;\n    } else {\n      bufferType = logicalType || GL.FLOAT;\n    }\n\n    // This is the attribute type defined by the layer\n    // If an external buffer is provided, this.type may be overwritten\n    // But we always want to use defaultType for allocation\n    let defaultType = glArrayFromType(logicalType || bufferType || GL.FLOAT);\n    this.doublePrecision = doublePrecision;\n\n    // `fp64: false` tells a double-precision attribute to allocate Float32Arrays\n    // by default when using auto-packing. This is more efficient in use cases where\n    // high precision is unnecessary, but the `64Low` attribute is still required\n    // by the shader.\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n\n    this.value = null;\n    this.settings = {\n      ...opts,\n      defaultType,\n      defaultValue: defaultValue as number[],\n      logicalType,\n      type: bufferType,\n      size: this.size,\n      bytesPerElement: defaultType.BYTES_PER_ELEMENT\n    };\n    this.state = {\n      ...state,\n      externalBuffer: null,\n      bufferAccessor: this.settings,\n      allocatedValue: null,\n      numInstances: 0,\n      bounds: null,\n      constant: false\n    };\n    this._buffer = null;\n  }\n  /* eslint-enable max-statements */\n\n  get isConstant(): boolean {\n    return this.state.constant;\n  }\n\n  get buffer(): LumaBuffer {\n    if (!this._buffer) {\n      const {isIndexed, type} = this.settings;\n      this._buffer = new Buffer(this.gl, {\n        id: this.id,\n        target: isIndexed ? GL.ELEMENT_ARRAY_BUFFER : GL.ARRAY_BUFFER,\n        accessor: {type}\n      }) as LumaBuffer;\n    }\n    return this._buffer;\n  }\n\n  get byteOffset(): number {\n    const accessor = this.getAccessor();\n    if (accessor.vertexOffset) {\n      return accessor.vertexOffset * getStride(accessor);\n    }\n    return 0;\n  }\n\n  get numInstances(): number {\n    return this.state.numInstances;\n  }\n\n  set numInstances(n: number) {\n    this.state.numInstances = n;\n  }\n\n  delete(): void {\n    if (this._buffer) {\n      this._buffer.delete();\n      this._buffer = null;\n    }\n    typedArrayManager.release(this.state.allocatedValue);\n  }\n\n  getShaderAttributes(\n    id: string,\n    options: Partial<ShaderAttributeOptions> | null\n  ): Record<string, IShaderAttribute> {\n    if (this.doublePrecision) {\n      const shaderAttributes = {};\n      const isBuffer64Bit = this.value instanceof Float64Array;\n\n      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(\n        this.getAccessor(),\n        options || {}\n      );\n\n      shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);\n      shaderAttributes[`${id}64Low`] = isBuffer64Bit\n        ? new ShaderAttribute(this, doubleShaderAttributeDefs.low)\n        : new Float32Array(this.size); // use constant for low part if buffer is 32-bit\n      return shaderAttributes;\n    }\n    if (options) {\n      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n      return {[id]: new ShaderAttribute(this, shaderAttributeDef)};\n    }\n    return {[id]: this};\n  }\n\n  getBuffer(): LumaBuffer | null {\n    if (this.state.constant) {\n      return null;\n    }\n    return this.state.externalBuffer || this._buffer;\n  }\n\n  getValue(): [LumaBuffer, BufferAccessor] | NumericArray | null {\n    if (this.state.constant) {\n      return this.value;\n    }\n    return [this.getBuffer() as LumaBuffer, this.getAccessor() as BufferAccessor];\n  }\n\n  getAccessor(): DataColumnSettings<Options> {\n    return this.state.bufferAccessor;\n  }\n\n  // Returns [min: Array(size), max: Array(size)]\n  /* eslint-disable max-depth */\n  getBounds(): [number[], number[]] | null {\n    if (this.state.bounds) {\n      return this.state.bounds;\n    }\n    let result: [number[], number[]] | null = null;\n    if (this.state.constant && this.value) {\n      const min = Array.from(this.value);\n      result = [min, min];\n    } else {\n      const {value, numInstances, size} = this;\n      const len = numInstances * size;\n      if (value && len && value.length >= len) {\n        const min = new Array(size).fill(Infinity);\n        const max = new Array(size).fill(-Infinity);\n        for (let i = 0; i < len; ) {\n          for (let j = 0; j < size; j++) {\n            const v = value[i++];\n            if (v < min[j]) min[j] = v;\n            if (v > max[j]) max[j] = v;\n          }\n        }\n        result = [min, max];\n      }\n    }\n    this.state.bounds = result;\n    return result;\n  }\n\n  // returns true if success\n  // eslint-disable-next-line max-statements\n  setData(\n    data:\n      | TypedArray\n      | LumaBuffer\n      | ({\n          constant?: boolean;\n          value?: NumericArray;\n          buffer?: LumaBuffer;\n        } & Partial<BufferAccessor>)\n  ): boolean {\n    const {state} = this;\n\n    let opts: {\n      constant?: boolean;\n      value?: NumericArray;\n      buffer?: LumaBuffer;\n    } & Partial<BufferAccessor>;\n    if (ArrayBuffer.isView(data)) {\n      opts = {value: data};\n    } else if (data instanceof Buffer) {\n      opts = {buffer: data as LumaBuffer};\n    } else {\n      opts = data;\n    }\n\n    const accessor: DataColumnSettings<Options> = {...this.settings, ...opts};\n    state.bufferAccessor = accessor;\n    state.bounds = null; // clear cached bounds\n\n    if (opts.constant) {\n      // set constant\n      let value = opts.value as NumericArray;\n      value = this._normalizeValue(value, [], 0);\n      if (this.settings.normalized) {\n        value = this.normalizeConstant(value);\n      }\n      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n\n      if (!hasChanged) {\n        return false;\n      }\n      state.externalBuffer = null;\n      state.constant = true;\n      this.value = value;\n    } else if (opts.buffer) {\n      const buffer = opts.buffer;\n      state.externalBuffer = buffer;\n      state.constant = false;\n      this.value = opts.value || null;\n      const isBuffer64Bit = opts.value instanceof Float64Array;\n\n      // Copy the type of the buffer into the accessor\n      // @ts-ignore\n      accessor.type = opts.type || buffer.accessor.type;\n      // @ts-ignore\n      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);\n      accessor.stride = getStride(accessor);\n    } else if (opts.value) {\n      this._checkExternalBuffer(opts);\n\n      let value = opts.value as TypedArray;\n      state.externalBuffer = null;\n      state.constant = false;\n      this.value = value;\n\n      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;\n      accessor.stride = getStride(accessor);\n\n      const {buffer, byteOffset} = this;\n\n      if (this.doublePrecision && value instanceof Float64Array) {\n        value = toDoublePrecisionArray(value, accessor);\n      }\n\n      // A small over allocation is used as safety margin\n      // Shader attributes may try to access this buffer with bigger offsets\n      const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;\n      if (buffer.byteLength < requiredBufferSize) {\n        buffer.reallocate(requiredBufferSize);\n      }\n      // Hack: force Buffer to infer data type\n      buffer.setAccessor(null);\n      buffer.subData({data: value, offset: byteOffset});\n      // @ts-ignore\n      accessor.type = opts.type || buffer.accessor.type;\n    }\n\n    return true;\n  }\n\n  updateSubBuffer(\n    opts: {\n      startOffset?: number;\n      endOffset?: number;\n    } = {}\n  ): void {\n    this.state.bounds = null; // clear cached bounds\n\n    const value = this.value as TypedArray;\n    const {startOffset = 0, endOffset} = opts;\n    this.buffer.subData({\n      data:\n        this.doublePrecision && value instanceof Float64Array\n          ? toDoublePrecisionArray(value, {\n              size: this.size,\n              startIndex: startOffset,\n              endIndex: endOffset\n            })\n          : value.subarray(startOffset, endOffset),\n      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset\n    });\n  }\n\n  allocate(numInstances: number, copy: boolean = false): boolean {\n    const {state} = this;\n    const oldValue = state.allocatedValue;\n\n    // Allocate at least one element to ensure a valid buffer\n    const value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n      size: this.size,\n      type: this.settings.defaultType,\n      copy\n    });\n\n    this.value = value;\n\n    const {buffer, byteOffset} = this;\n\n    if (buffer.byteLength < value.byteLength + byteOffset) {\n      buffer.reallocate(value.byteLength + byteOffset);\n\n      if (copy && oldValue) {\n        // Upload the full existing attribute value to the GPU, so that updateBuffer\n        // can choose to only update a partial range.\n        // TODO - copy old buffer to new buffer on the GPU\n        buffer.subData({\n          data:\n            oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,\n          offset: byteOffset\n        });\n      }\n    }\n\n    state.allocatedValue = value;\n    state.constant = false;\n    state.externalBuffer = null;\n    state.bufferAccessor = this.settings;\n    return true;\n  }\n\n  // PRIVATE HELPER METHODS\n  protected _checkExternalBuffer(opts: {value?: NumericArray; normalized?: boolean}): void {\n    const {value} = opts;\n    if (!ArrayBuffer.isView(value)) {\n      throw new Error(`Attribute ${this.id} value is not TypedArray`);\n    }\n    const ArrayType = this.settings.defaultType;\n\n    let illegalArrayType = false;\n    if (this.doublePrecision) {\n      // not 32bit or 64bit\n      illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n    }\n    if (illegalArrayType) {\n      throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);\n    }\n    if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n      log.warn(`Attribute ${this.id} is normalized`)();\n    }\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n  normalizeConstant(value: NumericArray): NumericArray {\n    switch (this.settings.type) {\n      case GL.BYTE:\n        // normalize [-128, 127] to [-1, 1]\n        return new Float32Array(value).map(x => ((x + 128) / 255) * 2 - 1);\n\n      case GL.SHORT:\n        // normalize [-32768, 32767] to [-1, 1]\n        return new Float32Array(value).map(x => ((x + 32768) / 65535) * 2 - 1);\n\n      case GL.UNSIGNED_BYTE:\n        // normalize [0, 255] to [0, 1]\n        return new Float32Array(value).map(x => x / 255);\n\n      case GL.UNSIGNED_SHORT:\n        // normalize [0, 65535] to [0, 1]\n        return new Float32Array(value).map(x => x / 65535);\n\n      default:\n        // No normalization for gl.FLOAT and gl.HALF_FLOAT\n        return value;\n    }\n  }\n\n  /* check user supplied values and apply fallback */\n  protected _normalizeValue(value: any, out: NumericArray, start: number): NumericArray {\n    const {defaultValue, size} = this.settings;\n\n    if (Number.isFinite(value)) {\n      out[start] = value;\n      return out;\n    }\n    if (!value) {\n      out[start] = defaultValue[0];\n      return out;\n    }\n\n    // Important - switch cases are 5x more performant than a for loop!\n    /* eslint-disable no-fallthrough, default-case */\n    switch (size) {\n      case 4:\n        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n      case 3:\n        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n      case 2:\n        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n      case 1:\n        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n        break;\n\n      default:\n        // In the rare case where the attribute size > 4, do it the slow way\n        // This is used for e.g. transform matrices\n        let i = size;\n        while (--i >= 0) {\n          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n        }\n    }\n\n    return out;\n  }\n\n  protected _areValuesEqual(value1: any, value2: any): boolean {\n    if (!value1 || !value2) {\n      return false;\n    }\n    const {size} = this;\n    for (let i = 0; i < size; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}