{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nvar _marked = _regeneratorRuntime.mark(makeStringIterator);\nexport function makeStringIterator(string) {\n  var options,\n    _options$chunkSize,\n    chunkSize,\n    offset,\n    textEncoder,\n    chunkLength,\n    chunk,\n    _args = arguments;\n  return _regeneratorRuntime.wrap(function makeStringIterator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n          _options$chunkSize = options.chunkSize, chunkSize = _options$chunkSize === void 0 ? 256 * 1024 : _options$chunkSize;\n          offset = 0;\n          textEncoder = new TextEncoder();\n        case 4:\n          if (!(offset < string.length)) {\n            _context.next = 12;\n            break;\n          }\n          chunkLength = Math.min(string.length - offset, chunkSize);\n          chunk = string.slice(offset, offset + chunkLength);\n          offset += chunkLength;\n          _context.next = 10;\n          return textEncoder.encode(chunk);\n        case 10:\n          _context.next = 4;\n          break;\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}","map":{"version":3,"names":["makeStringIterator","string","options","_options$chunkSize","chunkSize","offset","textEncoder","chunkLength","chunk","_args","arguments","_regeneratorRuntime","wrap","makeStringIterator$","_context","prev","next","length","undefined","TextEncoder","Math","min","slice","encode","stop","_marked"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/kepler.gl/node_modules/@loaders.gl/core/src/iterator-utils/make-iterator/string-iterator.js"],"sourcesContent":["/* global TextEncoder */\n\n/**\n * Returns an iterator that breaks a big string into chunks and yields them one-by-one\n */\nexport function* makeStringIterator(string, options = {}) {\n  const {chunkSize = 256 * 1024} = options;\n\n  let offset = 0;\n  const textEncoder = new TextEncoder();\n  while (offset < string.length) {\n    // Create a chunk of the right size\n    const chunkLength = Math.min(string.length - offset, chunkSize);\n    const chunk = string.slice(offset, offset + chunkLength);\n    offset += chunkLength;\n\n    // yield an ArrayBuffer chunk\n    yield textEncoder.encode(chunk);\n  }\n}\n"],"mappings":";uCAKiBA,kB;AAAjB,OAAO,SAAUA,kBAAVA,CAA6BC,MAA7B;EAAA,IAAAC,OAAA;IAAAC,kBAAA;IAAAC,SAAA;IAAAC,MAAA;IAAAC,WAAA;IAAAC,WAAA;IAAAC,KAAA;IAAAC,KAAA,GAAAC,SAAA;EAAA,OAAAC,mBAAA,CAAAC,IAAA,UAAAC,oBAAAC,QAAA;IAAA;MAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAAqCd,OAArC,GAAAO,KAAA,CAAAQ,MAAA,QAAAR,KAAA,QAAAS,SAAA,GAAAT,KAAA,MAA+C,EAA/C;UAAAN,kBAAA,GAC4BD,OAD5B,CACEE,SADF,EACEA,SADF,GAAAD,kBAAA,cACc,MAAM,IADpB,GAAAA,kBAAA;UAGDE,MAHC,GAGQ,CAHR;UAICC,WAJD,GAIe,IAAIa,WAAJ,EAJf;QAAA;UAAA,MAKEd,MAAM,GAAGJ,MAAM,CAACgB,MALlB;YAAAH,QAAA,CAAAE,IAAA;YAAA;UAAA;UAOGT,WAPH,GAOiBa,IAAI,CAACC,GAAL,CAASpB,MAAM,CAACgB,MAAP,GAAgBZ,MAAzB,EAAiCD,SAAjC,CAPjB;UAQGI,KARH,GAQWP,MAAM,CAACqB,KAAP,CAAajB,MAAb,EAAqBA,MAAM,GAAGE,WAA9B,CARX;UASHF,MAAM,IAAIE,WAAV;UATGO,QAAA,CAAAE,IAAA;UAYH,OAAMV,WAAW,CAACiB,MAAZ,CAAmBf,KAAnB,CAAN;QAZG;UAAAM,QAAA,CAAAE,IAAA;UAAA;QAAA;QAAA;UAAA,OAAAF,QAAA,CAAAU,IAAA;MAAA;IAAA;EAAA,GAAAC,OAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}