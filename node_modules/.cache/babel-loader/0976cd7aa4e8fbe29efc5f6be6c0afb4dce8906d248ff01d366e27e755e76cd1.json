{"ast":null,"code":"import _regeneratorRuntime from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(makeStringIterator);\nvar DEFAULT_CHUNK_SIZE = 256 * 1024;\nexport function makeStringIterator(string, options) {\n  var chunkSize, offset, textEncoder, chunkLength, chunk;\n  return _regeneratorRuntime().wrap(function makeStringIterator$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;\n        offset = 0;\n        textEncoder = new TextEncoder();\n      case 3:\n        if (!(offset < string.length)) {\n          _context.next = 11;\n          break;\n        }\n        chunkLength = Math.min(string.length - offset, chunkSize);\n        chunk = string.slice(offset, offset + chunkLength);\n        offset += chunkLength;\n        _context.next = 9;\n        return textEncoder.encode(chunk);\n      case 9:\n        _context.next = 3;\n        break;\n      case 11:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _marked);\n}","map":{"version":3,"names":["makeStringIterator","DEFAULT_CHUNK_SIZE","string","options","chunkSize","offset","textEncoder","chunkLength","chunk","_regeneratorRuntime","wrap","makeStringIterator$","_context","prev","next","TextEncoder","length","Math","min","slice","encode","stop","_marked"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/layers/node_modules/@loaders.gl/core/src/iterators/make-iterator/make-string-iterator.ts"],"sourcesContent":["import type {IteratorOptions} from './make-iterator';\n\nconst DEFAULT_CHUNK_SIZE = 256 * 1024;\n\n/**\n * Returns an iterator that breaks a big string into chunks and yields them one-by-one as ArrayBuffers\n * @param blob string to iterate over\n * @param options\n * @param options.chunkSize\n */\nexport function* makeStringIterator(\n  string: string,\n  options?: IteratorOptions\n): Iterable<ArrayBuffer> {\n  const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;\n\n  let offset = 0;\n  const textEncoder = new TextEncoder();\n  while (offset < string.length) {\n    // Create a chunk of the right size\n    const chunkLength = Math.min(string.length - offset, chunkSize);\n    const chunk = string.slice(offset, offset + chunkLength);\n    offset += chunkLength;\n\n    // yield an ArrayBuffer chunk\n    yield textEncoder.encode(chunk);\n  }\n}\n"],"mappings":";sDAUiBA,kBAAkB;AARnC,IAAMC,kBAAkB,GAAG,GAAG,GAAG,IAAI;AAQrC,OAAO,SAAUD,kBAAkBA,CACjCE,MAAc,EACdC,OAAyB;EAAA,IAAAC,SAAA,EAAAC,MAAA,EAAAC,WAAA,EAAAC,WAAA,EAAAC,KAAA;EAAA,OAAAC,mBAAA,GAAAC,IAAA,UAAAC,oBAAAC,QAAA;IAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;MAAA;QAEnBV,SAAS,GAAG,CAAAD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEC,SAAS,KAAIH,kBAAkB;QAEtDI,MAAM,GAAG,CAAC;QACRC,WAAW,GAAG,IAAIS,WAAW,EAAE;MAAA;QAAA,MAC9BV,MAAM,GAAGH,MAAM,CAACc,MAAM;UAAAJ,QAAA,CAAAE,IAAA;UAAA;QAAA;QAErBP,WAAW,GAAGU,IAAI,CAACC,GAAG,CAAChB,MAAM,CAACc,MAAM,GAAGX,MAAM,EAAED,SAAS,CAAC;QACzDI,KAAK,GAAGN,MAAM,CAACiB,KAAK,CAACd,MAAM,EAAEA,MAAM,GAAGE,WAAW,CAAC;QACxDF,MAAM,IAAIE,WAAW;QAAAK,QAAA,CAAAE,IAAA;QAGrB,OAAMR,WAAW,CAACc,MAAM,CAACZ,KAAK,CAAC;MAAA;QAAAI,QAAA,CAAAE,IAAA;QAAA;MAAA;MAAA;QAAA,OAAAF,QAAA,CAAAS,IAAA;IAAA;EAAA,GAAAC,OAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}