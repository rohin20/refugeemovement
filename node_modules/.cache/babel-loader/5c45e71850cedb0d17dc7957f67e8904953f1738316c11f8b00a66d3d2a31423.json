{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @param {number} [options.epsilon] Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // Normalize inputs\n  var ptCoords = invariant_1.getCoord(pt);\n  var lineCoords = invariant_1.getCoords(line);\n  // Main\n  for (var i = 0; i < lineCoords.length - 1; i++) {\n    var ignoreBoundary = false;\n    if (options.ignoreEndVertices) {\n      if (i === 0) {\n        ignoreBoundary = \"start\";\n      }\n      if (i === lineCoords.length - 2) {\n        ignoreBoundary = \"end\";\n      }\n      if (i === 0 && i + 1 === lineCoords.length - 1) {\n        ignoreBoundary = \"both\";\n      }\n    }\n    if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === \"undefined\" ? null : options.epsilon)) {\n      return true;\n    }\n  }\n  return false;\n}\n// See http://stackoverflow.com/a/4833823/1979085\n// See https://stackoverflow.com/a/328122/1048847\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * @param {number} epsilon Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {\n  var x = pt[0];\n  var y = pt[1];\n  var x1 = lineSegmentStart[0];\n  var y1 = lineSegmentStart[1];\n  var x2 = lineSegmentEnd[0];\n  var y2 = lineSegmentEnd[1];\n  var dxc = pt[0] - x1;\n  var dyc = pt[1] - y1;\n  var dxl = x2 - x1;\n  var dyl = y2 - y1;\n  var cross = dxc * dyl - dyc * dxl;\n  if (epsilon !== null) {\n    if (Math.abs(cross) > epsilon) {\n      return false;\n    }\n  } else if (cross !== 0) {\n    return false;\n  }\n  if (!excludeBoundary) {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n    }\n    return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n  } else if (excludeBoundary === \"start\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n    }\n    return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n  } else if (excludeBoundary === \"end\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n    }\n    return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n  } else if (excludeBoundary === \"both\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n    }\n    return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n  }\n  return false;\n}\nexports.default = booleanPointOnLine;","map":{"version":3,"names":["Object","defineProperty","exports","value","invariant_1","require","booleanPointOnLine","pt","line","options","ptCoords","getCoord","lineCoords","getCoords","i","length","ignoreBoundary","ignoreEndVertices","isPointOnLineSegment","epsilon","lineSegmentStart","lineSegmentEnd","excludeBoundary","x","y","x1","y1","x2","y2","dxc","dyc","dxl","dyl","cross","Math","abs","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@turf/boolean-point-on-line/dist/js/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @param {number} [options.epsilon] Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Normalize inputs\n    var ptCoords = invariant_1.getCoord(pt);\n    var lineCoords = invariant_1.getCoords(line);\n    // Main\n    for (var i = 0; i < lineCoords.length - 1; i++) {\n        var ignoreBoundary = false;\n        if (options.ignoreEndVertices) {\n            if (i === 0) {\n                ignoreBoundary = \"start\";\n            }\n            if (i === lineCoords.length - 2) {\n                ignoreBoundary = \"end\";\n            }\n            if (i === 0 && i + 1 === lineCoords.length - 1) {\n                ignoreBoundary = \"both\";\n            }\n        }\n        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === \"undefined\" ? null : options.epsilon)) {\n            return true;\n        }\n    }\n    return false;\n}\n// See http://stackoverflow.com/a/4833823/1979085\n// See https://stackoverflow.com/a/328122/1048847\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * @param {number} epsilon Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {\n    var x = pt[0];\n    var y = pt[1];\n    var x1 = lineSegmentStart[0];\n    var y1 = lineSegmentStart[1];\n    var x2 = lineSegmentEnd[0];\n    var y2 = lineSegmentEnd[1];\n    var dxc = pt[0] - x1;\n    var dyc = pt[1] - y1;\n    var dxl = x2 - x1;\n    var dyl = y2 - y1;\n    var cross = dxc * dyl - dyc * dxl;\n    if (epsilon !== null) {\n        if (Math.abs(cross) > epsilon) {\n            return false;\n        }\n    }\n    else if (cross !== 0) {\n        return false;\n    }\n    if (!excludeBoundary) {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n    }\n    else if (excludeBoundary === \"start\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n    }\n    else if (excludeBoundary === \"end\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n    }\n    else if (excludeBoundary === \"both\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n    }\n    return false;\n}\nexports.default = booleanPointOnLine;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,IAAIC,WAAW,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAACC,EAAE,EAAEC,IAAI,EAAEC,OAAO,EAAE;EAC3C,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC;EACA,IAAIC,QAAQ,GAAGN,WAAW,CAACO,QAAQ,CAACJ,EAAE,CAAC;EACvC,IAAIK,UAAU,GAAGR,WAAW,CAACS,SAAS,CAACL,IAAI,CAAC;EAC5C;EACA,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,UAAU,CAACG,MAAM,GAAG,CAAC,EAAED,CAAC,EAAE,EAAE;IAC5C,IAAIE,cAAc,GAAG,KAAK;IAC1B,IAAIP,OAAO,CAACQ,iBAAiB,EAAE;MAC3B,IAAIH,CAAC,KAAK,CAAC,EAAE;QACTE,cAAc,GAAG,OAAO;MAC5B;MACA,IAAIF,CAAC,KAAKF,UAAU,CAACG,MAAM,GAAG,CAAC,EAAE;QAC7BC,cAAc,GAAG,KAAK;MAC1B;MACA,IAAIF,CAAC,KAAK,CAAC,IAAIA,CAAC,GAAG,CAAC,KAAKF,UAAU,CAACG,MAAM,GAAG,CAAC,EAAE;QAC5CC,cAAc,GAAG,MAAM;MAC3B;IACJ;IACA,IAAIE,oBAAoB,CAACN,UAAU,CAACE,CAAC,CAAC,EAAEF,UAAU,CAACE,CAAC,GAAG,CAAC,CAAC,EAAEJ,QAAQ,EAAEM,cAAc,EAAE,OAAOP,OAAO,CAACU,OAAO,KAAK,WAAW,GAAG,IAAI,GAAGV,OAAO,CAACU,OAAO,CAAC,EAAE;MACnJ,OAAO,IAAI;IACf;EACJ;EACA,OAAO,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,oBAAoBA,CAACE,gBAAgB,EAAEC,cAAc,EAAEd,EAAE,EAAEe,eAAe,EAAEH,OAAO,EAAE;EAC1F,IAAII,CAAC,GAAGhB,EAAE,CAAC,CAAC,CAAC;EACb,IAAIiB,CAAC,GAAGjB,EAAE,CAAC,CAAC,CAAC;EACb,IAAIkB,EAAE,GAAGL,gBAAgB,CAAC,CAAC,CAAC;EAC5B,IAAIM,EAAE,GAAGN,gBAAgB,CAAC,CAAC,CAAC;EAC5B,IAAIO,EAAE,GAAGN,cAAc,CAAC,CAAC,CAAC;EAC1B,IAAIO,EAAE,GAAGP,cAAc,CAAC,CAAC,CAAC;EAC1B,IAAIQ,GAAG,GAAGtB,EAAE,CAAC,CAAC,CAAC,GAAGkB,EAAE;EACpB,IAAIK,GAAG,GAAGvB,EAAE,CAAC,CAAC,CAAC,GAAGmB,EAAE;EACpB,IAAIK,GAAG,GAAGJ,EAAE,GAAGF,EAAE;EACjB,IAAIO,GAAG,GAAGJ,EAAE,GAAGF,EAAE;EACjB,IAAIO,KAAK,GAAGJ,GAAG,GAAGG,GAAG,GAAGF,GAAG,GAAGC,GAAG;EACjC,IAAIZ,OAAO,KAAK,IAAI,EAAE;IAClB,IAAIe,IAAI,CAACC,GAAG,CAACF,KAAK,CAAC,GAAGd,OAAO,EAAE;MAC3B,OAAO,KAAK;IAChB;EACJ,CAAC,MACI,IAAIc,KAAK,KAAK,CAAC,EAAE;IAClB,OAAO,KAAK;EAChB;EACA,IAAI,CAACX,eAAe,EAAE;IAClB,IAAIY,IAAI,CAACC,GAAG,CAACJ,GAAG,CAAC,IAAIG,IAAI,CAACC,GAAG,CAACH,GAAG,CAAC,EAAE;MAChC,OAAOD,GAAG,GAAG,CAAC,GAAGN,EAAE,IAAIF,CAAC,IAAIA,CAAC,IAAII,EAAE,GAAGA,EAAE,IAAIJ,CAAC,IAAIA,CAAC,IAAIE,EAAE;IAC5D;IACA,OAAOO,GAAG,GAAG,CAAC,GAAGN,EAAE,IAAIF,CAAC,IAAIA,CAAC,IAAII,EAAE,GAAGA,EAAE,IAAIJ,CAAC,IAAIA,CAAC,IAAIE,EAAE;EAC5D,CAAC,MACI,IAAIJ,eAAe,KAAK,OAAO,EAAE;IAClC,IAAIY,IAAI,CAACC,GAAG,CAACJ,GAAG,CAAC,IAAIG,IAAI,CAACC,GAAG,CAACH,GAAG,CAAC,EAAE;MAChC,OAAOD,GAAG,GAAG,CAAC,GAAGN,EAAE,GAAGF,CAAC,IAAIA,CAAC,IAAII,EAAE,GAAGA,EAAE,IAAIJ,CAAC,IAAIA,CAAC,GAAGE,EAAE;IAC1D;IACA,OAAOO,GAAG,GAAG,CAAC,GAAGN,EAAE,GAAGF,CAAC,IAAIA,CAAC,IAAII,EAAE,GAAGA,EAAE,IAAIJ,CAAC,IAAIA,CAAC,GAAGE,EAAE;EAC1D,CAAC,MACI,IAAIJ,eAAe,KAAK,KAAK,EAAE;IAChC,IAAIY,IAAI,CAACC,GAAG,CAACJ,GAAG,CAAC,IAAIG,IAAI,CAACC,GAAG,CAACH,GAAG,CAAC,EAAE;MAChC,OAAOD,GAAG,GAAG,CAAC,GAAGN,EAAE,IAAIF,CAAC,IAAIA,CAAC,GAAGI,EAAE,GAAGA,EAAE,GAAGJ,CAAC,IAAIA,CAAC,IAAIE,EAAE;IAC1D;IACA,OAAOO,GAAG,GAAG,CAAC,GAAGN,EAAE,IAAIF,CAAC,IAAIA,CAAC,GAAGI,EAAE,GAAGA,EAAE,GAAGJ,CAAC,IAAIA,CAAC,IAAIE,EAAE;EAC1D,CAAC,MACI,IAAIJ,eAAe,KAAK,MAAM,EAAE;IACjC,IAAIY,IAAI,CAACC,GAAG,CAACJ,GAAG,CAAC,IAAIG,IAAI,CAACC,GAAG,CAACH,GAAG,CAAC,EAAE;MAChC,OAAOD,GAAG,GAAG,CAAC,GAAGN,EAAE,GAAGF,CAAC,IAAIA,CAAC,GAAGI,EAAE,GAAGA,EAAE,GAAGJ,CAAC,IAAIA,CAAC,GAAGE,EAAE;IACxD;IACA,OAAOO,GAAG,GAAG,CAAC,GAAGN,EAAE,GAAGF,CAAC,IAAIA,CAAC,GAAGI,EAAE,GAAGA,EAAE,GAAGJ,CAAC,IAAIA,CAAC,GAAGE,EAAE;EACxD;EACA,OAAO,KAAK;AAChB;AACAxB,OAAO,CAACkC,OAAO,GAAG9B,kBAAkB"},"metadata":{},"sourceType":"script","externalDependencies":[]}