{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDefaultFilter = getDefaultFilter;\nexports.shouldApplyFilter = shouldApplyFilter;\nexports.validatePolygonFilter = validatePolygonFilter;\nexports.validateFilter = validateFilter;\nexports.validateFilterWithData = validateFilterWithData;\nexports.getFilterProps = getFilterProps;\nexports.getFilterFunction = getFilterFunction;\nexports.updateFilterDataId = updateFilterDataId;\nexports.filterDataByFilterTypes = filterDataByFilterTypes;\nexports.getFilterRecord = getFilterRecord;\nexports.diffFilters = diffFilters;\nexports.adjustValueToFilterDomain = adjustValueToFilterDomain;\nexports.getNumericFieldDomain = getNumericFieldDomain;\nexports.getNumericStepSize = getNumericStepSize;\nexports.getTimestampFieldDomain = getTimestampFieldDomain;\nexports.histogramConstruct = histogramConstruct;\nexports.getHistogram = getHistogram;\nexports.formatNumberByStep = formatNumberByStep;\nexports.isInRange = isInRange;\nexports.isInPolygon = isInPolygon;\nexports.isValidTimeDomain = isValidTimeDomain;\nexports.getTimeWidgetTitleFormatter = getTimeWidgetTitleFormatter;\nexports.getTimeWidgetHintFormatter = getTimeWidgetHintFormatter;\nexports.isValidFilterValue = isValidFilterValue;\nexports.getFilterPlot = getFilterPlot;\nexports.getDefaultFilterPlotType = getDefaultFilterPlotType;\nexports.applyFiltersToDatasets = applyFiltersToDatasets;\nexports.applyFilterFieldName = applyFilterFieldName;\nexports.mergeFilterDomainStep = mergeFilterDomainStep;\nexports.generatePolygonFilter = generatePolygonFilter;\nexports.filterDatasetCPU = filterDatasetCPU;\nexports.validateFiltersUpdateDatasets = validateFiltersUpdateDatasets;\nexports.getIntervalBins = getIntervalBins;\nexports.getFilterIdInFeature = exports.featureToFilterValue = exports.getPolygonFilterFunctor = exports.LAYER_FILTERS = exports.FILTER_ID_LENGTH = exports.DEFAULT_FILTER_STRUCTURE = exports.FILTER_COMPONENTS = exports.LIMITED_FILTER_EFFECT_PROPS = exports.FILTER_UPDATER_PROPS = exports.PLOT_TYPES = exports.enlargedHistogramBins = exports.histogramBins = exports.TimestampStepMap = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _d3Array = require(\"d3-array\");\nvar _keymirror = _interopRequireDefault(require(\"keymirror\"));\nvar _console = require(\"global/console\");\nvar _lodash = _interopRequireDefault(require(\"lodash.get\"));\nvar _lodash2 = _interopRequireDefault(require(\"lodash.isequal\"));\nvar _booleanWithin = _interopRequireDefault(require(\"@turf/boolean-within\"));\nvar _helpers = require(\"@turf/helpers\");\nvar _decimal = require(\"decimal.js\");\nvar _defaultSettings = require(\"../constants/default-settings\");\nvar _dataUtils = require(\"./data-utils\");\nvar ScaleUtils = _interopRequireWildcard(require(\"./data-scale-utils\"));\nvar _types = require(\"../layers/types\");\nvar _utils = require(\"./utils\");\nvar _h3Utils = require(\"../layers/h3-hexagon-layer/h3-utils\");\nvar _FILTER_TYPES$timeRan, _FILTER_TYPES$range, _SupportedPlotType, _FILTER_COMPONENTS;\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n// TYPE\n\n/** @typedef {import('./table-utils/kepler-table').FilterRecord} FilterRecord */\n\n/** @typedef {import('./filter-utils').FilterResult} FilterResult */\nvar TimestampStepMap = [{\n  max: 1,\n  step: 0.05\n}, {\n  max: 10,\n  step: 0.1\n}, {\n  max: 100,\n  step: 1\n}, {\n  max: 500,\n  step: 5\n}, {\n  max: 1000,\n  step: 10\n}, {\n  max: 5000,\n  step: 50\n}, {\n  max: Number.POSITIVE_INFINITY,\n  step: 1000\n}];\nexports.TimestampStepMap = TimestampStepMap;\nvar histogramBins = 30;\nexports.histogramBins = histogramBins;\nvar enlargedHistogramBins = 100;\nexports.enlargedHistogramBins = enlargedHistogramBins;\nvar durationSecond = 1000;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationYear = durationDay * 365;\nvar PLOT_TYPES = (0, _keymirror[\"default\"])({\n  histogram: null,\n  lineChart: null\n});\nexports.PLOT_TYPES = PLOT_TYPES;\nvar FILTER_UPDATER_PROPS = (0, _keymirror[\"default\"])({\n  dataId: null,\n  name: null,\n  layerId: null\n});\nexports.FILTER_UPDATER_PROPS = FILTER_UPDATER_PROPS;\nvar LIMITED_FILTER_EFFECT_PROPS = (0, _keymirror[\"default\"])((0, _defineProperty2[\"default\"])({}, FILTER_UPDATER_PROPS.name, null));\n/**\n * Max number of filter value buffers that deck.gl provides\n */\n\nexports.LIMITED_FILTER_EFFECT_PROPS = LIMITED_FILTER_EFFECT_PROPS;\nvar SupportedPlotType = (_SupportedPlotType = {}, (0, _defineProperty2[\"default\"])(_SupportedPlotType, _defaultSettings.FILTER_TYPES.timeRange, (_FILTER_TYPES$timeRan = {\n  \"default\": 'histogram'\n}, (0, _defineProperty2[\"default\"])(_FILTER_TYPES$timeRan, _defaultSettings.ALL_FIELD_TYPES.integer, 'lineChart'), (0, _defineProperty2[\"default\"])(_FILTER_TYPES$timeRan, _defaultSettings.ALL_FIELD_TYPES.real, 'lineChart'), _FILTER_TYPES$timeRan)), (0, _defineProperty2[\"default\"])(_SupportedPlotType, _defaultSettings.FILTER_TYPES.range, (_FILTER_TYPES$range = {\n  \"default\": 'histogram'\n}, (0, _defineProperty2[\"default\"])(_FILTER_TYPES$range, _defaultSettings.ALL_FIELD_TYPES.integer, 'lineChart'), (0, _defineProperty2[\"default\"])(_FILTER_TYPES$range, _defaultSettings.ALL_FIELD_TYPES.real, 'lineChart'), _FILTER_TYPES$range)), _SupportedPlotType);\nvar FILTER_COMPONENTS = (_FILTER_COMPONENTS = {}, (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _defaultSettings.FILTER_TYPES.select, 'SingleSelectFilter'), (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _defaultSettings.FILTER_TYPES.multiSelect, 'MultiSelectFilter'), (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _defaultSettings.FILTER_TYPES.timeRange, 'TimeRangeFilter'), (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _defaultSettings.FILTER_TYPES.range, 'RangeFilter'), (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _defaultSettings.FILTER_TYPES.polygon, 'PolygonFilter'), _FILTER_COMPONENTS);\nexports.FILTER_COMPONENTS = FILTER_COMPONENTS;\nvar DEFAULT_FILTER_STRUCTURE = {\n  dataId: [],\n  // [string]\n  freeze: false,\n  id: null,\n  // time range filter specific\n  fixedDomain: false,\n  enlarged: false,\n  isAnimating: false,\n  animationWindow: _defaultSettings.ANIMATION_WINDOW.free,\n  speed: 1,\n  // field specific\n  name: [],\n  // string\n  type: null,\n  fieldIdx: [],\n  // [integer]\n  domain: null,\n  value: null,\n  // plot\n  plotType: PLOT_TYPES.histogram,\n  yAxis: null,\n  interval: null,\n  // mode\n  gpu: false\n};\nexports.DEFAULT_FILTER_STRUCTURE = DEFAULT_FILTER_STRUCTURE;\nvar FILTER_ID_LENGTH = 4;\nexports.FILTER_ID_LENGTH = FILTER_ID_LENGTH;\nvar LAYER_FILTERS = [_defaultSettings.FILTER_TYPES.polygon];\n/**\n * Generates a filter with a dataset id as dataId\n * @type {typeof import('./filter-utils').getDefaultFilter}\n */\n\nexports.LAYER_FILTERS = LAYER_FILTERS;\nfunction getDefaultFilter(dataId) {\n  return _objectSpread(_objectSpread({}, DEFAULT_FILTER_STRUCTURE), {}, {\n    // store it as dataId and it could be one or many\n    dataId: (0, _utils.toArray)(dataId),\n    id: (0, _utils.generateHashId)(FILTER_ID_LENGTH)\n  });\n}\n/**\n * Check if a filter is valid based on the given dataId\n * @param  filter to validate\n * @param  datasetId id to validate filter against\n * @return true if a filter is valid, false otherwise\n * @type {typeof import('./filter-utils').shouldApplyFilter}\n */\n\nfunction shouldApplyFilter(filter, datasetId) {\n  var dataIds = (0, _utils.toArray)(filter.dataId);\n  return dataIds.includes(datasetId) && filter.value !== null;\n}\n/**\n * Validates and modifies polygon filter structure\n * @param dataset\n * @param filter\n * @param layers\n * @return - {filter, dataset}\n * @type {typeof import('./filter-utils').validatePolygonFilter}\n */\n\nfunction validatePolygonFilter(dataset, filter, layers) {\n  var failed = {\n    dataset: dataset,\n    filter: null\n  };\n  var value = filter.value,\n    layerId = filter.layerId,\n    type = filter.type,\n    dataId = filter.dataId;\n  if (!layerId || !isValidFilterValue(type, value)) {\n    return failed;\n  }\n  var isValidDataset = dataId.includes(dataset.id);\n  if (!isValidDataset) {\n    return failed;\n  }\n  var layer = layers.find(function (l) {\n    return layerId.includes(l.id);\n  });\n  if (!layer) {\n    return failed;\n  }\n  return {\n    filter: _objectSpread(_objectSpread({}, filter), {}, {\n      freeze: true,\n      fieldIdx: []\n    }),\n    dataset: dataset\n  };\n}\n/**\n * Custom filter validators\n */\n\nvar filterValidators = (0, _defineProperty2[\"default\"])({}, _defaultSettings.FILTER_TYPES.polygon, validatePolygonFilter);\n/**\n * Default validate filter function\n * @param dataset\n * @param filter\n * @return - {filter, dataset}\n * @type {typeof import('./filter-utils').validateFilter}\n */\n\nfunction validateFilter(dataset, filter) {\n  // match filter.dataId\n  var failed = {\n    dataset: dataset,\n    filter: null\n  };\n  var filterDataId = (0, _utils.toArray)(filter.dataId);\n  var filterDatasetIndex = filterDataId.indexOf(dataset.id);\n  if (filterDatasetIndex < 0) {\n    // the current filter is not mapped against the current dataset\n    return failed;\n  }\n  var initializeFilter = _objectSpread(_objectSpread(_objectSpread({}, getDefaultFilter(filter.dataId)), filter), {}, {\n    dataId: filterDataId,\n    name: (0, _utils.toArray)(filter.name)\n  });\n  var fieldName = initializeFilter.name[filterDatasetIndex];\n  var _applyFilterFieldName = applyFilterFieldName(initializeFilter, dataset, fieldName, filterDatasetIndex, {\n      mergeDomain: true\n    }),\n    updatedFilter = _applyFilterFieldName.filter,\n    updatedDataset = _applyFilterFieldName.dataset;\n  if (!updatedFilter) {\n    return failed;\n  }\n  updatedFilter.value = adjustValueToFilterDomain(filter.value, updatedFilter);\n  updatedFilter.enlarged = typeof filter.enlarged === 'boolean' ? filter.enlarged : updatedFilter.enlarged;\n  if (updatedFilter.value === null) {\n    // cannot adjust saved value to filter\n    return failed;\n  }\n  return {\n    filter: validateFilterYAxis(updatedFilter, updatedDataset),\n    dataset: updatedDataset\n  };\n}\n/**\n * Validate saved filter config with new data,\n * calculate domain and fieldIdx based new fields and data\n *\n * @param dataset\n * @param filter - filter to be validate\n * @param layers - layers\n * @return validated filter\n * @type {typeof import('./filter-utils').validateFilterWithData}\n */\n\nfunction validateFilterWithData(dataset, filter, layers) {\n  // @ts-ignore\n  return filterValidators.hasOwnProperty(filter.type) ? filterValidators[filter.type](dataset, filter, layers) : validateFilter(dataset, filter);\n}\n/**\n * Validate YAxis\n * @param filter\n * @param dataset\n * @return {*}\n */\n\nfunction validateFilterYAxis(filter, dataset) {\n  // TODO: validate yAxis against other datasets\n  var fields = dataset.fields;\n  var _filter = filter,\n    yAxis = _filter.yAxis; // TODO: validate yAxis against other datasets\n\n  if (yAxis) {\n    var matchedAxis = fields.find(function (_ref) {\n      var name = _ref.name,\n        type = _ref.type;\n      return name === yAxis.name && type === yAxis.type;\n    });\n    filter = matchedAxis ? _objectSpread(_objectSpread({}, filter), {}, {\n      yAxis: matchedAxis\n    }, getFilterPlot(_objectSpread(_objectSpread({}, filter), {}, {\n      yAxis: matchedAxis\n    }), dataset)) : filter;\n  }\n  return filter;\n}\n/**\n * Get default filter prop based on field type\n *\n * @param field\n * @param fieldDomain\n * @returns default filter\n * @type {typeof import('./filter-utils').getFilterProps}\n */\n\nfunction getFilterProps(field, fieldDomain) {\n  var filterProps = _objectSpread(_objectSpread({}, fieldDomain), {}, {\n    fieldType: field.type\n  });\n  switch (field.type) {\n    case _defaultSettings.ALL_FIELD_TYPES.real:\n    case _defaultSettings.ALL_FIELD_TYPES.integer:\n      return _objectSpread(_objectSpread({}, filterProps), {}, {\n        value: fieldDomain.domain,\n        type: _defaultSettings.FILTER_TYPES.range,\n        typeOptions: [_defaultSettings.FILTER_TYPES.range],\n        gpu: true\n      });\n    case _defaultSettings.ALL_FIELD_TYPES[\"boolean\"]:\n      return _objectSpread(_objectSpread({}, filterProps), {}, {\n        type: _defaultSettings.FILTER_TYPES.select,\n        value: true,\n        gpu: false\n      });\n    case _defaultSettings.ALL_FIELD_TYPES.string:\n    case _defaultSettings.ALL_FIELD_TYPES.date:\n      return _objectSpread(_objectSpread({}, filterProps), {}, {\n        type: _defaultSettings.FILTER_TYPES.multiSelect,\n        value: [],\n        gpu: false\n      });\n    case _defaultSettings.ALL_FIELD_TYPES.timestamp:\n      return _objectSpread(_objectSpread({}, filterProps), {}, {\n        type: _defaultSettings.FILTER_TYPES.timeRange,\n        enlarged: true,\n        fixedDomain: true,\n        value: filterProps.domain,\n        gpu: true\n      });\n    default:\n      return {};\n  }\n}\nvar getPolygonFilterFunctor = function getPolygonFilterFunctor(layer, filter, dataContainer) {\n  var getPosition = layer.getPositionAccessor(dataContainer);\n  switch (layer.type) {\n    case _types.LAYER_TYPES.point:\n    case _types.LAYER_TYPES.icon:\n      return function (data) {\n        var pos = getPosition(data);\n        return pos.every(Number.isFinite) && isInPolygon(pos, filter.value);\n      };\n    case _types.LAYER_TYPES.arc:\n    case _types.LAYER_TYPES.line:\n      return function (data) {\n        var pos = getPosition(data);\n        return pos.every(Number.isFinite) && [[pos[0], pos[1]], [pos[3], pos[4]]].every(function (point) {\n          return isInPolygon(point, filter.value);\n        });\n      };\n    case _types.LAYER_TYPES.hexagonId:\n      if (layer.dataToFeature && layer.dataToFeature.centroids) {\n        return function (data) {\n          // null or getCentroid({id})\n          var centroid = layer.dataToFeature.centroids[data.index];\n          return centroid && isInPolygon(centroid, filter.value);\n        };\n      }\n      return function (data) {\n        var id = getPosition(data);\n        if (!(0, _h3Utils.h3IsValid)(id)) {\n          return false;\n        }\n        var pos = (0, _h3Utils.getCentroid)({\n          id: id\n        });\n        return pos.every(Number.isFinite) && isInPolygon(pos, filter.value);\n      };\n    default:\n      return function () {\n        return true;\n      };\n  }\n};\n/**\n * @param field dataset Field\n * @param dataId Dataset id\n * @param filter Filter object\n * @param layers list of layers to filter upon\n * @param dataContainer Data container\n * @return filterFunction\n * @type {typeof import('./filter-utils').getFilterFunction}\n */\n\nexports.getPolygonFilterFunctor = getPolygonFilterFunctor;\nfunction getFilterFunction(field, dataId, filter, layers, dataContainer) {\n  // field could be null in polygon filter\n  var valueAccessor = field ? field.valueAccessor : function (data) {\n    return null;\n  };\n  var defaultFunc = function defaultFunc(d) {\n    return true;\n  };\n  switch (filter.type) {\n    case _defaultSettings.FILTER_TYPES.range:\n      return function (data) {\n        return isInRange(valueAccessor(data), filter.value);\n      };\n    case _defaultSettings.FILTER_TYPES.multiSelect:\n      return function (data) {\n        return filter.value.includes(valueAccessor(data));\n      };\n    case _defaultSettings.FILTER_TYPES.select:\n      return function (data) {\n        return valueAccessor(data) === filter.value;\n      };\n    case _defaultSettings.FILTER_TYPES.timeRange:\n      if (!field) {\n        return defaultFunc;\n      }\n      var mappedValue = (0, _lodash[\"default\"])(field, ['filterProps', 'mappedValue']);\n      var accessor = Array.isArray(mappedValue) ? function (data) {\n        return mappedValue[data.index];\n      } : function (data) {\n        return (0, _dataUtils.timeToUnixMilli)(valueAccessor(data), field.format);\n      };\n      return function (data) {\n        return isInRange(accessor(data), filter.value);\n      };\n    case _defaultSettings.FILTER_TYPES.polygon:\n      if (!layers || !layers.length) {\n        return defaultFunc;\n      } // @ts-ignore\n\n      var layerFilterFunctions = filter.layerId.map(function (id) {\n        return layers.find(function (l) {\n          return l.id === id;\n        });\n      }).filter(function (l) {\n        return l && l.config.dataId === dataId;\n      }).map(function (layer) {\n        return getPolygonFilterFunctor(layer, filter, dataContainer);\n      });\n      return function (data) {\n        return layerFilterFunctions.every(function (filterFunc) {\n          return filterFunc(data);\n        });\n      };\n    default:\n      return defaultFunc;\n  }\n}\nfunction updateFilterDataId(dataId) {\n  return getDefaultFilter(dataId);\n}\n/**\n * @type {typeof import('./filter-utils').filterDataByFilterTypes}\n */\n\nfunction filterDataByFilterTypes(_ref2, dataContainer) {\n  var dynamicDomainFilters = _ref2.dynamicDomainFilters,\n    cpuFilters = _ref2.cpuFilters,\n    filterFuncs = _ref2.filterFuncs;\n  var result = _objectSpread(_objectSpread({}, dynamicDomainFilters ? {\n    filteredIndexForDomain: []\n  } : {}), cpuFilters ? {\n    filteredIndex: []\n  } : {});\n  var filterContext = {\n    index: -1,\n    dataContainer: dataContainer\n  };\n  var filterFuncCaller = function filterFuncCaller(filter) {\n    return filterFuncs[filter.id](filterContext);\n  };\n  var numRows = dataContainer.numRows();\n  for (var i = 0; i < numRows; ++i) {\n    filterContext.index = i;\n    var matchForDomain = dynamicDomainFilters && dynamicDomainFilters.every(filterFuncCaller);\n    if (matchForDomain) {\n      // @ts-ignore\n      result.filteredIndexForDomain.push(filterContext.index);\n    }\n    var matchForRender = cpuFilters && cpuFilters.every(filterFuncCaller);\n    if (matchForRender) {\n      // @ts-ignore\n      result.filteredIndex.push(filterContext.index);\n    }\n  }\n  return result;\n}\n/**\n * Get a record of filters based on domain type and gpu / cpu\n * @type {typeof import('./filter-utils').getFilterRecord}\n */\n\nfunction getFilterRecord(dataId, filters) {\n  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  /**\n   * @type {FilterRecord}\n   */\n  var filterRecord = {\n    dynamicDomain: [],\n    fixedDomain: [],\n    cpu: [],\n    gpu: []\n  };\n  filters.forEach(function (f) {\n    if (isValidFilterValue(f.type, f.value) && (0, _utils.toArray)(f.dataId).includes(dataId)) {\n      (f.fixedDomain || opt.ignoreDomain ? filterRecord.fixedDomain : filterRecord.dynamicDomain).push(f);\n      (f.gpu && !opt.cpuOnly ? filterRecord.gpu : filterRecord.cpu).push(f);\n    }\n  });\n  return filterRecord;\n}\n/**\n * Compare filter records to get what has changed\n * @type {typeof import('./filter-utils').diffFilters}\n */\n\nfunction diffFilters(filterRecord) {\n  var oldFilterRecord = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var filterChanged = {};\n  Object.entries(filterRecord).forEach(function (_ref3) {\n    var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n      record = _ref4[0],\n      items = _ref4[1];\n    items.forEach(function (filter) {\n      var oldFilter = (oldFilterRecord[record] || []).find(function (f) {\n        return f.id === filter.id;\n      });\n      if (!oldFilter) {\n        // added\n        filterChanged = (0, _utils.set)([record, filter.id], 'added', filterChanged);\n      } else {\n        // check  what has changed\n        ['name', 'value', 'dataId'].forEach(function (prop) {\n          if (filter[prop] !== oldFilter[prop]) {\n            filterChanged = (0, _utils.set)([record, filter.id], \"\".concat(prop, \"_changed\"), filterChanged);\n          }\n        });\n      }\n    });\n    (oldFilterRecord[record] || []).forEach(function (oldFilter) {\n      // deleted\n      if (!items.find(function (f) {\n        return f.id === oldFilter.id;\n      })) {\n        filterChanged = (0, _utils.set)([record, oldFilter.id], 'deleted', filterChanged);\n      }\n    });\n    if (!filterChanged[record]) {\n      filterChanged[record] = null;\n    }\n  }); // @ts-ignore\n\n  return filterChanged;\n}\n/**\n * Call by parsing filters from URL\n * Check if value of filter within filter domain, if not adjust it to match\n * filter domain\n *\n * @type {typeof import('./filter-utils').adjustValueToFilterDomain}\n * @returns value - adjusted value to match filter or null to remove filter\n */\n\n/* eslint-disable complexity */\n\nfunction adjustValueToFilterDomain(value, _ref5) {\n  var domain = _ref5.domain,\n    type = _ref5.type;\n  if (!domain || !type) {\n    return false;\n  }\n  switch (type) {\n    case _defaultSettings.FILTER_TYPES.range:\n    case _defaultSettings.FILTER_TYPES.timeRange:\n      if (!Array.isArray(value) || value.length !== 2) {\n        return domain.map(function (d) {\n          return d;\n        });\n      }\n      return value.map(function (d, i) {\n        return (0, _dataUtils.notNullorUndefined)(d) && isInRange(d, domain) ? d : domain[i];\n      });\n    case _defaultSettings.FILTER_TYPES.multiSelect:\n      if (!Array.isArray(value)) {\n        return [];\n      }\n      var filteredValue = value.filter(function (d) {\n        return domain.includes(d);\n      });\n      return filteredValue.length ? filteredValue : [];\n    case _defaultSettings.FILTER_TYPES.select:\n      return domain.includes(value) ? value : true;\n    default:\n      return null;\n  }\n}\n/* eslint-enable complexity */\n\n/**\n * Calculate numeric domain and suitable step\n *\n * @type {typeof import('./filter-utils').getNumericFieldDomain}\n */\n\nfunction getNumericFieldDomain(dataContainer, valueAccessor) {\n  var domain = [0, 1];\n  var step = 0.1;\n  var mappedValue = dataContainer.mapIndex(valueAccessor);\n  if (dataContainer.numRows() > 1) {\n    domain = ScaleUtils.getLinearDomain(mappedValue);\n    var diff = domain[1] - domain[0]; // in case equal domain, [96, 96], which will break quantize scale\n\n    if (!diff) {\n      domain[1] = domain[0] + 1;\n    }\n    step = getNumericStepSize(diff) || step;\n    domain[0] = formatNumberByStep(domain[0], step, 'floor');\n    domain[1] = formatNumberByStep(domain[1], step, 'ceil');\n  } // @ts-ignore\n\n  var _getHistogram = getHistogram(domain, mappedValue),\n    histogram = _getHistogram.histogram,\n    enlargedHistogram = _getHistogram.enlargedHistogram;\n  return {\n    domain: domain,\n    step: step,\n    histogram: histogram,\n    enlargedHistogram: enlargedHistogram\n  };\n}\n/**\n * Calculate step size for range and timerange filter\n *\n * @type {typeof import('./filter-utils').getNumericStepSize}\n */\n\nfunction getNumericStepSize(diff) {\n  diff = Math.abs(diff);\n  if (diff > 100) {\n    return 1;\n  } else if (diff > 3) {\n    return 0.01;\n  } else if (diff > 1) {\n    return 0.001;\n  } // Try to get at least 1000 steps - and keep the step size below that of\n  // the (diff > 1) case.\n\n  var x = diff / 1000; // Find the exponent and truncate to 10 to the power of that exponent\n\n  var exponentialForm = x.toExponential();\n  var exponent = parseFloat(exponentialForm.split('e')[1]); // Getting ready for node 12\n  // this is why we need decimal.js\n  // Math.pow(10, -5) = 0.000009999999999999999\n  // the above result shows in browser and node 10\n  // node 12 behaves correctly\n\n  return new _decimal.Decimal(10).pow(exponent).toNumber();\n}\n/**\n * Calculate timestamp domain and suitable step\n * @type {typeof import('./filter-utils').getTimestampFieldDomain}\n */\n\nfunction getTimestampFieldDomain(dataContainer, valueAccessor) {\n  // to avoid converting string format time to epoch\n  // every time we compare we store a value mapped to int in filter domain\n  var mappedValue = dataContainer.mapIndex(valueAccessor);\n  var domain = ScaleUtils.getLinearDomain(mappedValue);\n  var defaultTimeFormat = getTimeWidgetTitleFormatter(domain);\n  var step = 0.01;\n  var diff = domain[1] - domain[0];\n  var entry = TimestampStepMap.find(function (f) {\n    return f.max >= diff;\n  });\n  if (entry) {\n    step = entry.step;\n  }\n  var _getHistogram2 = getHistogram(domain, mappedValue),\n    histogram = _getHistogram2.histogram,\n    enlargedHistogram = _getHistogram2.enlargedHistogram;\n  return {\n    domain: domain,\n    step: step,\n    mappedValue: mappedValue,\n    histogram: histogram,\n    enlargedHistogram: enlargedHistogram,\n    defaultTimeFormat: defaultTimeFormat\n  };\n}\n/**\n *\n * @type {typeof import('./filter-utils').histogramConstruct}\n */\n\nfunction histogramConstruct(domain, mappedValue, bins) {\n  return (0, _d3Array.histogram)().thresholds((0, _d3Array.ticks)(domain[0], domain[1], bins)).domain(domain)(mappedValue).map(function (bin) {\n    return {\n      count: bin.length,\n      x0: bin.x0,\n      x1: bin.x1\n    };\n  });\n}\n/**\n * Calculate histogram from domain and array of values\n *\n * @type {typeof import('./filter-utils').getHistogram}\n */\n\nfunction getHistogram(domain, mappedValue) {\n  var histogram = histogramConstruct(domain, mappedValue, histogramBins);\n  var enlargedHistogram = histogramConstruct(domain, mappedValue, enlargedHistogramBins);\n  return {\n    histogram: histogram,\n    enlargedHistogram: enlargedHistogram\n  };\n}\n/**\n * round number based on step\n *\n * @param {Number} val\n * @param {Number} step\n * @param {string} bound\n * @returns {Number} rounded number\n */\n\nfunction formatNumberByStep(val, step, bound) {\n  if (bound === 'floor') {\n    return Math.floor(val * (1 / step)) / (1 / step);\n  }\n  return Math.ceil(val * (1 / step)) / (1 / step);\n}\n/**\n *\n * @type {typeof import('./filter-utils').isInRange}\n */\n\nfunction isInRange(val, domain) {\n  if (!Array.isArray(domain)) {\n    return false;\n  }\n  return val >= domain[0] && val <= domain[1];\n}\n/**\n * Determines whether a point is within the provided polygon\n *\n * @param point as input search [lat, lng]\n * @param polygon Points must be within these (Multi)Polygon(s)\n * @return {boolean}\n */\n\nfunction isInPolygon(point, polygon) {\n  return (0, _booleanWithin[\"default\"])((0, _helpers.point)(point), polygon);\n}\nfunction isValidTimeDomain(domain) {\n  return Array.isArray(domain) && domain.every(Number.isFinite);\n}\nfunction getTimeWidgetTitleFormatter(domain) {\n  if (!isValidTimeDomain(domain)) {\n    return null;\n  }\n  var diff = domain[1] - domain[0]; // Local aware formats\n  // https://momentjs.com/docs/#/parsing/string-format\n\n  return diff > durationYear ? 'L' : diff > durationDay ? 'L LT' : 'L LTS';\n}\nfunction getTimeWidgetHintFormatter(domain) {\n  if (!isValidTimeDomain(domain)) {\n    return null;\n  }\n  var diff = domain[1] - domain[0];\n  return diff > durationWeek ? 'L' : diff > durationDay ? 'L LT' : diff > durationHour ? 'LT' : 'LTS';\n}\n/**\n * Sanity check on filters to prepare for save\n * @type {typeof import('./filter-utils').isValidFilterValue}\n */\n\n/* eslint-disable complexity */\n\nfunction isValidFilterValue(type, value) {\n  if (!type) {\n    return false;\n  }\n  switch (type) {\n    case _defaultSettings.FILTER_TYPES.select:\n      return value === true || value === false;\n    case _defaultSettings.FILTER_TYPES.range:\n    case _defaultSettings.FILTER_TYPES.timeRange:\n      return Array.isArray(value) && value.every(function (v) {\n        return v !== null && !isNaN(v);\n      });\n    case _defaultSettings.FILTER_TYPES.multiSelect:\n      return Array.isArray(value) && Boolean(value.length);\n    case _defaultSettings.FILTER_TYPES.input:\n      return Boolean(value.length);\n    case _defaultSettings.FILTER_TYPES.polygon:\n      var coordinates = (0, _lodash[\"default\"])(value, ['geometry', 'coordinates']);\n      return Boolean(value && value.id && coordinates);\n    default:\n      return true;\n  }\n}\n/**\n *\n * @type {typeof import('./filter-utils').getFilterPlot}\n */\n\nfunction getFilterPlot(filter, dataset) {\n  if (filter.plotType === PLOT_TYPES.histogram || !filter.yAxis) {\n    // histogram should be calculated when create filter\n    return {};\n  }\n  var _filter$mappedValue = filter.mappedValue,\n    mappedValue = _filter$mappedValue === void 0 ? [] : _filter$mappedValue;\n  var yAxis = filter.yAxis;\n  var fieldIdx = dataset.getColumnFieldIdx(yAxis.name);\n  if (fieldIdx < 0) {\n    _console.console.warn(\"yAxis \".concat(yAxis.name, \" does not exist in dataset\"));\n    return {\n      lineChart: {},\n      yAxis: yAxis\n    };\n  } // return lineChart\n\n  var series = dataset.dataContainer.map(function (row, rowIndex) {\n    return {\n      x: mappedValue[rowIndex],\n      y: row.valueAt(fieldIdx)\n    };\n  }, true).filter(function (_ref6) {\n    var x = _ref6.x,\n      y = _ref6.y;\n    return Number.isFinite(x) && Number.isFinite(y);\n  }).sort(function (a, b) {\n    return (0, _d3Array.ascending)(a.x, b.x);\n  });\n  var yDomain = (0, _d3Array.extent)(series, function (d) {\n    return d.y;\n  });\n  var xDomain = [series[0].x, series[series.length - 1].x];\n  return {\n    lineChart: {\n      series: series,\n      yDomain: yDomain,\n      xDomain: xDomain\n    },\n    yAxis: yAxis\n  };\n}\nfunction getDefaultFilterPlotType(filter) {\n  var filterPlotTypes = SupportedPlotType[filter.type];\n  if (!filterPlotTypes) {\n    return null;\n  }\n  if (!filter.yAxis) {\n    return filterPlotTypes[\"default\"];\n  }\n  return filterPlotTypes[filter.yAxis.type] || null;\n}\n/**\n *\n * @param datasetIds list of dataset ids to be filtered\n * @param datasets all datasets\n * @param filters all filters to be applied to datasets\n * @return datasets - new updated datasets\n * @type {typeof import('./filter-utils').applyFiltersToDatasets}\n */\n\nfunction applyFiltersToDatasets(datasetIds, datasets, filters, layers) {\n  var dataIds = (0, _utils.toArray)(datasetIds);\n  return dataIds.reduce(function (acc, dataId) {\n    var layersToFilter = (layers || []).filter(function (l) {\n      return l.config.dataId === dataId;\n    });\n    var appliedFilters = filters.filter(function (d) {\n      return shouldApplyFilter(d, dataId);\n    });\n    var table = datasets[dataId];\n    return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, dataId, table.filterTable(appliedFilters, layersToFilter, {})));\n  }, datasets);\n}\n/**\n * Applies a new field name value to fielter and update both filter and dataset\n * @param filter - to be applied the new field name on\n * @param dataset - dataset the field belongs to\n * @param fieldName - field.name\n * @param filterDatasetIndex - field.name\n * @param option\n * @return - {filter, datasets}\n * @type {typeof import('./filter-utils').applyFilterFieldName}\n */\n\nfunction applyFilterFieldName(filter, dataset, fieldName) {\n  var filterDatasetIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var option = arguments.length > 4 ? arguments[4] : undefined;\n  // using filterDatasetIndex we can filter only the specified dataset\n  var mergeDomain = option && option.hasOwnProperty('mergeDomain') ? option.mergeDomain : false;\n  var fieldIndex = dataset.getColumnFieldIdx(fieldName); // if no field with same name is found, move to the next datasets\n\n  if (fieldIndex === -1) {\n    // throw new Error(`fieldIndex not found. Dataset must contain a property with name: ${fieldName}`);\n    return {\n      filter: null,\n      dataset: dataset\n    };\n  } // TODO: validate field type\n\n  var filterProps = dataset.getColumnFilterProps(fieldName);\n  var newFilter = _objectSpread(_objectSpread({}, mergeDomain ? mergeFilterDomainStep(filter, filterProps) : _objectSpread(_objectSpread({}, filter), filterProps)), {}, {\n    name: Object.assign((0, _toConsumableArray2[\"default\"])((0, _utils.toArray)(filter.name)), (0, _defineProperty2[\"default\"])({}, filterDatasetIndex, fieldName)),\n    fieldIdx: Object.assign((0, _toConsumableArray2[\"default\"])((0, _utils.toArray)(filter.fieldIdx)), (0, _defineProperty2[\"default\"])({}, filterDatasetIndex, fieldIndex)),\n    // TODO, since we allow to add multiple fields to a filter we can no longer freeze the filter\n    freeze: true\n  });\n  return {\n    filter: newFilter,\n    dataset: dataset\n  };\n}\n/**\n * Merge one filter with other filter prop domain\n * @type {typeof import('./filter-utils').mergeFilterDomainStep}\n */\n\n/* eslint-disable complexity */\n\nfunction mergeFilterDomainStep(filter, filterProps) {\n  if (!filter) {\n    return null;\n  }\n  if (!filterProps) {\n    return filter;\n  }\n  if (filter.fieldType && filter.fieldType !== filterProps.fieldType || !filterProps.domain) {\n    return filter;\n  }\n  var combinedDomain = !filter.domain ? filterProps.domain : [].concat((0, _toConsumableArray2[\"default\"])(filter.domain || []), (0, _toConsumableArray2[\"default\"])(filterProps.domain || [])).sort(function (a, b) {\n    return a - b;\n  });\n  var newFilter = _objectSpread(_objectSpread(_objectSpread({}, filter), filterProps), {}, {\n    domain: [combinedDomain[0], combinedDomain[combinedDomain.length - 1]]\n  });\n  switch (filterProps.fieldType) {\n    case _defaultSettings.ALL_FIELD_TYPES.string:\n    case _defaultSettings.ALL_FIELD_TYPES.date:\n      return _objectSpread(_objectSpread({}, newFilter), {}, {\n        domain: (0, _dataUtils.unique)(combinedDomain).sort()\n      });\n    case _defaultSettings.ALL_FIELD_TYPES.timestamp:\n      // @ts-ignore\n      var step = filter.step < filterProps.step ? filter.step : filterProps.step;\n      return _objectSpread(_objectSpread({}, newFilter), {}, {\n        step: step\n      });\n    case _defaultSettings.ALL_FIELD_TYPES.real:\n    case _defaultSettings.ALL_FIELD_TYPES.integer:\n    default:\n      return newFilter;\n  }\n}\n/* eslint-enable complexity */\n\n/**\n * Generates polygon filter\n * @type {typeof import('./filter-utils').featureToFilterValue}\n */\n\nvar featureToFilterValue = function featureToFilterValue(feature, filterId) {\n  var properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return _objectSpread(_objectSpread({}, feature), {}, {\n    id: feature.id,\n    properties: _objectSpread(_objectSpread(_objectSpread({}, feature.properties), properties), {}, {\n      filterId: filterId\n    })\n  });\n};\n/**\n * @type {typeof import('./filter-utils').getFilterIdInFeature}\n */\n\nexports.featureToFilterValue = featureToFilterValue;\nvar getFilterIdInFeature = function getFilterIdInFeature(f) {\n  return (0, _lodash[\"default\"])(f, ['properties', 'filterId']);\n};\n/**\n * Generates polygon filter\n * @type {typeof import('./filter-utils').generatePolygonFilter}\n */\n\nexports.getFilterIdInFeature = getFilterIdInFeature;\nfunction generatePolygonFilter(layers, feature) {\n  var dataId = layers.map(function (l) {\n    return l.config.dataId;\n  }).filter(function (d) {\n    return d;\n  });\n  var layerId = layers.map(function (l) {\n    return l.id;\n  });\n  var name = layers.map(function (l) {\n    return l.config.label;\n  }); // @ts-ignore\n\n  var filter = getDefaultFilter(dataId);\n  return _objectSpread(_objectSpread({}, filter), {}, {\n    fixedDomain: true,\n    type: _defaultSettings.FILTER_TYPES.polygon,\n    name: name,\n    layerId: layerId,\n    value: featureToFilterValue(feature, filter.id, {\n      isVisible: true\n    })\n  });\n}\n/**\n * Run filter entirely on CPU\n * @type {typeof import('./filter-utils').filterDatasetCPU}\n */\n\nfunction filterDatasetCPU(state, dataId) {\n  var datasetFilters = state.filters.filter(function (f) {\n    return f.dataId.includes(dataId);\n  });\n  var dataset = state.datasets[dataId];\n  if (!dataset) {\n    return state;\n  }\n  var cpuFilteredDataset = dataset.filterTableCPU(datasetFilters, state.layers);\n  return (0, _utils.set)(['datasets', dataId], cpuFilteredDataset, state);\n}\n/**\n * Validate parsed filters with datasets and add filterProps to field\n * @type {typeof import('./filter-utils').validateFiltersUpdateDatasets}\n */\n\nfunction validateFiltersUpdateDatasets(state) {\n  var filtersToValidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var validated = [];\n  var failed = [];\n  var datasets = state.datasets;\n  var updatedDatasets = datasets; // merge filters\n\n  filtersToValidate.forEach(function (filter) {\n    // we can only look for datasets define in the filter dataId\n    var datasetIds = (0, _utils.toArray)(filter.dataId); // we can merge a filter only if all datasets in filter.dataId are loaded\n\n    if (datasetIds.every(function (d) {\n      return datasets[d];\n    })) {\n      // all datasetIds in filter must be present the state datasets\n      var _datasetIds$reduce = datasetIds.reduce(function (acc, datasetId) {\n          var dataset = updatedDatasets[datasetId];\n          var layers = state.layers.filter(function (l) {\n            return l.config.dataId === dataset.id;\n          });\n          var _validateFilterWithDa = validateFilterWithData(acc.augmentedDatasets[datasetId] || dataset, filter, layers),\n            updatedFilter = _validateFilterWithDa.filter,\n            updatedDataset = _validateFilterWithDa.dataset;\n          if (updatedFilter) {\n            return _objectSpread(_objectSpread({}, acc), {}, {\n              // merge filter props\n              filter: acc.filter ? _objectSpread(_objectSpread({}, acc.filter), mergeFilterDomainStep(acc, updatedFilter)) : updatedFilter,\n              applyToDatasets: [].concat((0, _toConsumableArray2[\"default\"])(acc.applyToDatasets), [datasetId]),\n              augmentedDatasets: _objectSpread(_objectSpread({}, acc.augmentedDatasets), {}, (0, _defineProperty2[\"default\"])({}, datasetId, updatedDataset))\n            });\n          }\n          return acc;\n        }, {\n          filter: null,\n          applyToDatasets: [],\n          augmentedDatasets: {}\n        }),\n        validatedFilter = _datasetIds$reduce.filter,\n        applyToDatasets = _datasetIds$reduce.applyToDatasets,\n        augmentedDatasets = _datasetIds$reduce.augmentedDatasets;\n      if (validatedFilter && (0, _lodash2[\"default\"])(datasetIds, applyToDatasets)) {\n        validated.push(validatedFilter);\n        updatedDatasets = _objectSpread(_objectSpread({}, updatedDatasets), augmentedDatasets);\n      }\n    } else {\n      failed.push(filter);\n    }\n  });\n  return {\n    validated: validated,\n    failed: failed,\n    updatedDatasets: updatedDatasets\n  };\n}\n/**\n * Retrieve interval bins for time filter\n * @type {typeof import('./filter-utils').getIntervalBins}\n */\n\nfunction getIntervalBins(filter) {\n  var _filter$plotType;\n  var bins = filter.bins;\n  var interval = (_filter$plotType = filter.plotType) === null || _filter$plotType === void 0 ? void 0 : _filter$plotType.interval;\n  if (!interval || !bins || Object.keys(bins).length === 0) {\n    return null;\n  }\n  var values = Object.values(bins);\n  return values[0] ? values[0][interval] : null;\n}","map":{"version":3,"names":["_d3Array","require","_keymirror","_interopRequireDefault","_console","_lodash","_lodash2","_booleanWithin","_helpers","_decimal","_defaultSettings","_dataUtils","ScaleUtils","_interopRequireWildcard","_types","_utils","_h3Utils","TimestampStepMap","max","step","Number","POSITIVE_INFINITY","histogramBins","enlargedHistogramBins","durationSecond","durationMinute","durationHour","durationDay","durationWeek","durationYear","PLOT_TYPES","histogram","lineChart","FILTER_UPDATER_PROPS","dataId","name","layerId","LIMITED_FILTER_EFFECT_PROPS","_defineProperty2","SupportedPlotType","_SupportedPlotType","FILTER_TYPES","timeRange","_FILTER_TYPES$timeRan","ALL_FIELD_TYPES","integer","real","range","_FILTER_TYPES$range","FILTER_COMPONENTS","_FILTER_COMPONENTS","select","multiSelect","polygon","DEFAULT_FILTER_STRUCTURE","freeze","id","fixedDomain","enlarged","isAnimating","animationWindow","ANIMATION_WINDOW","free","speed","type","fieldIdx","domain","value","plotType","yAxis","interval","gpu","FILTER_ID_LENGTH","LAYER_FILTERS","getDefaultFilter","_objectSpread","toArray","generateHashId","shouldApplyFilter","filter","datasetId","dataIds","includes","validatePolygonFilter","dataset","layers","failed","isValidFilterValue","isValidDataset","layer","find","l","filterValidators","validateFilter","filterDataId","filterDatasetIndex","indexOf","initializeFilter","fieldName","_applyFilterFieldName","applyFilterFieldName","mergeDomain","updatedFilter","updatedDataset","adjustValueToFilterDomain","validateFilterYAxis","validateFilterWithData","hasOwnProperty","fields","_filter","matchedAxis","_ref","getFilterPlot","getFilterProps","field","fieldDomain","filterProps","fieldType","typeOptions","string","date","timestamp","getPolygonFilterFunctor","dataContainer","getPosition","getPositionAccessor","LAYER_TYPES","point","icon","data","pos","every","isFinite","isInPolygon","arc","line","hexagonId","dataToFeature","centroids","centroid","index","h3IsValid","getCentroid","getFilterFunction","valueAccessor","defaultFunc","d","isInRange","mappedValue","accessor","Array","isArray","timeToUnixMilli","format","length","layerFilterFunctions","map","config","filterFunc","updateFilterDataId","filterDataByFilterTypes","_ref2","dynamicDomainFilters","cpuFilters","filterFuncs","result","filteredIndexForDomain","filteredIndex","filterContext","filterFuncCaller","numRows","i","matchForDomain","push","matchForRender","getFilterRecord","filters","opt","arguments","undefined","filterRecord","dynamicDomain","cpu","forEach","f","ignoreDomain","cpuOnly","diffFilters","oldFilterRecord","filterChanged","Object","entries","_ref3","_ref4","_slicedToArray2","record","items","oldFilter","set","prop","concat","_ref5","notNullorUndefined","filteredValue","getNumericFieldDomain","mapIndex","getLinearDomain","diff","getNumericStepSize","formatNumberByStep","_getHistogram","getHistogram","enlargedHistogram","Math","abs","x","exponentialForm","toExponential","exponent","parseFloat","split","Decimal","pow","toNumber","getTimestampFieldDomain","defaultTimeFormat","getTimeWidgetTitleFormatter","entry","_getHistogram2","histogramConstruct","bins","thresholds","ticks","bin","count","x0","x1","val","bound","floor","ceil","isValidTimeDomain","getTimeWidgetHintFormatter","v","isNaN","Boolean","input","coordinates","_filter$mappedValue","getColumnFieldIdx","console","warn","series","row","rowIndex","y","valueAt","_ref6","sort","a","b","ascending","yDomain","extent","xDomain","getDefaultFilterPlotType","filterPlotTypes","applyFiltersToDatasets","datasetIds","datasets","reduce","acc","layersToFilter","appliedFilters","table","filterTable","option","fieldIndex","getColumnFilterProps","newFilter","mergeFilterDomainStep","assign","_toConsumableArray2","combinedDomain","unique","featureToFilterValue","feature","filterId","properties","getFilterIdInFeature","generatePolygonFilter","label","isVisible","filterDatasetCPU","state","datasetFilters","cpuFilteredDataset","filterTableCPU","validateFiltersUpdateDatasets","filtersToValidate","validated","updatedDatasets","_datasetIds$reduce","_validateFilterWithDa","augmentedDatasets","applyToDatasets","validatedFilter","getIntervalBins","_filter$plotType","keys","values"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/kepler.gl/src/utils/filter-utils.js"],"sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {ascending, extent, histogram as d3Histogram, ticks} from 'd3-array';\nimport keyMirror from 'keymirror';\nimport {console as Console} from 'global/console';\nimport get from 'lodash.get';\nimport isEqual from 'lodash.isequal';\n\nimport booleanWithin from '@turf/boolean-within';\nimport {point as turfPoint} from '@turf/helpers';\nimport {Decimal} from 'decimal.js';\nimport {ALL_FIELD_TYPES, FILTER_TYPES, ANIMATION_WINDOW} from 'constants/default-settings';\nimport {notNullorUndefined, unique, timeToUnixMilli} from './data-utils';\nimport * as ScaleUtils from './data-scale-utils';\nimport {LAYER_TYPES} from 'layers/types';\nimport {generateHashId, set, toArray} from './utils';\nimport {getCentroid, h3IsValid} from 'layers/h3-hexagon-layer/h3-utils';\n\n// TYPE\n/** @typedef {import('./table-utils/kepler-table').FilterRecord} FilterRecord */\n/** @typedef {import('./filter-utils').FilterResult} FilterResult */\n\nexport const TimestampStepMap = [\n  {max: 1, step: 0.05},\n  {max: 10, step: 0.1},\n  {max: 100, step: 1},\n  {max: 500, step: 5},\n  {max: 1000, step: 10},\n  {max: 5000, step: 50},\n  {max: Number.POSITIVE_INFINITY, step: 1000}\n];\n\nexport const histogramBins = 30;\nexport const enlargedHistogramBins = 100;\n\nconst durationSecond = 1000;\nconst durationMinute = durationSecond * 60;\nconst durationHour = durationMinute * 60;\nconst durationDay = durationHour * 24;\nconst durationWeek = durationDay * 7;\nconst durationYear = durationDay * 365;\n\nexport const PLOT_TYPES = keyMirror({\n  histogram: null,\n  lineChart: null\n});\n\nexport const FILTER_UPDATER_PROPS = keyMirror({\n  dataId: null,\n  name: null,\n  layerId: null\n});\n\nexport const LIMITED_FILTER_EFFECT_PROPS = keyMirror({\n  [FILTER_UPDATER_PROPS.name]: null\n});\n/**\n * Max number of filter value buffers that deck.gl provides\n */\n\nconst SupportedPlotType = {\n  [FILTER_TYPES.timeRange]: {\n    default: 'histogram',\n    [ALL_FIELD_TYPES.integer]: 'lineChart',\n    [ALL_FIELD_TYPES.real]: 'lineChart'\n  },\n  [FILTER_TYPES.range]: {\n    default: 'histogram',\n    [ALL_FIELD_TYPES.integer]: 'lineChart',\n    [ALL_FIELD_TYPES.real]: 'lineChart'\n  }\n};\n\nexport const FILTER_COMPONENTS = {\n  [FILTER_TYPES.select]: 'SingleSelectFilter',\n  [FILTER_TYPES.multiSelect]: 'MultiSelectFilter',\n  [FILTER_TYPES.timeRange]: 'TimeRangeFilter',\n  [FILTER_TYPES.range]: 'RangeFilter',\n  [FILTER_TYPES.polygon]: 'PolygonFilter'\n};\n\nexport const DEFAULT_FILTER_STRUCTURE = {\n  dataId: [], // [string]\n  freeze: false,\n  id: null,\n\n  // time range filter specific\n  fixedDomain: false,\n  enlarged: false,\n  isAnimating: false,\n  animationWindow: ANIMATION_WINDOW.free,\n  speed: 1,\n\n  // field specific\n  name: [], // string\n  type: null,\n  fieldIdx: [], // [integer]\n  domain: null,\n  value: null,\n\n  // plot\n  plotType: PLOT_TYPES.histogram,\n  yAxis: null,\n  interval: null,\n\n  // mode\n  gpu: false\n};\n\nexport const FILTER_ID_LENGTH = 4;\n\nexport const LAYER_FILTERS = [FILTER_TYPES.polygon];\n\n/**\n * Generates a filter with a dataset id as dataId\n * @type {typeof import('./filter-utils').getDefaultFilter}\n */\nexport function getDefaultFilter(dataId) {\n  return {\n    ...DEFAULT_FILTER_STRUCTURE,\n    // store it as dataId and it could be one or many\n    dataId: toArray(dataId),\n    id: generateHashId(FILTER_ID_LENGTH)\n  };\n}\n\n/**\n * Check if a filter is valid based on the given dataId\n * @param  filter to validate\n * @param  datasetId id to validate filter against\n * @return true if a filter is valid, false otherwise\n * @type {typeof import('./filter-utils').shouldApplyFilter}\n */\nexport function shouldApplyFilter(filter, datasetId) {\n  const dataIds = toArray(filter.dataId);\n  return dataIds.includes(datasetId) && filter.value !== null;\n}\n\n/**\n * Validates and modifies polygon filter structure\n * @param dataset\n * @param filter\n * @param layers\n * @return - {filter, dataset}\n * @type {typeof import('./filter-utils').validatePolygonFilter}\n */\nexport function validatePolygonFilter(dataset, filter, layers) {\n  const failed = {dataset, filter: null};\n  const {value, layerId, type, dataId} = filter;\n\n  if (!layerId || !isValidFilterValue(type, value)) {\n    return failed;\n  }\n\n  const isValidDataset = dataId.includes(dataset.id);\n\n  if (!isValidDataset) {\n    return failed;\n  }\n\n  const layer = layers.find(l => layerId.includes(l.id));\n\n  if (!layer) {\n    return failed;\n  }\n\n  return {\n    filter: {\n      ...filter,\n      freeze: true,\n      fieldIdx: []\n    },\n    dataset\n  };\n}\n\n/**\n * Custom filter validators\n */\nconst filterValidators = {\n  [FILTER_TYPES.polygon]: validatePolygonFilter\n};\n\n/**\n * Default validate filter function\n * @param dataset\n * @param filter\n * @return - {filter, dataset}\n * @type {typeof import('./filter-utils').validateFilter}\n */\nexport function validateFilter(dataset, filter) {\n  // match filter.dataId\n  const failed = {dataset, filter: null};\n  const filterDataId = toArray(filter.dataId);\n\n  const filterDatasetIndex = filterDataId.indexOf(dataset.id);\n  if (filterDatasetIndex < 0) {\n    // the current filter is not mapped against the current dataset\n    return failed;\n  }\n\n  const initializeFilter = {\n    ...getDefaultFilter(filter.dataId),\n    ...filter,\n    dataId: filterDataId,\n    name: toArray(filter.name)\n  };\n\n  const fieldName = initializeFilter.name[filterDatasetIndex];\n  const {filter: updatedFilter, dataset: updatedDataset} = applyFilterFieldName(\n    initializeFilter,\n    dataset,\n    fieldName,\n    filterDatasetIndex,\n    {mergeDomain: true}\n  );\n\n  if (!updatedFilter) {\n    return failed;\n  }\n\n  updatedFilter.value = adjustValueToFilterDomain(filter.value, updatedFilter);\n  updatedFilter.enlarged =\n    typeof filter.enlarged === 'boolean' ? filter.enlarged : updatedFilter.enlarged;\n\n  if (updatedFilter.value === null) {\n    // cannot adjust saved value to filter\n    return failed;\n  }\n\n  return {\n    filter: validateFilterYAxis(updatedFilter, updatedDataset),\n    dataset: updatedDataset\n  };\n}\n\n/**\n * Validate saved filter config with new data,\n * calculate domain and fieldIdx based new fields and data\n *\n * @param dataset\n * @param filter - filter to be validate\n * @param layers - layers\n * @return validated filter\n * @type {typeof import('./filter-utils').validateFilterWithData}\n */\nexport function validateFilterWithData(dataset, filter, layers) {\n  // @ts-ignore\n  return filterValidators.hasOwnProperty(filter.type)\n    ? filterValidators[filter.type](dataset, filter, layers)\n    : validateFilter(dataset, filter);\n}\n\n/**\n * Validate YAxis\n * @param filter\n * @param dataset\n * @return {*}\n */\nfunction validateFilterYAxis(filter, dataset) {\n  // TODO: validate yAxis against other datasets\n\n  const {fields} = dataset;\n  const {yAxis} = filter;\n  // TODO: validate yAxis against other datasets\n  if (yAxis) {\n    const matchedAxis = fields.find(({name, type}) => name === yAxis.name && type === yAxis.type);\n\n    filter = matchedAxis\n      ? {\n          ...filter,\n          yAxis: matchedAxis,\n          ...getFilterPlot({...filter, yAxis: matchedAxis}, dataset)\n        }\n      : filter;\n  }\n\n  return filter;\n}\n\n/**\n * Get default filter prop based on field type\n *\n * @param field\n * @param fieldDomain\n * @returns default filter\n * @type {typeof import('./filter-utils').getFilterProps}\n */\nexport function getFilterProps(field, fieldDomain) {\n  const filterProps = {\n    ...fieldDomain,\n    fieldType: field.type\n  };\n\n  switch (field.type) {\n    case ALL_FIELD_TYPES.real:\n    case ALL_FIELD_TYPES.integer:\n      return {\n        ...filterProps,\n        value: fieldDomain.domain,\n        type: FILTER_TYPES.range,\n        typeOptions: [FILTER_TYPES.range],\n        gpu: true\n      };\n\n    case ALL_FIELD_TYPES.boolean:\n      return {\n        ...filterProps,\n        type: FILTER_TYPES.select,\n        value: true,\n        gpu: false\n      };\n\n    case ALL_FIELD_TYPES.string:\n    case ALL_FIELD_TYPES.date:\n      return {\n        ...filterProps,\n        type: FILTER_TYPES.multiSelect,\n        value: [],\n        gpu: false\n      };\n\n    case ALL_FIELD_TYPES.timestamp:\n      return {\n        ...filterProps,\n        type: FILTER_TYPES.timeRange,\n        enlarged: true,\n        fixedDomain: true,\n        value: filterProps.domain,\n        gpu: true\n      };\n\n    default:\n      return {};\n  }\n}\n\nexport const getPolygonFilterFunctor = (layer, filter, dataContainer) => {\n  const getPosition = layer.getPositionAccessor(dataContainer);\n\n  switch (layer.type) {\n    case LAYER_TYPES.point:\n    case LAYER_TYPES.icon:\n      return data => {\n        const pos = getPosition(data);\n        return pos.every(Number.isFinite) && isInPolygon(pos, filter.value);\n      };\n    case LAYER_TYPES.arc:\n    case LAYER_TYPES.line:\n      return data => {\n        const pos = getPosition(data);\n        return (\n          pos.every(Number.isFinite) &&\n          [\n            [pos[0], pos[1]],\n            [pos[3], pos[4]]\n          ].every(point => isInPolygon(point, filter.value))\n        );\n      };\n    case LAYER_TYPES.hexagonId:\n      if (layer.dataToFeature && layer.dataToFeature.centroids) {\n        return data => {\n          // null or getCentroid({id})\n          const centroid = layer.dataToFeature.centroids[data.index];\n          return centroid && isInPolygon(centroid, filter.value);\n        };\n      }\n      return data => {\n        const id = getPosition(data);\n        if (!h3IsValid(id)) {\n          return false;\n        }\n        const pos = getCentroid({id});\n        return pos.every(Number.isFinite) && isInPolygon(pos, filter.value);\n      };\n    default:\n      return () => true;\n  }\n};\n\n/**\n * @param field dataset Field\n * @param dataId Dataset id\n * @param filter Filter object\n * @param layers list of layers to filter upon\n * @param dataContainer Data container\n * @return filterFunction\n * @type {typeof import('./filter-utils').getFilterFunction}\n */\nexport function getFilterFunction(field, dataId, filter, layers, dataContainer) {\n  // field could be null in polygon filter\n  const valueAccessor = field ? field.valueAccessor : data => null;\n  const defaultFunc = d => true;\n\n  switch (filter.type) {\n    case FILTER_TYPES.range:\n      return data => isInRange(valueAccessor(data), filter.value);\n    case FILTER_TYPES.multiSelect:\n      return data => filter.value.includes(valueAccessor(data));\n    case FILTER_TYPES.select:\n      return data => valueAccessor(data) === filter.value;\n    case FILTER_TYPES.timeRange:\n      if (!field) {\n        return defaultFunc;\n      }\n      const mappedValue = get(field, ['filterProps', 'mappedValue']);\n      const accessor = Array.isArray(mappedValue)\n        ? data => mappedValue[data.index]\n        : data => timeToUnixMilli(valueAccessor(data), field.format);\n      return data => isInRange(accessor(data), filter.value);\n    case FILTER_TYPES.polygon:\n      if (!layers || !layers.length) {\n        return defaultFunc;\n      }\n      // @ts-ignore\n      const layerFilterFunctions = filter.layerId\n        .map(id => layers.find(l => l.id === id))\n        .filter(l => l && l.config.dataId === dataId)\n        .map(layer => getPolygonFilterFunctor(layer, filter, dataContainer));\n\n      return data => layerFilterFunctions.every(filterFunc => filterFunc(data));\n    default:\n      return defaultFunc;\n  }\n}\n\nexport function updateFilterDataId(dataId) {\n  return getDefaultFilter(dataId);\n}\n\n/**\n * @type {typeof import('./filter-utils').filterDataByFilterTypes}\n */\nexport function filterDataByFilterTypes(\n  {dynamicDomainFilters, cpuFilters, filterFuncs},\n  dataContainer\n) {\n  const result = {\n    ...(dynamicDomainFilters ? {filteredIndexForDomain: []} : {}),\n    ...(cpuFilters ? {filteredIndex: []} : {})\n  };\n\n  const filterContext = {index: -1, dataContainer};\n  const filterFuncCaller = filter => filterFuncs[filter.id](filterContext);\n\n  const numRows = dataContainer.numRows();\n  for (let i = 0; i < numRows; ++i) {\n    filterContext.index = i;\n\n    const matchForDomain = dynamicDomainFilters && dynamicDomainFilters.every(filterFuncCaller);\n    if (matchForDomain) {\n      // @ts-ignore\n      result.filteredIndexForDomain.push(filterContext.index);\n    }\n\n    const matchForRender = cpuFilters && cpuFilters.every(filterFuncCaller);\n    if (matchForRender) {\n      // @ts-ignore\n      result.filteredIndex.push(filterContext.index);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Get a record of filters based on domain type and gpu / cpu\n * @type {typeof import('./filter-utils').getFilterRecord}\n */\nexport function getFilterRecord(dataId, filters, opt = {}) {\n  /**\n   * @type {FilterRecord}\n   */\n  const filterRecord = {\n    dynamicDomain: [],\n    fixedDomain: [],\n    cpu: [],\n    gpu: []\n  };\n\n  filters.forEach(f => {\n    if (isValidFilterValue(f.type, f.value) && toArray(f.dataId).includes(dataId)) {\n      (f.fixedDomain || opt.ignoreDomain\n        ? filterRecord.fixedDomain\n        : filterRecord.dynamicDomain\n      ).push(f);\n\n      (f.gpu && !opt.cpuOnly ? filterRecord.gpu : filterRecord.cpu).push(f);\n    }\n  });\n\n  return filterRecord;\n}\n\n/**\n * Compare filter records to get what has changed\n * @type {typeof import('./filter-utils').diffFilters}\n */\nexport function diffFilters(filterRecord, oldFilterRecord = {}) {\n  let filterChanged = {};\n\n  Object.entries(filterRecord).forEach(([record, items]) => {\n    items.forEach(filter => {\n      const oldFilter = (oldFilterRecord[record] || []).find(f => f.id === filter.id);\n\n      if (!oldFilter) {\n        // added\n        filterChanged = set([record, filter.id], 'added', filterChanged);\n      } else {\n        // check  what has changed\n        ['name', 'value', 'dataId'].forEach(prop => {\n          if (filter[prop] !== oldFilter[prop]) {\n            filterChanged = set([record, filter.id], `${prop}_changed`, filterChanged);\n          }\n        });\n      }\n    });\n\n    (oldFilterRecord[record] || []).forEach(oldFilter => {\n      // deleted\n      if (!items.find(f => f.id === oldFilter.id)) {\n        filterChanged = set([record, oldFilter.id], 'deleted', filterChanged);\n      }\n    });\n\n    if (!filterChanged[record]) {\n      filterChanged[record] = null;\n    }\n  });\n\n  // @ts-ignore\n  return filterChanged;\n}\n/**\n * Call by parsing filters from URL\n * Check if value of filter within filter domain, if not adjust it to match\n * filter domain\n *\n * @type {typeof import('./filter-utils').adjustValueToFilterDomain}\n * @returns value - adjusted value to match filter or null to remove filter\n */\n/* eslint-disable complexity */\nexport function adjustValueToFilterDomain(value, {domain, type}) {\n  if (!domain || !type) {\n    return false;\n  }\n\n  switch (type) {\n    case FILTER_TYPES.range:\n    case FILTER_TYPES.timeRange:\n      if (!Array.isArray(value) || value.length !== 2) {\n        return domain.map(d => d);\n      }\n\n      return value.map((d, i) => (notNullorUndefined(d) && isInRange(d, domain) ? d : domain[i]));\n\n    case FILTER_TYPES.multiSelect:\n      if (!Array.isArray(value)) {\n        return [];\n      }\n      const filteredValue = value.filter(d => domain.includes(d));\n      return filteredValue.length ? filteredValue : [];\n\n    case FILTER_TYPES.select:\n      return domain.includes(value) ? value : true;\n\n    default:\n      return null;\n  }\n}\n/* eslint-enable complexity */\n\n/**\n * Calculate numeric domain and suitable step\n *\n * @type {typeof import('./filter-utils').getNumericFieldDomain}\n */\nexport function getNumericFieldDomain(dataContainer, valueAccessor) {\n  let domain = [0, 1];\n  let step = 0.1;\n\n  const mappedValue = dataContainer.mapIndex(valueAccessor);\n\n  if (dataContainer.numRows() > 1) {\n    domain = ScaleUtils.getLinearDomain(mappedValue);\n    const diff = domain[1] - domain[0];\n\n    // in case equal domain, [96, 96], which will break quantize scale\n    if (!diff) {\n      domain[1] = domain[0] + 1;\n    }\n\n    step = getNumericStepSize(diff) || step;\n    domain[0] = formatNumberByStep(domain[0], step, 'floor');\n    domain[1] = formatNumberByStep(domain[1], step, 'ceil');\n  }\n\n  // @ts-ignore\n  const {histogram, enlargedHistogram} = getHistogram(domain, mappedValue);\n\n  return {domain, step, histogram, enlargedHistogram};\n}\n\n/**\n * Calculate step size for range and timerange filter\n *\n * @type {typeof import('./filter-utils').getNumericStepSize}\n */\nexport function getNumericStepSize(diff) {\n  diff = Math.abs(diff);\n\n  if (diff > 100) {\n    return 1;\n  } else if (diff > 3) {\n    return 0.01;\n  } else if (diff > 1) {\n    return 0.001;\n  }\n  // Try to get at least 1000 steps - and keep the step size below that of\n  // the (diff > 1) case.\n  const x = diff / 1000;\n  // Find the exponent and truncate to 10 to the power of that exponent\n\n  const exponentialForm = x.toExponential();\n  const exponent = parseFloat(exponentialForm.split('e')[1]);\n\n  // Getting ready for node 12\n  // this is why we need decimal.js\n  // Math.pow(10, -5) = 0.000009999999999999999\n  // the above result shows in browser and node 10\n  // node 12 behaves correctly\n  return new Decimal(10).pow(exponent).toNumber();\n}\n\n/**\n * Calculate timestamp domain and suitable step\n * @type {typeof import('./filter-utils').getTimestampFieldDomain}\n */\nexport function getTimestampFieldDomain(dataContainer, valueAccessor) {\n  // to avoid converting string format time to epoch\n  // every time we compare we store a value mapped to int in filter domain\n\n  const mappedValue = dataContainer.mapIndex(valueAccessor);\n  const domain = ScaleUtils.getLinearDomain(mappedValue);\n  const defaultTimeFormat = getTimeWidgetTitleFormatter(domain);\n\n  let step = 0.01;\n\n  const diff = domain[1] - domain[0];\n  const entry = TimestampStepMap.find(f => f.max >= diff);\n  if (entry) {\n    step = entry.step;\n  }\n\n  const {histogram, enlargedHistogram} = getHistogram(domain, mappedValue);\n\n  return {\n    domain,\n    step,\n    mappedValue,\n    histogram,\n    enlargedHistogram,\n    defaultTimeFormat\n  };\n}\n\n/**\n *\n * @type {typeof import('./filter-utils').histogramConstruct}\n */\nexport function histogramConstruct(domain, mappedValue, bins) {\n  return d3Histogram()\n    .thresholds(ticks(domain[0], domain[1], bins))\n    .domain(domain)(mappedValue)\n    .map(bin => ({\n      count: bin.length,\n      x0: bin.x0,\n      x1: bin.x1\n    }));\n}\n/**\n * Calculate histogram from domain and array of values\n *\n * @type {typeof import('./filter-utils').getHistogram}\n */\nexport function getHistogram(domain, mappedValue) {\n  const histogram = histogramConstruct(domain, mappedValue, histogramBins);\n  const enlargedHistogram = histogramConstruct(domain, mappedValue, enlargedHistogramBins);\n\n  return {histogram, enlargedHistogram};\n}\n\n/**\n * round number based on step\n *\n * @param {Number} val\n * @param {Number} step\n * @param {string} bound\n * @returns {Number} rounded number\n */\nexport function formatNumberByStep(val, step, bound) {\n  if (bound === 'floor') {\n    return Math.floor(val * (1 / step)) / (1 / step);\n  }\n\n  return Math.ceil(val * (1 / step)) / (1 / step);\n}\n\n/**\n *\n * @type {typeof import('./filter-utils').isInRange}\n */\nexport function isInRange(val, domain) {\n  if (!Array.isArray(domain)) {\n    return false;\n  }\n\n  return val >= domain[0] && val <= domain[1];\n}\n\n/**\n * Determines whether a point is within the provided polygon\n *\n * @param point as input search [lat, lng]\n * @param polygon Points must be within these (Multi)Polygon(s)\n * @return {boolean}\n */\nexport function isInPolygon(point, polygon) {\n  return booleanWithin(turfPoint(point), polygon);\n}\nexport function isValidTimeDomain(domain) {\n  return Array.isArray(domain) && domain.every(Number.isFinite);\n}\nexport function getTimeWidgetTitleFormatter(domain) {\n  if (!isValidTimeDomain(domain)) {\n    return null;\n  }\n\n  const diff = domain[1] - domain[0];\n\n  // Local aware formats\n  // https://momentjs.com/docs/#/parsing/string-format\n  return diff > durationYear ? 'L' : diff > durationDay ? 'L LT' : 'L LTS';\n}\n\nexport function getTimeWidgetHintFormatter(domain) {\n  if (!isValidTimeDomain(domain)) {\n    return null;\n  }\n\n  const diff = domain[1] - domain[0];\n  return diff > durationWeek\n    ? 'L'\n    : diff > durationDay\n    ? 'L LT'\n    : diff > durationHour\n    ? 'LT'\n    : 'LTS';\n}\n\n/**\n * Sanity check on filters to prepare for save\n * @type {typeof import('./filter-utils').isValidFilterValue}\n */\n/* eslint-disable complexity */\nexport function isValidFilterValue(type, value) {\n  if (!type) {\n    return false;\n  }\n  switch (type) {\n    case FILTER_TYPES.select:\n      return value === true || value === false;\n\n    case FILTER_TYPES.range:\n    case FILTER_TYPES.timeRange:\n      return Array.isArray(value) && value.every(v => v !== null && !isNaN(v));\n\n    case FILTER_TYPES.multiSelect:\n      return Array.isArray(value) && Boolean(value.length);\n\n    case FILTER_TYPES.input:\n      return Boolean(value.length);\n\n    case FILTER_TYPES.polygon:\n      const coordinates = get(value, ['geometry', 'coordinates']);\n      return Boolean(value && value.id && coordinates);\n\n    default:\n      return true;\n  }\n}\n\n/**\n *\n * @type {typeof import('./filter-utils').getFilterPlot}\n */\nexport function getFilterPlot(filter, dataset) {\n  if (filter.plotType === PLOT_TYPES.histogram || !filter.yAxis) {\n    // histogram should be calculated when create filter\n    return {};\n  }\n\n  const {mappedValue = []} = filter;\n  const {yAxis} = filter;\n  const fieldIdx = dataset.getColumnFieldIdx(yAxis.name);\n  if (fieldIdx < 0) {\n    Console.warn(`yAxis ${yAxis.name} does not exist in dataset`);\n    return {lineChart: {}, yAxis};\n  }\n\n  // return lineChart\n  const series = dataset.dataContainer\n    .map(\n      (row, rowIndex) => ({\n        x: mappedValue[rowIndex],\n        y: row.valueAt(fieldIdx)\n      }),\n      true\n    )\n    .filter(({x, y}) => Number.isFinite(x) && Number.isFinite(y))\n    .sort((a, b) => ascending(a.x, b.x));\n\n  const yDomain = extent(series, d => d.y);\n  const xDomain = [series[0].x, series[series.length - 1].x];\n\n  return {lineChart: {series, yDomain, xDomain}, yAxis};\n}\n\nexport function getDefaultFilterPlotType(filter) {\n  const filterPlotTypes = SupportedPlotType[filter.type];\n  if (!filterPlotTypes) {\n    return null;\n  }\n\n  if (!filter.yAxis) {\n    return filterPlotTypes.default;\n  }\n\n  return filterPlotTypes[filter.yAxis.type] || null;\n}\n\n/**\n *\n * @param datasetIds list of dataset ids to be filtered\n * @param datasets all datasets\n * @param filters all filters to be applied to datasets\n * @return datasets - new updated datasets\n * @type {typeof import('./filter-utils').applyFiltersToDatasets}\n */\nexport function applyFiltersToDatasets(datasetIds, datasets, filters, layers) {\n  const dataIds = toArray(datasetIds);\n  return dataIds.reduce((acc, dataId) => {\n    const layersToFilter = (layers || []).filter(l => l.config.dataId === dataId);\n    const appliedFilters = filters.filter(d => shouldApplyFilter(d, dataId));\n    const table = datasets[dataId];\n\n    return {\n      ...acc,\n      [dataId]: table.filterTable(appliedFilters, layersToFilter, {})\n    };\n  }, datasets);\n}\n\n/**\n * Applies a new field name value to fielter and update both filter and dataset\n * @param filter - to be applied the new field name on\n * @param dataset - dataset the field belongs to\n * @param fieldName - field.name\n * @param filterDatasetIndex - field.name\n * @param option\n * @return - {filter, datasets}\n * @type {typeof import('./filter-utils').applyFilterFieldName}\n */\nexport function applyFilterFieldName(filter, dataset, fieldName, filterDatasetIndex = 0, option) {\n  // using filterDatasetIndex we can filter only the specified dataset\n  const mergeDomain = option && option.hasOwnProperty('mergeDomain') ? option.mergeDomain : false;\n\n  const fieldIndex = dataset.getColumnFieldIdx(fieldName);\n  // if no field with same name is found, move to the next datasets\n  if (fieldIndex === -1) {\n    // throw new Error(`fieldIndex not found. Dataset must contain a property with name: ${fieldName}`);\n    return {filter: null, dataset};\n  }\n\n  // TODO: validate field type\n  const filterProps = dataset.getColumnFilterProps(fieldName);\n\n  const newFilter = {\n    ...(mergeDomain ? mergeFilterDomainStep(filter, filterProps) : {...filter, ...filterProps}),\n    name: Object.assign([...toArray(filter.name)], {[filterDatasetIndex]: fieldName}),\n    fieldIdx: Object.assign([...toArray(filter.fieldIdx)], {\n      [filterDatasetIndex]: fieldIndex\n    }),\n    // TODO, since we allow to add multiple fields to a filter we can no longer freeze the filter\n    freeze: true\n  };\n\n  return {\n    filter: newFilter,\n    dataset\n  };\n}\n\n/**\n * Merge one filter with other filter prop domain\n * @type {typeof import('./filter-utils').mergeFilterDomainStep}\n */\n/* eslint-disable complexity */\nexport function mergeFilterDomainStep(filter, filterProps) {\n  if (!filter) {\n    return null;\n  }\n\n  if (!filterProps) {\n    return filter;\n  }\n\n  if ((filter.fieldType && filter.fieldType !== filterProps.fieldType) || !filterProps.domain) {\n    return filter;\n  }\n\n  const combinedDomain = !filter.domain\n    ? filterProps.domain\n    : [...(filter.domain || []), ...(filterProps.domain || [])].sort((a, b) => a - b);\n\n  const newFilter = {\n    ...filter,\n    ...filterProps,\n    domain: [combinedDomain[0], combinedDomain[combinedDomain.length - 1]]\n  };\n\n  switch (filterProps.fieldType) {\n    case ALL_FIELD_TYPES.string:\n    case ALL_FIELD_TYPES.date:\n      return {\n        ...newFilter,\n        domain: unique(combinedDomain).sort()\n      };\n\n    case ALL_FIELD_TYPES.timestamp:\n      // @ts-ignore\n      const step = filter.step < filterProps.step ? filter.step : filterProps.step;\n\n      return {\n        ...newFilter,\n        step\n      };\n    case ALL_FIELD_TYPES.real:\n    case ALL_FIELD_TYPES.integer:\n    default:\n      return newFilter;\n  }\n}\n/* eslint-enable complexity */\n\n/**\n * Generates polygon filter\n * @type {typeof import('./filter-utils').featureToFilterValue}\n */\nexport const featureToFilterValue = (feature, filterId, properties = {}) => ({\n  ...feature,\n  id: feature.id,\n  properties: {\n    ...feature.properties,\n    ...properties,\n    filterId\n  }\n});\n\n/**\n * @type {typeof import('./filter-utils').getFilterIdInFeature}\n */\nexport const getFilterIdInFeature = f => get(f, ['properties', 'filterId']);\n\n/**\n * Generates polygon filter\n * @type {typeof import('./filter-utils').generatePolygonFilter}\n */\nexport function generatePolygonFilter(layers, feature) {\n  const dataId = layers.map(l => l.config.dataId).filter(d => d);\n  const layerId = layers.map(l => l.id);\n  const name = layers.map(l => l.config.label);\n  // @ts-ignore\n  const filter = getDefaultFilter(dataId);\n  return {\n    ...filter,\n    fixedDomain: true,\n    type: FILTER_TYPES.polygon,\n    name,\n    layerId,\n    value: featureToFilterValue(feature, filter.id, {isVisible: true})\n  };\n}\n\n/**\n * Run filter entirely on CPU\n * @type {typeof import('./filter-utils').filterDatasetCPU}\n */\nexport function filterDatasetCPU(state, dataId) {\n  const datasetFilters = state.filters.filter(f => f.dataId.includes(dataId));\n  const dataset = state.datasets[dataId];\n\n  if (!dataset) {\n    return state;\n  }\n\n  const cpuFilteredDataset = dataset.filterTableCPU(datasetFilters, state.layers);\n\n  return set(['datasets', dataId], cpuFilteredDataset, state);\n}\n\n/**\n * Validate parsed filters with datasets and add filterProps to field\n * @type {typeof import('./filter-utils').validateFiltersUpdateDatasets}\n */\nexport function validateFiltersUpdateDatasets(state, filtersToValidate = []) {\n  const validated = [];\n  const failed = [];\n  const {datasets} = state;\n  let updatedDatasets = datasets;\n\n  // merge filters\n  filtersToValidate.forEach(filter => {\n    // we can only look for datasets define in the filter dataId\n    const datasetIds = toArray(filter.dataId);\n\n    // we can merge a filter only if all datasets in filter.dataId are loaded\n    if (datasetIds.every(d => datasets[d])) {\n      // all datasetIds in filter must be present the state datasets\n      const {filter: validatedFilter, applyToDatasets, augmentedDatasets} = datasetIds.reduce(\n        (acc, datasetId) => {\n          const dataset = updatedDatasets[datasetId];\n          const layers = state.layers.filter(l => l.config.dataId === dataset.id);\n          const {filter: updatedFilter, dataset: updatedDataset} = validateFilterWithData(\n            acc.augmentedDatasets[datasetId] || dataset,\n            filter,\n            layers\n          );\n\n          if (updatedFilter) {\n            return {\n              ...acc,\n              // merge filter props\n              filter: acc.filter\n                ? {\n                    ...acc.filter,\n                    ...mergeFilterDomainStep(acc, updatedFilter)\n                  }\n                : updatedFilter,\n\n              applyToDatasets: [...acc.applyToDatasets, datasetId],\n\n              augmentedDatasets: {\n                ...acc.augmentedDatasets,\n                [datasetId]: updatedDataset\n              }\n            };\n          }\n\n          return acc;\n        },\n        {\n          filter: null,\n          applyToDatasets: [],\n          augmentedDatasets: {}\n        }\n      );\n\n      if (validatedFilter && isEqual(datasetIds, applyToDatasets)) {\n        validated.push(validatedFilter);\n        updatedDatasets = {\n          ...updatedDatasets,\n          ...augmentedDatasets\n        };\n      }\n    } else {\n      failed.push(filter);\n    }\n  });\n\n  return {validated, failed, updatedDatasets};\n}\n\n/**\n * Retrieve interval bins for time filter\n * @type {typeof import('./filter-utils').getIntervalBins}\n */\nexport function getIntervalBins(filter) {\n  const {bins} = filter;\n  const interval = filter.plotType?.interval;\n  if (!interval || !bins || Object.keys(bins).length === 0) {\n    return null;\n  }\n  const values = Object.values(bins);\n  return values[0] ? values[0][interval] : null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}