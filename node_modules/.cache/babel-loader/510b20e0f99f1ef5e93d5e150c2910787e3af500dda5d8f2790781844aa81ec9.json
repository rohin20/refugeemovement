{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isGeoJson = isGeoJson;\nexports.isFeature = isFeature;\nexports.isFeatureCollection = isFeatureCollection;\nexports.isRowObject = isRowObject;\nexports.isKeplerGlMap = isKeplerGlMap;\nexports.makeProgressIterator = makeProgressIterator;\nexports.readBatch = readBatch;\nexports.readFileInBatches = readFileInBatches;\nexports.processFileData = processFileData;\nexports.filesToDataPayload = filesToDataPayload;\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _awaitAsyncGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/awaitAsyncGenerator\"));\nvar _wrapAsyncGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/wrapAsyncGenerator\"));\nvar _asyncIterator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncIterator\"));\nvar _core = require(\"@loaders.gl/core\");\nvar _json = require(\"@loaders.gl/json\");\nvar _csv = require(\"@loaders.gl/csv\");\nvar _dataProcessor = require(\"./data-processor\");\nvar _utils = require(\"@kepler.gl/utils\");\nvar _constants = require(\"@kepler.gl/constants\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar BATCH_TYPE = {\n  METADATA: 'metadata',\n  PARTIAL_RESULT: 'partial-result',\n  FINAL_RESULT: 'final-result'\n};\nvar CSV_LOADER_OPTIONS = {\n  shape: 'object-row-table',\n  dynamicTyping: false // not working for now\n};\n\nvar JSON_LOADER_OPTIONS = {\n  shape: 'object-row-table',\n  // instruct loaders.gl on what json paths to stream\n  jsonpaths: ['$',\n  // JSON Row array\n  '$.features',\n  // GeoJSON\n  '$.datasets' // KeplerGL JSON\n  ]\n};\n\nfunction isGeoJson(json) {\n  // json can be feature collection\n  // or single feature\n  return (0, _utils.isPlainObject)(json) && (isFeature(json) || isFeatureCollection(json));\n}\nfunction isFeature(json) {\n  return (0, _utils.isPlainObject)(json) && json.type === 'Feature' && Boolean(json.geometry);\n}\nfunction isFeatureCollection(json) {\n  return (0, _utils.isPlainObject)(json) && json.type === 'FeatureCollection' && Boolean(json.features);\n}\nfunction isRowObject(json) {\n  return Array.isArray(json) && (0, _utils.isPlainObject)(json[0]);\n}\nfunction isKeplerGlMap(json) {\n  return Boolean((0, _utils.isPlainObject)(json) && json.datasets && json.config && json.info && (0, _utils.isPlainObject)(json.info) && json.info.app === 'kepler.gl');\n}\nfunction makeProgressIterator(_x, _x2) {\n  return _makeProgressIterator.apply(this, arguments);\n} // eslint-disable-next-line complexity\n\nfunction _makeProgressIterator() {\n  _makeProgressIterator = (0, _wrapAsyncGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(asyncIterator, info) {\n    var rowCount, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, rowCountInBatch, percent, progress;\n    return _regenerator[\"default\"].wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            rowCount = 0;\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context.prev = 3;\n            _iterator = (0, _asyncIterator2[\"default\"])(asyncIterator);\n          case 5:\n            _context.next = 7;\n            return (0, _awaitAsyncGenerator2[\"default\"])(_iterator.next());\n          case 7:\n            _step = _context.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context.next = 11;\n            return (0, _awaitAsyncGenerator2[\"default\"])(_step.value);\n          case 11:\n            _value = _context.sent;\n            if (_iteratorNormalCompletion) {\n              _context.next = 23;\n              break;\n            }\n            batch = _value;\n            rowCountInBatch = batch.data && batch.data.length || 0;\n            rowCount += rowCountInBatch;\n            percent = Number.isFinite(batch.bytesUsed) ? batch.bytesUsed / info.size : null; // Update progress object\n\n            progress = _objectSpread({\n              rowCount: rowCount,\n              rowCountInBatch: rowCountInBatch\n            }, Number.isFinite(percent) ? {\n              percent: percent\n            } : {});\n            _context.next = 20;\n            return _objectSpread(_objectSpread({}, batch), {}, {\n              progress: progress\n            });\n          case 20:\n            _iteratorNormalCompletion = true;\n            _context.next = 5;\n            break;\n          case 23:\n            _context.next = 29;\n            break;\n          case 25:\n            _context.prev = 25;\n            _context.t0 = _context[\"catch\"](3);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n          case 29:\n            _context.prev = 29;\n            _context.prev = 30;\n            if (!(!_iteratorNormalCompletion && _iterator[\"return\"] != null)) {\n              _context.next = 34;\n              break;\n            }\n            _context.next = 34;\n            return (0, _awaitAsyncGenerator2[\"default\"])(_iterator[\"return\"]());\n          case 34:\n            _context.prev = 34;\n            if (!_didIteratorError) {\n              _context.next = 37;\n              break;\n            }\n            throw _iteratorError;\n          case 37:\n            return _context.finish(34);\n          case 38:\n            return _context.finish(29);\n          case 39:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[3, 25, 29, 39], [30,, 34, 38]]);\n  }));\n  return _makeProgressIterator.apply(this, arguments);\n}\nfunction readBatch(_x3, _x4) {\n  return _readBatch.apply(this, arguments);\n}\nfunction _readBatch() {\n  _readBatch = (0, _wrapAsyncGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(asyncIterator, fileName) {\n    var result, batches, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, batch, streamingPath, i;\n    return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            result = null;\n            batches = [];\n            _iteratorNormalCompletion2 = true;\n            _didIteratorError2 = false;\n            _context2.prev = 4;\n            _iterator2 = (0, _asyncIterator2[\"default\"])(asyncIterator);\n          case 6:\n            _context2.next = 8;\n            return (0, _awaitAsyncGenerator2[\"default\"])(_iterator2.next());\n          case 8:\n            _step2 = _context2.sent;\n            _iteratorNormalCompletion2 = _step2.done;\n            _context2.next = 12;\n            return (0, _awaitAsyncGenerator2[\"default\"])(_step2.value);\n          case 12:\n            _value2 = _context2.sent;\n            if (_iteratorNormalCompletion2) {\n              _context2.next = 21;\n              break;\n            }\n            batch = _value2;\n\n            // Last batch will have this special type and will provide all the root\n            // properties of the parsed document.\n            // Only json parse will have `FINAL_RESULT`\n            if (batch.batchType === BATCH_TYPE.FINAL_RESULT) {\n              if (batch.container) {\n                result = _objectSpread({}, batch.container);\n              } // Set the streamed data correctly is Batch json path is set\n              // and the path streamed is not the top level object (jsonpath = '$')\n\n              if (batch.jsonpath && batch.jsonpath.length > 1) {\n                streamingPath = new _json._JSONPath(batch.jsonpath);\n                streamingPath.setFieldAtPath(result, batches);\n              } else if (batch.jsonpath && batch.jsonpath.length === 1) {\n                // The streamed object is a ROW JSON-batch (jsonpath = '$')\n                // row objects\n                result = batches;\n              }\n            } else {\n              for (i = 0; i < batch.data.length; i++) {\n                batches.push(batch.data[i]);\n              }\n            }\n            _context2.next = 18;\n            return _objectSpread(_objectSpread(_objectSpread({}, batch), batch.schema ? {\n              headers: Object.keys(batch.schema)\n            } : {}), {}, {\n              fileName: fileName,\n              // if dataset is CSV, data is set to the raw batches\n              data: result ? result : batches\n            });\n          case 18:\n            _iteratorNormalCompletion2 = true;\n            _context2.next = 6;\n            break;\n          case 21:\n            _context2.next = 27;\n            break;\n          case 23:\n            _context2.prev = 23;\n            _context2.t0 = _context2[\"catch\"](4);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context2.t0;\n          case 27:\n            _context2.prev = 27;\n            _context2.prev = 28;\n            if (!(!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null)) {\n              _context2.next = 32;\n              break;\n            }\n            _context2.next = 32;\n            return (0, _awaitAsyncGenerator2[\"default\"])(_iterator2[\"return\"]());\n          case 32:\n            _context2.prev = 32;\n            if (!_didIteratorError2) {\n              _context2.next = 35;\n              break;\n            }\n            throw _iteratorError2;\n          case 35:\n            return _context2.finish(32);\n          case 36:\n            return _context2.finish(27);\n          case 37:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[4, 23, 27, 37], [28,, 32, 36]]);\n  }));\n  return _readBatch.apply(this, arguments);\n}\nfunction readFileInBatches(_x5) {\n  return _readFileInBatches.apply(this, arguments);\n}\nfunction _readFileInBatches() {\n  _readFileInBatches = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(_ref) {\n    var file, _ref$loaders, loaders, _ref$loadOptions, loadOptions, batchIterator, progressIterator;\n    return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            file = _ref.file, _ref$loaders = _ref.loaders, loaders = _ref$loaders === void 0 ? [] : _ref$loaders, _ref$loadOptions = _ref.loadOptions, loadOptions = _ref$loadOptions === void 0 ? {} : _ref$loadOptions;\n            loaders = [_json.JSONLoader, _csv.CSVLoader].concat((0, _toConsumableArray2[\"default\"])(loaders));\n            loadOptions = _objectSpread({\n              csv: CSV_LOADER_OPTIONS,\n              json: JSON_LOADER_OPTIONS,\n              metadata: true\n            }, loadOptions);\n            _context3.next = 5;\n            return (0, _core.parseInBatches)(file, loaders, loadOptions);\n          case 5:\n            batchIterator = _context3.sent;\n            progressIterator = makeProgressIterator(batchIterator, {\n              size: file.size\n            });\n            return _context3.abrupt(\"return\", readBatch(progressIterator, file.name));\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _readFileInBatches.apply(this, arguments);\n}\nfunction processFileData(_ref2) {\n  var content = _ref2.content,\n    fileCache = _ref2.fileCache;\n  return new Promise(function (resolve, reject) {\n    var data = content.data;\n    var format;\n    var processor;\n    if (isKeplerGlMap(data)) {\n      format = _constants.DATASET_FORMATS.keplergl;\n      processor = _dataProcessor.processKeplerglJSON;\n    } else if (isRowObject(data)) {\n      format = _constants.DATASET_FORMATS.row;\n      processor = _dataProcessor.processRowObject;\n    } else if (isGeoJson(data)) {\n      format = _constants.DATASET_FORMATS.geojson;\n      processor = _dataProcessor.processGeojson;\n    }\n    if (format && processor) {\n      var result = processor(data);\n      resolve([].concat((0, _toConsumableArray2[\"default\"])(fileCache), [{\n        data: result,\n        info: {\n          label: content.fileName,\n          format: format\n        }\n      }]));\n    }\n    reject('Unknown File Format');\n  });\n}\nfunction filesToDataPayload(fileCache) {\n  // seperate out files which could be a single datasets. or a keplergl map json\n  var collection = fileCache.reduce(function (accu, file) {\n    var data = file.data,\n      info = file.info;\n    if ((info === null || info === void 0 ? void 0 : info.format) === _constants.DATASET_FORMATS.keplergl) {\n      // if file contains a single kepler map dataset & config\n      accu.keplerMaps.push(_objectSpread(_objectSpread({}, data), {}, {\n        options: {\n          centerMap: !(data.config && data.config.mapState)\n        }\n      }));\n    } else if (_constants.DATASET_FORMATS[info === null || info === void 0 ? void 0 : info.format]) {\n      // if file contains only data\n      var newDataset = {\n        data: data,\n        info: _objectSpread({\n          id: (info === null || info === void 0 ? void 0 : info.id) || (0, _utils.generateHashId)(4)\n        }, info || {})\n      };\n      accu.datasets.push(newDataset);\n    }\n    return accu;\n  }, {\n    datasets: [],\n    keplerMaps: []\n  }); // add kepler map first with config\n  // add datasets later in one add data call\n\n  return collection.keplerMaps.concat({\n    datasets: collection.datasets\n  });\n}","map":{"version":3,"names":["exports","makeProgressIterator","readFileInBatches","filesToDataPayload","_regenerator","_interopRequireDefault","require","_toConsumableArray2","_asyncToGenerator2","_wrapAsyncGenerator2","_asyncIterator2","_core","_json","_dataProcessor","_utils","_constants","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","BATCH_TYPE","METADATA","PARTIAL_RESULT","FINAL_RESULT","CSV_LOADER_OPTIONS","shape","dynamicTyping","JSON_LOADER_OPTIONS","jsonpaths","isGeoJson","json","isPlainObject","type","Boolean","features","isRowObject","Array","isArray","isKeplerGlMap","datasets","config","info","app","_x","_x2","_makeProgressIterator","arguments","mark","_callee","asyncIterator","rowCount","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","_value","batch","rowCountInBatch","percent","progress","wrap","_callee$","_context","next","sent","done","_awaitAsyncGenerator2","value","data","length","Number","isFinite","bytesUsed","size","_objectSpread","prev","t0","finish","stop","readBatch","_x3","_x4","_readBatch","_callee2","fileName","result","batches","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_value2","streamingPath","i","_context2","container","jsonpath","_JSONPath","schema","headers","_x5","_readFileInBatches","_callee3","_ref","file","_ref$loaders","loaders","_ref$loadOptions","loadOptions","batchIterator","progressIterator","_context3","JSONLoader","_csv","CSVLoader","concat","parseInBatches","abrupt","name","processFileData","_ref2","content","fileCache","Promise","resolve","reject","format","processor","processKeplerglJSON","DATASET_FORMATS","row","geojson","processGeojson","label","collection","reduce","accu","keplergl","keplerMaps","options"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/processors/src/file-handler.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {parseInBatches} from '@loaders.gl/core';\nimport {JSONLoader, _JSONPath} from '@loaders.gl/json';\nimport {CSVLoader} from '@loaders.gl/csv';\nimport {processGeojson, processKeplerglJSON, processRowObject} from './data-processor';\nimport {generateHashId, isPlainObject} from '@kepler.gl/utils';\nimport {DATASET_FORMATS} from '@kepler.gl/constants';\nimport {Loader} from '@loaders.gl/loader-utils';\nimport {FileCacheItem, ValidKeplerGlMap} from './types';\nimport {Feature, AddDataToMapPayload} from '@kepler.gl/types';\nimport {FeatureCollection} from '@turf/helpers';\n\nconst BATCH_TYPE = {\n  METADATA: 'metadata',\n  PARTIAL_RESULT: 'partial-result',\n  FINAL_RESULT: 'final-result'\n};\n\nconst CSV_LOADER_OPTIONS = {\n  shape: 'object-row-table',\n  dynamicTyping: false // not working for now\n};\n\nconst JSON_LOADER_OPTIONS = {\n  shape: 'object-row-table',\n  // instruct loaders.gl on what json paths to stream\n  jsonpaths: [\n    '$', // JSON Row array\n    '$.features', // GeoJSON\n    '$.datasets' // KeplerGL JSON\n  ]\n};\n\nexport function isGeoJson(json: unknown): json is Feature | FeatureCollection {\n  // json can be feature collection\n  // or single feature\n  return isPlainObject(json) && (isFeature(json) || isFeatureCollection(json));\n}\n\nexport function isFeature(json: unknown): json is Feature {\n  return isPlainObject(json) && json.type === 'Feature' && Boolean(json.geometry);\n}\n\nexport function isFeatureCollection(json: unknown): json is FeatureCollection {\n  return isPlainObject(json) && json.type === 'FeatureCollection' && Boolean(json.features);\n}\n\nexport function isRowObject(json: any): boolean {\n  return Array.isArray(json) && isPlainObject(json[0]);\n}\n\nexport function isKeplerGlMap(json: unknown): json is ValidKeplerGlMap {\n  return Boolean(\n    isPlainObject(json) &&\n      json.datasets &&\n      json.config &&\n      json.info &&\n      isPlainObject(json.info) &&\n      json.info.app === 'kepler.gl'\n  );\n}\n\nexport async function* makeProgressIterator(\n  asyncIterator: AsyncIterable<any>,\n  info: {size: number}\n): AsyncGenerator {\n  let rowCount = 0;\n\n  for await (const batch of asyncIterator) {\n    const rowCountInBatch = (batch.data && batch.data.length) || 0;\n    rowCount += rowCountInBatch;\n    const percent = Number.isFinite(batch.bytesUsed) ? batch.bytesUsed / info.size : null;\n\n    // Update progress object\n    const progress = {\n      rowCount,\n      rowCountInBatch,\n      ...(Number.isFinite(percent) ? {percent} : {})\n    };\n\n    yield {...batch, progress};\n  }\n}\n\n// eslint-disable-next-line complexity\nexport async function* readBatch(\n  asyncIterator: AsyncIterable<any>,\n  fileName: string\n): AsyncGenerator {\n  let result = null;\n  const batches = <any>[];\n\n  for await (const batch of asyncIterator) {\n    // Last batch will have this special type and will provide all the root\n    // properties of the parsed document.\n    // Only json parse will have `FINAL_RESULT`\n    if (batch.batchType === BATCH_TYPE.FINAL_RESULT) {\n      if (batch.container) {\n        result = {...batch.container};\n      }\n      // Set the streamed data correctly is Batch json path is set\n      // and the path streamed is not the top level object (jsonpath = '$')\n      if (batch.jsonpath && batch.jsonpath.length > 1) {\n        const streamingPath = new _JSONPath(batch.jsonpath);\n        streamingPath.setFieldAtPath(result, batches);\n      } else if (batch.jsonpath && batch.jsonpath.length === 1) {\n        // The streamed object is a ROW JSON-batch (jsonpath = '$')\n        // row objects\n        result = batches;\n      }\n    } else {\n      for (let i = 0; i < batch.data.length; i++) {\n        batches.push(batch.data[i]);\n      }\n    }\n\n    yield {\n      ...batch,\n      ...(batch.schema ? {headers: Object.keys(batch.schema)} : {}),\n      fileName,\n      // if dataset is CSV, data is set to the raw batches\n      data: result ? result : batches\n    };\n  }\n}\n\nexport async function readFileInBatches({\n  file,\n  loaders = [],\n  loadOptions = {}\n}: {\n  file: File;\n  fileCache: FileCacheItem[];\n  loaders: Loader[];\n  loadOptions: any;\n}): Promise<AsyncGenerator> {\n  loaders = [JSONLoader, CSVLoader, ...loaders];\n  loadOptions = {\n    csv: CSV_LOADER_OPTIONS,\n    json: JSON_LOADER_OPTIONS,\n    metadata: true,\n    ...loadOptions\n  };\n\n  const batchIterator = await parseInBatches(file, loaders, loadOptions);\n  const progressIterator = makeProgressIterator(batchIterator, {size: file.size});\n\n  return readBatch(progressIterator, file.name);\n}\n\nexport function processFileData({\n  content,\n  fileCache\n}: {\n  content: {data: unknown; fileName: string};\n  fileCache: FileCacheItem[];\n}): Promise<FileCacheItem[]> {\n  return new Promise((resolve, reject) => {\n    const {data} = content;\n\n    let format: string | undefined;\n    let processor: Function | undefined;\n    if (isKeplerGlMap(data)) {\n      format = DATASET_FORMATS.keplergl;\n      processor = processKeplerglJSON;\n    } else if (isRowObject(data)) {\n      format = DATASET_FORMATS.row;\n      processor = processRowObject;\n    } else if (isGeoJson(data)) {\n      format = DATASET_FORMATS.geojson;\n      processor = processGeojson;\n    }\n\n    if (format && processor) {\n      const result = processor(data);\n\n      resolve([\n        ...fileCache,\n        {\n          data: result,\n          info: {\n            label: content.fileName,\n            format\n          }\n        }\n      ]);\n    }\n\n    reject('Unknown File Format');\n  });\n}\n\nexport function filesToDataPayload(fileCache: FileCacheItem[]): AddDataToMapPayload[] {\n  // seperate out files which could be a single datasets. or a keplergl map json\n  const collection = fileCache.reduce<{\n    datasets: FileCacheItem[];\n    keplerMaps: AddDataToMapPayload[];\n  }>(\n    (accu, file) => {\n      const {data, info} = file;\n      if (info?.format === DATASET_FORMATS.keplergl) {\n        // if file contains a single kepler map dataset & config\n        accu.keplerMaps.push({\n          ...data,\n          options: {\n            centerMap: !(data.config && data.config.mapState)\n          }\n        });\n      } else if (DATASET_FORMATS[info?.format]) {\n        // if file contains only data\n        const newDataset = {\n          data,\n          info: {\n            id: info?.id || generateHashId(4),\n            ...(info || {})\n          }\n        };\n        accu.datasets.push(newDataset);\n      }\n      return accu;\n    },\n    {datasets: [], keplerMaps: []}\n  );\n\n  // add kepler map first with config\n  // add datasets later in one add data call\n  return collection.keplerMaps.concat({datasets: collection.datasets});\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}