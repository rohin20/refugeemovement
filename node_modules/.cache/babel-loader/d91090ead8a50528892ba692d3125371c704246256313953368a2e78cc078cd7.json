{"ast":null,"code":"import _defineProperty from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { isWebGL } from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport { Program, VertexArray, clear as _clear, TransformFeedback, Buffer, log, isObjectEmpty, uid, assert } from '@luma.gl/webgl';\nimport { getDebugTableForUniforms, getDebugTableForVertexArray, getDebugTableForProgramConfiguration } from '@luma.gl/webgl';\nimport { getBuffersFromGeometry } from './model-utils';\nvar LOG_DRAW_PRIORITY = 2;\nvar LOG_DRAW_TIMEOUT = 10000;\nvar ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\nvar NOOP = function NOOP() {};\nvar DRAW_PARAMS = {};\nvar Model = /*#__PURE__*/function () {\n  function Model(gl) {\n    _classCallCheck(this, Model);\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _props$id = props.id,\n      id = _props$id === void 0 ? uid('model') : _props$id;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0;\n    this.animated = false;\n    this.initialize(props);\n  }\n  _createClass(Model, [{\n    key: \"initialize\",\n    value: function initialize(props) {\n      this.props = {};\n      this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n      this._programManagerState = -1;\n      this._managedProgram = false;\n      var _props$program = props.program,\n        program = _props$program === void 0 ? null : _props$program,\n        vs = props.vs,\n        fs = props.fs,\n        modules = props.modules,\n        defines = props.defines,\n        inject = props.inject,\n        varyings = props.varyings,\n        bufferMode = props.bufferMode,\n        transpileToGLSL100 = props.transpileToGLSL100;\n      this.programProps = {\n        program: program,\n        vs: vs,\n        fs: fs,\n        modules: modules,\n        defines: defines,\n        inject: inject,\n        varyings: varyings,\n        bufferMode: bufferMode,\n        transpileToGLSL100: transpileToGLSL100\n      };\n      this.program = null;\n      this.vertexArray = null;\n      this._programDirty = true;\n      this.userData = {};\n      this.needsRedraw = true;\n      this._attributes = {};\n      this.attributes = {};\n      this.uniforms = {};\n      this.pickable = true;\n      this._checkProgram();\n      this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));\n      this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;\n      this.vertexCount = props.vertexCount || 0;\n      this.geometryBuffers = {};\n      this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n      this._setModelProps(props);\n      this.geometry = {};\n      assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      this._setModelProps(props);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      for (var key in this._attributes) {\n        if (this._attributes[key] !== this.attributes[key]) {\n          this._attributes[key].delete();\n        }\n      }\n      if (this._managedProgram) {\n        this.programManager.release(this.program);\n        this._managedProgram = false;\n      }\n      this.vertexArray.delete();\n      this._deleteGeometryBuffers();\n    }\n  }, {\n    key: \"getDrawMode\",\n    value: function getDrawMode() {\n      return this.drawMode;\n    }\n  }, {\n    key: \"getVertexCount\",\n    value: function getVertexCount() {\n      return this.vertexCount;\n    }\n  }, {\n    key: \"getInstanceCount\",\n    value: function getInstanceCount() {\n      return this.instanceCount;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"getProgram\",\n    value: function getProgram() {\n      return this.program;\n    }\n  }, {\n    key: \"setProgram\",\n    value: function setProgram(props) {\n      var program = props.program,\n        vs = props.vs,\n        fs = props.fs,\n        modules = props.modules,\n        defines = props.defines,\n        inject = props.inject,\n        varyings = props.varyings,\n        bufferMode = props.bufferMode,\n        transpileToGLSL100 = props.transpileToGLSL100;\n      this.programProps = {\n        program: program,\n        vs: vs,\n        fs: fs,\n        modules: modules,\n        defines: defines,\n        inject: inject,\n        varyings: varyings,\n        bufferMode: bufferMode,\n        transpileToGLSL100: transpileToGLSL100\n      };\n      this._programDirty = true;\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms() {\n      return this.uniforms;\n    }\n  }, {\n    key: \"setDrawMode\",\n    value: function setDrawMode(drawMode) {\n      this.drawMode = drawMode;\n      return this;\n    }\n  }, {\n    key: \"setVertexCount\",\n    value: function setVertexCount(vertexCount) {\n      assert(Number.isFinite(vertexCount));\n      this.vertexCount = vertexCount;\n      return this;\n    }\n  }, {\n    key: \"setInstanceCount\",\n    value: function setInstanceCount(instanceCount) {\n      assert(Number.isFinite(instanceCount));\n      this.instanceCount = instanceCount;\n      return this;\n    }\n  }, {\n    key: \"setGeometry\",\n    value: function setGeometry(geometry) {\n      this.drawMode = geometry.drawMode;\n      this.vertexCount = geometry.getVertexCount();\n      this._deleteGeometryBuffers();\n      this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n      this.vertexArray.setAttributes(this.geometryBuffers);\n      return this;\n    }\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes() {\n      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (isObjectEmpty(attributes)) {\n        return this;\n      }\n      var normalizedAttributes = {};\n      for (var name in attributes) {\n        var attribute = attributes[name];\n        normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n      }\n      this.vertexArray.setAttributes(normalizedAttributes);\n      return this;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.assign(this.uniforms, uniforms);\n      return this;\n    }\n  }, {\n    key: \"getModuleUniforms\",\n    value: function getModuleUniforms(opts) {\n      this._checkProgram();\n      var getUniforms = this.programManager.getUniforms(this.program);\n      if (getUniforms) {\n        return getUniforms(opts);\n      }\n      return {};\n    }\n  }, {\n    key: \"updateModuleSettings\",\n    value: function updateModuleSettings(opts) {\n      var uniforms = this.getModuleUniforms(opts || {});\n      return this.setUniforms(uniforms);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(opts) {\n      _clear(this.program.gl, opts);\n      return this;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this._checkProgram();\n      var _opts$moduleSettings = opts.moduleSettings,\n        moduleSettings = _opts$moduleSettings === void 0 ? null : _opts$moduleSettings,\n        framebuffer = opts.framebuffer,\n        _opts$uniforms = opts.uniforms,\n        uniforms = _opts$uniforms === void 0 ? {} : _opts$uniforms,\n        _opts$attributes = opts.attributes,\n        attributes = _opts$attributes === void 0 ? {} : _opts$attributes,\n        _opts$transformFeedba = opts.transformFeedback,\n        transformFeedback = _opts$transformFeedba === void 0 ? this.transformFeedback : _opts$transformFeedba,\n        _opts$parameters = opts.parameters,\n        parameters = _opts$parameters === void 0 ? {} : _opts$parameters,\n        _opts$vertexArray = opts.vertexArray,\n        vertexArray = _opts$vertexArray === void 0 ? this.vertexArray : _opts$vertexArray;\n      this.setAttributes(attributes);\n      this.updateModuleSettings(moduleSettings);\n      this.setUniforms(uniforms);\n      var logPriority;\n      if (log.priority >= LOG_DRAW_PRIORITY) {\n        logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n      }\n      var drawParams = this.vertexArray.getDrawParams();\n      var _this$props = this.props,\n        _this$props$isIndexed = _this$props.isIndexed,\n        isIndexed = _this$props$isIndexed === void 0 ? drawParams.isIndexed : _this$props$isIndexed,\n        _this$props$indexType = _this$props.indexType,\n        indexType = _this$props$indexType === void 0 ? drawParams.indexType : _this$props$indexType,\n        _this$props$indexOffs = _this$props.indexOffset,\n        indexOffset = _this$props$indexOffs === void 0 ? drawParams.indexOffset : _this$props$indexOffs,\n        _this$props$vertexArr = _this$props.vertexArrayInstanced,\n        vertexArrayInstanced = _this$props$vertexArr === void 0 ? drawParams.isInstanced : _this$props$vertexArr;\n      if (vertexArrayInstanced && !this.isInstanced) {\n        log.warn('Found instanced attributes on non-instanced model', this.id)();\n      }\n      var isInstanced = this.isInstanced,\n        instanceCount = this.instanceCount;\n      var _this$props2 = this.props,\n        _this$props2$onBefore = _this$props2.onBeforeRender,\n        onBeforeRender = _this$props2$onBefore === void 0 ? NOOP : _this$props2$onBefore,\n        _this$props2$onAfterR = _this$props2.onAfterRender,\n        onAfterRender = _this$props2$onAfterR === void 0 ? NOOP : _this$props2$onAfterR;\n      onBeforeRender();\n      this.program.setUniforms(this.uniforms);\n      var didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {\n        logPriority: logPriority,\n        uniforms: null,\n        framebuffer: framebuffer,\n        parameters: parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray: vertexArray,\n        transformFeedback: transformFeedback,\n        isIndexed: isIndexed,\n        indexType: indexType,\n        isInstanced: isInstanced,\n        instanceCount: instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      }));\n      onAfterRender();\n      if (log.priority >= LOG_DRAW_PRIORITY) {\n        this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n      }\n      return didDraw;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _opts$discard = opts.discard,\n        discard = _opts$discard === void 0 ? true : _opts$discard,\n        feedbackBuffers = opts.feedbackBuffers,\n        _opts$unbindModels = opts.unbindModels,\n        unbindModels = _opts$unbindModels === void 0 ? [] : _opts$unbindModels;\n      var parameters = opts.parameters;\n      if (feedbackBuffers) {\n        this._setFeedbackBuffers(feedbackBuffers);\n      }\n      if (discard) {\n        parameters = Object.assign({}, parameters, _defineProperty({}, 35977, discard));\n      }\n      unbindModels.forEach(function (model) {\n        return model.vertexArray.unbindBuffers();\n      });\n      try {\n        this.draw(Object.assign({}, opts, {\n          parameters: parameters\n        }));\n      } finally {\n        unbindModels.forEach(function (model) {\n          return model.vertexArray.bindBuffers();\n        });\n      }\n      return this;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n      return this.setUniforms(uniforms).draw();\n    }\n  }, {\n    key: \"_setModelProps\",\n    value: function _setModelProps(props) {\n      Object.assign(this.props, props);\n      if ('uniforms' in props) {\n        this.setUniforms(props.uniforms);\n      }\n      if ('pickable' in props) {\n        this.pickable = props.pickable;\n      }\n      if ('instanceCount' in props) {\n        this.instanceCount = props.instanceCount;\n      }\n      if ('geometry' in props) {\n        this.setGeometry(props.geometry);\n      }\n      if ('attributes' in props) {\n        this.setAttributes(props.attributes);\n      }\n      if ('_feedbackBuffers' in props) {\n        this._setFeedbackBuffers(props._feedbackBuffers);\n      }\n    }\n  }, {\n    key: \"_checkProgram\",\n    value: function _checkProgram() {\n      var needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;\n      if (!needsUpdate) {\n        return;\n      }\n      var program = this.programProps.program;\n      if (program) {\n        this._managedProgram = false;\n      } else {\n        var _this$programProps = this.programProps,\n          vs = _this$programProps.vs,\n          fs = _this$programProps.fs,\n          modules = _this$programProps.modules,\n          inject = _this$programProps.inject,\n          defines = _this$programProps.defines,\n          varyings = _this$programProps.varyings,\n          bufferMode = _this$programProps.bufferMode,\n          transpileToGLSL100 = _this$programProps.transpileToGLSL100;\n        program = this.programManager.get({\n          vs: vs,\n          fs: fs,\n          modules: modules,\n          inject: inject,\n          defines: defines,\n          varyings: varyings,\n          bufferMode: bufferMode,\n          transpileToGLSL100: transpileToGLSL100\n        });\n        if (this.program && this._managedProgram) {\n          this.programManager.release(this.program);\n        }\n        this._programManagerState = this.programManager.stateHash;\n        this._managedProgram = true;\n      }\n      assert(program instanceof Program, 'Model needs a program');\n      this._programDirty = false;\n      if (program === this.program) {\n        return;\n      }\n      this.program = program;\n      if (this.vertexArray) {\n        this.vertexArray.setProps({\n          program: this.program,\n          attributes: this.vertexArray.attributes\n        });\n      } else {\n        this.vertexArray = new VertexArray(this.gl, {\n          program: this.program\n        });\n      }\n      this.setUniforms(Object.assign({}, this.getModuleUniforms()));\n    }\n  }, {\n    key: \"_deleteGeometryBuffers\",\n    value: function _deleteGeometryBuffers() {\n      for (var name in this.geometryBuffers) {\n        var buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n        if (buffer instanceof Buffer) {\n          buffer.delete();\n        }\n      }\n    }\n  }, {\n    key: \"_setAnimationProps\",\n    value: function _setAnimationProps(animationProps) {\n      if (this.animated) {\n        assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      }\n    }\n  }, {\n    key: \"_setFeedbackBuffers\",\n    value: function _setFeedbackBuffers() {\n      var feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (isObjectEmpty(feedbackBuffers)) {\n        return this;\n      }\n      var gl = this.program.gl;\n      this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {\n        program: this.program\n      });\n      this.transformFeedback.setBuffers(feedbackBuffers);\n      return this;\n    }\n  }, {\n    key: \"_logDrawCallStart\",\n    value: function _logDrawCallStart(logLevel) {\n      var logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n      if (Date.now() - this.lastLogTime < logDrawTimeout) {\n        return undefined;\n      }\n      this.lastLogTime = Date.now();\n      log.group(LOG_DRAW_PRIORITY, \">>> DRAWING MODEL \".concat(this.id), {\n        collapsed: log.level <= 2\n      })();\n      return logLevel;\n    }\n  }, {\n    key: \"_logDrawCallEnd\",\n    value: function _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n      if (logLevel === undefined) {\n        return;\n      }\n      var attributeTable = getDebugTableForVertexArray({\n        vertexArray: vertexArray,\n        header: \"\".concat(this.id, \" attributes\"),\n        attributes: this._attributes\n      });\n      var _getDebugTableForUnif = getDebugTableForUniforms({\n          header: \"\".concat(this.id, \" uniforms\"),\n          program: this.program,\n          uniforms: Object.assign({}, this.program.uniforms, uniforms)\n        }),\n        uniformTable = _getDebugTableForUnif.table,\n        unusedTable = _getDebugTableForUnif.unusedTable,\n        unusedCount = _getDebugTableForUnif.unusedCount;\n      var _getDebugTableForUnif2 = getDebugTableForUniforms({\n          header: \"\".concat(this.id, \" uniforms\"),\n          program: this.program,\n          uniforms: Object.assign({}, this.program.uniforms, uniforms),\n          undefinedOnly: true\n        }),\n        missingTable = _getDebugTableForUnif2.table,\n        missingCount = _getDebugTableForUnif2.count;\n      if (missingCount > 0) {\n        log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      }\n      if (unusedCount > 0) {\n        log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      }\n      var configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n      log.table(logLevel, attributeTable)();\n      log.table(logLevel, uniformTable)();\n      log.table(logLevel + 1, configTable)();\n      if (framebuffer) {\n        framebuffer.log({\n          logLevel: LOG_DRAW_PRIORITY,\n          message: \"Rendered to \".concat(framebuffer.id)\n        });\n      }\n      log.groupEnd(LOG_DRAW_PRIORITY)();\n    }\n  }]);\n  return Model;\n}();\nexport { Model as default };","map":{"version":3,"names":["isWebGL","ProgramManager","Program","VertexArray","clear","TransformFeedback","Buffer","log","isObjectEmpty","uid","assert","getDebugTableForUniforms","getDebugTableForVertexArray","getDebugTableForProgramConfiguration","getBuffersFromGeometry","LOG_DRAW_PRIORITY","LOG_DRAW_TIMEOUT","ERR_MODEL_PARAMS","NOOP","DRAW_PARAMS","Model","gl","_classCallCheck","props","arguments","length","undefined","_props$id","id","lastLogTime","animated","initialize","_createClass","key","value","programManager","getDefaultProgramManager","_programManagerState","_managedProgram","_props$program","program","vs","fs","modules","defines","inject","varyings","bufferMode","transpileToGLSL100","programProps","vertexArray","_programDirty","userData","needsRedraw","_attributes","attributes","uniforms","pickable","_checkProgram","setUniforms","Object","assign","getModuleUniforms","moduleSettings","drawMode","vertexCount","geometryBuffers","isInstanced","instanced","instanceCount","_setModelProps","geometry","Number","isFinite","setProps","_delete","delete","release","_deleteGeometryBuffers","getDrawMode","getVertexCount","getInstanceCount","getAttributes","getProgram","setProgram","getUniforms","setDrawMode","setVertexCount","setInstanceCount","setGeometry","setAttributes","normalizedAttributes","name","attribute","getValue","opts","updateModuleSettings","draw","_opts$moduleSettings","framebuffer","_opts$uniforms","_opts$attributes","_opts$transformFeedba","transformFeedback","_opts$parameters","parameters","_opts$vertexArray","logPriority","priority","_logDrawCallStart","drawParams","getDrawParams","_this$props","_this$props$isIndexed","isIndexed","_this$props$indexType","indexType","_this$props$indexOffs","indexOffset","_this$props$vertexArr","vertexArrayInstanced","warn","_this$props2","_this$props2$onBefore","onBeforeRender","_this$props2$onAfterR","onAfterRender","didDraw","offset","_logDrawCallEnd","transform","_opts$discard","discard","feedbackBuffers","_opts$unbindModels","unbindModels","_setFeedbackBuffers","_defineProperty","forEach","model","unbindBuffers","bindBuffers","render","_feedbackBuffers","needsUpdate","stateHash","_this$programProps","get","buffer","_setAnimationProps","animationProps","setBuffers","logLevel","logDrawTimeout","Date","now","group","concat","collapsed","level","attributeTable","header","_getDebugTableForUnif","uniformTable","table","unusedTable","unusedCount","_getDebugTableForUnif2","undefinedOnly","missingTable","missingCount","count","keys","configTable","configuration","message","groupEnd","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@luma.gl/engine/src/lib/model.js"],"sourcesContent":["/* eslint-disable complexity */\n\nimport GL from '@luma.gl/constants';\nimport {isWebGL} from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport {\n  Program,\n  VertexArray,\n  clear,\n  TransformFeedback,\n  Buffer,\n  log,\n  isObjectEmpty,\n  uid,\n  assert\n} from '@luma.gl/webgl';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nconst NOOP = () => {};\nconst DRAW_PARAMS = {};\n\nexport default class Model {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.animated = false;\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n\n    const {\n      program = null,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.uniforms = {};\n\n    // picking options\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    this._setModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n      this._managedProgram = false;\n    }\n\n    this.vertexArray.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    const {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    Object.assign(this.uniforms, uniforms);\n\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n\n  draw(opts = {}) {\n    // Lazy update program and vertex array\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray\n    } = opts;\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    let logPriority;\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n    }\n\n    const drawParams = this.vertexArray.getDrawParams();\n    const {\n      isIndexed = drawParams.isIndexed,\n      indexType = drawParams.indexType,\n      indexOffset = drawParams.indexOffset,\n      vertexArrayInstanced = drawParams.isInstanced\n    } = this.props;\n\n    if (vertexArrayInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isInstanced, instanceCount} = this;\n\n    const {onBeforeRender = NOOP, onAfterRender = NOOP} = this.props;\n\n    onBeforeRender();\n\n    this.program.setUniforms(this.uniforms);\n\n    const didDraw = this.program.draw(\n      Object.assign(DRAW_PARAMS, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    onAfterRender();\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n    }\n\n    return didDraw;\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _checkProgram() {\n    const needsUpdate =\n      this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {program} = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      } = this.programProps;\n      program = this.programManager.get({\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      });\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      // @ts-ignore TODO\n      this.vertexArray.setProps({program: this.program, attributes: this.vertexArray.attributes});\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {program: this.program});\n    }\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms() // Get all default uniforms,\n      )\n    );\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      // const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      // Object.assign(this.uniforms, animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n\n  _logDrawCallStart(logLevel) {\n    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.level <= 2})();\n\n    return logLevel;\n  }\n\n  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n    // HACK: logLevel === undefined means logDrawCallStart didn't run\n    if (logLevel === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      // @ts-ignore\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(logLevel, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(logLevel, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(logLevel, attributeTable)();\n\n    log.table(logLevel, uniformTable)();\n\n    log.table(logLevel + 1, configTable)();\n\n    if (framebuffer) {\n      framebuffer.log({logLevel: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY)();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}