{"ast":null,"code":"import _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isWebGL2, assertWebGL2Context, withParameters, log } from '@luma.gl/gltools';\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport { TEXTURE_FORMATS, DATA_FORMAT_CHANNELS, TYPE_SIZES, isFormatSupported, isLinearFilteringSupported } from './texture-formats';\nimport { assert } from '../utils/assert';\nimport { uid, isPowerOfTwo } from '../utils/utils';\nvar NPOT_MIN_FILTERS = [9729, 9728];\nvar WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer() {};\nvar Texture = /*#__PURE__*/function (_Resource, _Symbol$toStringTag) {\n  _inherits(Texture, _Resource);\n  var _super = _createSuper(Texture);\n  function Texture(gl, props) {\n    var _this;\n    _classCallCheck(this, Texture);\n    var _props$id = props.id,\n      id = _props$id === void 0 ? uid('texture') : _props$id,\n      handle = props.handle,\n      target = props.target;\n    _this = _super.call(this, gl, {\n      id: id,\n      handle: handle\n    });\n    _this.target = target;\n    _this.textureUnit = undefined;\n    _this.loaded = false;\n    _this.width = undefined;\n    _this.height = undefined;\n    _this.depth = undefined;\n    _this.format = undefined;\n    _this.type = undefined;\n    _this.dataFormat = undefined;\n    _this.border = undefined;\n    _this.textureUnit = undefined;\n    _this.mipmaps = undefined;\n    return _this;\n  }\n  _createClass(Texture, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'Texture';\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Texture(\".concat(this.id, \",\").concat(this.width, \"x\").concat(this.height, \")\");\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      var _this2 = this;\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var data = props.data;\n      if (data instanceof Promise) {\n        data.then(function (resolvedImageData) {\n          return _this2.initialize(Object.assign({}, props, {\n            pixels: resolvedImageData,\n            data: resolvedImageData\n          }));\n        });\n        return this;\n      }\n      var isVideo = typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement;\n      if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {\n        this._video = null;\n        data.addEventListener('loadeddata', function () {\n          return _this2.initialize(props);\n        });\n        return this;\n      }\n      var _props$pixels = props.pixels,\n        pixels = _props$pixels === void 0 ? null : _props$pixels,\n        _props$format = props.format,\n        format = _props$format === void 0 ? 6408 : _props$format,\n        _props$border = props.border,\n        border = _props$border === void 0 ? 0 : _props$border,\n        _props$recreate = props.recreate,\n        recreate = _props$recreate === void 0 ? false : _props$recreate,\n        _props$parameters = props.parameters,\n        parameters = _props$parameters === void 0 ? {} : _props$parameters,\n        _props$pixelStore = props.pixelStore,\n        pixelStore = _props$pixelStore === void 0 ? {} : _props$pixelStore,\n        _props$textureUnit = props.textureUnit,\n        textureUnit = _props$textureUnit === void 0 ? undefined : _props$textureUnit;\n      if (!data) {\n        data = pixels;\n      }\n      var width = props.width,\n        height = props.height,\n        dataFormat = props.dataFormat,\n        type = props.type,\n        _props$compressed = props.compressed,\n        compressed = _props$compressed === void 0 ? false : _props$compressed,\n        _props$mipmaps = props.mipmaps,\n        mipmaps = _props$mipmaps === void 0 ? true : _props$mipmaps;\n      var _props$depth = props.depth,\n        depth = _props$depth === void 0 ? 0 : _props$depth;\n      var _this$_deduceParamete = this._deduceParameters({\n        format: format,\n        type: type,\n        dataFormat: dataFormat,\n        compressed: compressed,\n        data: data,\n        width: width,\n        height: height\n      });\n      width = _this$_deduceParamete.width;\n      height = _this$_deduceParamete.height;\n      compressed = _this$_deduceParamete.compressed;\n      dataFormat = _this$_deduceParamete.dataFormat;\n      type = _this$_deduceParamete.type;\n      this.width = width;\n      this.height = height;\n      this.depth = depth;\n      this.format = format;\n      this.type = type;\n      this.dataFormat = dataFormat;\n      this.border = border;\n      this.textureUnit = textureUnit;\n      if (Number.isFinite(this.textureUnit)) {\n        this.gl.activeTexture(33984 + this.textureUnit);\n        this.gl.bindTexture(this.target, this.handle);\n      }\n      if (mipmaps && this._isNPOT()) {\n        log.warn(\"texture: \".concat(this, \" is Non-Power-Of-Two, disabling mipmaping\"))();\n        mipmaps = false;\n        this._updateForNPOT(parameters);\n      }\n      this.mipmaps = mipmaps;\n      this.setImageData({\n        data: data,\n        width: width,\n        height: height,\n        depth: depth,\n        format: format,\n        type: type,\n        dataFormat: dataFormat,\n        border: border,\n        mipmaps: mipmaps,\n        parameters: pixelStore,\n        compressed: compressed\n      });\n      if (mipmaps) {\n        this.generateMipmap();\n      }\n      this.setParameters(parameters);\n      if (recreate) {\n        this.data = data;\n      }\n      if (isVideo) {\n        this._video = {\n          video: data,\n          parameters: parameters,\n          lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1\n        };\n      }\n      return this;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this._video) {\n        var _this$_video = this._video,\n          video = _this$_video.video,\n          parameters = _this$_video.parameters,\n          lastTime = _this$_video.lastTime;\n        if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {\n          return;\n        }\n        this.setSubImageData({\n          data: video,\n          parameters: parameters\n        });\n        if (this.mipmaps) {\n          this.generateMipmap();\n        }\n        this._video.lastTime = video.currentTime;\n      }\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(_ref) {\n      var height = _ref.height,\n        width = _ref.width,\n        _ref$mipmaps = _ref.mipmaps,\n        mipmaps = _ref$mipmaps === void 0 ? false : _ref$mipmaps;\n      if (width !== this.width || height !== this.height) {\n        return this.initialize({\n          width: width,\n          height: height,\n          format: this.format,\n          type: this.type,\n          dataFormat: this.dataFormat,\n          border: this.border,\n          mipmaps: mipmaps\n        });\n      }\n      return this;\n    }\n  }, {\n    key: \"generateMipmap\",\n    value: function generateMipmap() {\n      var _this3 = this;\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (this._isNPOT()) {\n        log.warn(\"texture: \".concat(this, \" is Non-Power-Of-Two, disabling mipmaping\"))();\n        return this;\n      }\n      this.mipmaps = true;\n      this.gl.bindTexture(this.target, this.handle);\n      withParameters(this.gl, params, function () {\n        _this3.gl.generateMipmap(_this3.target);\n      });\n      this.gl.bindTexture(this.target, null);\n      return this;\n    }\n  }, {\n    key: \"setImageData\",\n    value: function setImageData(options) {\n      this._trackDeallocatedMemory('Texture');\n      var _options$target = options.target,\n        target = _options$target === void 0 ? this.target : _options$target,\n        _options$pixels = options.pixels,\n        pixels = _options$pixels === void 0 ? null : _options$pixels,\n        _options$level = options.level,\n        level = _options$level === void 0 ? 0 : _options$level,\n        _options$format = options.format,\n        format = _options$format === void 0 ? this.format : _options$format,\n        _options$border = options.border,\n        border = _options$border === void 0 ? this.border : _options$border,\n        _options$offset = options.offset,\n        offset = _options$offset === void 0 ? 0 : _options$offset,\n        _options$parameters = options.parameters,\n        parameters = _options$parameters === void 0 ? {} : _options$parameters;\n      var _options$data = options.data,\n        data = _options$data === void 0 ? null : _options$data,\n        _options$type = options.type,\n        type = _options$type === void 0 ? this.type : _options$type,\n        _options$width = options.width,\n        width = _options$width === void 0 ? this.width : _options$width,\n        _options$height = options.height,\n        height = _options$height === void 0 ? this.height : _options$height,\n        _options$dataFormat = options.dataFormat,\n        dataFormat = _options$dataFormat === void 0 ? this.dataFormat : _options$dataFormat,\n        _options$compressed = options.compressed,\n        compressed = _options$compressed === void 0 ? false : _options$compressed;\n      if (!data) {\n        data = pixels;\n      }\n      var _this$_deduceParamete2 = this._deduceParameters({\n        format: format,\n        type: type,\n        dataFormat: dataFormat,\n        compressed: compressed,\n        data: data,\n        width: width,\n        height: height\n      });\n      type = _this$_deduceParamete2.type;\n      dataFormat = _this$_deduceParamete2.dataFormat;\n      compressed = _this$_deduceParamete2.compressed;\n      width = _this$_deduceParamete2.width;\n      height = _this$_deduceParamete2.height;\n      var gl = this.gl;\n      gl.bindTexture(this.target, this.handle);\n      var dataType = null;\n      var _this$_getDataType = this._getDataType({\n        data: data,\n        compressed: compressed\n      });\n      data = _this$_getDataType.data;\n      dataType = _this$_getDataType.dataType;\n      var gl2;\n      var compressedTextureSize = 0;\n      withParameters(this.gl, parameters, function () {\n        switch (dataType) {\n          case 'null':\n            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n            break;\n          case 'typed-array':\n            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);\n            break;\n          case 'buffer':\n            gl2 = assertWebGL2Context(gl);\n            gl2.bindBuffer(35052, data.handle || data);\n            gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);\n            gl2.bindBuffer(35052, null);\n            break;\n          case 'browser-object':\n            if (isWebGL2(gl)) {\n              gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n            } else {\n              gl.texImage2D(target, level, format, dataFormat, type, data);\n            }\n            break;\n          case 'compressed':\n            var _iterator = _createForOfIteratorHelper(data.entries()),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var _step$value = _slicedToArray(_step.value, 2),\n                  levelIndex = _step$value[0],\n                  levelData = _step$value[1];\n                gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);\n                compressedTextureSize += levelData.levelSize;\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n            break;\n          default:\n            assert(false, 'Unknown image data type');\n        }\n      });\n      if (dataType === 'compressed') {\n        this._trackAllocatedMemory(compressedTextureSize, 'Texture');\n      } else if (data && data.byteLength) {\n        this._trackAllocatedMemory(data.byteLength, 'Texture');\n      } else {\n        var channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;\n        var channelSize = TYPE_SIZES[this.type] || 1;\n        this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');\n      }\n      this.loaded = true;\n      return this;\n    }\n  }, {\n    key: \"setSubImageData\",\n    value: function setSubImageData(_ref2) {\n      var _this4 = this;\n      var _ref2$target = _ref2.target,\n        target = _ref2$target === void 0 ? this.target : _ref2$target,\n        _ref2$pixels = _ref2.pixels,\n        pixels = _ref2$pixels === void 0 ? null : _ref2$pixels,\n        _ref2$data = _ref2.data,\n        data = _ref2$data === void 0 ? null : _ref2$data,\n        _ref2$x = _ref2.x,\n        x = _ref2$x === void 0 ? 0 : _ref2$x,\n        _ref2$y = _ref2.y,\n        y = _ref2$y === void 0 ? 0 : _ref2$y,\n        _ref2$width = _ref2.width,\n        width = _ref2$width === void 0 ? this.width : _ref2$width,\n        _ref2$height = _ref2.height,\n        height = _ref2$height === void 0 ? this.height : _ref2$height,\n        _ref2$level = _ref2.level,\n        level = _ref2$level === void 0 ? 0 : _ref2$level,\n        _ref2$format = _ref2.format,\n        format = _ref2$format === void 0 ? this.format : _ref2$format,\n        _ref2$type = _ref2.type,\n        type = _ref2$type === void 0 ? this.type : _ref2$type,\n        _ref2$dataFormat = _ref2.dataFormat,\n        dataFormat = _ref2$dataFormat === void 0 ? this.dataFormat : _ref2$dataFormat,\n        _ref2$compressed = _ref2.compressed,\n        compressed = _ref2$compressed === void 0 ? false : _ref2$compressed,\n        _ref2$offset = _ref2.offset,\n        offset = _ref2$offset === void 0 ? 0 : _ref2$offset,\n        _ref2$border = _ref2.border,\n        border = _ref2$border === void 0 ? this.border : _ref2$border,\n        _ref2$parameters = _ref2.parameters,\n        parameters = _ref2$parameters === void 0 ? {} : _ref2$parameters;\n      var _this$_deduceParamete3 = this._deduceParameters({\n        format: format,\n        type: type,\n        dataFormat: dataFormat,\n        compressed: compressed,\n        data: data,\n        width: width,\n        height: height\n      });\n      type = _this$_deduceParamete3.type;\n      dataFormat = _this$_deduceParamete3.dataFormat;\n      compressed = _this$_deduceParamete3.compressed;\n      width = _this$_deduceParamete3.width;\n      height = _this$_deduceParamete3.height;\n      assert(this.depth === 0, 'texSubImage not supported for 3D textures');\n      if (!data) {\n        data = pixels;\n      }\n      if (data && data.data) {\n        var ndarray = data;\n        data = ndarray.data;\n        width = ndarray.shape[0];\n        height = ndarray.shape[1];\n      }\n      if (data instanceof Buffer) {\n        data = data.handle;\n      }\n      this.gl.bindTexture(this.target, this.handle);\n      withParameters(this.gl, parameters, function () {\n        if (compressed) {\n          _this4.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);\n        } else if (data === null) {\n          _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);\n        } else if (ArrayBuffer.isView(data)) {\n          _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);\n        } else if (data instanceof WebGLBuffer) {\n          var gl2 = assertWebGL2Context(_this4.gl);\n          gl2.bindBuffer(35052, data);\n          gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);\n          gl2.bindBuffer(35052, null);\n        } else if (isWebGL2(_this4.gl)) {\n          var _gl = assertWebGL2Context(_this4.gl);\n          _gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);\n        } else {\n          _this4.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);\n        }\n      });\n      this.gl.bindTexture(this.target, null);\n    }\n  }, {\n    key: \"copyFramebuffer\",\n    value: function copyFramebuffer() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      log.error('Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})')();\n      return null;\n    }\n  }, {\n    key: \"getActiveUnit\",\n    value: function getActiveUnit() {\n      return this.gl.getParameter(34016) - 33984;\n    }\n  }, {\n    key: \"bind\",\n    value: function bind() {\n      var textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;\n      var gl = this.gl;\n      if (textureUnit !== undefined) {\n        this.textureUnit = textureUnit;\n        gl.activeTexture(33984 + textureUnit);\n      }\n      gl.bindTexture(this.target, this.handle);\n      return textureUnit;\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      var textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;\n      var gl = this.gl;\n      if (textureUnit !== undefined) {\n        this.textureUnit = textureUnit;\n        gl.activeTexture(33984 + textureUnit);\n      }\n      gl.bindTexture(this.target, null);\n      return textureUnit;\n    }\n  }, {\n    key: \"_getDataType\",\n    value: function _getDataType(_ref3) {\n      var data = _ref3.data,\n        _ref3$compressed = _ref3.compressed,\n        compressed = _ref3$compressed === void 0 ? false : _ref3$compressed;\n      if (compressed) {\n        return {\n          data: data,\n          dataType: 'compressed'\n        };\n      }\n      if (data === null) {\n        return {\n          data: data,\n          dataType: 'null'\n        };\n      }\n      if (ArrayBuffer.isView(data)) {\n        return {\n          data: data,\n          dataType: 'typed-array'\n        };\n      }\n      if (data instanceof Buffer) {\n        return {\n          data: data.handle,\n          dataType: 'buffer'\n        };\n      }\n      if (data instanceof WebGLBuffer) {\n        return {\n          data: data,\n          dataType: 'buffer'\n        };\n      }\n      return {\n        data: data,\n        dataType: 'browser-object'\n      };\n    }\n  }, {\n    key: \"_deduceParameters\",\n    value: function _deduceParameters(opts) {\n      var format = opts.format,\n        data = opts.data;\n      var width = opts.width,\n        height = opts.height,\n        dataFormat = opts.dataFormat,\n        type = opts.type,\n        compressed = opts.compressed;\n      var textureFormat = TEXTURE_FORMATS[format];\n      dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;\n      type = type || textureFormat && textureFormat.types[0];\n      compressed = compressed || textureFormat && textureFormat.compressed;\n      var _this$_deduceImageSiz = this._deduceImageSize(data, width, height);\n      width = _this$_deduceImageSiz.width;\n      height = _this$_deduceImageSiz.height;\n      return {\n        dataFormat: dataFormat,\n        type: type,\n        compressed: compressed,\n        width: width,\n        height: height,\n        format: format,\n        data: data\n      };\n    }\n  }, {\n    key: \"_deduceImageSize\",\n    value: function _deduceImageSize(data, width, height) {\n      var size;\n      if (typeof ImageData !== 'undefined' && data instanceof ImageData) {\n        size = {\n          width: data.width,\n          height: data.height\n        };\n      } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n        size = {\n          width: data.naturalWidth,\n          height: data.naturalHeight\n        };\n      } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {\n        size = {\n          width: data.width,\n          height: data.height\n        };\n      } else if (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {\n        size = {\n          width: data.width,\n          height: data.height\n        };\n      } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n        size = {\n          width: data.videoWidth,\n          height: data.videoHeight\n        };\n      } else if (!data) {\n        size = {\n          width: width >= 0 ? width : 1,\n          height: height >= 0 ? height : 1\n        };\n      } else {\n        size = {\n          width: width,\n          height: height\n        };\n      }\n      assert(size, 'Could not deduced texture size');\n      assert(width === undefined || size.width === width, 'Deduced texture width does not match supplied width');\n      assert(height === undefined || size.height === height, 'Deduced texture height does not match supplied height');\n      return size;\n    }\n  }, {\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return this.gl.createTexture();\n    }\n  }, {\n    key: \"_deleteHandle\",\n    value: function _deleteHandle() {\n      this.gl.deleteTexture(this.handle);\n      this._trackDeallocatedMemory('Texture');\n    }\n  }, {\n    key: \"_getParameter\",\n    value: function _getParameter(pname) {\n      switch (pname) {\n        case 4096:\n          return this.width;\n        case 4097:\n          return this.height;\n        default:\n          this.gl.bindTexture(this.target, this.handle);\n          var value = this.gl.getTexParameter(this.target, pname);\n          this.gl.bindTexture(this.target, null);\n          return value;\n      }\n    }\n  }, {\n    key: \"_setParameter\",\n    value: function _setParameter(pname, param) {\n      this.gl.bindTexture(this.target, this.handle);\n      param = this._getNPOTParam(pname, param);\n      switch (pname) {\n        case 33082:\n        case 33083:\n          this.gl.texParameterf(this.handle, pname, param);\n          break;\n        case 4096:\n        case 4097:\n          assert(false);\n          break;\n        default:\n          this.gl.texParameteri(this.target, pname, param);\n          break;\n      }\n      this.gl.bindTexture(this.target, null);\n      return this;\n    }\n  }, {\n    key: \"_isNPOT\",\n    value: function _isNPOT() {\n      if (isWebGL2(this.gl)) {\n        return false;\n      }\n      if (!this.width || !this.height) {\n        return false;\n      }\n      return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);\n    }\n  }, {\n    key: \"_updateForNPOT\",\n    value: function _updateForNPOT(parameters) {\n      if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {\n        parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;\n      }\n      if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {\n        parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;\n      }\n      if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {\n        parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;\n      }\n    }\n  }, {\n    key: \"_getNPOTParam\",\n    value: function _getNPOTParam(pname, param) {\n      if (this._isNPOT()) {\n        switch (pname) {\n          case 10241:\n            if (NPOT_MIN_FILTERS.indexOf(param) === -1) {\n              param = 9729;\n            }\n            break;\n          case 10242:\n          case 10243:\n            if (param !== 33071) {\n              param = 33071;\n            }\n            break;\n          default:\n            break;\n        }\n      }\n      return param;\n    }\n  }], [{\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var format = opts.format,\n        linearFiltering = opts.linearFiltering;\n      var supported = true;\n      if (format) {\n        supported = supported && isFormatSupported(gl, format);\n        supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));\n      }\n      return supported;\n    }\n  }]);\n  return Texture;\n}(Resource, Symbol.toStringTag);\nexport { Texture as default };","map":{"version":3,"names":["isWebGL2","assertWebGL2Context","withParameters","log","Resource","Buffer","TEXTURE_FORMATS","DATA_FORMAT_CHANNELS","TYPE_SIZES","isFormatSupported","isLinearFilteringSupported","assert","uid","isPowerOfTwo","NPOT_MIN_FILTERS","WebGLBuffer","globalThis","Texture","_Resource","_Symbol$toStringTag","_inherits","_super","_createSuper","gl","props","_this","_classCallCheck","_props$id","id","handle","target","call","textureUnit","undefined","loaded","width","height","depth","format","type","dataFormat","border","mipmaps","_createClass","key","get","value","toString","concat","initialize","_this2","arguments","length","data","Promise","then","resolvedImageData","Object","assign","pixels","isVideo","HTMLVideoElement","readyState","HAVE_METADATA","_video","addEventListener","_props$pixels","_props$format","_props$border","_props$recreate","recreate","_props$parameters","parameters","_props$pixelStore","pixelStore","_props$textureUnit","_props$compressed","compressed","_props$mipmaps","_props$depth","_this$_deduceParamete","_deduceParameters","Number","isFinite","activeTexture","bindTexture","_isNPOT","warn","_updateForNPOT","setImageData","generateMipmap","setParameters","video","lastTime","HAVE_CURRENT_DATA","currentTime","update","_this$_video","setSubImageData","resize","_ref","_ref$mipmaps","_this3","params","options","_trackDeallocatedMemory","_options$target","_options$pixels","_options$level","level","_options$format","_options$border","_options$offset","offset","_options$parameters","_options$data","_options$type","_options$width","_options$height","_options$dataFormat","_options$compressed","_this$_deduceParamete2","dataType","_this$_getDataType","_getDataType","gl2","compressedTextureSize","texImage2D","bindBuffer","_iterator","_createForOfIteratorHelper","entries","_step","s","n","done","_step$value","_slicedToArray","levelIndex","levelData","compressedTexImage2D","levelSize","err","e","f","_trackAllocatedMemory","byteLength","channels","channelSize","_ref2","_this4","_ref2$target","_ref2$pixels","_ref2$data","_ref2$x","x","_ref2$y","y","_ref2$width","_ref2$height","_ref2$level","_ref2$format","_ref2$type","_ref2$dataFormat","_ref2$compressed","_ref2$offset","_ref2$border","_ref2$parameters","_this$_deduceParamete3","ndarray","shape","compressedTexSubImage2D","texSubImage2D","ArrayBuffer","isView","copyFramebuffer","opts","error","getActiveUnit","getParameter","bind","unbind","_ref3","_ref3$compressed","textureFormat","types","_this$_deduceImageSiz","_deduceImageSize","size","ImageData","HTMLImageElement","naturalWidth","naturalHeight","HTMLCanvasElement","ImageBitmap","videoWidth","videoHeight","_createHandle","createTexture","_deleteHandle","deleteTexture","_getParameter","pname","getTexParameter","_setParameter","param","_getNPOTParam","texParameterf","texParameteri","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","indexOf","isSupported","linearFiltering","supported","Symbol","toStringTag","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@luma.gl/webgl/src/classes/texture.js"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport {isWebGL2, assertWebGL2Context, withParameters, log} from '@luma.gl/gltools';\n\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport {\n  TEXTURE_FORMATS,\n  DATA_FORMAT_CHANNELS,\n  TYPE_SIZES,\n  isFormatSupported,\n  isLinearFilteringSupported\n} from './texture-formats';\nimport {assert} from '../utils/assert';\nimport {uid, isPowerOfTwo} from '../utils/utils';\n\n// Supported min filters for NPOT texture.\nconst NPOT_MIN_FILTERS = [GL.LINEAR, GL.NEAREST];\n\n// Polyfill\n// Note (Tarek): Do we really need to support this API?\nconst WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer() {};\n\nexport default class Texture extends Resource {\n  // eslint-disable-next-line accessor-pairs\n  get [Symbol.toStringTag]() {\n    return 'Texture';\n  }\n  static isSupported(gl, opts = {}) {\n    const {format, linearFiltering} = opts;\n    let supported = true;\n    if (format) {\n      supported = supported && isFormatSupported(gl, format);\n      supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));\n    }\n    return supported;\n  }\n\n  // target cannot be modified by bind:\n  // textures are special because when you first bind them to a target,\n  // they get special information. When you first bind a texture as a\n  // GL_TEXTURE_2D, you are actually setting special state in the texture.\n  // You are saying that this texture is a 2D texture.\n  // And it will always be a 2D texture; this state cannot be changed ever.\n  // If you have a texture that was first bound as a GL_TEXTURE_2D,\n  // you must always bind it as a GL_TEXTURE_2D;\n  // attempting to bind it as GL_TEXTURE_1D will give rise to an error\n  // (while run-time).\n  constructor(gl, props) {\n    const {\n      id = uid('texture'),\n      handle,\n      target\n      // , magFilter, minFilter, wrapS, wrapT\n    } = props;\n\n    super(gl, {id, handle});\n\n    this.target = target;\n    this.textureUnit = undefined;\n\n    // Program.draw() checks the loaded flag of all textures to avoid\n    // Textures that are still loading from promises\n    // Set to true as soon as texture has been initialized with valid data\n    this.loaded = false;\n\n    this.width = undefined;\n    this.height = undefined;\n    this.depth = undefined;\n    this.format = undefined;\n    this.type = undefined;\n    this.dataFormat = undefined;\n    this.border = undefined;\n    this.textureUnit = undefined;\n    this.mipmaps = undefined;\n  }\n\n  toString() {\n    return `Texture(${this.id},${this.width}x${this.height})`;\n  }\n\n  /* eslint-disable max-len, max-statements */\n  initialize(props = {}) {\n    let data = props.data;\n\n    if (data instanceof Promise) {\n      data.then(resolvedImageData =>\n        this.initialize(\n          Object.assign({}, props, {\n            pixels: resolvedImageData,\n            data: resolvedImageData\n          })\n        )\n      );\n      return this;\n    }\n    const isVideo = typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement;\n    // @ts-ignore\n    if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {\n      this._video = null; // Declare member before the object is sealed\n      data.addEventListener('loadeddata', () => this.initialize(props));\n      return this;\n    }\n\n    const {\n      pixels = null,\n      format = GL.RGBA,\n      border = 0,\n      recreate = false,\n      parameters = {},\n      pixelStore = {},\n      textureUnit = undefined\n    } = props;\n\n    // pixels variable is for API compatibility purpose\n    if (!data) {\n      // TODO - This looks backwards? Commenting out for now until we decide\n      // which prop to use\n      // log.deprecated('data', 'pixels')();\n      data = pixels;\n    }\n\n    let {width, height, dataFormat, type, compressed = false, mipmaps = true} = props;\n    const {depth = 0} = props;\n\n    // Deduce width and height\n    ({width, height, compressed, dataFormat, type} = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n\n    // Store opts for accessors\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n    this.format = format;\n    this.type = type;\n    this.dataFormat = dataFormat;\n    this.border = border;\n    this.textureUnit = textureUnit;\n\n    if (Number.isFinite(this.textureUnit)) {\n      this.gl.activeTexture(GL.TEXTURE0 + this.textureUnit);\n      this.gl.bindTexture(this.target, this.handle);\n    }\n\n    if (mipmaps && this._isNPOT()) {\n      log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();\n      mipmaps = false;\n\n      this._updateForNPOT(parameters);\n    }\n\n    this.mipmaps = mipmaps;\n\n    this.setImageData({\n      data,\n      width,\n      height,\n      depth,\n      format,\n      type,\n      dataFormat,\n      border,\n      mipmaps,\n      parameters: pixelStore,\n      compressed\n    });\n\n    if (mipmaps) {\n      this.generateMipmap();\n    }\n\n    // Set texture sampler parameters\n    this.setParameters(parameters);\n\n    // TODO - Store data to enable auto recreate on context loss\n    if (recreate) {\n      this.data = data;\n    }\n    if (isVideo) {\n      this._video = {\n        video: data,\n        parameters,\n        // @ts-ignore\n        lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1\n      };\n    }\n\n    return this;\n  }\n\n  update() {\n    if (this._video) {\n      const {video, parameters, lastTime} = this._video;\n      // @ts-ignore\n      if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {\n        return;\n      }\n      this.setSubImageData({\n        data: video,\n        parameters\n      });\n      if (this.mipmaps) {\n        this.generateMipmap();\n      }\n      this._video.lastTime = video.currentTime;\n    }\n  }\n\n  // If size has changed, reinitializes with current format\n  // note clears image and mipmaps\n  resize({height, width, mipmaps = false}) {\n    if (width !== this.width || height !== this.height) {\n      return this.initialize({\n        width,\n        height,\n        format: this.format,\n        type: this.type,\n        dataFormat: this.dataFormat,\n        border: this.border,\n        mipmaps\n      });\n    }\n    return this;\n  }\n\n  // Call to regenerate mipmaps after modifying texture(s)\n  generateMipmap(params = {}) {\n    if (this._isNPOT()) {\n      log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();\n      return this;\n    }\n\n    this.mipmaps = true;\n\n    this.gl.bindTexture(this.target, this.handle);\n    withParameters(this.gl, params, () => {\n      this.gl.generateMipmap(this.target);\n    });\n    this.gl.bindTexture(this.target, null);\n    return this;\n  }\n\n  /*\n   * Allocates storage\n   * @param {*} pixels -\n   *  null - create empty texture of specified format\n   *  Typed array - init from image data in typed array\n   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer\n   *  HTMLImageElement|Image - Inits with content of image. Auto width/height\n   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height\n   *  HTMLVideoElement - Creates video texture. Auto width/height\n   *\n   * @param {GLint} width -\n   * @param {GLint} height -\n   * @param {GLint} mipMapLevel -\n   * @param {GLenum} format - format of image data.\n   * @param {GLenum} type\n   *  - format of array (autodetect from type) or\n   *  - (WEBGL2) format of buffer\n   * @param {Number} offset - (WEBGL2) offset from start of buffer\n   * @param {GLint} border - must be 0.\n   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.\n   */\n  /* eslint-disable max-len, max-statements, complexity */\n  setImageData(options) {\n    this._trackDeallocatedMemory('Texture');\n\n    const {\n      target = this.target,\n      pixels = null,\n      level = 0,\n      format = this.format,\n      border = this.border,\n      offset = 0,\n      parameters = {}\n    } = options;\n\n    let {\n      data = null,\n      type = this.type,\n      width = this.width,\n      height = this.height,\n      dataFormat = this.dataFormat,\n      compressed = false\n    } = options;\n\n    // pixels variable is  for API compatibility purpose\n    if (!data) {\n      data = pixels;\n    }\n\n    ({type, dataFormat, compressed, width, height} = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n\n    const {gl} = this;\n    gl.bindTexture(this.target, this.handle);\n\n    let dataType = null;\n    ({data, dataType} = this._getDataType({data, compressed}));\n\n    let gl2;\n\n    let compressedTextureSize = 0;\n\n    withParameters(this.gl, parameters, () => {\n      switch (dataType) {\n        case 'null':\n          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n          break;\n        case 'typed-array':\n          // Looks like this assert is not necessary, as offset is ignored under WebGL1\n          // assert((offset === 0 || isWebGL2(gl)), 'offset supported in WebGL2 only');\n          // @ts-ignore\n          gl.texImage2D(\n            target,\n            level,\n            format,\n            width,\n            height,\n            border,\n            dataFormat,\n            type,\n            data,\n            // @ts-ignore\n            offset\n          );\n          break;\n        case 'buffer':\n          // WebGL2 enables creating textures directly from a WebGL buffer\n          gl2 = assertWebGL2Context(gl);\n          gl2.bindBuffer(GL.PIXEL_UNPACK_BUFFER, data.handle || data);\n          gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);\n          gl2.bindBuffer(GL.PIXEL_UNPACK_BUFFER, null);\n          break;\n        case 'browser-object':\n          if (isWebGL2(gl)) {\n            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n          } else {\n            gl.texImage2D(target, level, format, dataFormat, type, data);\n          }\n          break;\n        case 'compressed':\n          for (const [levelIndex, levelData] of data.entries()) {\n            gl.compressedTexImage2D(\n              target,\n              levelIndex,\n              levelData.format,\n              levelData.width,\n              levelData.height,\n              border,\n              levelData.data\n            );\n            compressedTextureSize += levelData.levelSize;\n          }\n          break;\n        default:\n          assert(false, 'Unknown image data type');\n      }\n    });\n\n    if (dataType === 'compressed') {\n      this._trackAllocatedMemory(compressedTextureSize, 'Texture');\n    } else if (data && data.byteLength) {\n      this._trackAllocatedMemory(data.byteLength, 'Texture');\n    } else {\n      // NOTE(Tarek): Default to RGBA bytes\n      const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;\n      const channelSize = TYPE_SIZES[this.type] || 1;\n\n      this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');\n    }\n\n    this.loaded = true;\n\n    return this;\n  }\n  /* eslint-enable max-len, max-statements, complexity */\n\n  /**\n   * Redefines an area of an existing texture\n   * Note: does not allocate storage\n   */\n  /*\n   * Redefines an area of an existing texture\n   * @param {*} pixels, data -\n   *  null - create empty texture of specified format\n   *  Typed array - init from image data in typed array\n   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer\n   *  HTMLImageElement|Image - Inits with content of image. Auto width/height\n   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height\n   *  HTMLVideoElement - Creates video texture. Auto width/height\n   *\n   * @param {GLint} x - xOffset from where texture to be updated\n   * @param {GLint} y - yOffset from where texture to be updated\n   * @param {GLint} width - width of the sub image to be updated\n   * @param {GLint} height - height of the sub image to be updated\n   * @param {GLint} level - mip level to be updated\n   * @param {GLenum} format - internal format of image data.\n   * @param {GLenum} type\n   *  - format of array (autodetect from type) or\n   *  - (WEBGL2) format of buffer or ArrayBufferView\n   * @param {GLenum} dataFormat - format of image data.\n   * @param {Number} offset - (WEBGL2) offset from start of buffer\n   * @param {GLint} border - must be 0.\n   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.\n   */\n  setSubImageData({\n    target = this.target,\n    pixels = null,\n    data = null,\n    x = 0,\n    y = 0,\n    width = this.width,\n    height = this.height,\n    level = 0,\n    format = this.format,\n    type = this.type,\n    dataFormat = this.dataFormat,\n    compressed = false,\n    offset = 0,\n    border = this.border,\n    parameters = {}\n  }) {\n    ({type, dataFormat, compressed, width, height} = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n\n    assert(this.depth === 0, 'texSubImage not supported for 3D textures');\n\n    // pixels variable is  for API compatibility purpose\n    if (!data) {\n      data = pixels;\n    }\n\n    // Support ndarrays\n    if (data && data.data) {\n      const ndarray = data;\n      data = ndarray.data;\n      width = ndarray.shape[0];\n      height = ndarray.shape[1];\n    }\n\n    // Support buffers\n    if (data instanceof Buffer) {\n      data = data.handle;\n    }\n\n    this.gl.bindTexture(this.target, this.handle);\n\n    withParameters(this.gl, parameters, () => {\n      // TODO - x,y parameters\n      if (compressed) {\n        this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);\n      } else if (data === null) {\n        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);\n      } else if (ArrayBuffer.isView(data)) {\n        // const gl2 = assertWebGL2Context(this.gl);\n        // @ts-ignore last offset parameter is ignored under WebGL1\n        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);\n      } else if (data instanceof WebGLBuffer) {\n        // WebGL2 allows us to create texture directly from a WebGL buffer\n        const gl2 = assertWebGL2Context(this.gl);\n        // This texImage2D signature uses currently bound GL.PIXEL_UNPACK_BUFFER\n        gl2.bindBuffer(GL.PIXEL_UNPACK_BUFFER, data);\n        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);\n        gl2.bindBuffer(GL.PIXEL_UNPACK_BUFFER, null);\n      } else if (isWebGL2(this.gl)) {\n        // Assume data is a browser supported object (ImageData, Canvas, ...)\n        const gl2 = assertWebGL2Context(this.gl);\n        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);\n      } else {\n        this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);\n      }\n    });\n\n    this.gl.bindTexture(this.target, null);\n  }\n  /* eslint-enable max-len, max-statements, complexity */\n\n  /**\n   * Defines a two-dimensional texture image or cube-map texture image with\n   * pixels from the current framebuffer (rather than from client memory).\n   * (gl.copyTexImage2D wrapper)\n   *\n   * Note that binding a texture into a Framebuffer's color buffer and\n   * rendering can be faster.\n   */\n  copyFramebuffer(opts = {}) {\n    log.error(\n      'Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})'\n    )();\n    return null;\n  }\n\n  getActiveUnit() {\n    return this.gl.getParameter(GL.ACTIVE_TEXTURE) - GL.TEXTURE0;\n  }\n\n  // target cannot be modified by bind:\n  // textures are special because when you first bind them to a target,\n  // they get special information. When you first bind a texture as a\n  // GL_TEXTURE_2D, you are actually setting special state in the texture.\n  // You are saying that this texture is a 2D texture.\n  // And it will always be a 2D texture; this state cannot be changed ever.\n  // If you have a texture that was first bound as a GL_TEXTURE_2D,\n  // you must always bind it as a GL_TEXTURE_2D;\n  // attempting to bind it as GL_TEXTURE_1D will give rise to an error\n  // (while run-time).\n\n  bind(textureUnit = this.textureUnit) {\n    const {gl} = this;\n\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(gl.TEXTURE0 + textureUnit);\n    }\n\n    gl.bindTexture(this.target, this.handle);\n    return textureUnit;\n  }\n\n  unbind(textureUnit = this.textureUnit) {\n    const {gl} = this;\n\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(gl.TEXTURE0 + textureUnit);\n    }\n\n    gl.bindTexture(this.target, null);\n    return textureUnit;\n  }\n\n  // PRIVATE METHODS\n\n  _getDataType({data, compressed = false}) {\n    if (compressed) {\n      return {data, dataType: 'compressed'};\n    }\n    if (data === null) {\n      return {data, dataType: 'null'};\n    }\n    if (ArrayBuffer.isView(data)) {\n      return {data, dataType: 'typed-array'};\n    }\n    if (data instanceof Buffer) {\n      return {data: data.handle, dataType: 'buffer'};\n    }\n    if (data instanceof WebGLBuffer) {\n      return {data, dataType: 'buffer'};\n    }\n    // Assume data is a browser supported object (ImageData, Canvas, ...)\n    return {data, dataType: 'browser-object'};\n  }\n\n  /* Copied from texture-2d.js\n  // WebGL2\n  setPixels(opts = {}) {\n    const {\n      buffer,\n      width = null,\n      height = null,\n      mipmapLevel = 0,\n      format = GL.RGBA,\n      type = GL.UNSIGNED_BYTE,\n      border = 0\n    } = opts;\n\n    const {gl} = this;\n\n    // This signature of texImage2D uses currently bound GL.PIXEL_UNPACK_BUFFER\n    gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, buffer.target);\n    // And as always, we must also bind the texture itself\n    this.bind();\n\n    gl.texImage2D(gl.TEXTURE_2D,\n      mipmapLevel, format, width, height, border, format, type, buffer.target);\n\n    this.unbind();\n    gl.bindBuffer(GL.GL.PIXEL_UNPACK_BUFFER, null);\n    return this;\n  }\n\n  setImageDataFromCompressedBuffer(opts) {\n    const {\n      buffer,\n      // offset = 0,\n      width = null,\n      height = null,\n      mipmapLevel = 0,\n      internalFormat = GL.RGBA,\n      // format = GL.RGBA,\n      // type = GL.UNSIGNED_BYTE,\n      border = 0\n    } = opts;\n\n    const {gl} = this;\n    gl.compressedTexImage2D(this.target,\n      mipmapLevel, internalFormat, width, height, border, buffer);\n    // gl.compressedTexSubImage2D(target,\n    //   level, xoffset, yoffset, width, height, format, ArrayBufferView? pixels);\n    return this;\n  }\n\n  copySubImage(opts) {\n    const {\n      // pixels,\n      // offset = 0,\n      // x,\n      // y,\n      // width,\n      // height,\n      // mipmapLevel = 0,\n      // internalFormat = GL.RGBA,\n      // type = GL.UNSIGNED_BYTE,\n      // border = 0\n    } = opts;\n\n    // if (pixels instanceof ArrayBufferView) {\n    //   gl.texSubImage2D(target, level, x, y, width, height, format, type, pixels);\n    // }\n    // gl.texSubImage2D(target, level, x, y, format, type, ? pixels);\n    // gl.texSubImage2D(target, level, x, y, format, type, HTMLImageElement pixels);\n    // gl.texSubImage2D(target, level, x, y, format, type, HTMLCanvasElement pixels);\n    // gl.texSubImage2D(target, level, x, y, format, type, HTMLVideoElement pixels);\n    // // Additional signature in a WebGL 2 context:\n    // gl.texSubImage2D(target, level, x, y, format, type, GLintptr offset);\n  }\n  */\n\n  // HELPER METHODS\n\n  _deduceParameters(opts) {\n    const {format, data} = opts;\n    let {width, height, dataFormat, type, compressed} = opts;\n\n    // Deduce format and type from format\n    const textureFormat = TEXTURE_FORMATS[format];\n    dataFormat = dataFormat || (textureFormat && textureFormat.dataFormat);\n    type = type || (textureFormat && textureFormat.types[0]);\n\n    // Deduce compression from format\n    compressed = compressed || (textureFormat && textureFormat.compressed);\n\n    ({width, height} = this._deduceImageSize(data, width, height));\n\n    return {dataFormat, type, compressed, width, height, format, data};\n  }\n\n  // eslint-disable-next-line complexity\n  _deduceImageSize(data, width, height) {\n    let size;\n\n    if (typeof ImageData !== 'undefined' && data instanceof ImageData) {\n      size = {width: data.width, height: data.height};\n    } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n      size = {width: data.naturalWidth, height: data.naturalHeight};\n    } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {\n      size = {width: data.width, height: data.height};\n    } else if (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {\n      size = {width: data.width, height: data.height};\n    } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n      size = {width: data.videoWidth, height: data.videoHeight};\n    } else if (!data) {\n      size = {width: width >= 0 ? width : 1, height: height >= 0 ? height : 1};\n    } else {\n      size = {width, height};\n    }\n\n    assert(size, 'Could not deduced texture size');\n    assert(\n      width === undefined || size.width === width,\n      'Deduced texture width does not match supplied width'\n    );\n    assert(\n      height === undefined || size.height === height,\n      'Deduced texture height does not match supplied height'\n    );\n\n    return size;\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createTexture();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteTexture(this.handle);\n    this._trackDeallocatedMemory('Texture');\n  }\n\n  _getParameter(pname) {\n    switch (pname) {\n      case GL.TEXTURE_WIDTH:\n        return this.width;\n      case GL.TEXTURE_HEIGHT:\n        return this.height;\n      default:\n        this.gl.bindTexture(this.target, this.handle);\n        const value = this.gl.getTexParameter(this.target, pname);\n        this.gl.bindTexture(this.target, null);\n        return value;\n    }\n  }\n\n  _setParameter(pname, param) {\n    this.gl.bindTexture(this.target, this.handle);\n\n    // NOTE: Apply NPOT workaround\n    param = this._getNPOTParam(pname, param);\n\n    // Apparently there are some integer/float conversion rules that made\n    // the WebGL committe expose two parameter setting functions in JavaScript.\n    // For now, pick the float version for parameters specified as GLfloat.\n    switch (pname) {\n      case GL.TEXTURE_MIN_LOD:\n      case GL.TEXTURE_MAX_LOD:\n        this.gl.texParameterf(this.handle, pname, param);\n        break;\n\n      case GL.TEXTURE_WIDTH:\n      case GL.TEXTURE_HEIGHT:\n        assert(false);\n        break;\n\n      default:\n        this.gl.texParameteri(this.target, pname, param);\n        break;\n    }\n\n    this.gl.bindTexture(this.target, null);\n    return this;\n  }\n\n  _isNPOT() {\n    if (isWebGL2(this.gl)) {\n      // NPOT restriction is only for WebGL1\n      return false;\n    }\n    // Width and height not available, consider it is not NPOT texture\n    if (!this.width || !this.height) {\n      return false;\n    }\n    return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);\n  }\n\n  // Update default settings which are not supported by NPOT textures.\n  _updateForNPOT(parameters) {\n    if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {\n      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR`)();\n      parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;\n    }\n    if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {\n      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_WRAP_S to CLAMP_TO_EDGE`)();\n      parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;\n    }\n    if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {\n      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_WRAP_T to CLAMP_TO_EDGE`)();\n      parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;\n    }\n  }\n\n  _getNPOTParam(pname, param) {\n    if (this._isNPOT()) {\n      switch (pname) {\n        case GL.TEXTURE_MIN_FILTER:\n          if (NPOT_MIN_FILTERS.indexOf(param) === -1) {\n            // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR`)();\n            param = GL.LINEAR;\n          }\n          break;\n        case GL.TEXTURE_WRAP_S:\n        case GL.TEXTURE_WRAP_T:\n          if (param !== GL.CLAMP_TO_EDGE) {\n            // log.warn(`texture: ${this} is Non-Power-Of-Two, ${getKey(this.gl, pname)} to CLAMP_TO_EDGE`)();\n            param = GL.CLAMP_TO_EDGE;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n    return param;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}