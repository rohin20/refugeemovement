{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { getCode, getVertices, CONTOUR_TYPE } from './marching-squares';\nexport function generateContours(_ref) {\n  var thresholdData = _ref.thresholdData,\n    colors = _ref.colors,\n    cellWeights = _ref.cellWeights,\n    gridSize = _ref.gridSize,\n    gridOrigin = _ref.gridOrigin,\n    cellSize = _ref.cellSize;\n  var contourSegments = [];\n  var contourPolygons = [];\n  var width = gridSize[0];\n  var height = gridSize[1];\n  var segmentIndex = 0;\n  var polygonIndex = 0;\n  var _iterator = _createForOfIteratorHelper(thresholdData),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var data = _step.value;\n      var contour = data.contour;\n      var threshold = contour.threshold;\n      for (var x = -1; x < width; x++) {\n        for (var y = -1; y < height; y++) {\n          var _getCode = getCode({\n              cellWeights: cellWeights,\n              threshold: threshold,\n              x: x,\n              y: y,\n              width: width,\n              height: height\n            }),\n            code = _getCode.code,\n            meanCode = _getCode.meanCode;\n          var opts = {\n            gridOrigin: gridOrigin,\n            cellSize: cellSize,\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            code: code,\n            meanCode: meanCode,\n            thresholdData: data\n          };\n          if (Array.isArray(threshold)) {\n            opts.type = CONTOUR_TYPE.ISO_BANDS;\n            var polygons = getVertices(opts);\n            var _iterator2 = _createForOfIteratorHelper(polygons),\n              _step2;\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var polygon = _step2.value;\n                contourPolygons[polygonIndex++] = {\n                  vertices: polygon,\n                  contour: contour\n                };\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          } else {\n            opts.type = CONTOUR_TYPE.ISO_LINES;\n            var vertices = getVertices(opts);\n            for (var i = 0; i < vertices.length; i += 2) {\n              contourSegments[segmentIndex++] = {\n                start: vertices[i],\n                end: vertices[i + 1],\n                contour: contour\n              };\n            }\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    contourSegments: contourSegments,\n    contourPolygons: contourPolygons\n  };\n}","map":{"version":3,"names":["getCode","getVertices","CONTOUR_TYPE","generateContours","_ref","thresholdData","colors","cellWeights","gridSize","gridOrigin","cellSize","contourSegments","contourPolygons","width","height","segmentIndex","polygonIndex","_iterator","_createForOfIteratorHelper","_step","s","n","done","data","value","contour","threshold","x","y","_getCode","code","meanCode","opts","Array","isArray","type","ISO_BANDS","polygons","_iterator2","_step2","polygon","vertices","err","e","f","ISO_LINES","i","length","start","end"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/aggregation-layers/src/contour-layer/contour-utils.js"],"sourcesContent":["import {getCode, getVertices, CONTOUR_TYPE} from './marching-squares';\n\n// Given all the cell weights, generates contours for each threshold.\n/* eslint-disable max-depth */\nexport function generateContours({\n  thresholdData,\n  colors,\n  cellWeights,\n  gridSize,\n  gridOrigin,\n  cellSize\n}) {\n  const contourSegments = [];\n  const contourPolygons = [];\n  const width = gridSize[0];\n  const height = gridSize[1];\n  let segmentIndex = 0;\n  let polygonIndex = 0;\n\n  for (const data of thresholdData) {\n    const {contour} = data;\n    const {threshold} = contour;\n    for (let x = -1; x < width; x++) {\n      for (let y = -1; y < height; y++) {\n        // Get the MarchingSquares code based on neighbor cell weights.\n        const {code, meanCode} = getCode({\n          cellWeights,\n          threshold,\n          x,\n          y,\n          width,\n          height\n        });\n        const opts = {\n          gridOrigin,\n          cellSize,\n          x,\n          y,\n          width,\n          height,\n          code,\n          meanCode,\n          thresholdData: data\n        };\n        if (Array.isArray(threshold)) {\n          opts.type = CONTOUR_TYPE.ISO_BANDS;\n          const polygons = getVertices(opts);\n          for (const polygon of polygons) {\n            contourPolygons[polygonIndex++] = {\n              vertices: polygon,\n              contour\n            };\n          }\n        } else {\n          // Get the intersection vertices based on MarchingSquares code.\n          opts.type = CONTOUR_TYPE.ISO_LINES;\n          const vertices = getVertices(opts);\n          for (let i = 0; i < vertices.length; i += 2) {\n            contourSegments[segmentIndex++] = {\n              start: vertices[i],\n              end: vertices[i + 1],\n              contour\n            };\n          }\n        }\n      }\n    }\n  }\n  return {contourSegments, contourPolygons};\n}\n/* eslint-enable max-depth */\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}