{"ast":null,"code":"import _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { assert, log } from '@luma.gl/webgl';\nimport { Matrix4, Quaternion } from '@math.gl/core';\nexport var ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nexport var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    var ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    var components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    var length = components * accessor.count;\n    var _accessor$bufferView$ = accessor.bufferView.data,\n      buffer = _accessor$bufferView$.buffer,\n      byteOffset = _accessor$bufferView$.byteOffset;\n    var array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      var slicedArray = [];\n      for (var i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n  return accessor._animation;\n}\nvar helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n  if (gltfNode.rotation) {\n    var rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\nvar quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    quaternion.slerp({\n      start: start,\n      target: stop,\n      ratio: ratio\n    });\n    for (var i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    for (var _i = 0; _i < start.length; _i++) {\n      target[path][_i] = ratio * stop[_i] + (1 - ratio) * start[_i];\n    }\n  }\n}\nfunction cubicsplineInterpolate(target, path, _ref) {\n  var p0 = _ref.p0,\n    outTangent0 = _ref.outTangent0,\n    inTangent1 = _ref.inTangent1,\n    p1 = _ref.p1,\n    tDiff = _ref.tDiff,\n    t = _ref.ratio;\n  for (var i = 0; i < target[path].length; i++) {\n    var m0 = outTangent0[i] * tDiff;\n    var m1 = inTangent1[i] * tDiff;\n    target[path][i] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\nfunction stepInterpolate(target, path, value) {\n  for (var i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\nfunction interpolate(time, _ref2, target, path) {\n  var input = _ref2.input,\n    interpolation = _ref2.interpolation,\n    output = _ref2.output;\n  var maxTime = input[input.length - 1];\n  var animationTime = time % maxTime;\n  var nextIndex = input.findIndex(function (t) {\n    return t >= animationTime;\n  });\n  var previousIndex = Math.max(0, nextIndex - 1);\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n      default:\n        log.warn(\"Bad animation path \".concat(path))();\n    }\n  }\n  assert(target[path].length === output[previousIndex].length);\n  var previousTime = input[previousIndex];\n  var nextTime = input[nextIndex];\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        var ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n      break;\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        var _ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        var tDiff = nextTime - previousTime;\n        var p0 = output[3 * previousIndex + 1];\n        var outTangent0 = output[3 * previousIndex + 2];\n        var inTangent1 = output[3 * nextIndex + 0];\n        var p1 = output[3 * nextIndex + 1];\n        cubicsplineInterpolate(target, path, {\n          p0: p0,\n          outTangent0: outTangent0,\n          inTangent1: inTangent1,\n          p1: p1,\n          tDiff: tDiff,\n          ratio: _ratio\n        });\n      }\n      break;\n    default:\n      log.warn(\"Interpolation \".concat(interpolation, \" not supported\"))();\n      break;\n  }\n}\nvar GLTFAnimation = /*#__PURE__*/function () {\n  function GLTFAnimation(props) {\n    _classCallCheck(this, GLTFAnimation);\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n    this.channels = [];\n    Object.assign(this, props);\n  }\n  _createClass(GLTFAnimation, [{\n    key: \"animate\",\n    value: function animate(timeMs) {\n      if (!this.playing) {\n        return;\n      }\n      var absTime = timeMs / 1000;\n      var time = (absTime - this.startTime) * this.speed;\n      this.channels.forEach(function (_ref3) {\n        var sampler = _ref3.sampler,\n          target = _ref3.target,\n          path = _ref3.path;\n        interpolate(time, sampler, target, path);\n        applyTranslationRotationScale(target, target._node);\n      });\n    }\n  }]);\n  return GLTFAnimation;\n}();\nvar GLTFAnimator = /*#__PURE__*/function () {\n  function GLTFAnimator(gltf) {\n    _classCallCheck(this, GLTFAnimator);\n    this.animations = gltf.animations.map(function (animation, index) {\n      var name = animation.name || \"Animation-\".concat(index);\n      var samplers = animation.samplers.map(function (_ref4) {\n        var input = _ref4.input,\n          _ref4$interpolation = _ref4.interpolation,\n          interpolation = _ref4$interpolation === void 0 ? 'LINEAR' : _ref4$interpolation,\n          output = _ref4.output;\n        return {\n          input: accessorToJsArray(gltf.accessors[input]),\n          interpolation: interpolation,\n          output: accessorToJsArray(gltf.accessors[output])\n        };\n      });\n      var channels = animation.channels.map(function (_ref5) {\n        var sampler = _ref5.sampler,\n          target = _ref5.target;\n        return {\n          sampler: samplers[sampler],\n          target: gltf.nodes[target.node],\n          path: target.path\n        };\n      });\n      return new GLTFAnimation({\n        name: name,\n        channels: channels\n      });\n    });\n  }\n  _createClass(GLTFAnimator, [{\n    key: \"animate\",\n    value: function animate(time) {\n      this.setTime(time);\n    }\n  }, {\n    key: \"setTime\",\n    value: function setTime(time) {\n      this.animations.forEach(function (animation) {\n        return animation.animate(time);\n      });\n    }\n  }, {\n    key: \"getAnimations\",\n    value: function getAnimations() {\n      return this.animations;\n    }\n  }]);\n  return GLTFAnimator;\n}();\nexport { GLTFAnimator as default };","map":{"version":3,"names":["assert","log","Matrix4","Quaternion","ATTRIBUTE_TYPE_TO_COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY","Int8Array","Uint8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","accessorToJsArray","accessor","_animation","ArrayType","componentType","components","type","length","count","_accessor$bufferView$","bufferView","data","buffer","byteOffset","array","Array","from","slicedArray","i","push","slice","helperMatrix","applyTranslationRotationScale","gltfNode","node","matrix","identity","translation","translate","rotation","rotationMatrix","fromQuaternion","multiplyRight","scale","quaternion","linearInterpolate","target","path","start","stop","ratio","slerp","cubicsplineInterpolate","_ref","p0","outTangent0","inTangent1","p1","tDiff","t","m0","m1","Math","pow","stepInterpolate","value","interpolate","time","_ref2","input","interpolation","output","maxTime","animationTime","nextIndex","findIndex","previousIndex","max","isArray","warn","concat","previousTime","nextTime","GLTFAnimation","props","_classCallCheck","startTime","playing","speed","channels","Object","assign","_createClass","key","animate","timeMs","absTime","forEach","_ref3","sampler","_node","GLTFAnimator","gltf","animations","map","animation","index","name","samplers","_ref4","_ref4$interpolation","accessors","_ref5","nodes","setTime","getAnimations","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@luma.gl/experimental/src/gltf/gltf-animator.js"],"sourcesContent":["import {assert, log} from '@luma.gl/webgl';\nimport {Matrix4, Quaternion} from '@math.gl/core';\n\n// TODO: import from loaders.gl?\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n//\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {buffer, byteOffset} = accessor.bufferView.data;\n\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\n// TODO: share with GLTFInstantiator\nconst helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nconst quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    quaternion.slerp({start, target: stop, ratio});\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio: t}) {\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] =\n      (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] +\n      (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 +\n      (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] +\n      (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, {input, interpolation, output}, target, path) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n\n        cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio});\n      }\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n\nclass GLTFAnimation {\n  constructor(props) {\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n    this.channels = [];\n\n    Object.assign(this, props);\n  }\n\n  animate(timeMs) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n\n    this.channels.forEach(({sampler, target, path}) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n}\n\nexport default class GLTFAnimator {\n  constructor(gltf) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(({input, interpolation = 'LINEAR', output}) => ({\n        input: accessorToJsArray(gltf.accessors[input]),\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      }));\n      const channels = animation.channels.map(({sampler, target}) => ({\n        sampler: samplers[sampler],\n        target: gltf.nodes[target.node],\n        path: target.path\n      }));\n      return new GLTFAnimation({name, channels});\n    });\n  }\n\n  // TODO(Tarek): This should be removed? (deck.gl is using this)\n  animate(time) {\n    this.setTime(time);\n  }\n\n  setTime(time) {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}