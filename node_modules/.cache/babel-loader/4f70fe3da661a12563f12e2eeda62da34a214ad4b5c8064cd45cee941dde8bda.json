{"ast":null,"code":"import _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Buffer, Transform } from '@luma.gl/core';\nimport Attribute from '../lib/attribute/attribute';\nimport { padBuffer, getAttributeTypeFromSize, getSourceBufferAttribute, getAttributeBufferLength, cycleBuffers } from '../lib/attribute/attribute-transition-utils';\nimport Transition from './transition';\nvar GPUInterpolationTransition = /*#__PURE__*/function () {\n  function GPUInterpolationTransition(_ref) {\n    var gl = _ref.gl,\n      attribute = _ref.attribute,\n      timeline = _ref.timeline;\n    _classCallCheck(this, GPUInterpolationTransition);\n    _defineProperty(this, \"gl\", void 0);\n    _defineProperty(this, \"type\", 'interpolation');\n    _defineProperty(this, \"attributeInTransition\", void 0);\n    _defineProperty(this, \"settings\", void 0);\n    _defineProperty(this, \"attribute\", void 0);\n    _defineProperty(this, \"transition\", void 0);\n    _defineProperty(this, \"currentStartIndices\", void 0);\n    _defineProperty(this, \"currentLength\", void 0);\n    _defineProperty(this, \"transform\", void 0);\n    _defineProperty(this, \"buffers\", void 0);\n    this.gl = gl;\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    this.attributeInTransition = new Attribute(gl, attribute.settings);\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = 0;\n    this.transform = getTransform(gl, attribute);\n    var bufferOpts = {\n      byteLength: 0,\n      usage: 35050\n    };\n    this.buffers = [new Buffer(gl, bufferOpts), new Buffer(gl, bufferOpts)];\n  }\n  _createClass(GPUInterpolationTransition, [{\n    key: \"inProgress\",\n    get: function get() {\n      return this.transition.inProgress;\n    }\n  }, {\n    key: \"start\",\n    value: function start(transitionSettings, numInstances) {\n      if (transitionSettings.duration <= 0) {\n        this.transition.cancel();\n        return;\n      }\n      this.settings = transitionSettings;\n      var gl = this.gl,\n        buffers = this.buffers,\n        attribute = this.attribute;\n      cycleBuffers(buffers);\n      var padBufferOpts = {\n        numInstances: numInstances,\n        attribute: attribute,\n        fromLength: this.currentLength,\n        fromStartIndices: this.currentStartIndices,\n        getData: transitionSettings.enter\n      };\n      var _iterator = _createForOfIteratorHelper(buffers),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var buffer = _step.value;\n          padBuffer(_objectSpread({\n            buffer: buffer\n          }, padBufferOpts));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.currentStartIndices = attribute.startIndices;\n      this.currentLength = getAttributeBufferLength(attribute, numInstances);\n      this.attributeInTransition.setData({\n        buffer: buffers[1],\n        value: attribute.value\n      });\n      this.transition.start(transitionSettings);\n      this.transform.update({\n        elementCount: Math.floor(this.currentLength / attribute.size),\n        sourceBuffers: {\n          aFrom: buffers[0],\n          aTo: getSourceBufferAttribute(gl, attribute)\n        },\n        feedbackBuffers: {\n          vCurrent: buffers[1]\n        }\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var updated = this.transition.update();\n      if (updated) {\n        var _this$settings = this.settings,\n          duration = _this$settings.duration,\n          easing = _this$settings.easing;\n        var time = this.transition.time;\n        var t = time / duration;\n        if (easing) {\n          t = easing(t);\n        }\n        this.transform.run({\n          uniforms: {\n            time: t\n          }\n        });\n      }\n      return updated;\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this.transition.cancel();\n      this.transform.delete();\n      var _iterator2 = _createForOfIteratorHelper(this.buffers),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var buffer = _step2.value;\n          buffer.delete();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      this.buffers.length = 0;\n    }\n  }]);\n  return GPUInterpolationTransition;\n}();\nexport { GPUInterpolationTransition as default };\nvar vs = \"\\n#define SHADER_NAME interpolation-transition-vertex-shader\\n\\nuniform float time;\\nattribute ATTRIBUTE_TYPE aFrom;\\nattribute ATTRIBUTE_TYPE aTo;\\nvarying ATTRIBUTE_TYPE vCurrent;\\n\\nvoid main(void) {\\n  vCurrent = mix(aFrom, aTo, time);\\n  gl_Position = vec4(0.0);\\n}\\n\";\nfunction getTransform(gl, attribute) {\n  var attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    vs: vs,\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vCurrent']\n  });\n}","map":{"version":3,"names":["Buffer","Transform","Attribute","padBuffer","getAttributeTypeFromSize","getSourceBufferAttribute","getAttributeBufferLength","cycleBuffers","Transition","GPUInterpolationTransition","_ref","gl","attribute","timeline","_classCallCheck","_defineProperty","transition","attributeInTransition","settings","currentStartIndices","startIndices","currentLength","transform","getTransform","bufferOpts","byteLength","usage","buffers","_createClass","key","get","inProgress","value","start","transitionSettings","numInstances","duration","cancel","padBufferOpts","fromLength","fromStartIndices","getData","enter","_iterator","_createForOfIteratorHelper","_step","s","n","done","buffer","_objectSpread","err","e","f","setData","update","elementCount","Math","floor","size","sourceBuffers","aFrom","aTo","feedbackBuffers","vCurrent","updated","_this$settings","easing","time","t","run","uniforms","delete","_iterator2","_step2","length","default","vs","attributeType","defines","ATTRIBUTE_TYPE","varyings"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/core/src/transitions/gpu-interpolation-transition.ts"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport {Buffer, Transform} from '@luma.gl/core';\nimport Attribute from '../lib/attribute/attribute';\nimport {\n  padBuffer,\n  getAttributeTypeFromSize,\n  getSourceBufferAttribute,\n  getAttributeBufferLength,\n  cycleBuffers,\n  InterpolationTransitionSettings\n} from '../lib/attribute/attribute-transition-utils';\nimport Transition from './transition';\n\nimport type {Timeline, Transform as LumaTransform} from '@luma.gl/engine';\nimport type {Buffer as LumaBuffer} from '@luma.gl/webgl';\nimport type {NumericArray} from '../types/types';\nimport type GPUTransition from './gpu-transition';\n\nexport default class GPUInterpolationTransition implements GPUTransition {\n  gl: WebGLRenderingContext;\n  type = 'interpolation';\n  attributeInTransition: Attribute;\n\n  private settings?: InterpolationTransitionSettings;\n  private attribute: Attribute;\n  private transition: Transition;\n  private currentStartIndices: NumericArray | null;\n  private currentLength: number;\n  private transform: LumaTransform;\n  private buffers: LumaBuffer[];\n\n  constructor({\n    gl,\n    attribute,\n    timeline\n  }: {\n    gl: WebGLRenderingContext;\n    attribute: Attribute;\n    timeline: Timeline;\n  }) {\n    this.gl = gl;\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    // this is the attribute we return during the transition - note: if it is a constant\n    // attribute, it will be converted and returned as a regular attribute\n    // `attribute.userData` is the original options passed when constructing the attribute.\n    // This ensures that we set the proper `doublePrecision` flag and shader attributes.\n    this.attributeInTransition = new Attribute(gl, attribute.settings);\n    this.currentStartIndices = attribute.startIndices;\n    // storing currentLength because this.buffer may be larger than the actual length we want to use\n    // this is because we only reallocate buffers when they grow, not when they shrink,\n    // due to performance costs\n    this.currentLength = 0;\n    this.transform = getTransform(gl, attribute);\n    const bufferOpts = {\n      byteLength: 0,\n      usage: GL.DYNAMIC_COPY\n    };\n    this.buffers = [\n      new Buffer(gl, bufferOpts), // from\n      new Buffer(gl, bufferOpts) // current\n    ];\n  }\n\n  get inProgress(): boolean {\n    return this.transition.inProgress;\n  }\n\n  // this is called when an attribute's values have changed and\n  // we need to start animating towards the new values\n  // this also correctly resizes / pads the transform's buffers\n  // in case the attribute's buffer has changed in length or in\n  // startIndices\n  start(transitionSettings: InterpolationTransitionSettings, numInstances: number): void {\n    if (transitionSettings.duration <= 0) {\n      this.transition.cancel();\n      return;\n    }\n    this.settings = transitionSettings;\n\n    const {gl, buffers, attribute} = this;\n    // Alternate between two buffers when new transitions start.\n    // Last destination buffer is used as an attribute (from state),\n    // And the other buffer is now the current buffer.\n    cycleBuffers(buffers);\n\n    const padBufferOpts = {\n      numInstances,\n      attribute,\n      fromLength: this.currentLength,\n      fromStartIndices: this.currentStartIndices,\n      getData: transitionSettings.enter\n    };\n\n    for (const buffer of buffers) {\n      padBuffer({buffer, ...padBufferOpts});\n    }\n\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = getAttributeBufferLength(attribute, numInstances);\n    this.attributeInTransition.setData({\n      buffer: buffers[1],\n      // Hack: Float64Array is required for double-precision attributes\n      // to generate correct shader attributes\n      value: attribute.value as NumericArray\n    });\n\n    this.transition.start(transitionSettings);\n\n    this.transform.update({\n      elementCount: Math.floor(this.currentLength / attribute.size),\n      sourceBuffers: {\n        aFrom: buffers[0],\n        aTo: getSourceBufferAttribute(gl, attribute)\n      },\n      feedbackBuffers: {\n        vCurrent: buffers[1]\n      }\n    });\n  }\n\n  update(): boolean {\n    const updated = this.transition.update();\n    if (updated) {\n      const {duration, easing} = this.settings as InterpolationTransitionSettings;\n      const {time} = this.transition;\n      let t = time / duration;\n      if (easing) {\n        t = easing(t);\n      }\n      this.transform.run({\n        uniforms: {time: t}\n      });\n    }\n    return updated;\n  }\n\n  cancel(): void {\n    this.transition.cancel();\n    this.transform.delete();\n    for (const buffer of this.buffers) {\n      buffer.delete();\n    }\n    this.buffers.length = 0;\n  }\n}\n\nconst vs = `\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n`;\n\nfunction getTransform(gl: WebGLRenderingContext, attribute: Attribute): LumaTransform {\n  const attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    vs,\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vCurrent']\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}