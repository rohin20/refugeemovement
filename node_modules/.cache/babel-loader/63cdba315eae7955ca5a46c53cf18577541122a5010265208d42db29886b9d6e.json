{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.defaultRadius = exports.defaultLineWidth = exports.defaultElevation = exports.featureAccessor = exports.geoJsonRequiredColumns = exports.geojsonVisConfigs = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.uniq\"));\nvar _typeAnalyzer = require(\"type-analyzer\");\nvar _baseLayer = _interopRequireWildcard(require(\"../base-layer\"));\nvar _layers = require(\"@deck.gl/layers\");\nvar _geojsonUtils = require(\"./geojson-utils\");\nvar _geojsonLayerIcon = _interopRequireDefault(require(\"./geojson-layer-icon\"));\nvar _constants = require(\"@kepler.gl/constants\");\nvar _SUPPORTED_ANALYZER_T;\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar SUPPORTED_ANALYZER_TYPES = (_SUPPORTED_ANALYZER_T = {}, (0, _defineProperty2[\"default\"])(_SUPPORTED_ANALYZER_T, _typeAnalyzer.DATA_TYPES.GEOMETRY, true), (0, _defineProperty2[\"default\"])(_SUPPORTED_ANALYZER_T, _typeAnalyzer.DATA_TYPES.GEOMETRY_FROM_STRING, true), (0, _defineProperty2[\"default\"])(_SUPPORTED_ANALYZER_T, _typeAnalyzer.DATA_TYPES.PAIR_GEOMETRY_FROM_STRING, true), _SUPPORTED_ANALYZER_T);\nvar geojsonVisConfigs = {\n  opacity: 'opacity',\n  strokeOpacity: _objectSpread(_objectSpread({}, _constants.LAYER_VIS_CONFIGS.opacity), {}, {\n    property: 'strokeOpacity'\n  }),\n  thickness: _objectSpread(_objectSpread({}, _constants.LAYER_VIS_CONFIGS.thickness), {}, {\n    defaultValue: 0.5\n  }),\n  strokeColor: 'strokeColor',\n  colorRange: 'colorRange',\n  strokeColorRange: 'strokeColorRange',\n  radius: 'radius',\n  sizeRange: 'strokeWidthRange',\n  radiusRange: 'radiusRange',\n  heightRange: 'elevationRange',\n  elevationScale: 'elevationScale',\n  enableElevationZoomFactor: 'enableElevationZoomFactor',\n  stroked: 'stroked',\n  filled: 'filled',\n  enable3d: 'enable3d',\n  wireframe: 'wireframe'\n};\nexports.geojsonVisConfigs = geojsonVisConfigs;\nvar geoJsonRequiredColumns = ['geojson'];\nexports.geoJsonRequiredColumns = geoJsonRequiredColumns;\nvar featureAccessor = function featureAccessor(_ref) {\n  var geojson = _ref.geojson;\n  return function (dc) {\n    return function (d) {\n      return dc.valueAt(d.index, geojson.fieldIdx);\n    };\n  };\n}; // access feature properties from geojson sub layer\n\nexports.featureAccessor = featureAccessor;\nvar defaultElevation = 500;\nexports.defaultElevation = defaultElevation;\nvar defaultLineWidth = 1;\nexports.defaultLineWidth = defaultLineWidth;\nvar defaultRadius = 1;\nexports.defaultRadius = defaultRadius;\nvar GeoJsonLayer = /*#__PURE__*/function (_Layer) {\n  (0, _inherits2[\"default\"])(GeoJsonLayer, _Layer);\n  var _super = _createSuper(GeoJsonLayer);\n  function GeoJsonLayer(props) {\n    var _this;\n    (0, _classCallCheck2[\"default\"])(this, GeoJsonLayer);\n    _this = _super.call(this, props);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"dataToFeature\", void 0);\n    _this.dataToFeature = [];\n    _this.registerVisConfig(geojsonVisConfigs);\n    _this.getPositionAccessor = function (dataContainer) {\n      return featureAccessor(_this.config.columns)(dataContainer);\n    };\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(GeoJsonLayer, [{\n    key: \"type\",\n    get: function get() {\n      return GeoJsonLayer.type;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'Polygon';\n    }\n  }, {\n    key: \"layerIcon\",\n    get: function get() {\n      return _geojsonLayerIcon[\"default\"];\n    }\n  }, {\n    key: \"requiredLayerColumns\",\n    get: function get() {\n      return geoJsonRequiredColumns;\n    }\n  }, {\n    key: \"visualChannels\",\n    get: function get() {\n      var visualChannels = (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(GeoJsonLayer.prototype), \"visualChannels\", this);\n      return {\n        color: _objectSpread(_objectSpread({}, visualChannels.color), {}, {\n          accessor: 'getFillColor',\n          condition: function condition(config) {\n            return config.visConfig.filled;\n          },\n          nullValue: visualChannels.color.nullValue,\n          getAttributeValue: function getAttributeValue(config) {\n            return function (d) {\n              return d.properties.fillColor || config.color;\n            };\n          },\n          // used this to get updateTriggers\n          defaultValue: function defaultValue(config) {\n            return config.color;\n          }\n        }),\n        strokeColor: {\n          property: 'strokeColor',\n          field: 'strokeColorField',\n          scale: 'strokeColorScale',\n          domain: 'strokeColorDomain',\n          range: 'strokeColorRange',\n          key: 'strokeColor',\n          channelScaleType: _constants.CHANNEL_SCALES.color,\n          accessor: 'getLineColor',\n          condition: function condition(config) {\n            return config.visConfig.stroked;\n          },\n          nullValue: visualChannels.color.nullValue,\n          getAttributeValue: function getAttributeValue(config) {\n            return function (d) {\n              return d.properties.lineColor || config.visConfig.strokeColor || config.color;\n            };\n          },\n          // used this to get updateTriggers\n          defaultValue: function defaultValue(config) {\n            return config.visConfig.strokeColor || config.color;\n          }\n        },\n        size: _objectSpread(_objectSpread({}, visualChannels.size), {}, {\n          property: 'stroke',\n          accessor: 'getLineWidth',\n          condition: function condition(config) {\n            return config.visConfig.stroked;\n          },\n          nullValue: 0,\n          getAttributeValue: function getAttributeValue() {\n            return function (d) {\n              return d.properties.lineWidth || defaultLineWidth;\n            };\n          }\n        }),\n        height: {\n          property: 'height',\n          field: 'heightField',\n          scale: 'heightScale',\n          domain: 'heightDomain',\n          range: 'heightRange',\n          key: 'height',\n          channelScaleType: _constants.CHANNEL_SCALES.size,\n          accessor: 'getElevation',\n          condition: function condition(config) {\n            return config.visConfig.enable3d;\n          },\n          nullValue: 0,\n          getAttributeValue: function getAttributeValue() {\n            return function (d) {\n              return d.properties.elevation || defaultElevation;\n            };\n          }\n        },\n        radius: {\n          property: 'radius',\n          field: 'radiusField',\n          scale: 'radiusScale',\n          domain: 'radiusDomain',\n          range: 'radiusRange',\n          key: 'radius',\n          channelScaleType: _constants.CHANNEL_SCALES.radius,\n          accessor: 'getPointRadius',\n          nullValue: 0,\n          getAttributeValue: function getAttributeValue() {\n            return function (d) {\n              return d.properties.radius || defaultRadius;\n            };\n          }\n        }\n      };\n    }\n  }, {\n    key: \"getDefaultLayerConfig\",\n    value: function getDefaultLayerConfig() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return _objectSpread(_objectSpread({}, (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(GeoJsonLayer.prototype), \"getDefaultLayerConfig\", this).call(this, props)), {}, {\n        // add height visual channel\n        heightField: null,\n        heightDomain: [0, 1],\n        heightScale: 'linear',\n        // add radius visual channel\n        radiusField: null,\n        radiusDomain: [0, 1],\n        radiusScale: 'linear',\n        // add stroke color visual channel\n        strokeColorField: null,\n        strokeColorDomain: [0, 1],\n        strokeColorScale: 'quantile'\n      });\n    }\n  }, {\n    key: \"getHoverData\",\n    value: function getHoverData(object, dataContainer) {\n      // index of dataContainer is saved to feature.properties\n      return dataContainer.row(object.properties.index);\n    }\n  }, {\n    key: \"calculateDataAttribute\",\n    value: function calculateDataAttribute(_ref2, getPosition) {\n      var _this2 = this;\n      var dataContainer = _ref2.dataContainer,\n        filteredIndex = _ref2.filteredIndex;\n      return filteredIndex.map(function (i) {\n        return _this2.dataToFeature[i];\n      }).filter(function (d) {\n        return d;\n      });\n    }\n  }, {\n    key: \"formatLayerData\",\n    value: function formatLayerData(datasets, oldLayerData) {\n      if (this.config.dataId === null) {\n        return {};\n      }\n      var _datasets$this$config = datasets[this.config.dataId],\n        gpuFilter = _datasets$this$config.gpuFilter,\n        dataContainer = _datasets$this$config.dataContainer;\n      var _this$updateData = this.updateData(datasets, oldLayerData),\n        data = _this$updateData.data;\n      var customFilterValueAccessor = function customFilterValueAccessor(dc, d, fieldIndex) {\n        return dc.valueAt(d.properties.index, fieldIndex);\n      };\n      var indexAccessor = function indexAccessor(f) {\n        return f.properties.index;\n      };\n      var dataAccessor = function dataAccessor(dc) {\n        return function (d) {\n          return {\n            index: d.properties.index\n          };\n        };\n      };\n      var accessors = this.getAttributeAccessors({\n        dataAccessor: dataAccessor,\n        dataContainer: dataContainer\n      });\n      return _objectSpread({\n        data: data,\n        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(indexAccessor, customFilterValueAccessor)\n      }, accessors);\n    }\n  }, {\n    key: \"updateLayerMeta\",\n    value: function updateLayerMeta(dataContainer) {\n      var getFeature = this.getPositionAccessor(dataContainer);\n      this.dataToFeature = (0, _geojsonUtils.getGeojsonDataMaps)(dataContainer, getFeature); // get bounds from features\n\n      var bounds = (0, _geojsonUtils.getGeojsonBounds)(this.dataToFeature); // if any of the feature has properties.radius set to be true\n\n      var fixedRadius = Boolean(this.dataToFeature.find(function (d) {\n        return d && d.properties && d.properties.radius;\n      })); // keep a record of what type of geometry the collection has\n\n      var featureTypes = (0, _geojsonUtils.getGeojsonFeatureTypes)(this.dataToFeature);\n      this.updateMeta({\n        bounds: bounds,\n        fixedRadius: fixedRadius,\n        featureTypes: featureTypes\n      });\n    }\n  }, {\n    key: \"setInitialLayerConfig\",\n    value: function setInitialLayerConfig(_ref3) {\n      var dataContainer = _ref3.dataContainer;\n      if (!dataContainer.numRows()) {\n        return this;\n      }\n      this.updateLayerMeta(dataContainer);\n      var featureTypes = this.meta.featureTypes; // default settings is stroke: true, filled: false\n\n      if (featureTypes && featureTypes.polygon) {\n        // set both fill and stroke to true\n        return this.updateLayerVisConfig({\n          filled: true,\n          stroked: true,\n          strokeColor: _baseLayer.colorMaker.next().value\n        });\n      } else if (featureTypes && featureTypes.point) {\n        // set fill to true if detect point\n        return this.updateLayerVisConfig({\n          filled: true,\n          stroked: false\n        });\n      }\n      return this;\n    }\n  }, {\n    key: \"renderLayer\",\n    value: function renderLayer(opts) {\n      var data = opts.data,\n        gpuFilter = opts.gpuFilter,\n        objectHovered = opts.objectHovered,\n        mapState = opts.mapState,\n        interactionConfig = opts.interactionConfig;\n      var _this$meta = this.meta,\n        fixedRadius = _this$meta.fixedRadius,\n        featureTypes = _this$meta.featureTypes;\n      var radiusScale = this.getRadiusScaleByZoom(mapState, fixedRadius);\n      var zoomFactor = this.getZoomFactor(mapState);\n      var eleZoomFactor = this.getElevationZoomFactor(mapState);\n      var visConfig = this.config.visConfig;\n      var layerProps = {\n        lineWidthScale: visConfig.thickness * zoomFactor * 8,\n        elevationScale: visConfig.elevationScale * eleZoomFactor,\n        pointRadiusScale: radiusScale,\n        lineMiterLimit: 4\n      };\n      var updateTriggers = _objectSpread(_objectSpread({}, this.getVisualChannelUpdateTriggers()), {}, {\n        getFilterValue: gpuFilter.filterValueUpdateTriggers\n      });\n      var defaultLayerProps = this.getDefaultDeckLayerProps(opts);\n      var opaOverwrite = {\n        opacity: visConfig.strokeOpacity\n      };\n      var pickable = interactionConfig.tooltip.enabled;\n      var hoveredObject = this.hasHoveredObject(objectHovered);\n      return [new _layers.GeoJsonLayer(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaultLayerProps), layerProps), data), {}, {\n        pickable: pickable,\n        highlightColor: _constants.HIGHLIGH_COLOR_3D,\n        autoHighlight: visConfig.enable3d && pickable,\n        stroked: visConfig.stroked,\n        filled: visConfig.filled,\n        extruded: visConfig.enable3d,\n        wireframe: visConfig.wireframe,\n        wrapLongitude: false,\n        lineMiterLimit: 2,\n        capRounded: true,\n        jointRounded: true,\n        updateTriggers: updateTriggers,\n        _subLayerProps: _objectSpread(_objectSpread(_objectSpread({}, featureTypes !== null && featureTypes !== void 0 && featureTypes.polygon ? {\n          'polygons-stroke': opaOverwrite\n        } : {}), featureTypes !== null && featureTypes !== void 0 && featureTypes.line ? {\n          linestrings: opaOverwrite\n        } : {}), featureTypes !== null && featureTypes !== void 0 && featureTypes.point ? {\n          points: {\n            lineOpacity: visConfig.strokeOpacity\n          }\n        } : {})\n      }))].concat((0, _toConsumableArray2[\"default\"])(hoveredObject && !visConfig.enable3d ? [new _layers.GeoJsonLayer(_objectSpread(_objectSpread(_objectSpread({}, this.getDefaultHoverLayerProps()), layerProps), {}, {\n        wrapLongitude: false,\n        data: [hoveredObject],\n        getLineWidth: data.getLineWidth,\n        getPointRadius: data.getPointRadius,\n        getElevation: data.getElevation,\n        getLineColor: this.config.highlightColor,\n        getFillColor: this.config.highlightColor,\n        // always draw outline\n        stroked: true,\n        filled: false\n      }))] : []));\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'geojson';\n    }\n  }, {\n    key: \"findDefaultLayerProps\",\n    value: function findDefaultLayerProps(_ref4) {\n      var _this3 = this;\n      var label = _ref4.label,\n        _ref4$fields = _ref4.fields,\n        fields = _ref4$fields === void 0 ? [] : _ref4$fields;\n      var geojsonColumns = fields.filter(function (f) {\n        return f.type === 'geojson' && SUPPORTED_ANALYZER_TYPES[f.analyzerType];\n      }).map(function (f) {\n        return f.name;\n      });\n      var defaultColumns = {\n        geojson: (0, _lodash[\"default\"])([].concat((0, _toConsumableArray2[\"default\"])(_constants.GEOJSON_FIELDS.geojson), (0, _toConsumableArray2[\"default\"])(geojsonColumns)))\n      };\n      var foundColumns = this.findDefaultColumnField(defaultColumns, fields);\n      if (!foundColumns || !foundColumns.length) {\n        return {\n          props: []\n        };\n      }\n      return {\n        props: foundColumns.map(function (columns) {\n          return {\n            label: typeof label === 'string' && label.replace(/\\.[^/.]+$/, '') || _this3.type,\n            columns: columns,\n            isVisible: true\n          };\n        })\n      };\n    }\n  }]);\n  return GeoJsonLayer;\n}(_baseLayer[\"default\"]);\nexports[\"default\"] = GeoJsonLayer;","map":{"version":3,"names":["exports","defaultRadius","defaultLineWidth","defaultElevation","featureAccessor","geoJsonRequiredColumns","geojsonVisConfigs","_toConsumableArray2","_interopRequireDefault","require","_classCallCheck2","_createClass2","_assertThisInitialized2","_get2","_inherits2","_baseLayer","_interopRequireWildcard","_layers","_geojsonUtils","_geojsonLayerIcon","_constants","_SUPPORTED_ANALYZER_T","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","_getPrototypeOf2","result","NewTarget","constructor","Reflect","construct","arguments","apply","_possibleConstructorReturn2","radiusRange","sham","Proxy","Boolean","prototype","valueOf","call","e","ownKeys","elevationScale","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","_objectSpread","target","i","length","source","forEach","key","_defineProperty2","getOwnPropertyDescriptors","defineProperties","defineProperty","SUPPORTED_ANALYZER_TYPES","_typeAnalyzer","DATA_TYPES","GEOMETRY","GEOMETRY_FROM_STRING","PAIR_GEOMETRY_FROM_STRING","opacity","property","defaultValue","strokeColor","colorRange","strokeColorRange","radius","sizeRange","stroked","enable3d","d","dc","valueAt","index","geojson","fieldIdx","GeoJsonLayer","_Layer","props","_this","_super","dataToFeature","getPositionAccessor","dataContainer","config","columns","get","type","condition","visualChannels","color","accessor","visConfig","filled","nullValue","getAttributeValue","properties","fillColor","field","scale","domain","range","channelScaleType","CHANNEL_SCALES","lineColor","size","lineWidth","height","elevation","value","getDefaultLayerConfig","undefined","heightScale","radiusField","radiusDomain","radiusScale","strokeColorField","strokeColorDomain","strokeColorScale","getHoverData","row","calculateDataAttribute","_ref2","getPosition","filteredIndex","map","_this2","formatLayerData","datasets","oldLayerData","dataId","_datasets$this$config","gpuFilter","_this$updateData","updateData","data","customFilterValueAccessor","fieldIndex","indexAccessor","f","dataAccessor","getFilterValue","filterValueAccessor","accessors","updateLayerMeta","getGeojsonDataMaps","getFeature","bounds","getGeojsonBounds","fixedRadius","find","featureTypes","getGeojsonFeatureTypes","updateMeta","setInitialLayerConfig","_ref3","numRows","polygon","updateLayerVisConfig","colorMaker","next","point","renderLayer","updateTriggers","opts","mapState","interactionConfig","_this$meta","meta","getRadiusScaleByZoom","zoomFactor","getZoomFactor","eleZoomFactor","getElevationZoomFactor","layerProps","lineWidthScale","thickness","pointRadiusScale","lineMiterLimit","getVisualChannelUpdateTriggers","filterValueUpdateTriggers","defaultLayerProps","getDefaultDeckLayerProps","opaOverwrite","strokeOpacity","pickable","tooltip","enabled","hoveredObject","hasHoveredObject","objectHovered","highlightColor","HIGHLIGH_COLOR_3D","autoHighlight","extruded","wireframe","wrapLongitude","capRounded","jointRounded","_subLayerProps","points","lineOpacity","concat","getDefaultHoverLayerProps","getLineWidth","getPointRadius","getElevation","getLineColor","getFillColor","findDefaultLayerProps","_ref4","label","_ref4$fields","fields","geojsonColumns","analyzerType","name","defaultColumns","foundColumns"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/layers/src/geojson-layer/geojson-layer.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport uniq from 'lodash.uniq';\nimport {DATA_TYPES} from 'type-analyzer';\n\nimport Layer, {\n  colorMaker,\n  LayerBaseConfig,\n  LayerColorConfig,\n  LayerColumn,\n  LayerHeightConfig,\n  LayerRadiusConfig,\n  LayerSizeConfig,\n  LayerStrokeColorConfig\n} from '../base-layer';\nimport {GeoJsonLayer as DeckGLGeoJsonLayer} from '@deck.gl/layers';\nimport {\n  getGeojsonDataMaps,\n  getGeojsonBounds,\n  getGeojsonFeatureTypes,\n  GeojsonDataMaps\n} from './geojson-utils';\nimport GeojsonLayerIcon from './geojson-layer-icon';\nimport {\n  GEOJSON_FIELDS,\n  HIGHLIGH_COLOR_3D,\n  CHANNEL_SCALES,\n  ColorRange,\n  LAYER_VIS_CONFIGS\n} from '@kepler.gl/constants';\nimport {\n  VisConfigNumber,\n  VisConfigColorSelect,\n  VisConfigColorRange,\n  VisConfigRange,\n  VisConfigBoolean,\n  Merge,\n  RGBColor\n} from '@kepler.gl/types';\nimport {KeplerTable} from '@kepler.gl/table';\nimport {DataContainerInterface} from '@kepler.gl/utils';\n\nconst SUPPORTED_ANALYZER_TYPES = {\n  [DATA_TYPES.GEOMETRY]: true,\n  [DATA_TYPES.GEOMETRY_FROM_STRING]: true,\n  [DATA_TYPES.PAIR_GEOMETRY_FROM_STRING]: true\n};\n\nexport const geojsonVisConfigs: {\n  opacity: 'opacity';\n  strokeOpacity: VisConfigNumber;\n  thickness: VisConfigNumber;\n  strokeColor: 'strokeColor';\n  colorRange: 'colorRange';\n  strokeColorRange: 'strokeColorRange';\n  radius: 'radius';\n\n  sizeRange: 'strokeWidthRange';\n  radiusRange: 'radiusRange';\n  heightRange: 'elevationRange';\n  elevationScale: 'elevationScale';\n  enableElevationZoomFactor: 'enableElevationZoomFactor';\n  stroked: 'stroked';\n  filled: 'filled';\n  enable3d: 'enable3d';\n  wireframe: 'wireframe';\n} = {\n  opacity: 'opacity',\n  strokeOpacity: {\n    ...LAYER_VIS_CONFIGS.opacity,\n    property: 'strokeOpacity'\n  },\n  thickness: {\n    ...LAYER_VIS_CONFIGS.thickness,\n    defaultValue: 0.5\n  },\n  strokeColor: 'strokeColor',\n  colorRange: 'colorRange',\n  strokeColorRange: 'strokeColorRange',\n  radius: 'radius',\n\n  sizeRange: 'strokeWidthRange',\n  radiusRange: 'radiusRange',\n  heightRange: 'elevationRange',\n  elevationScale: 'elevationScale',\n  enableElevationZoomFactor: 'enableElevationZoomFactor',\n  stroked: 'stroked',\n  filled: 'filled',\n  enable3d: 'enable3d',\n  wireframe: 'wireframe'\n};\n\nexport type GeoJsonVisConfigSettings = {\n  opacity: VisConfigNumber;\n  strokeOpacity: VisConfigNumber;\n  thickness: VisConfigNumber;\n  strokeColor: VisConfigColorSelect;\n  colorRange: VisConfigColorRange;\n  strokeColorRange: VisConfigColorRange;\n  radius: VisConfigNumber;\n\n  sizeRange: VisConfigRange;\n  radiusRange: VisConfigRange;\n  heightRange: VisConfigRange;\n  elevationScale: VisConfigNumber;\n  enableElevationZoomFactor: VisConfigBoolean;\n  stroked: VisConfigBoolean;\n  filled: VisConfigBoolean;\n  enable3d: VisConfigBoolean;\n  wireframe: VisConfigBoolean;\n};\n\nexport type GeoJsonLayerColumnsConfig = {\n  geojson: LayerColumn;\n};\n\nexport type GeoJsonLayerVisConfig = {\n  opacity: number;\n  strokeOpacity: number;\n  thickness: number;\n  strokeColor: RGBColor;\n  colorRange: ColorRange;\n  strokeColorRange: ColorRange;\n  radius: number;\n\n  sizeRange: [number, number];\n  radiusRange: [number, number];\n  heightRange: [number, number];\n  elevationScale: number;\n  enableElevationZoomFactor: boolean;\n  stroked: boolean;\n  filled: boolean;\n  enable3d: boolean;\n  wireframe: boolean;\n};\n\ntype GeoJsonLayerVisualChannelConfig = LayerColorConfig &\n  LayerStrokeColorConfig &\n  LayerSizeConfig &\n  LayerHeightConfig &\n  LayerRadiusConfig;\nexport type GeoJsonLayerConfig = Merge<\n  LayerBaseConfig,\n  {columns: GeoJsonLayerColumnsConfig; visConfig: GeoJsonLayerVisConfig}\n> &\n  GeoJsonLayerVisualChannelConfig;\n\nexport type GeoJsonLayerMeta = {\n  featureTypes?: {polygon: boolean; point: boolean; line: boolean};\n  fixedRadius?: boolean;\n};\n\nexport const geoJsonRequiredColumns: ['geojson'] = ['geojson'];\nexport const featureAccessor = ({geojson}: GeoJsonLayerColumnsConfig) => (\n  dc: DataContainerInterface\n) => d => dc.valueAt(d.index, geojson.fieldIdx);\n\n// access feature properties from geojson sub layer\nexport const defaultElevation = 500;\nexport const defaultLineWidth = 1;\nexport const defaultRadius = 1;\n\nexport default class GeoJsonLayer extends Layer {\n  declare config: GeoJsonLayerConfig;\n  declare visConfigSettings: GeoJsonVisConfigSettings;\n  declare meta: GeoJsonLayerMeta;\n  dataToFeature: GeojsonDataMaps;\n\n  constructor(props) {\n    super(props);\n\n    this.dataToFeature = [];\n    this.registerVisConfig(geojsonVisConfigs);\n    this.getPositionAccessor = (dataContainer: DataContainerInterface) =>\n      featureAccessor(this.config.columns)(dataContainer);\n  }\n\n  get type() {\n    return GeoJsonLayer.type;\n  }\n  static get type(): 'geojson' {\n    return 'geojson';\n  }\n\n  get name(): 'Polygon' {\n    return 'Polygon';\n  }\n\n  get layerIcon() {\n    return GeojsonLayerIcon;\n  }\n\n  get requiredLayerColumns() {\n    return geoJsonRequiredColumns;\n  }\n\n  get visualChannels() {\n    const visualChannels = super.visualChannels;\n    return {\n      color: {\n        ...visualChannels.color,\n        accessor: 'getFillColor',\n        condition: config => config.visConfig.filled,\n        nullValue: visualChannels.color.nullValue,\n        getAttributeValue: config => d => d.properties.fillColor || config.color,\n        // used this to get updateTriggers\n        defaultValue: config => config.color\n      },\n      strokeColor: {\n        property: 'strokeColor',\n        field: 'strokeColorField',\n        scale: 'strokeColorScale',\n        domain: 'strokeColorDomain',\n        range: 'strokeColorRange',\n        key: 'strokeColor',\n        channelScaleType: CHANNEL_SCALES.color,\n        accessor: 'getLineColor',\n        condition: config => config.visConfig.stroked,\n        nullValue: visualChannels.color.nullValue,\n        getAttributeValue: config => d =>\n          d.properties.lineColor || config.visConfig.strokeColor || config.color,\n        // used this to get updateTriggers\n        defaultValue: config => config.visConfig.strokeColor || config.color\n      },\n      size: {\n        ...visualChannels.size,\n        property: 'stroke',\n        accessor: 'getLineWidth',\n        condition: config => config.visConfig.stroked,\n        nullValue: 0,\n        getAttributeValue: () => d => d.properties.lineWidth || defaultLineWidth\n      },\n      height: {\n        property: 'height',\n        field: 'heightField',\n        scale: 'heightScale',\n        domain: 'heightDomain',\n        range: 'heightRange',\n        key: 'height',\n        channelScaleType: CHANNEL_SCALES.size,\n        accessor: 'getElevation',\n        condition: config => config.visConfig.enable3d,\n        nullValue: 0,\n        getAttributeValue: () => d => d.properties.elevation || defaultElevation\n      },\n      radius: {\n        property: 'radius',\n        field: 'radiusField',\n        scale: 'radiusScale',\n        domain: 'radiusDomain',\n        range: 'radiusRange',\n        key: 'radius',\n        channelScaleType: CHANNEL_SCALES.radius,\n        accessor: 'getPointRadius',\n        nullValue: 0,\n        getAttributeValue: () => d => d.properties.radius || defaultRadius\n      }\n    };\n  }\n\n  static findDefaultLayerProps({label, fields = []}: KeplerTable) {\n    const geojsonColumns = fields\n      .filter(f => f.type === 'geojson' && SUPPORTED_ANALYZER_TYPES[f.analyzerType])\n      .map(f => f.name);\n\n    const defaultColumns = {\n      geojson: uniq([...GEOJSON_FIELDS.geojson, ...geojsonColumns])\n    };\n\n    const foundColumns = this.findDefaultColumnField(defaultColumns, fields);\n    if (!foundColumns || !foundColumns.length) {\n      return {props: []};\n    }\n\n    return {\n      props: foundColumns.map(columns => ({\n        label: (typeof label === 'string' && label.replace(/\\.[^/.]+$/, '')) || this.type,\n        columns,\n        isVisible: true\n      }))\n    };\n  }\n\n  getDefaultLayerConfig(props = {}) {\n    return {\n      ...super.getDefaultLayerConfig(props),\n\n      // add height visual channel\n      heightField: null,\n      heightDomain: [0, 1],\n      heightScale: 'linear',\n\n      // add radius visual channel\n      radiusField: null,\n      radiusDomain: [0, 1],\n      radiusScale: 'linear',\n\n      // add stroke color visual channel\n      strokeColorField: null,\n      strokeColorDomain: [0, 1],\n      strokeColorScale: 'quantile'\n    };\n  }\n\n  getHoverData(object, dataContainer) {\n    // index of dataContainer is saved to feature.properties\n    return dataContainer.row(object.properties.index);\n  }\n\n  calculateDataAttribute({dataContainer, filteredIndex}, getPosition) {\n    return filteredIndex.map(i => this.dataToFeature[i]).filter(d => d);\n  }\n\n  formatLayerData(datasets, oldLayerData) {\n    if (this.config.dataId === null) {\n      return {};\n    }\n    const {gpuFilter, dataContainer} = datasets[this.config.dataId];\n    const {data} = this.updateData(datasets, oldLayerData);\n\n    const customFilterValueAccessor = (dc, d, fieldIndex) => {\n      return dc.valueAt(d.properties.index, fieldIndex);\n    };\n    const indexAccessor = f => f.properties.index;\n\n    const dataAccessor = dc => d => ({index: d.properties.index});\n    const accessors = this.getAttributeAccessors({dataAccessor, dataContainer});\n\n    return {\n      data,\n      getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(\n        indexAccessor,\n        customFilterValueAccessor\n      ),\n      ...accessors\n    };\n  }\n\n  updateLayerMeta(dataContainer) {\n    const getFeature = this.getPositionAccessor(dataContainer);\n    this.dataToFeature = getGeojsonDataMaps(dataContainer, getFeature);\n\n    // get bounds from features\n    const bounds = getGeojsonBounds(this.dataToFeature);\n    // if any of the feature has properties.radius set to be true\n    const fixedRadius = Boolean(\n      this.dataToFeature.find(d => d && d.properties && d.properties.radius)\n    );\n\n    // keep a record of what type of geometry the collection has\n    const featureTypes = getGeojsonFeatureTypes(this.dataToFeature);\n\n    this.updateMeta({bounds, fixedRadius, featureTypes});\n  }\n\n  setInitialLayerConfig({dataContainer}) {\n    if (!dataContainer.numRows()) {\n      return this;\n    }\n    this.updateLayerMeta(dataContainer);\n\n    const {featureTypes} = this.meta;\n    // default settings is stroke: true, filled: false\n    if (featureTypes && featureTypes.polygon) {\n      // set both fill and stroke to true\n      return this.updateLayerVisConfig({\n        filled: true,\n        stroked: true,\n        strokeColor: colorMaker.next().value\n      });\n    } else if (featureTypes && featureTypes.point) {\n      // set fill to true if detect point\n      return this.updateLayerVisConfig({filled: true, stroked: false});\n    }\n\n    return this;\n  }\n\n  renderLayer(opts) {\n    const {data, gpuFilter, objectHovered, mapState, interactionConfig} = opts;\n\n    const {fixedRadius, featureTypes} = this.meta;\n    const radiusScale = this.getRadiusScaleByZoom(mapState, fixedRadius);\n    const zoomFactor = this.getZoomFactor(mapState);\n    const eleZoomFactor = this.getElevationZoomFactor(mapState);\n\n    const {visConfig} = this.config;\n\n    const layerProps = {\n      lineWidthScale: visConfig.thickness * zoomFactor * 8,\n      elevationScale: visConfig.elevationScale * eleZoomFactor,\n      pointRadiusScale: radiusScale,\n      lineMiterLimit: 4\n    };\n\n    const updateTriggers = {\n      ...this.getVisualChannelUpdateTriggers(),\n      getFilterValue: gpuFilter.filterValueUpdateTriggers\n    };\n\n    const defaultLayerProps = this.getDefaultDeckLayerProps(opts);\n    const opaOverwrite = {\n      opacity: visConfig.strokeOpacity\n    };\n\n    const pickable = interactionConfig.tooltip.enabled;\n    const hoveredObject = this.hasHoveredObject(objectHovered);\n\n    return [\n      new DeckGLGeoJsonLayer({\n        ...defaultLayerProps,\n        ...layerProps,\n        ...data,\n        pickable,\n        highlightColor: HIGHLIGH_COLOR_3D,\n        autoHighlight: visConfig.enable3d && pickable,\n        stroked: visConfig.stroked,\n        filled: visConfig.filled,\n        extruded: visConfig.enable3d,\n        wireframe: visConfig.wireframe,\n        wrapLongitude: false,\n        lineMiterLimit: 2,\n        capRounded: true,\n        jointRounded: true,\n        updateTriggers,\n        _subLayerProps: {\n          ...(featureTypes?.polygon ? {'polygons-stroke': opaOverwrite} : {}),\n          ...(featureTypes?.line ? {linestrings: opaOverwrite} : {}),\n          ...(featureTypes?.point\n            ? {\n                points: {\n                  lineOpacity: visConfig.strokeOpacity\n                }\n              }\n            : {})\n        }\n      }),\n      ...(hoveredObject && !visConfig.enable3d\n        ? [\n            new DeckGLGeoJsonLayer({\n              ...this.getDefaultHoverLayerProps(),\n              ...layerProps,\n              wrapLongitude: false,\n              data: [hoveredObject],\n              getLineWidth: data.getLineWidth,\n              getPointRadius: data.getPointRadius,\n              getElevation: data.getElevation,\n              getLineColor: this.config.highlightColor,\n              getFillColor: this.config.highlightColor,\n              // always draw outline\n              stroked: true,\n              filled: false\n            })\n          ]\n        : [])\n    ];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}