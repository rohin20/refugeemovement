{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.datasetSchema = exports.DatasetSchema = exports.propertiesV1 = exports.propertiesV0 = exports.FieldSchema = exports.fieldPropertiesV1 = exports.fieldPropertiesV0 = void 0;\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.pick\"));\nvar _window = require(\"global/window\");\nvar _versions = require(\"./versions\");\nvar _schema = _interopRequireDefault(require(\"./schema\"));\nvar _utils = require(\"@kepler.gl/utils\");\nvar _datasetSchema;\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// version v0\nvar fieldPropertiesV0 = {\n  name: null,\n  type: null\n};\nexports.fieldPropertiesV0 = fieldPropertiesV0;\nvar fieldPropertiesV1 = {\n  name: null,\n  type: null,\n  format: null,\n  analyzerType: null,\n  metadata: null\n};\nexports.fieldPropertiesV1 = fieldPropertiesV1;\nvar FieldSchema = /*#__PURE__*/function (_Schema) {\n  (0, _inherits2[\"default\"])(FieldSchema, _Schema);\n  var _super = _createSuper(FieldSchema);\n  function FieldSchema() {\n    (0, _classCallCheck2[\"default\"])(this, FieldSchema);\n    return _super.apply(this, arguments);\n  }\n  (0, _createClass2[\"default\"])(FieldSchema, [{\n    key: \"save\",\n    value: function save(fields) {\n      var _this = this;\n      return (0, _defineProperty2[\"default\"])({}, this.key, fields.map(function (f) {\n        return _this.savePropertiesOrApplySchema(f)[_this.key];\n      }));\n    }\n  }, {\n    key: \"load\",\n    value: function load(fields) {\n      return (0, _defineProperty2[\"default\"])({}, this.key, fields);\n    }\n  }]);\n  return FieldSchema;\n}(_schema[\"default\"]);\nexports.FieldSchema = FieldSchema;\nvar propertiesV0 = {\n  id: null,\n  label: null,\n  color: null,\n  allData: null,\n  fields: new FieldSchema({\n    key: 'fields',\n    version: _versions.VERSIONS.v0,\n    properties: fieldPropertiesV0\n  })\n};\nexports.propertiesV0 = propertiesV0;\nvar propertiesV1 = _objectSpread(_objectSpread({}, propertiesV0), {}, {\n  fields: new FieldSchema({\n    key: 'fields',\n    version: _versions.VERSIONS.v1,\n    properties: fieldPropertiesV1\n  })\n});\nexports.propertiesV1 = propertiesV1;\nvar DatasetSchema = /*#__PURE__*/function (_Schema2) {\n  (0, _inherits2[\"default\"])(DatasetSchema, _Schema2);\n  var _super2 = _createSuper(DatasetSchema);\n  function DatasetSchema() {\n    var _this2;\n    (0, _classCallCheck2[\"default\"])(this, DatasetSchema);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this2 = _super2.call.apply(_super2, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this2), \"key\", 'dataset');\n    return _this2;\n  }\n  (0, _createClass2[\"default\"])(DatasetSchema, [{\n    key: \"save\",\n    value: function save(dataset) {\n      var datasetFlattened = dataset.dataContainer ? _objectSpread(_objectSpread({}, dataset), {}, {\n        allData: dataset.dataContainer.flattenData()\n      }) : dataset;\n      return this.savePropertiesOrApplySchema(datasetFlattened)[this.key];\n    }\n  }, {\n    key: \"load\",\n    value: function load(dataset) {\n      var fields = dataset.fields,\n        allData = dataset.allData;\n      var updatedFields = fields; // recalculate field type\n      // because we have updated type-analyzer\n      // we need to add format to each field\n\n      var needCalculateMeta = fields[0] && (!fields[0].hasOwnProperty('format') || !fields[0].hasOwnProperty('analyzerType'));\n      if (needCalculateMeta) {\n        var fieldOrder = fields.map(function (f) {\n          return f.name;\n        });\n        var sampleData = (0, _utils.getSampleForTypeAnalyze)({\n          fields: fieldOrder,\n          rows: allData\n        });\n        var meta = (0, _utils.getFieldsFromData)(sampleData, fieldOrder);\n        updatedFields = meta.map(function (f, i) {\n          return _objectSpread(_objectSpread({}, (0, _lodash[\"default\"])(meta[i], ['name', 'type', 'format'])), {}, {\n            analyzerType: meta[i].analyzerType\n          });\n        });\n        updatedFields.forEach(function (f, i) {\n          if (fields[i].type !== f.type) {\n            // if newly detected field type is different from saved type\n            // we log it but won't update it, cause we don't want to break people's map\n            _window.console.warn(\"detect \".concat(f.name, \" type is now \").concat(f.type, \" instead of \").concat(fields[i].type));\n          }\n        });\n      } // get format of all fields\n\n      return {\n        data: {\n          fields: updatedFields,\n          rows: dataset.allData\n        },\n        info: (0, _lodash[\"default\"])(dataset, ['id', 'label', 'color'])\n      };\n    }\n  }]);\n  return DatasetSchema;\n}(_schema[\"default\"]);\nexports.DatasetSchema = DatasetSchema;\nvar datasetSchema = (_datasetSchema = {}, (0, _defineProperty2[\"default\"])(_datasetSchema, _versions.VERSIONS.v0, new DatasetSchema({\n  key: 'dataset',\n  version: _versions.VERSIONS.v0,\n  properties: propertiesV0\n})), (0, _defineProperty2[\"default\"])(_datasetSchema, _versions.VERSIONS.v1, new DatasetSchema({\n  key: 'dataset',\n  version: _versions.VERSIONS.v1,\n  properties: propertiesV1\n})), _datasetSchema);\nexports.datasetSchema = datasetSchema;\nvar _default = datasetSchema;\nexports[\"default\"] = _default;","map":{"version":3,"names":["value","exports","datasetSchema","DatasetSchema","propertiesV1","propertiesV0","FieldSchema","fieldPropertiesV1","fieldPropertiesV0","_assertThisInitialized2","_interopRequireDefault","require","_defineProperty2","_lodash","_window","_versions","_schema","_utils","_datasetSchema","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","type","analyzerType","metadata","_Schema","_super","_createSuper","_classCallCheck2","_createClass2","key","save","fields","_this","map","f","savePropertiesOrApplySchema","_Schema2","_super2","_this2","_len","arguments","length","args","Array","_key","call","concat","dataset","datasetFlattened","dataContainer","_objectSpread","allData","flattenData","load","updatedFields","needCalculateMeta","hasOwnProperty","fieldOrder","sampleData","getSampleForTypeAnalyze","rows","meta","getFieldsFromData","i","console","warn","name","data"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/schemas/src/dataset-schema.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport pick from 'lodash.pick';\nimport {console as globalConsole} from 'global/window';\n\nimport {ProtoDataset, RGBColor} from '@kepler.gl/types';\nimport {KeplerTable} from '@kepler.gl/table';\nimport {VERSIONS} from './versions';\nimport Schema from './schema';\nimport {getFieldsFromData, getSampleForTypeAnalyze} from '@kepler.gl/utils';\n\nexport type SavedField = {\n  name: string;\n  type: string;\n  format?: string;\n  analyzerType?: string;\n};\n\nexport type ParsedField = {\n  name: string;\n  type: string;\n  format: string;\n  analyzerType: string;\n};\n\nexport type SavedDatasetV1 = {\n  version: 'v1';\n  data: {\n    id: string;\n    label: string;\n    color: RGBColor;\n    allData: any[][];\n    fields: SavedField[];\n  };\n};\n\nexport type ParsedDataset = {\n  data: {\n    fields: ParsedField[];\n    rows: any[][];\n  };\n  info: {\n    id?: string;\n    label?: string;\n    color?: RGBColor;\n  };\n};\n\n// version v0\nexport const fieldPropertiesV0 = {\n  name: null,\n  type: null\n};\n\nexport const fieldPropertiesV1 = {\n  name: null,\n  type: null,\n  format: null,\n  analyzerType: null,\n  metadata: null\n};\n\nexport class FieldSchema extends Schema {\n  save(fields) {\n    return {\n      [this.key]: fields.map(f => this.savePropertiesOrApplySchema(f)[this.key])\n    };\n  }\n  load(fields) {\n    return {[this.key]: fields};\n  }\n}\n\nexport const propertiesV0 = {\n  id: null,\n  label: null,\n  color: null,\n  allData: null,\n  fields: new FieldSchema({\n    key: 'fields',\n    version: VERSIONS.v0,\n    properties: fieldPropertiesV0\n  })\n};\n\nexport const propertiesV1 = {\n  ...propertiesV0,\n  fields: new FieldSchema({\n    key: 'fields',\n    version: VERSIONS.v1,\n    properties: fieldPropertiesV1\n  })\n};\n\nexport class DatasetSchema extends Schema {\n  key = 'dataset';\n\n  save(dataset: KeplerTable): SavedDatasetV1['data'] {\n    const datasetFlattened = dataset.dataContainer\n      ? {\n          ...dataset,\n          allData: dataset.dataContainer.flattenData()\n        }\n      : dataset;\n\n    return this.savePropertiesOrApplySchema(datasetFlattened)[this.key];\n  }\n  load(dataset: SavedDatasetV1['data']): ProtoDataset {\n    const {fields, allData} = dataset;\n    let updatedFields = fields;\n\n    // recalculate field type\n    // because we have updated type-analyzer\n    // we need to add format to each field\n    const needCalculateMeta =\n      fields[0] &&\n      (!fields[0].hasOwnProperty('format') || !fields[0].hasOwnProperty('analyzerType'));\n\n    if (needCalculateMeta) {\n      const fieldOrder = fields.map(f => f.name);\n\n      const sampleData = getSampleForTypeAnalyze({\n        fields: fieldOrder,\n        rows: allData\n      });\n      const meta = getFieldsFromData(sampleData, fieldOrder);\n\n      updatedFields = meta.map((f, i) => ({\n        ...pick(meta[i], ['name', 'type', 'format']),\n        analyzerType: meta[i].analyzerType\n      }));\n\n      updatedFields.forEach((f, i) => {\n        if (fields[i].type !== f.type) {\n          // if newly detected field type is different from saved type\n          // we log it but won't update it, cause we don't want to break people's map\n          globalConsole.warn(`detect ${f.name} type is now ${f.type} instead of ${fields[i].type}`);\n        }\n      });\n    }\n\n    // get format of all fields\n    return {\n      data: {fields: updatedFields, rows: dataset.allData},\n      info: pick(dataset, ['id', 'label', 'color'])\n    };\n  }\n}\n\nexport const datasetSchema = {\n  [VERSIONS.v0]: new DatasetSchema({\n    key: 'dataset',\n    version: VERSIONS.v0,\n    properties: propertiesV0\n  }),\n  [VERSIONS.v1]: new DatasetSchema({\n    key: 'dataset',\n    version: VERSIONS.v1,\n    properties: propertiesV1\n  })\n};\n\nexport default datasetSchema;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}