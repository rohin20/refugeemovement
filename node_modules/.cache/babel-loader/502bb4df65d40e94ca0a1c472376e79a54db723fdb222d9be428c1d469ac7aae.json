{"ast":null,"code":"import _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport log from '../utils/log';\nimport { createMat4, getCameraPosition, getFrustumPlanes as _getFrustumPlanes } from '../utils/math-utils';\nimport { Matrix4, Vector3, equals as _equals, clamp } from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\nimport { getDistanceScales as _getDistanceScales, getMeterZoom, lngLatToWorld, worldToLngLat, worldToPixels, pixelsToWorld } from '@math.gl/web-mercator';\nimport { PROJECTION_MODE } from '../lib/constants';\nvar DEGREES_TO_RADIANS = Math.PI / 180;\nvar IDENTITY = createMat4();\nvar ZERO_VECTOR = [0, 0, 0];\nvar DEFAULT_DISTANCE_SCALES = {\n  unitsPerMeter: [1, 1, 1],\n  metersPerUnit: [1, 1, 1]\n};\nfunction createProjectionMatrix(_ref) {\n  var width = _ref.width,\n    height = _ref.height,\n    orthographic = _ref.orthographic,\n    fovyRadians = _ref.fovyRadians,\n    focalDistance = _ref.focalDistance,\n    padding = _ref.padding,\n    near = _ref.near,\n    far = _ref.far;\n  var aspect = width / height;\n  var matrix = orthographic ? new Matrix4().orthographic({\n    fovy: fovyRadians,\n    aspect: aspect,\n    focalDistance: focalDistance,\n    near: near,\n    far: far\n  }) : new Matrix4().perspective({\n    fovy: fovyRadians,\n    aspect: aspect,\n    near: near,\n    far: far\n  });\n  if (padding) {\n    var _padding$left = padding.left,\n      left = _padding$left === void 0 ? 0 : _padding$left,\n      _padding$right = padding.right,\n      right = _padding$right === void 0 ? 0 : _padding$right,\n      _padding$top = padding.top,\n      top = _padding$top === void 0 ? 0 : _padding$top,\n      _padding$bottom = padding.bottom,\n      bottom = _padding$bottom === void 0 ? 0 : _padding$bottom;\n    var offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;\n    var offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;\n    matrix[8] -= offsetX * 2 / width;\n    matrix[9] += offsetY * 2 / height;\n  }\n  return matrix;\n}\nvar Viewport = /*#__PURE__*/function () {\n  function Viewport() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Viewport);\n    _defineProperty(this, \"id\", void 0);\n    _defineProperty(this, \"x\", void 0);\n    _defineProperty(this, \"y\", void 0);\n    _defineProperty(this, \"width\", void 0);\n    _defineProperty(this, \"height\", void 0);\n    _defineProperty(this, \"padding\", void 0);\n    _defineProperty(this, \"isGeospatial\", void 0);\n    _defineProperty(this, \"zoom\", void 0);\n    _defineProperty(this, \"focalDistance\", void 0);\n    _defineProperty(this, \"position\", void 0);\n    _defineProperty(this, \"modelMatrix\", void 0);\n    _defineProperty(this, \"distanceScales\", void 0);\n    _defineProperty(this, \"scale\", void 0);\n    _defineProperty(this, \"center\", void 0);\n    _defineProperty(this, \"cameraPosition\", void 0);\n    _defineProperty(this, \"projectionMatrix\", void 0);\n    _defineProperty(this, \"viewMatrix\", void 0);\n    _defineProperty(this, \"viewMatrixUncentered\", void 0);\n    _defineProperty(this, \"viewMatrixInverse\", void 0);\n    _defineProperty(this, \"viewProjectionMatrix\", void 0);\n    _defineProperty(this, \"pixelProjectionMatrix\", void 0);\n    _defineProperty(this, \"pixelUnprojectionMatrix\", void 0);\n    _defineProperty(this, \"resolution\", void 0);\n    _defineProperty(this, \"_frustumPlanes\", {});\n    this.id = opts.id || this.constructor.displayName || 'viewport';\n    this.x = opts.x || 0;\n    this.y = opts.y || 0;\n    this.width = opts.width || 1;\n    this.height = opts.height || 1;\n    this.zoom = opts.zoom || 0;\n    this.padding = opts.padding;\n    this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;\n    this.focalDistance = opts.focalDistance || 1;\n    this.position = opts.position || ZERO_VECTOR;\n    this.modelMatrix = opts.modelMatrix || null;\n    var longitude = opts.longitude,\n      latitude = opts.latitude;\n    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);\n    this._initProps(opts);\n    this._initMatrices(opts);\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n  _createClass(Viewport, [{\n    key: \"subViewports\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"metersPerPixel\",\n    get: function get() {\n      return this.distanceScales.metersPerUnit[2] / this.scale;\n    }\n  }, {\n    key: \"projectionMode\",\n    get: function get() {\n      if (this.isGeospatial) {\n        return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;\n      }\n      return PROJECTION_MODE.IDENTITY;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(viewport) {\n      if (!(viewport instanceof Viewport)) {\n        return false;\n      }\n      if (this === viewport) {\n        return true;\n      }\n      return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && _equals(viewport.projectionMatrix, this.projectionMatrix) && _equals(viewport.viewMatrix, this.viewMatrix);\n    }\n  }, {\n    key: \"project\",\n    value: function project(xyz) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref2$topLeft = _ref2.topLeft,\n        topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft;\n      var worldPosition = this.projectPosition(xyz);\n      var coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n      var _coord = _slicedToArray(coord, 2),\n        x = _coord[0],\n        y = _coord[1];\n      var y2 = topLeft ? y : this.height - y;\n      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n    }\n  }, {\n    key: \"unproject\",\n    value: function unproject(xyz) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref3$topLeft = _ref3.topLeft,\n        topLeft = _ref3$topLeft === void 0 ? true : _ref3$topLeft,\n        targetZ = _ref3.targetZ;\n      var _xyz = _slicedToArray(xyz, 3),\n        x = _xyz[0],\n        y = _xyz[1],\n        z = _xyz[2];\n      var y2 = topLeft ? y : this.height - y;\n      var targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n      var coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n      var _this$unprojectPositi = this.unprojectPosition(coord),\n        _this$unprojectPositi2 = _slicedToArray(_this$unprojectPositi, 3),\n        X = _this$unprojectPositi2[0],\n        Y = _this$unprojectPositi2[1],\n        Z = _this$unprojectPositi2[2];\n      if (Number.isFinite(z)) {\n        return [X, Y, Z];\n      }\n      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    }\n  }, {\n    key: \"projectPosition\",\n    value: function projectPosition(xyz) {\n      var _this$projectFlat = this.projectFlat(xyz),\n        _this$projectFlat2 = _slicedToArray(_this$projectFlat, 2),\n        X = _this$projectFlat2[0],\n        Y = _this$projectFlat2[1];\n      var Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n      return [X, Y, Z];\n    }\n  }, {\n    key: \"unprojectPosition\",\n    value: function unprojectPosition(xyz) {\n      var _this$unprojectFlat = this.unprojectFlat(xyz),\n        _this$unprojectFlat2 = _slicedToArray(_this$unprojectFlat, 2),\n        X = _this$unprojectFlat2[0],\n        Y = _this$unprojectFlat2[1];\n      var Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n      return [X, Y, Z];\n    }\n  }, {\n    key: \"projectFlat\",\n    value: function projectFlat(xyz) {\n      if (this.isGeospatial) {\n        var result = lngLatToWorld(xyz);\n        result[1] = clamp(result[1], -318, 830);\n        return result;\n      }\n      return xyz;\n    }\n  }, {\n    key: \"unprojectFlat\",\n    value: function unprojectFlat(xyz) {\n      if (this.isGeospatial) {\n        return worldToLngLat(xyz);\n      }\n      return xyz;\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var unprojectOption = {\n        targetZ: options.z || 0\n      };\n      var topLeft = this.unproject([0, 0], unprojectOption);\n      var topRight = this.unproject([this.width, 0], unprojectOption);\n      var bottomLeft = this.unproject([0, this.height], unprojectOption);\n      var bottomRight = this.unproject([this.width, this.height], unprojectOption);\n      return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];\n    }\n  }, {\n    key: \"getDistanceScales\",\n    value: function getDistanceScales(coordinateOrigin) {\n      if (coordinateOrigin) {\n        return _getDistanceScales({\n          longitude: coordinateOrigin[0],\n          latitude: coordinateOrigin[1],\n          highPrecision: true\n        });\n      }\n      return this.distanceScales;\n    }\n  }, {\n    key: \"containsPixel\",\n    value: function containsPixel(_ref4) {\n      var x = _ref4.x,\n        y = _ref4.y,\n        _ref4$width = _ref4.width,\n        width = _ref4$width === void 0 ? 1 : _ref4$width,\n        _ref4$height = _ref4.height,\n        height = _ref4$height === void 0 ? 1 : _ref4$height;\n      return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;\n    }\n  }, {\n    key: \"getFrustumPlanes\",\n    value: function getFrustumPlanes() {\n      if (this._frustumPlanes.near) {\n        return this._frustumPlanes;\n      }\n      Object.assign(this._frustumPlanes, _getFrustumPlanes(this.viewProjectionMatrix));\n      return this._frustumPlanes;\n    }\n  }, {\n    key: \"panByPosition\",\n    value: function panByPosition(coords, pixel) {\n      return null;\n    }\n  }, {\n    key: \"_initProps\",\n    value: function _initProps(opts) {\n      var longitude = opts.longitude;\n      var latitude = opts.latitude;\n      if (this.isGeospatial) {\n        if (!Number.isFinite(opts.zoom)) {\n          this.zoom = getMeterZoom({\n            latitude: latitude\n          }) + Math.log2(this.focalDistance);\n        }\n        this.distanceScales = opts.distanceScales || _getDistanceScales({\n          latitude: latitude,\n          longitude: longitude\n        });\n      }\n      var scale = Math.pow(2, this.zoom);\n      this.scale = scale;\n      var position = opts.position,\n        modelMatrix = opts.modelMatrix;\n      var meterOffset = ZERO_VECTOR;\n      if (position) {\n        meterOffset = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(position, []) : position;\n      }\n      if (this.isGeospatial) {\n        var center = this.projectPosition([longitude, latitude, 0]);\n        this.center = new Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);\n      } else {\n        this.center = this.projectPosition(meterOffset);\n      }\n    }\n  }, {\n    key: \"_initMatrices\",\n    value: function _initMatrices(opts) {\n      var _opts$viewMatrix = opts.viewMatrix,\n        viewMatrix = _opts$viewMatrix === void 0 ? IDENTITY : _opts$viewMatrix,\n        _opts$projectionMatri = opts.projectionMatrix,\n        projectionMatrix = _opts$projectionMatri === void 0 ? null : _opts$projectionMatri,\n        _opts$orthographic = opts.orthographic,\n        orthographic = _opts$orthographic === void 0 ? false : _opts$orthographic,\n        fovyRadians = opts.fovyRadians,\n        _opts$fovy = opts.fovy,\n        fovy = _opts$fovy === void 0 ? 75 : _opts$fovy,\n        _opts$near = opts.near,\n        near = _opts$near === void 0 ? 0.1 : _opts$near,\n        _opts$far = opts.far,\n        far = _opts$far === void 0 ? 1000 : _opts$far,\n        _opts$padding = opts.padding,\n        padding = _opts$padding === void 0 ? null : _opts$padding,\n        _opts$focalDistance = opts.focalDistance,\n        focalDistance = _opts$focalDistance === void 0 ? 1 : _opts$focalDistance;\n      this.viewMatrixUncentered = viewMatrix;\n      this.viewMatrix = new Matrix4().multiplyRight(viewMatrix).translate(new Vector3(this.center).negate());\n      this.projectionMatrix = projectionMatrix || createProjectionMatrix({\n        width: this.width,\n        height: this.height,\n        orthographic: orthographic,\n        fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,\n        focalDistance: focalDistance,\n        padding: padding,\n        near: near,\n        far: far\n      });\n      var vpm = createMat4();\n      mat4.multiply(vpm, vpm, this.projectionMatrix);\n      mat4.multiply(vpm, vpm, this.viewMatrix);\n      this.viewProjectionMatrix = vpm;\n      this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;\n      this.cameraPosition = getCameraPosition(this.viewMatrixInverse);\n      var viewportMatrix = createMat4();\n      var pixelProjectionMatrix = createMat4();\n      mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);\n      mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);\n      mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);\n      this.pixelProjectionMatrix = pixelProjectionMatrix;\n      this.pixelUnprojectionMatrix = mat4.invert(createMat4(), this.pixelProjectionMatrix);\n      if (!this.pixelUnprojectionMatrix) {\n        log.warn('Pixel project matrix not invertible')();\n      }\n    }\n  }]);\n  return Viewport;\n}();\nexport { Viewport as default };\n_defineProperty(Viewport, \"displayName\", 'Viewport');","map":{"version":3,"names":["log","createMat4","getCameraPosition","getFrustumPlanes","Matrix4","Vector3","equals","clamp","mat4","getDistanceScales","getMeterZoom","lngLatToWorld","worldToLngLat","worldToPixels","pixelsToWorld","PROJECTION_MODE","DEGREES_TO_RADIANS","Math","PI","IDENTITY","ZERO_VECTOR","DEFAULT_DISTANCE_SCALES","unitsPerMeter","metersPerUnit","createProjectionMatrix","_ref","width","height","orthographic","fovyRadians","focalDistance","padding","near","far","aspect","matrix","fovy","perspective","_padding$left","left","_padding$right","right","_padding$top","top","_padding$bottom","bottom","offsetX","offsetY","Viewport","opts","arguments","length","undefined","_classCallCheck","_defineProperty","id","constructor","displayName","x","y","zoom","distanceScales","position","modelMatrix","longitude","latitude","isGeospatial","Number","isFinite","_initProps","_initMatrices","bind","project","unproject","projectPosition","unprojectPosition","projectFlat","unprojectFlat","_createClass","key","get","scale","WEB_MERCATOR","WEB_MERCATOR_AUTO_OFFSET","value","viewport","projectionMatrix","viewMatrix","xyz","_ref2","_ref2$topLeft","topLeft","worldPosition","coord","pixelProjectionMatrix","_coord","_slicedToArray","y2","_ref3","_ref3$topLeft","targetZ","_xyz","z","targetZWorld","pixelUnprojectionMatrix","_this$unprojectPositi","_this$unprojectPositi2","X","Y","Z","_this$projectFlat","_this$projectFlat2","_this$unprojectFlat","_this$unprojectFlat2","result","getBounds","options","unprojectOption","topRight","bottomLeft","bottomRight","min","max","coordinateOrigin","highPrecision","containsPixel","_ref4","_ref4$width","_ref4$height","_frustumPlanes","Object","assign","viewProjectionMatrix","panByPosition","coords","pixel","log2","pow","meterOffset","transformAsVector","center","add","_opts$viewMatrix","_opts$projectionMatri","_opts$orthographic","_opts$fovy","_opts$near","_opts$far","_opts$padding","_opts$focalDistance","viewMatrixUncentered","multiplyRight","translate","negate","vpm","multiply","viewMatrixInverse","invert","cameraPosition","viewportMatrix","warn","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/core/src/viewports/viewport.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport log from '../utils/log';\nimport {createMat4, getCameraPosition, getFrustumPlanes, FrustumPlane} from '../utils/math-utils';\n\nimport {Matrix4, Vector3, equals, clamp} from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\n\nimport {\n  getDistanceScales,\n  getMeterZoom,\n  lngLatToWorld,\n  worldToLngLat,\n  worldToPixels,\n  pixelsToWorld\n} from '@math.gl/web-mercator';\n\nimport {PROJECTION_MODE} from '../lib/constants';\n\nexport type DistanceScales = {\n  unitsPerMeter: number[];\n  metersPerUnit: number[];\n};\n\nexport type Padding = {\n  left?: number;\n  right?: number;\n  top?: number;\n  bottom?: number;\n};\n\nexport type ViewportOptions = {\n  /** Name of the viewport */\n  id?: string;\n  /** Left offset from the canvas edge, in pixels */\n  x?: number;\n  /** Top offset from the canvas edge, in pixels */\n  y?: number;\n  /** Viewport width in pixels */\n  width?: number;\n  /** Viewport height in pixels */\n  height?: number;\n  /** Longitude in degrees (geospatial only) */\n  longitude?: number;\n  /** Latitude in degrees (geospatial only) */\n  latitude?: number;\n  /** Viewport center in world space. If geospatial, refers to meter offsets from lng, lat */\n  position?: number[];\n  /** Zoom level */\n  zoom?: number;\n  /** Padding around the viewport, in pixels. */\n  padding?: Padding | null;\n  distanceScales?: DistanceScales;\n  /** Model matrix of viewport center */\n  modelMatrix?: number[] | null;\n  /** Custom view matrix */\n  viewMatrix?: number[];\n  /** Custom projection matrix */\n  projectionMatrix?: number[];\n  /** Modifier of viewport scale. Corresponds to the number of pixels per common unit at zoom 0. */\n  focalDistance?: number;\n  /** Use orthographic projection */\n  orthographic?: boolean;\n  /** fovy in radians. If supplied, overrides fovy */\n  fovyRadians?: number;\n  /** fovy in degrees. */\n  fovy?: number;\n  /** Near plane of the projection matrix */\n  near?: number;\n  /** Far plane of the projection matrix */\n  far?: number;\n};\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\nconst IDENTITY = createMat4();\n\nconst ZERO_VECTOR = [0, 0, 0];\n\nconst DEFAULT_DISTANCE_SCALES: DistanceScales = {\n  unitsPerMeter: [1, 1, 1],\n  metersPerUnit: [1, 1, 1]\n};\n\n// / Helpers\nfunction createProjectionMatrix({\n  width,\n  height,\n  orthographic,\n  fovyRadians,\n  focalDistance,\n  padding,\n  near,\n  far\n}: {\n  width: number;\n  height: number;\n  orthographic: boolean;\n  fovyRadians: number;\n  focalDistance: number;\n  padding: Padding | null;\n  near: number;\n  far: number;\n}) {\n  const aspect = width / height;\n  const matrix = orthographic\n    ? new Matrix4().orthographic({fovy: fovyRadians, aspect, focalDistance, near, far})\n    : new Matrix4().perspective({fovy: fovyRadians, aspect, near, far});\n  if (padding) {\n    const {left = 0, right = 0, top = 0, bottom = 0} = padding;\n    const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;\n    const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;\n    // pixels to clip space\n    matrix[8] -= (offsetX * 2) / width;\n    matrix[9] += (offsetY * 2) / height;\n  }\n  return matrix;\n}\n\n/**\n * Manages coordinate system transformations.\n *\n * Note: The Viewport is immutable in the sense that it only has accessors.\n * A new viewport instance should be created if any parameters have changed.\n */\nexport default class Viewport {\n  static displayName = 'Viewport';\n\n  /** Init parameters */\n\n  id: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  padding?: Padding | null;\n  isGeospatial: boolean;\n  zoom: number;\n  focalDistance: number;\n  position: number[];\n  modelMatrix: number[] | null;\n\n  /** Derived parameters */\n\n  // `!` post-fix expression operator asserts that its operand is non-null and non-undefined in contexts\n  // where the type checker is unable to conclude that fact.\n\n  distanceScales: DistanceScales; /** scale factors between world space and common space */\n  scale!: number; /** scale factor, equals 2^zoom */\n  center!: number[]; /** viewport center in common space */\n  cameraPosition!: number[]; /** Camera position in common space */\n  projectionMatrix!: number[];\n  viewMatrix!: number[];\n  viewMatrixUncentered!: number[];\n  viewMatrixInverse!: number[];\n  viewProjectionMatrix!: number[];\n  pixelProjectionMatrix!: number[];\n  pixelUnprojectionMatrix!: number[];\n  resolution?: number;\n\n  private _frustumPlanes: {[name: string]: FrustumPlane} = {};\n\n  constructor(opts: ViewportOptions = {}) {\n    // @ts-ignore\n    this.id = opts.id || this.constructor.displayName || 'viewport';\n\n    this.x = opts.x || 0;\n    this.y = opts.y || 0;\n    // Silently allow apps to send in w,h = 0,0\n    this.width = opts.width || 1;\n    this.height = opts.height || 1;\n    this.zoom = opts.zoom || 0;\n    this.padding = opts.padding;\n    this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;\n    this.focalDistance = opts.focalDistance || 1;\n    this.position = opts.position || ZERO_VECTOR;\n    this.modelMatrix = opts.modelMatrix || null;\n\n    const {longitude, latitude} = opts;\n    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);\n\n    this._initProps(opts);\n    this._initMatrices(opts);\n\n    // Bind methods for easy access\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n\n  get subViewports(): Viewport[] | null {\n    return null;\n  }\n\n  get metersPerPixel(): number {\n    return this.distanceScales.metersPerUnit[2] / this.scale;\n  }\n\n  get projectionMode(): number {\n    if (this.isGeospatial) {\n      return this.zoom < 12\n        ? PROJECTION_MODE.WEB_MERCATOR\n        : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;\n    }\n    return PROJECTION_MODE.IDENTITY;\n  }\n\n  // Two viewports are equal if width and height are identical, and if\n  // their view and projection matrices are (approximately) equal.\n  equals(viewport: Viewport): boolean {\n    if (!(viewport instanceof Viewport)) {\n      return false;\n    }\n    if (this === viewport) {\n      return true;\n    }\n\n    return (\n      viewport.width === this.width &&\n      viewport.height === this.height &&\n      viewport.scale === this.scale &&\n      equals(viewport.projectionMatrix, this.projectionMatrix) &&\n      equals(viewport.viewMatrix, this.viewMatrix)\n    );\n    // TODO - check distance scales?\n  }\n\n  /**\n   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n   * using viewport projection parameters\n   * - [longitude, latitude] to [x, y]\n   * - [longitude, latitude, Z] => [x, y, z]\n   * Note: By default, returns top-left coordinates for canvas/SVG type render\n   *\n   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether projected coords are top left\n   * @return {Array} - [x, y] or [x, y, z] in top left coords\n   */\n  project(xyz: number[], {topLeft = true}: {topLeft?: boolean} = {}): number[] {\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n\n  /**\n   * Unproject pixel coordinates on screen onto world coordinates,\n   * (possibly [lon, lat]) on map.\n   * - [x, y] => [lng, lat]\n   * - [x, y, z] => [lng, lat, Z]\n   * @param {Array} xyz -\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether origin is top left\n   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]\n   */\n  unproject(\n    xyz: number[],\n    {topLeft = true, targetZ}: {topLeft?: boolean; targetZ?: number} = {}\n  ): number[] {\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ as number] : [X, Y];\n  }\n\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n\n  projectPosition(xyz: number[]): [number, number, number] {\n    const [X, Y] = this.projectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n\n  unprojectPosition(xyz: number[]): [number, number, number] {\n    const [X, Y] = this.unprojectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   * @param {Array} lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return {Array} [x,y] coordinates.\n   */\n  projectFlat(xyz: number[]): [number, number] {\n    if (this.isGeospatial) {\n      // Shader clamps latitude to +-89.9, see /shaderlib/project/project.glsl.js\n      // lngLatToWorld([0, -89.9])[1] = -317.9934163758329\n      // lngLatToWorld([0, 89.9])[1] = 829.9934163758271\n      const result = lngLatToWorld(xyz);\n      result[1] = clamp(result[1], -318, 830);\n      return result;\n    }\n    return xyz as [number, number];\n  }\n\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   * @param {object|Vector} xy - object with {x,y} members\n   *  representing point on projected map plane\n   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  unprojectFlat(xyz: number[]): [number, number] {\n    if (this.isGeospatial) {\n      return worldToLngLat(xyz);\n    }\n    return xyz as [number, number];\n  }\n\n  /**\n   * Get bounds of the current viewport\n   * @return {Array} - [minX, minY, maxX, maxY]\n   */\n  getBounds(options: {z?: number} = {}): [number, number, number, number] {\n    const unprojectOption = {targetZ: options.z || 0};\n\n    const topLeft = this.unproject([0, 0], unprojectOption);\n    const topRight = this.unproject([this.width, 0], unprojectOption);\n    const bottomLeft = this.unproject([0, this.height], unprojectOption);\n    const bottomRight = this.unproject([this.width, this.height], unprojectOption);\n\n    return [\n      Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),\n      Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),\n      Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),\n      Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])\n    ];\n  }\n\n  getDistanceScales(coordinateOrigin?: number[]): DistanceScales {\n    if (coordinateOrigin) {\n      return getDistanceScales({\n        longitude: coordinateOrigin[0],\n        latitude: coordinateOrigin[1],\n        highPrecision: true\n      });\n    }\n    return this.distanceScales;\n  }\n\n  containsPixel({\n    x,\n    y,\n    width = 1,\n    height = 1\n  }: {\n    x: number;\n    y: number;\n    width?: number;\n    height?: number;\n  }): boolean {\n    return (\n      x < this.x + this.width &&\n      this.x < x + width &&\n      y < this.y + this.height &&\n      this.y < y + height\n    );\n  }\n\n  // Extract frustum planes in common space\n  getFrustumPlanes(): {\n    left: FrustumPlane;\n    right: FrustumPlane;\n    bottom: FrustumPlane;\n    top: FrustumPlane;\n    near: FrustumPlane;\n    far: FrustumPlane;\n  } {\n    if (this._frustumPlanes.near) {\n      // @ts-ignore\n      return this._frustumPlanes;\n    }\n\n    Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));\n\n    // @ts-ignore\n    return this._frustumPlanes;\n  }\n\n  // EXPERIMENTAL METHODS\n\n  /**\n   * Needed by panning and linear transition\n   * Pan the viewport to place a given world coordinate at screen point [x, y]\n   *\n   * @param {Array} coords - world coordinates\n   * @param {Array} pixel - [x,y] coordinates on screen\n   * @return {Object} props of the new viewport\n   */\n  panByPosition(coords: number[], pixel: number[]): any {\n    return null;\n  }\n\n  // INTERNAL METHODS\n\n  /* eslint-disable complexity, max-statements */\n  private _initProps(opts: ViewportOptions) {\n    const longitude = opts.longitude as number;\n    const latitude = opts.latitude as number;\n\n    if (this.isGeospatial) {\n      if (!Number.isFinite(opts.zoom)) {\n        this.zoom = getMeterZoom({latitude}) + Math.log2(this.focalDistance);\n      }\n      this.distanceScales = opts.distanceScales || getDistanceScales({latitude, longitude});\n    }\n    const scale = Math.pow(2, this.zoom);\n    this.scale = scale;\n\n    const {position, modelMatrix} = opts;\n    let meterOffset: number[] = ZERO_VECTOR;\n    if (position) {\n      meterOffset = modelMatrix\n        ? (new Matrix4(modelMatrix).transformAsVector(position, []) as number[])\n        : position;\n    }\n\n    if (this.isGeospatial) {\n      // Determine camera center in common space\n      const center = this.projectPosition([longitude, latitude, 0]);\n\n      this.center = new Vector3(meterOffset)\n        // Convert to pixels in current zoom\n        .scale(this.distanceScales.unitsPerMeter)\n        .add(center);\n    } else {\n      this.center = this.projectPosition(meterOffset);\n    }\n  }\n  /* eslint-enable complexity, max-statements */\n\n  private _initMatrices(opts: ViewportOptions) {\n    const {\n      // View matrix\n      viewMatrix = IDENTITY,\n      // Projection matrix\n      projectionMatrix = null,\n\n      // Projection matrix parameters, used if projectionMatrix not supplied\n      orthographic = false,\n      fovyRadians,\n      fovy = 75,\n      near = 0.1, // Distance of near clipping plane\n      far = 1000, // Distance of far clipping plane\n      padding = null, // Center offset in pixels\n      focalDistance = 1\n    } = opts;\n\n    this.viewMatrixUncentered = viewMatrix;\n    // Make a centered version of the matrix for projection modes without an offset\n    this.viewMatrix = new Matrix4()\n      // Apply the uncentered view matrix\n      .multiplyRight(viewMatrix)\n      // And center it\n      .translate(new Vector3(this.center).negate());\n\n    this.projectionMatrix =\n      projectionMatrix ||\n      createProjectionMatrix({\n        width: this.width,\n        height: this.height,\n        orthographic,\n        fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,\n        focalDistance,\n        padding,\n        near,\n        far\n      });\n\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, this.projectionMatrix);\n    mat4.multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // console.log('VPM', this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);\n\n    // Calculate inverse view matrix\n    this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;\n\n    // Decompose camera parameters\n    this.cameraPosition = getCameraPosition(this.viewMatrixInverse);\n\n    /*\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n\n    // matrix for conversion from world location to screen (pixel) coordinates\n    const viewportMatrix = createMat4(); // matrix from NDC to viewport.\n    const pixelProjectionMatrix = createMat4(); // matrix from world space to viewport.\n    mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);\n    mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);\n    this.pixelProjectionMatrix = pixelProjectionMatrix;\n\n    this.pixelUnprojectionMatrix = mat4.invert(createMat4(), this.pixelProjectionMatrix);\n    if (!this.pixelUnprojectionMatrix) {\n      log.warn('Pixel project matrix not invertible')();\n      // throw new Error('Pixel project matrix not invertible');\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}