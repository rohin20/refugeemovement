{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withTasks = withTasks;\nexports.disableStackCapturing = disableStackCapturing;\nexports.withTask = exports.taskMiddleware = void 0;\nvar _core = require(\"./core\");\nvar _global = require(\"./global\");\nvar CACHED_PROMISE = Promise.resolve();\nvar makeDispatchAsync = function makeDispatchAsync(dispatch) {\n  return function (action) {\n    return CACHED_PROMISE.then(function () {\n      return dispatch(action);\n    });\n  };\n}; // The way webpack does hot-reloading seems to break the checks we\n// do against the stack trace.\n\nvar WEBPACK_HOT_RELOAD_ENABLED = Boolean(module.hot);\nvar enableStackCapture = !WEBPACK_HOT_RELOAD_ENABLED;\nvar IMPROPER_TASK_USAGE = \"Tasks should not be added outside of reducers.\";\n/**\n * You need to install this middleware for tasks to have their handlers run.\n *\n * You probably do not want to use this middleware within your test environment.\n * Instead, use `drainTasksForTesting` to retrieve and make assertions about them.\n *\n * This middleware changes the behavior of `store.dispatch` to return a promise.\n * That promise will resolve when all pending tasks for that call to `dispatch`\n * have finished (including calls transitively enqueued by tasks that dispatch actions).\n */\n\nvar taskMiddleware = function taskMiddleware(store) {\n  return function (next) {\n    return function (action) {\n      // If we begin a call to dispatch with tasks still in the queue,\n      // we have a problem.\n      if (enableStackCapture && (0, _global.getGlobalTaskQueue)().length > 0) {\n        var err = (0, _global.getLastWithTaskCall)();\n        (0, _global.clearLastWithTaskCall)();\n        throw err;\n      }\n      next(action);\n      var dispatch = makeDispatchAsync(store.dispatch);\n      if ((0, _global.getGlobalTaskQueue)().length > 0) {\n        var taskResolutions = (0, _global.getGlobalTaskQueue)().map(runTaskActual(dispatch));\n        (0, _global.updateGlobalTaskQueue)([]);\n        (0, _global.clearLastWithTaskCall)();\n        return Promise.all(taskResolutions);\n      }\n      return CACHED_PROMISE;\n    };\n  };\n}; // Given a function that accepts two continuations (one for success, one for error),\n// call the function supplying the provided continuations.\n\nexports.taskMiddleware = taskMiddleware;\nvar biApply = function biApply(f, s, e, c) {\n  return f(s, e, c);\n}; // Run the task with the proper effect\n\nfunction runTaskActual(dispatch) {\n  return function (task) {\n    // unsafe coerce this because it doesn't matter\n    return (0, _core._run)(task, biApply, dispatch, dispatch, {\n      onProgress: dispatch\n    });\n  };\n}\n/**\n * Use this function in your reducer to add tasks to an action handler.\n * The task will be lifted up to the top of your app. Returns the same\n * state object passed into it.\n */\n\nfunction withTasks(state, tasks) {\n  if (enableStackCapture && !(0, _global.getLastWithTaskCall)()) {\n    (0, _global.setLastWithTaskCall)(trace(IMPROPER_TASK_USAGE));\n  }\n  (0, _global.updateGlobalTaskQueue)((0, _global.getGlobalTaskQueue)().concat(tasks instanceof Array ? tasks : [tasks]));\n  return state;\n}\n/**\n * A helpful alias for providing just one task.\n * `withTask(state, task1)` is the same as `withTasks(state, [task1])`.\n */\n\nvar withTask = withTasks;\n/**\n * In order to make it easy to track down incorrect uses for `withTask`, we capture exception\n * objects for every call to withTask. This has some performance overhead, so you'll\n * probably want to disable it in production.\n *\n * Note that if you're using Webpack's hot reload, we disable this functionality by default.\n */\n\nexports.withTask = withTask;\nfunction disableStackCapturing() {\n  enableStackCapture = false;\n}\n/*\n * Helpers\n */\n\nfunction trace(message) {\n  try {\n    throw new Error(message);\n  } catch (e) {\n    return e;\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","withTasks","disableStackCapturing","withTask","taskMiddleware","_core","require","_global","CACHED_PROMISE","Promise","resolve","makeDispatchAsync","dispatch","action","then","WEBPACK_HOT_RELOAD_ENABLED","Boolean","module","hot","enableStackCapture","IMPROPER_TASK_USAGE","store","next","getGlobalTaskQueue","length","err","getLastWithTaskCall","clearLastWithTaskCall","taskResolutions","map","runTaskActual","updateGlobalTaskQueue","all","biApply","f","s","e","c","task","_run","onProgress","state","tasks","setLastWithTaskCall","trace","concat","Array","message","Error"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/react-palm/tasks/redux.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withTasks = withTasks;\nexports.disableStackCapturing = disableStackCapturing;\nexports.withTask = exports.taskMiddleware = void 0;\n\nvar _core = require(\"./core\");\n\nvar _global = require(\"./global\");\n\nvar CACHED_PROMISE = Promise.resolve();\n\nvar makeDispatchAsync = function makeDispatchAsync(dispatch) {\n  return function (action) {\n    return CACHED_PROMISE.then(function () {\n      return dispatch(action);\n    });\n  };\n}; // The way webpack does hot-reloading seems to break the checks we\n// do against the stack trace.\n\n\nvar WEBPACK_HOT_RELOAD_ENABLED = Boolean(module.hot);\nvar enableStackCapture = !WEBPACK_HOT_RELOAD_ENABLED;\nvar IMPROPER_TASK_USAGE = \"Tasks should not be added outside of reducers.\";\n/**\n * You need to install this middleware for tasks to have their handlers run.\n *\n * You probably do not want to use this middleware within your test environment.\n * Instead, use `drainTasksForTesting` to retrieve and make assertions about them.\n *\n * This middleware changes the behavior of `store.dispatch` to return a promise.\n * That promise will resolve when all pending tasks for that call to `dispatch`\n * have finished (including calls transitively enqueued by tasks that dispatch actions).\n */\n\nvar taskMiddleware = function taskMiddleware(store) {\n  return function (next) {\n    return function (action) {\n      // If we begin a call to dispatch with tasks still in the queue,\n      // we have a problem.\n      if (enableStackCapture && (0, _global.getGlobalTaskQueue)().length > 0) {\n        var err = (0, _global.getLastWithTaskCall)();\n        (0, _global.clearLastWithTaskCall)();\n        throw err;\n      }\n\n      next(action);\n      var dispatch = makeDispatchAsync(store.dispatch);\n\n      if ((0, _global.getGlobalTaskQueue)().length > 0) {\n        var taskResolutions = (0, _global.getGlobalTaskQueue)().map(runTaskActual(dispatch));\n        (0, _global.updateGlobalTaskQueue)([]);\n        (0, _global.clearLastWithTaskCall)();\n        return Promise.all(taskResolutions);\n      }\n\n      return CACHED_PROMISE;\n    };\n  };\n}; // Given a function that accepts two continuations (one for success, one for error),\n// call the function supplying the provided continuations.\n\n\nexports.taskMiddleware = taskMiddleware;\n\nvar biApply = function biApply(f, s, e, c) {\n  return f(s, e, c);\n}; // Run the task with the proper effect\n\n\nfunction runTaskActual(dispatch) {\n  return function (task) {\n    // unsafe coerce this because it doesn't matter\n    return (0, _core._run)(task, biApply, dispatch, dispatch, {\n      onProgress: dispatch\n    });\n  };\n}\n/**\n * Use this function in your reducer to add tasks to an action handler.\n * The task will be lifted up to the top of your app. Returns the same\n * state object passed into it.\n */\n\n\nfunction withTasks(state, tasks) {\n  if (enableStackCapture && !(0, _global.getLastWithTaskCall)()) {\n    (0, _global.setLastWithTaskCall)(trace(IMPROPER_TASK_USAGE));\n  }\n\n  (0, _global.updateGlobalTaskQueue)((0, _global.getGlobalTaskQueue)().concat(tasks instanceof Array ? tasks : [tasks]));\n  return state;\n}\n/**\n * A helpful alias for providing just one task.\n * `withTask(state, task1)` is the same as `withTasks(state, [task1])`.\n */\n\n\nvar withTask = withTasks;\n/**\n * In order to make it easy to track down incorrect uses for `withTask`, we capture exception\n * objects for every call to withTask. This has some performance overhead, so you'll\n * probably want to disable it in production.\n *\n * Note that if you're using Webpack's hot reload, we disable this functionality by default.\n */\n\nexports.withTask = withTask;\n\nfunction disableStackCapturing() {\n  enableStackCapture = false;\n}\n/*\n * Helpers\n */\n\n\nfunction trace(message) {\n  try {\n    throw new Error(message);\n  } catch (e) {\n    return e;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}