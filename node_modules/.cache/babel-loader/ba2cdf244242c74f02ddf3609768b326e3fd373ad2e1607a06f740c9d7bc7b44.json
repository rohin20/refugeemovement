{"ast":null,"code":"import _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { createFeature } from './feature';\nexport function clip(features, scale, k1, k2, axis, minAll, maxAll, options) {\n  k1 /= scale;\n  k2 /= scale;\n  if (minAll >= k1 && maxAll < k2) {\n    return features;\n  } else if (maxAll < k1 || minAll >= k2) {\n    return null;\n  }\n  var clipped = [];\n  var _iterator = _createForOfIteratorHelper(features),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var feature = _step.value;\n      var geometry = feature.geometry;\n      var type = feature.type;\n      var min = axis === 0 ? feature.minX : feature.minY;\n      var max = axis === 0 ? feature.maxX : feature.maxY;\n      if (min >= k1 && max < k2) {\n        clipped.push(feature);\n        continue;\n      } else if (max < k1 || min >= k2) {\n        continue;\n      }\n      var newGeometry = [];\n      if (type === 'Point' || type === 'MultiPoint') {\n        clipPoints(geometry, newGeometry, k1, k2, axis);\n      } else if (type === 'LineString') {\n        clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);\n      } else if (type === 'MultiLineString') {\n        clipLines(geometry, newGeometry, k1, k2, axis, false);\n      } else if (type === 'Polygon') {\n        clipLines(geometry, newGeometry, k1, k2, axis, true);\n      } else if (type === 'MultiPolygon') {\n        var _iterator2 = _createForOfIteratorHelper(geometry),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var polygon = _step2.value;\n            var newPolygon = [];\n            clipLines(polygon, newPolygon, k1, k2, axis, true);\n            if (newPolygon.length) {\n              newGeometry.push(newPolygon);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      if (newGeometry.length) {\n        if (options.lineMetrics && type === 'LineString') {\n          var _iterator3 = _createForOfIteratorHelper(newGeometry),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var line = _step3.value;\n              clipped.push(createFeature(feature.id, type, line, feature.tags));\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          continue;\n        }\n        if (type === 'LineString' || type === 'MultiLineString') {\n          if (newGeometry.length === 1) {\n            type = 'LineString';\n            newGeometry = newGeometry[0];\n          } else {\n            type = 'MultiLineString';\n          }\n        }\n        if (type === 'Point' || type === 'MultiPoint') {\n          type = newGeometry.length === 3 ? 'Point' : 'MultiPoint';\n        }\n        clipped.push(createFeature(feature.id, type, newGeometry, feature.tags));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return clipped.length ? clipped : null;\n}\nfunction clipPoints(geom, newGeom, k1, k2, axis) {\n  for (var i = 0; i < geom.length; i += 3) {\n    var a = geom[i + axis];\n    if (a >= k1 && a <= k2) {\n      addPoint(newGeom, geom[i], geom[i + 1], geom[i + 2]);\n    }\n  }\n}\nfunction clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {\n  var slice = newSlice(geom);\n  var intersect = axis === 0 ? intersectX : intersectY;\n  var len = geom.start;\n  var segLen;\n  var t;\n  for (var i = 0; i < geom.length - 3; i += 3) {\n    var _ax = geom[i];\n    var _ay = geom[i + 1];\n    var _az = geom[i + 2];\n    var bx = geom[i + 3];\n    var by = geom[i + 4];\n    var _a = axis === 0 ? _ax : _ay;\n    var b = axis === 0 ? bx : by;\n    var exited = false;\n    if (trackMetrics) {\n      segLen = Math.sqrt(Math.pow(_ax - bx, 2) + Math.pow(_ay - by, 2));\n    }\n    if (_a < k1) {\n      if (b > k1) {\n        t = intersect(slice, _ax, _ay, bx, by, k1);\n        if (trackMetrics) {\n          slice.start = len + segLen * t;\n        }\n      }\n    } else if (_a > k2) {\n      if (b < k2) {\n        t = intersect(slice, _ax, _ay, bx, by, k2);\n        if (trackMetrics) {\n          slice.start = len + segLen * t;\n        }\n      }\n    } else {\n      addPoint(slice, _ax, _ay, _az);\n    }\n    if (b < k1 && _a >= k1) {\n      t = intersect(slice, _ax, _ay, bx, by, k1);\n      exited = true;\n    }\n    if (b > k2 && _a <= k2) {\n      t = intersect(slice, _ax, _ay, bx, by, k2);\n      exited = true;\n    }\n    if (!isPolygon && exited) {\n      if (trackMetrics) {\n        slice.end = len + segLen * t;\n      }\n      newGeom.push(slice);\n      slice = newSlice(geom);\n    }\n    if (trackMetrics) {\n      len += segLen;\n    }\n  }\n  var last = geom.length - 3;\n  var ax = geom[last];\n  var ay = geom[last + 1];\n  var az = geom[last + 2];\n  var a = axis === 0 ? ax : ay;\n  if (a >= k1 && a <= k2) addPoint(slice, ax, ay, az);\n  last = slice.length - 3;\n  if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {\n    addPoint(slice, slice[0], slice[1], slice[2]);\n  }\n  if (slice.length) {\n    newGeom.push(slice);\n  }\n}\nvar Slice = /*#__PURE__*/function (_Array) {\n  _inherits(Slice, _Array);\n  var _super = _createSuper(Slice);\n  function Slice() {\n    var _this;\n    _classCallCheck(this, Slice);\n    _this = _super.apply(this, arguments);\n    _defineProperty(_assertThisInitialized(_this), \"size\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"start\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"end\", void 0);\n    return _this;\n  }\n  return _createClass(Slice);\n}( /*#__PURE__*/_wrapNativeSuper(Array));\nfunction newSlice(line) {\n  var slice = [];\n  slice.size = line.size;\n  slice.start = line.start;\n  slice.end = line.end;\n  return slice;\n}\nfunction clipLines(geom, newGeom, k1, k2, axis, isPolygon) {\n  var _iterator4 = _createForOfIteratorHelper(geom),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var line = _step4.value;\n      clipLine(line, newGeom, k1, k2, axis, isPolygon, false);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n}\nfunction addPoint(out, x, y, z) {\n  out.push(x, y, z);\n}\nfunction intersectX(out, ax, ay, bx, by, x) {\n  var t = (x - ax) / (bx - ax);\n  addPoint(out, x, ay + (by - ay) * t, 1);\n  return t;\n}\nfunction intersectY(out, ax, ay, bx, by, y) {\n  var t = (y - ay) / (by - ay);\n  addPoint(out, ax + (bx - ax) * t, y, 1);\n  return t;\n}","map":{"version":3,"names":["createFeature","clip","features","scale","k1","k2","axis","minAll","maxAll","options","clipped","_iterator","_createForOfIteratorHelper","_step","s","n","done","feature","value","geometry","type","min","minX","minY","max","maxX","maxY","push","newGeometry","clipPoints","clipLine","lineMetrics","clipLines","_iterator2","_step2","polygon","newPolygon","length","err","e","f","_iterator3","_step3","line","id","tags","geom","newGeom","i","a","addPoint","isPolygon","trackMetrics","slice","newSlice","intersect","intersectX","intersectY","len","start","segLen","t","ax","ay","az","bx","by","b","exited","Math","sqrt","pow","end","last","Slice","_Array","_inherits","_super","_createSuper","_this","_classCallCheck","apply","arguments","_defineProperty","_assertThisInitialized","_createClass","_wrapNativeSuper","Array","size","_iterator4","_step4","out","x","y","z"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/mvt/src/lib/geojson-tiler/clip.ts"],"sourcesContent":["// loaders.gl, MIT license\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\n\nimport type {GeoJSONTileFeature} from './tile';\nimport {createFeature} from './feature';\n\n/* eslint-disable no-continue */\n\n/**\n * Clip features between two vertical or horizontal axis-parallel lines:\n *     |        |\n *  ___|___     |     /\n * /   |   \\____|____/\n *     |        |\n *\n * @param k1 and k2 are the line coordinates\n * @param axis: 0 for x, 1 for y\n * @param minAll and maxAll: minimum and maximum coordinate value for all features\n */\n// eslint-disable-next-line max-params, complexity, max-statements\nexport function clip(\n  features: GeoJSONTileFeature[],\n  scale: number,\n  k1: number,\n  k2: number,\n  axis,\n  minAll: number,\n  maxAll: number,\n  options: {lineMetrics: boolean}\n): GeoJSONTileFeature[] | null {\n  k1 /= scale;\n  k2 /= scale;\n\n  if (minAll >= k1 && maxAll < k2) {\n    return features;\n  }\n  // trivial accept\n  else if (maxAll < k1 || minAll >= k2) {\n    return null; // trivial reject\n  }\n\n  const clipped: GeoJSONTileFeature[] = [];\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    let type = feature.type;\n\n    const min = axis === 0 ? feature.minX : feature.minY;\n    const max = axis === 0 ? feature.maxX : feature.maxY;\n\n    if (min >= k1 && max < k2) {\n      // trivial accept\n      clipped.push(feature);\n      continue;\n    } else if (max < k1 || min >= k2) {\n      // trivial reject\n      continue;\n    }\n\n    let newGeometry: number[][][] | number[][] = [];\n\n    if (type === 'Point' || type === 'MultiPoint') {\n      clipPoints(geometry, newGeometry, k1, k2, axis);\n    } else if (type === 'LineString') {\n      clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);\n    } else if (type === 'MultiLineString') {\n      clipLines(geometry, newGeometry, k1, k2, axis, false);\n    } else if (type === 'Polygon') {\n      clipLines(geometry, newGeometry, k1, k2, axis, true);\n    } else if (type === 'MultiPolygon') {\n      for (const polygon of geometry) {\n        const newPolygon = [];\n        clipLines(polygon, newPolygon, k1, k2, axis, true);\n        if (newPolygon.length) {\n          newGeometry.push(newPolygon);\n        }\n      }\n    }\n\n    if (newGeometry.length) {\n      if (options.lineMetrics && type === 'LineString') {\n        for (const line of newGeometry) {\n          clipped.push(createFeature(feature.id, type, line, feature.tags));\n        }\n        continue;\n      }\n\n      if (type === 'LineString' || type === 'MultiLineString') {\n        if (newGeometry.length === 1) {\n          type = 'LineString';\n          // @ts-expect-error TODO - use proper GeoJSON geometry types\n          newGeometry = newGeometry[0];\n        } else {\n          type = 'MultiLineString';\n        }\n      }\n      if (type === 'Point' || type === 'MultiPoint') {\n        type = newGeometry.length === 3 ? 'Point' : 'MultiPoint';\n      }\n\n      clipped.push(createFeature(feature.id, type, newGeometry, feature.tags));\n    }\n  }\n\n  return clipped.length ? clipped : null;\n}\n\nfunction clipPoints(geom, newGeom, k1: number, k2: number, axis): void {\n  for (let i = 0; i < geom.length; i += 3) {\n    const a = geom[i + axis];\n\n    if (a >= k1 && a <= k2) {\n      addPoint(newGeom, geom[i], geom[i + 1], geom[i + 2]);\n    }\n  }\n}\n\n// eslint-disable-next-line max-params, complexity, max-statements\nfunction clipLine(\n  geom,\n  newGeom,\n  k1: number,\n  k2: number,\n  axis,\n  isPolygon: boolean,\n  trackMetrics: boolean\n): void {\n  let slice = newSlice(geom);\n  const intersect = axis === 0 ? intersectX : intersectY;\n  let len = geom.start;\n  let segLen;\n  let t;\n\n  for (let i = 0; i < geom.length - 3; i += 3) {\n    const ax = geom[i];\n    const ay = geom[i + 1];\n    const az = geom[i + 2];\n    const bx = geom[i + 3];\n    const by = geom[i + 4];\n    const a = axis === 0 ? ax : ay;\n    const b = axis === 0 ? bx : by;\n    let exited = false;\n\n    if (trackMetrics) {\n      segLen = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n    }\n\n    if (a < k1) {\n      // ---|-->  | (line enters the clip region from the left)\n      if (b > k1) {\n        t = intersect(slice, ax, ay, bx, by, k1);\n        if (trackMetrics) {\n          slice.start = len + segLen * t;\n        }\n      }\n    } else if (a > k2) {\n      // |  <--|--- (line enters the clip region from the right)\n      if (b < k2) {\n        t = intersect(slice, ax, ay, bx, by, k2);\n        if (trackMetrics) {\n          slice.start = len + segLen * t;\n        }\n      }\n    } else {\n      addPoint(slice, ax, ay, az);\n    }\n    if (b < k1 && a >= k1) {\n      // <--|---  | or <--|-----|--- (line exits the clip region on the left)\n      t = intersect(slice, ax, ay, bx, by, k1);\n      exited = true;\n    }\n    if (b > k2 && a <= k2) {\n      // |  ---|--> or ---|-----|--> (line exits the clip region on the right)\n      t = intersect(slice, ax, ay, bx, by, k2);\n      exited = true;\n    }\n\n    if (!isPolygon && exited) {\n      if (trackMetrics) {\n        slice.end = len + segLen * t;\n      }\n      newGeom.push(slice);\n      slice = newSlice(geom);\n    }\n\n    if (trackMetrics) {\n      len += segLen;\n    }\n  }\n\n  // add the last point\n  let last = geom.length - 3;\n  const ax = geom[last];\n  const ay = geom[last + 1];\n  const az = geom[last + 2];\n  const a = axis === 0 ? ax : ay;\n  if (a >= k1 && a <= k2) addPoint(slice, ax, ay, az);\n\n  // close the polygon if its endpoints are not the same after clipping\n  last = slice.length - 3;\n  if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {\n    addPoint(slice, slice[0], slice[1], slice[2]);\n  }\n\n  // add the final slice\n  if (slice.length) {\n    newGeom.push(slice);\n  }\n}\n\nclass Slice extends Array<number> {\n  size?: number;\n  start?: number;\n  end?: number;\n}\n\nfunction newSlice(line: {size: number; start: number; end: number}): Slice {\n  const slice: Slice = [];\n  slice.size = line.size;\n  slice.start = line.start;\n  slice.end = line.end;\n  return slice;\n}\n\n// eslint-disable-next-line max-params\nfunction clipLines(geom, newGeom, k1: number, k2: number, axis, isPolygon: boolean): void {\n  for (const line of geom) {\n    clipLine(line, newGeom, k1, k2, axis, isPolygon, false);\n  }\n}\n\nfunction addPoint(out: number[], x: number, y: number, z: number): void {\n  out.push(x, y, z);\n}\n\n// eslint-disable-next-line max-params\nfunction intersectX(out, ax: number, ay: number, bx: number, by: number, x: number): number {\n  const t = (x - ax) / (bx - ax);\n  addPoint(out, x, ay + (by - ay) * t, 1);\n  return t;\n}\n\n// eslint-disable-next-line max-params\nfunction intersectY(out, ax: number, ay: number, bx: number, by: number, y): number {\n  const t = (y - ay) / (by - ay);\n  addPoint(out, ax + (bx - ax) * t, y, 1);\n  return t;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}