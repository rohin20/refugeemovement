{"ast":null,"code":"import _regeneratorRuntime from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\nvar KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\nexport var name = KHR_TECHNIQUES_WEBGL;\nexport function decode(_x) {\n  return _decode.apply(this, arguments);\n}\nfunction _decode() {\n  _decode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(gltfData) {\n    var gltfScenegraph, json, extension, techniques, _iterator, _step, material, materialExtension;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          gltfScenegraph = new GLTFScenegraph(gltfData);\n          json = gltfScenegraph.json;\n          extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n          if (extension) {\n            techniques = resolveTechniques(extension, gltfScenegraph);\n            _iterator = _createForOfIteratorHelper(json.materials || []);\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                material = _step.value;\n                materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n                if (materialExtension) {\n                  material.technique = Object.assign({}, materialExtension, techniques[materialExtension.technique]);\n                  material.technique.values = resolveValues(material.technique, gltfScenegraph);\n                }\n                gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n            gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n          }\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _decode.apply(this, arguments);\n}\nexport function encode(_x2, _x3) {\n  return _encode.apply(this, arguments);\n}\nfunction _encode() {\n  _encode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(gltfData, options) {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _encode.apply(this, arguments);\n}\nfunction resolveTechniques(techniquesExtension, gltfScenegraph) {\n  var _techniquesExtension$ = techniquesExtension.programs,\n    programs = _techniquesExtension$ === void 0 ? [] : _techniquesExtension$,\n    _techniquesExtension$2 = techniquesExtension.shaders,\n    shaders = _techniquesExtension$2 === void 0 ? [] : _techniquesExtension$2,\n    _techniquesExtension$3 = techniquesExtension.techniques,\n    techniques = _techniquesExtension$3 === void 0 ? [] : _techniquesExtension$3;\n  var textDecoder = new TextDecoder();\n  shaders.forEach(function (shader) {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));\n    } else {\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n  programs.forEach(function (program) {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n  techniques.forEach(function (technique) {\n    technique.program = programs[technique.program];\n  });\n  return techniques;\n}\nfunction resolveValues(technique, gltfScenegraph) {\n  var values = Object.assign({}, technique.values);\n  Object.keys(technique.uniforms || {}).forEach(function (uniform) {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n  Object.keys(values).forEach(function (uniform) {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n  return values;\n}","map":{"version":3,"names":["GLTFScenegraph","KHR_TECHNIQUES_WEBGL","name","decode","_x","_decode","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","gltfData","gltfScenegraph","json","extension","techniques","_iterator","_step","material","materialExtension","wrap","_callee$","_context","prev","next","getExtension","resolveTechniques","_createForOfIteratorHelper","materials","s","n","done","value","getObjectExtension","technique","Object","assign","values","resolveValues","removeObjectExtension","err","e","f","removeExtension","stop","encode","_x2","_x3","_encode","_callee2","options","_callee2$","_context2","techniquesExtension","_techniquesExtension$","programs","_techniquesExtension$2","shaders","_techniquesExtension$3","textDecoder","TextDecoder","forEach","shader","Number","isFinite","bufferView","code","getTypedArrayForBufferView","Error","program","fragmentShader","vertexShader","keys","uniforms","uniform","index","undefined","texture","getTexture"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/gltf/src/lib/extensions/deprecated/KHR_techniques_webgl.ts"],"sourcesContent":["// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\n\nexport const name = KHR_TECHNIQUES_WEBGL;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign(\n          {},\n          materialExtension,\n          // @ts-ignore\n          techniques[materialExtension.technique]\n        );\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    // Remove the top-level extension\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options): Promise<void> {\n  // TODO\n}\n\nfunction resolveTechniques(\n  techniquesExtension: {[key: string]: any},\n  // programs: {[key: string]: any}[],\n  // shaders: {[key: string]: any}[],\n  // techniques: {[key: string]: any}[]\n  gltfScenegraph\n) {\n  const {programs = [], shaders = [], techniques = []} = techniquesExtension;\n  const textDecoder = new TextDecoder();\n\n  shaders.forEach((shader) => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(\n        gltfScenegraph.getTypedArrayForBufferView(shader.bufferView)\n      );\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n\n  programs.forEach((program) => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n\n  techniques.forEach((technique) => {\n    technique.program = programs[technique.program];\n  });\n\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach((uniform) => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n\n  // resolve textures\n  Object.keys(values).forEach((uniform) => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n\n  return values;\n}\n"],"mappings":";;;AAKA,OAAOA,cAAc,MAAM,2BAA2B;AAEtD,IAAMC,oBAAoB,GAAG,sBAAsB;AAEnD,OAAO,IAAMC,IAAI,GAAGD,oBAAoB;AAExC,gBAAsBE,MAAMA,CAAAC,EAAA;EAAA,OAAAC,OAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AA2B5B,SAAAF,QAAA;EAAAA,OAAA,GAAAG,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CA3BO,SAAAC,QAAsBC,QAAsB;IAAA,IAAAC,cAAA,EAAAC,IAAA,EAAAC,SAAA,EAAAC,UAAA,EAAAC,SAAA,EAAAC,KAAA,EAAAC,QAAA,EAAAC,iBAAA;IAAA,OAAAX,mBAAA,GAAAY,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAC3CZ,cAAc,GAAG,IAAIb,cAAc,CAACY,QAAQ,CAAC;UAC5CE,IAAA,GAAQD,cAAc,CAAtBC,IAAA;UAEDC,SAAS,GAAGF,cAAc,CAACa,YAAY,CAACzB,oBAAoB,CAAC;UACnE,IAAIc,SAAS,EAAE;YACPC,UAAU,GAAGW,iBAAiB,CAACZ,SAAS,EAAEF,cAAc,CAAC;YAAAI,SAAA,GAAAW,0BAAA,CAExCd,IAAI,CAACe,SAAS,IAAI,EAAE;YAAA;cAA3C,KAAAZ,SAAA,CAAAa,CAAA,MAAAZ,KAAA,GAAAD,SAAA,CAAAc,CAAA,IAAAC,IAAA,GAA6C;gBAAlCb,QAAQ,GAAAD,KAAA,CAAAe,KAAA;gBACXb,iBAAiB,GAAGP,cAAc,CAACqB,kBAAkB,CAACf,QAAQ,EAAElB,oBAAoB,CAAC;gBAC3F,IAAImB,iBAAiB,EAAE;kBAErBD,QAAQ,CAACgB,SAAS,GAAGC,MAAM,CAACC,MAAM,CAChC,CAAC,CAAC,EACFjB,iBAAiB,EAEjBJ,UAAU,CAACI,iBAAiB,CAACe,SAAS,CAAC,CACxC;kBAEDhB,QAAQ,CAACgB,SAAS,CAACG,MAAM,GAAGC,aAAa,CAACpB,QAAQ,CAACgB,SAAS,EAAEtB,cAAc,CAAC;gBAC/E;gBACAA,cAAc,CAAC2B,qBAAqB,CAACrB,QAAQ,EAAElB,oBAAoB,CAAC;cACtE;YAAA,SAAAwC,GAAA;cAAAxB,SAAA,CAAAyB,CAAA,CAAAD,GAAA;YAAA;cAAAxB,SAAA,CAAA0B,CAAA;YAAA;YAGA9B,cAAc,CAAC+B,eAAe,CAAC3C,oBAAoB,CAAC;UACtD;QAAA;QAAA;UAAA,OAAAsB,QAAA,CAAAsB,IAAA;MAAA;IAAA,GAAAlC,OAAA;EAAA,CACF;EAAA,OAAAN,OAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAEA,gBAAsBuC,MAAMA,CAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,OAAA,CAAA3C,KAAA,OAAAC,SAAA;AAAA;AAE5B,SAAA0C,QAAA;EAAAA,OAAA,GAAAzC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAFO,SAAAwC,SAAsBtC,QAAQ,EAAEuC,OAAO;IAAA,OAAA1C,mBAAA,GAAAY,IAAA,UAAA+B,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAA7B,IAAA,GAAA6B,SAAA,CAAA5B,IAAA;QAAA;QAAA;UAAA,OAAA4B,SAAA,CAAAR,IAAA;MAAA;IAAA,GAAAK,QAAA;EAAA,CAE9C;EAAA,OAAAD,OAAA,CAAA3C,KAAA,OAAAC,SAAA;AAAA;AAEA,SAASoB,iBAAiBA,CACxB2B,mBAAyC,EAIzCzC,cAAc,EACd;EACA,IAAA0C,qBAAA,GAAuDD,mBAAmB,CAAnEE,QAAQ;IAARA,QAAQ,GAAAD,qBAAA,cAAG,EAAE,GAAAA,qBAAA;IAAAE,sBAAA,GAAmCH,mBAAmB,CAApDI,OAAO;IAAPA,OAAO,GAAAD,sBAAA,cAAG,EAAE,GAAAA,sBAAA;IAAAE,sBAAA,GAAqBL,mBAAmB,CAAtCtC,UAAU;IAAVA,UAAU,GAAA2C,sBAAA,cAAG,KAAAA,sBAAA;EACjD,IAAMC,WAAW,GAAG,IAAIC,WAAW,EAAE;EAErCH,OAAO,CAACI,OAAO,CAAE,UAAAC,MAAM,EAAK;IAC1B,IAAIC,MAAM,CAACC,QAAQ,CAACF,MAAM,CAACG,UAAU,CAAC,EAAE;MACtCH,MAAM,CAACI,IAAI,GAAGP,WAAW,CAACzD,MAAM,CAC9BU,cAAc,CAACuD,0BAA0B,CAACL,MAAM,CAACG,UAAU,CAAC,CAC7D;IACH,CAAC,MAAM;MAEL,MAAM,IAAIG,KAAK,CAAC,sCAAsC,CAAC;IACzD;EACF,CAAC,CAAC;EAEFb,QAAQ,CAACM,OAAO,CAAE,UAAAQ,OAAO,EAAK;IAC5BA,OAAO,CAACC,cAAc,GAAGb,OAAO,CAACY,OAAO,CAACC,cAAc,CAAC;IACxDD,OAAO,CAACE,YAAY,GAAGd,OAAO,CAACY,OAAO,CAACE,YAAY,CAAC;EACtD,CAAC,CAAC;EAEFxD,UAAU,CAAC8C,OAAO,CAAE,UAAA3B,SAAS,EAAK;IAChCA,SAAS,CAACmC,OAAO,GAAGd,QAAQ,CAACrB,SAAS,CAACmC,OAAO,CAAC;EACjD,CAAC,CAAC;EAEF,OAAOtD,UAAU;AACnB;AAEA,SAASuB,aAAaA,CAACJ,SAAS,EAAEtB,cAAc,EAAE;EAChD,IAAMyB,MAAM,GAAGF,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEF,SAAS,CAACG,MAAM,CAAC;EAGlDF,MAAM,CAACqC,IAAI,CAACtC,SAAS,CAACuC,QAAQ,IAAI,CAAC,CAAC,CAAC,CAACZ,OAAO,CAAE,UAAAa,OAAO,EAAK;IACzD,IAAIxC,SAAS,CAACuC,QAAQ,CAACC,OAAO,CAAC,CAAC1C,KAAK,IAAI,EAAE0C,OAAO,IAAIrC,MAAM,CAAC,EAAE;MAC7DA,MAAM,CAACqC,OAAO,CAAC,GAAGxC,SAAS,CAACuC,QAAQ,CAACC,OAAO,CAAC,CAAC1C,KAAK;IACrD;EACF,CAAC,CAAC;EAGFG,MAAM,CAACqC,IAAI,CAACnC,MAAM,CAAC,CAACwB,OAAO,CAAE,UAAAa,OAAO,EAAK;IACvC,IAAI,OAAOrC,MAAM,CAACqC,OAAO,CAAC,KAAK,QAAQ,IAAIrC,MAAM,CAACqC,OAAO,CAAC,CAACC,KAAK,KAAKC,SAAS,EAAE;MAG9EvC,MAAM,CAACqC,OAAO,CAAC,CAACG,OAAO,GAAGjE,cAAc,CAACkE,UAAU,CAACzC,MAAM,CAACqC,OAAO,CAAC,CAACC,KAAK,CAAC;IAC5E;EACF,CAAC,CAAC;EAEF,OAAOtC,MAAM;AACf"},"metadata":{},"sourceType":"module","externalDependencies":[]}