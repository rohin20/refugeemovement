{"ast":null,"code":"import _regeneratorRuntime from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Geometry } from '@luma.gl/core';\nimport { CompositeLayer, COORDINATE_SYSTEM, log } from '@deck.gl/core';\nimport { PointCloudLayer } from '@deck.gl/layers';\nimport { ScenegraphLayer } from '@deck.gl/mesh-layers';\nimport { default as MeshLayer } from '../mesh-layer/mesh-layer';\nimport { load } from '@loaders.gl/core';\nimport { Tileset3D, TILE_TYPE } from '@loaders.gl/tiles';\nimport { Tiles3DLoader } from '@loaders.gl/3d-tiles';\nvar SINGLE_DATA = [0];\nvar defaultProps = {\n  getPointColor: {\n    type: 'accessor',\n    value: [0, 0, 0, 255]\n  },\n  pointSize: 1.0,\n  data: null,\n  loader: Tiles3DLoader,\n  onTilesetLoad: {\n    type: 'function',\n    value: function value(tileset3d) {},\n    compare: false\n  },\n  onTileLoad: {\n    type: 'function',\n    value: function value(tileHeader) {},\n    compare: false\n  },\n  onTileUnload: {\n    type: 'function',\n    value: function value(tileHeader) {},\n    compare: false\n  },\n  onTileError: {\n    type: 'function',\n    value: function value(tile, message, url) {},\n    compare: false\n  },\n  _getMeshColor: {\n    type: 'function',\n    value: function value(tileHeader) {\n      return [255, 255, 255];\n    },\n    compare: false\n  }\n};\nvar Tile3DLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(Tile3DLayer, _CompositeLayer);\n  var _super = _createSuper(Tile3DLayer);\n  function Tile3DLayer() {\n    var _this;\n    _classCallCheck(this, Tile3DLayer);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"state\", void 0);\n    return _this;\n  }\n  _createClass(Tile3DLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      if ('onTileLoadFail' in this.props) {\n        log.removed('onTileLoadFail', 'onTileError')();\n      }\n      this.state = {\n        layerMap: {},\n        tileset3d: null,\n        activeViewports: {},\n        lastUpdatedViewports: null\n      };\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      var tileset3d = this.state.tileset3d;\n      return tileset3d !== null && tileset3d.isLoaded();\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var props = _ref2.props,\n        oldProps = _ref2.oldProps,\n        changeFlags = _ref2.changeFlags;\n      if (props.data && props.data !== oldProps.data) {\n        this._loadTileset(props.data);\n      }\n      if (changeFlags.viewportChanged) {\n        var activeViewports = this.state.activeViewports;\n        var viewportsNumber = Object.keys(activeViewports).length;\n        if (viewportsNumber) {\n          this._updateTileset(activeViewports);\n          this.state.lastUpdatedViewports = activeViewports;\n          this.state.activeViewports = {};\n        }\n      }\n      if (changeFlags.propsChanged) {\n        var layerMap = this.state.layerMap;\n        for (var key in layerMap) {\n          layerMap[key].needsUpdate = true;\n        }\n      }\n    }\n  }, {\n    key: \"activateViewport\",\n    value: function activateViewport(viewport) {\n      var _this$state = this.state,\n        activeViewports = _this$state.activeViewports,\n        lastUpdatedViewports = _this$state.lastUpdatedViewports;\n      this.internalState.viewport = viewport;\n      activeViewports[viewport.id] = viewport;\n      var lastViewport = lastUpdatedViewports === null || lastUpdatedViewports === void 0 ? void 0 : lastUpdatedViewports[viewport.id];\n      if (!lastViewport || !viewport.equals(lastViewport)) {\n        this.setChangeFlags({\n          viewportChanged: true\n        });\n        this.setNeedsUpdate();\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info,\n        sourceLayer = _ref3.sourceLayer;\n      var layerMap = this.state.layerMap;\n      var layerId = sourceLayer && sourceLayer.id;\n      if (layerId) {\n        var substr = layerId.substring(this.id.length + 1);\n        var tileId = substr.substring(substr.indexOf('-') + 1);\n        info.object = layerMap[tileId] && layerMap[tileId].tile;\n      }\n      return info;\n    }\n  }, {\n    key: \"filterSubLayer\",\n    value: function filterSubLayer(_ref4) {\n      var layer = _ref4.layer,\n        viewport = _ref4.viewport;\n      var tile = layer.props.tile;\n      var viewportId = viewport.id;\n      return tile.selected && tile.viewportIds.includes(viewportId);\n    }\n  }, {\n    key: \"_updateAutoHighlight\",\n    value: function _updateAutoHighlight(info) {\n      if (info.sourceLayer) {\n        info.sourceLayer.updateAutoHighlight(info);\n      }\n    }\n  }, {\n    key: \"_loadTileset\",\n    value: function () {\n      var _loadTileset2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tilesetUrl) {\n        var _this$props$loadOptio, loadOptions, loader, options, preloadOptions, tilesetJson, tileset3d;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _this$props$loadOptio = this.props.loadOptions, loadOptions = _this$props$loadOptio === void 0 ? {} : _this$props$loadOptio;\n              loader = this.props.loader || this.props.loaders;\n              if (Array.isArray(loader)) {\n                loader = loader[0];\n              }\n              options = {\n                loadOptions: _objectSpread({}, loadOptions)\n              };\n              if (!loader.preload) {\n                _context.next = 10;\n                break;\n              }\n              _context.next = 7;\n              return loader.preload(tilesetUrl, loadOptions);\n            case 7:\n              preloadOptions = _context.sent;\n              if (preloadOptions.headers) {\n                options.loadOptions.fetch = _objectSpread(_objectSpread({}, options.loadOptions.fetch), {}, {\n                  headers: preloadOptions.headers\n                });\n              }\n              Object.assign(options, preloadOptions);\n            case 10:\n              _context.next = 12;\n              return load(tilesetUrl, loader, options.loadOptions);\n            case 12:\n              tilesetJson = _context.sent;\n              tileset3d = new Tileset3D(tilesetJson, _objectSpread({\n                onTileLoad: this._onTileLoad.bind(this),\n                onTileUnload: this._onTileUnload.bind(this),\n                onTileError: this.props.onTileError\n              }, options));\n              this.setState({\n                tileset3d: tileset3d,\n                layerMap: {}\n              });\n              this._updateTileset(this.state.activeViewports);\n              this.props.onTilesetLoad(tileset3d);\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function _loadTileset(_x) {\n        return _loadTileset2.apply(this, arguments);\n      }\n      return _loadTileset;\n    }()\n  }, {\n    key: \"_onTileLoad\",\n    value: function _onTileLoad(tileHeader) {\n      var lastUpdatedViewports = this.state.lastUpdatedViewports;\n      this.props.onTileLoad(tileHeader);\n      this._updateTileset(lastUpdatedViewports);\n      this.setNeedsUpdate();\n    }\n  }, {\n    key: \"_onTileUnload\",\n    value: function _onTileUnload(tileHeader) {\n      delete this.state.layerMap[tileHeader.id];\n      this.props.onTileUnload(tileHeader);\n    }\n  }, {\n    key: \"_updateTileset\",\n    value: function _updateTileset(viewports) {\n      var _this2 = this;\n      if (!viewports) {\n        return;\n      }\n      var tileset3d = this.state.tileset3d;\n      var timeline = this.context.timeline;\n      var viewportsNumber = Object.keys(viewports).length;\n      if (!timeline || !viewportsNumber || !tileset3d) {\n        return;\n      }\n      tileset3d.selectTiles(Object.values(viewports)).then(function (frameNumber) {\n        var tilesetChanged = _this2.state.frameNumber !== frameNumber;\n        if (tilesetChanged) {\n          _this2.setState({\n            frameNumber: frameNumber\n          });\n        }\n      });\n    }\n  }, {\n    key: \"_getSubLayer\",\n    value: function _getSubLayer(tileHeader, oldLayer) {\n      if (!tileHeader.content) {\n        return null;\n      }\n      switch (tileHeader.type) {\n        case TILE_TYPE.POINTCLOUD:\n          return this._makePointCloudLayer(tileHeader, oldLayer);\n        case TILE_TYPE.SCENEGRAPH:\n          return this._make3DModelLayer(tileHeader);\n        case TILE_TYPE.MESH:\n          return this._makeSimpleMeshLayer(tileHeader, oldLayer);\n        default:\n          throw new Error(\"Tile3DLayer: Failed to render layer of type \".concat(tileHeader.content.type));\n      }\n    }\n  }, {\n    key: \"_makePointCloudLayer\",\n    value: function _makePointCloudLayer(tileHeader, oldLayer) {\n      var _tileHeader$content = tileHeader.content,\n        attributes = _tileHeader$content.attributes,\n        pointCount = _tileHeader$content.pointCount,\n        constantRGBA = _tileHeader$content.constantRGBA,\n        cartographicOrigin = _tileHeader$content.cartographicOrigin,\n        modelMatrix = _tileHeader$content.modelMatrix;\n      var positions = attributes.positions,\n        normals = attributes.normals,\n        colors = attributes.colors;\n      if (!positions) {\n        return null;\n      }\n      var data = oldLayer && oldLayer.props.data || {\n        header: {\n          vertexCount: pointCount\n        },\n        attributes: {\n          POSITION: positions,\n          NORMAL: normals,\n          COLOR_0: colors\n        }\n      };\n      var _this$props = this.props,\n        pointSize = _this$props.pointSize,\n        getPointColor = _this$props.getPointColor;\n      var SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n      return new SubLayerClass({\n        pointSize: pointSize\n      }, this.getSubLayerProps({\n        id: 'pointcloud'\n      }), {\n        id: \"\".concat(this.id, \"-pointcloud-\").concat(tileHeader.id),\n        tile: tileHeader,\n        data: data,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix: modelMatrix,\n        getColor: constantRGBA || getPointColor,\n        _offset: 0\n      });\n    }\n  }, {\n    key: \"_make3DModelLayer\",\n    value: function _make3DModelLayer(tileHeader) {\n      var _tileHeader$content2 = tileHeader.content,\n        gltf = _tileHeader$content2.gltf,\n        instances = _tileHeader$content2.instances,\n        cartographicOrigin = _tileHeader$content2.cartographicOrigin,\n        modelMatrix = _tileHeader$content2.modelMatrix;\n      var SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n      return new SubLayerClass({\n        _lighting: 'pbr'\n      }, this.getSubLayerProps({\n        id: 'scenegraph'\n      }), {\n        id: \"\".concat(this.id, \"-scenegraph-\").concat(tileHeader.id),\n        tile: tileHeader,\n        data: instances || SINGLE_DATA,\n        scenegraph: gltf,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix: modelMatrix,\n        getTransformMatrix: function getTransformMatrix(instance) {\n          return instance.modelMatrix;\n        },\n        getPosition: [0, 0, 0],\n        _offset: 0\n      });\n    }\n  }, {\n    key: \"_makeSimpleMeshLayer\",\n    value: function _makeSimpleMeshLayer(tileHeader, oldLayer) {\n      var content = tileHeader.content;\n      var attributes = content.attributes,\n        indices = content.indices,\n        modelMatrix = content.modelMatrix,\n        cartographicOrigin = content.cartographicOrigin,\n        _content$coordinateSy = content.coordinateSystem,\n        coordinateSystem = _content$coordinateSy === void 0 ? COORDINATE_SYSTEM.METER_OFFSETS : _content$coordinateSy,\n        material = content.material,\n        featureIds = content.featureIds;\n      var _getMeshColor = this.props._getMeshColor;\n      var geometry = oldLayer && oldLayer.props.mesh || new Geometry({\n        drawMode: 4,\n        attributes: getMeshGeometry(attributes),\n        indices: indices\n      });\n      var SubLayerClass = this.getSubLayerClass('mesh', MeshLayer);\n      return new SubLayerClass(this.getSubLayerProps({\n        id: 'mesh'\n      }), {\n        id: \"\".concat(this.id, \"-mesh-\").concat(tileHeader.id),\n        tile: tileHeader,\n        mesh: geometry,\n        data: SINGLE_DATA,\n        getColor: _getMeshColor(tileHeader),\n        pbrMaterial: material,\n        modelMatrix: modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem: coordinateSystem,\n        featureIds: featureIds,\n        _offset: 0\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this3 = this;\n      var _this$state2 = this.state,\n        tileset3d = _this$state2.tileset3d,\n        layerMap = _this$state2.layerMap;\n      if (!tileset3d) {\n        return null;\n      }\n      return tileset3d.tiles.map(function (tile) {\n        var layerCache = layerMap[tile.id] = layerMap[tile.id] || {\n          tile: tile\n        };\n        var layer = layerCache.layer;\n        if (tile.selected) {\n          if (!layer) {\n            layer = _this3._getSubLayer(tile);\n          } else if (layerCache.needsUpdate) {\n            layer = _this3._getSubLayer(tile, layer);\n            layerCache.needsUpdate = false;\n          }\n        }\n        layerCache.layer = layer;\n        return layer;\n      }).filter(Boolean);\n    }\n  }]);\n  return Tile3DLayer;\n}(CompositeLayer);\nexport { Tile3DLayer as default };\n_defineProperty(Tile3DLayer, \"defaultProps\", defaultProps);\n_defineProperty(Tile3DLayer, \"layerName\", 'Tile3DLayer');\nfunction getMeshGeometry(contentAttributes) {\n  var attributes = {};\n  attributes.positions = _objectSpread(_objectSpread({}, contentAttributes.positions), {}, {\n    value: new Float32Array(contentAttributes.positions.value)\n  });\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n  if (contentAttributes.colors) {\n    attributes.colors = contentAttributes.colors;\n  }\n  if (contentAttributes.uvRegions) {\n    attributes.uvRegions = contentAttributes.uvRegions;\n  }\n  return attributes;\n}","map":{"version":3,"names":["Geometry","CompositeLayer","COORDINATE_SYSTEM","log","PointCloudLayer","ScenegraphLayer","default","MeshLayer","load","Tileset3D","TILE_TYPE","Tiles3DLoader","SINGLE_DATA","defaultProps","getPointColor","type","value","pointSize","data","loader","onTilesetLoad","tileset3d","compare","onTileLoad","tileHeader","onTileUnload","onTileError","tile","message","url","_getMeshColor","Tile3DLayer","_CompositeLayer","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","_defineProperty","_assertThisInitialized","_createClass","key","initializeState","props","removed","state","layerMap","activeViewports","lastUpdatedViewports","get","isLoaded","shouldUpdateState","_ref","changeFlags","somethingChanged","updateState","_ref2","oldProps","_loadTileset","viewportChanged","viewportsNumber","Object","keys","_updateTileset","propsChanged","needsUpdate","activateViewport","viewport","_this$state","internalState","id","lastViewport","equals","setChangeFlags","setNeedsUpdate","getPickingInfo","_ref3","info","sourceLayer","layerId","substr","substring","tileId","indexOf","object","filterSubLayer","_ref4","layer","viewportId","selected","viewportIds","includes","_updateAutoHighlight","updateAutoHighlight","_loadTileset2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","tilesetUrl","_this$props$loadOptio","loadOptions","options","preloadOptions","tilesetJson","wrap","_callee$","_context","prev","next","loaders","isArray","_objectSpread","preload","sent","headers","fetch","assign","_onTileLoad","bind","_onTileUnload","setState","stop","_x","viewports","_this2","timeline","context","selectTiles","values","then","frameNumber","tilesetChanged","_getSubLayer","oldLayer","content","POINTCLOUD","_makePointCloudLayer","SCENEGRAPH","_make3DModelLayer","MESH","_makeSimpleMeshLayer","Error","_tileHeader$content","attributes","pointCount","constantRGBA","cartographicOrigin","modelMatrix","positions","normals","colors","header","vertexCount","POSITION","NORMAL","COLOR_0","_this$props","SubLayerClass","getSubLayerClass","getSubLayerProps","coordinateSystem","METER_OFFSETS","coordinateOrigin","getColor","_offset","_tileHeader$content2","gltf","instances","_lighting","scenegraph","getTransformMatrix","instance","getPosition","indices","_content$coordinateSy","material","featureIds","geometry","mesh","drawMode","getMeshGeometry","pbrMaterial","renderLayers","_this3","_this$state2","tiles","map","layerCache","filter","Boolean","contentAttributes","Float32Array","texCoords","uvRegions"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/geo-layers/src/tile-3d-layer/tile-3d-layer.ts"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport {Geometry} from '@luma.gl/core';\n\nimport {\n  Accessor,\n  Color,\n  CompositeLayer,\n  CompositeLayerProps,\n  COORDINATE_SYSTEM,\n  FilterContext,\n  GetPickingInfoParams,\n  Layer,\n  LayersList,\n  log,\n  PickingInfo,\n  UpdateParameters,\n  Viewport,\n  DefaultProps\n} from '@deck.gl/core';\nimport {PointCloudLayer} from '@deck.gl/layers';\nimport {ScenegraphLayer} from '@deck.gl/mesh-layers';\nimport {default as MeshLayer} from '../mesh-layer/mesh-layer';\n\nimport {load} from '@loaders.gl/core';\nimport {MeshAttributes} from '@loaders.gl/schema';\nimport {Tileset3D, Tile3D, TILE_TYPE} from '@loaders.gl/tiles';\nimport {Tiles3DLoader} from '@loaders.gl/3d-tiles';\n\nconst SINGLE_DATA = [0];\n\nconst defaultProps: DefaultProps<Tile3DLayerProps> = {\n  getPointColor: {type: 'accessor', value: [0, 0, 0, 255]},\n  pointSize: 1.0,\n\n  // @ts-expect-error Disable async data loading (handling it in _loadTileSet)\n  data: null,\n  loader: Tiles3DLoader,\n\n  onTilesetLoad: {type: 'function', value: tileset3d => {}, compare: false},\n  onTileLoad: {type: 'function', value: tileHeader => {}, compare: false},\n  onTileUnload: {type: 'function', value: tileHeader => {}, compare: false},\n  onTileError: {type: 'function', value: (tile, message, url) => {}, compare: false},\n  _getMeshColor: {type: 'function', value: tileHeader => [255, 255, 255], compare: false}\n};\n\n/** All properties supported by Tile3DLayer */\nexport type Tile3DLayerProps<DataT = any> = _Tile3DLayerProps<DataT> & CompositeLayerProps<DataT>;\n\n/** Props added by the Tile3DLayer */\ntype _Tile3DLayerProps<DataT> = {\n  /** Color Accessor for point clouds. **/\n  getPointColor?: Accessor<DataT, Color>;\n\n  /** Global radius of all points in pixels. **/\n  pointSize?: number;\n\n  /** A loader which is used to decode the fetched tiles.\n   * @deprecated Use `loaders` instead\n   */\n  loader?: typeof Tiles3DLoader;\n\n  /** Called when Tileset JSON file is loaded. **/\n  onTilesetLoad?: (tile: Tileset3D) => void;\n\n  /** Called when a tile in the tileset hierarchy is loaded. **/\n  onTileLoad?: (tile: Tile3D) => void;\n\n  /** Called when a tile is unloaded. **/\n  onTileUnload?: (tile: Tile3D) => void;\n\n  /** Called when a tile fails to load. **/\n  onTileError?: (tile: Tile3D, url: string, message: string) => void;\n\n  /** (Experimental) Accessor to change color of mesh based on properties. **/\n  _getMeshColor?: (tile: Tile3D) => Color;\n};\n\n/** Render 3d tiles data formatted according to the [3D Tiles Specification](https://www.opengeospatial.org/standards/3DTiles) and [`ESRI I3S`](https://github.com/Esri/i3s-spec) */\nexport default class Tile3DLayer<DataT = any, ExtraPropsT = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_Tile3DLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps as any;\n  static layerName = 'Tile3DLayer';\n\n  state!: {\n    activeViewports: {};\n    frameNumber?: number;\n    lastUpdatedViewports: {[viewportId: string]: Viewport} | null;\n    layerMap: {[layerId: string]: any};\n    tileset3d: Tileset3D | null;\n  };\n\n  initializeState() {\n    if ('onTileLoadFail' in this.props) {\n      log.removed('onTileLoadFail', 'onTileError')();\n    }\n    // prop verification\n    this.state = {\n      layerMap: {},\n      tileset3d: null,\n      activeViewports: {},\n      lastUpdatedViewports: null\n    };\n  }\n\n  get isLoaded(): boolean {\n    const {tileset3d} = this.state;\n    return tileset3d !== null && tileset3d.isLoaded();\n  }\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>): boolean {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, changeFlags}: UpdateParameters<this>): void {\n    if (props.data && props.data !== oldProps.data) {\n      this._loadTileset(props.data);\n    }\n\n    if (changeFlags.viewportChanged) {\n      const {activeViewports} = this.state;\n      const viewportsNumber = Object.keys(activeViewports).length;\n      if (viewportsNumber) {\n        this._updateTileset(activeViewports);\n        this.state.lastUpdatedViewports = activeViewports;\n        this.state.activeViewports = {};\n      }\n    }\n    if (changeFlags.propsChanged) {\n      const {layerMap} = this.state;\n      for (const key in layerMap) {\n        layerMap[key].needsUpdate = true;\n      }\n    }\n  }\n\n  activateViewport(viewport: Viewport): void {\n    const {activeViewports, lastUpdatedViewports} = this.state;\n    this.internalState!.viewport = viewport;\n\n    activeViewports[viewport.id] = viewport;\n    const lastViewport = lastUpdatedViewports?.[viewport.id];\n    if (!lastViewport || !viewport.equals(lastViewport)) {\n      this.setChangeFlags({viewportChanged: true});\n      this.setNeedsUpdate();\n    }\n  }\n\n  getPickingInfo({info, sourceLayer}: GetPickingInfoParams) {\n    const {layerMap} = this.state;\n    const layerId = sourceLayer && sourceLayer.id;\n    if (layerId) {\n      // layerId: this.id-[scenegraph|pointcloud]-tileId\n      const substr = layerId.substring(this.id.length + 1);\n      const tileId = substr.substring(substr.indexOf('-') + 1);\n      info.object = layerMap[tileId] && layerMap[tileId].tile;\n    }\n\n    return info;\n  }\n\n  filterSubLayer({layer, viewport}: FilterContext): boolean {\n    // All sublayers will have a tile prop\n    const {tile} = layer.props as unknown as {tile: Tile3D};\n    const {id: viewportId} = viewport;\n    return tile.selected && tile.viewportIds.includes(viewportId);\n  }\n\n  protected _updateAutoHighlight(info: PickingInfo): void {\n    if (info.sourceLayer) {\n      info.sourceLayer.updateAutoHighlight(info);\n    }\n  }\n\n  private async _loadTileset(tilesetUrl) {\n    const {loadOptions = {}} = this.props;\n\n    // TODO: deprecate `loader` in v9.0\n    // @ts-ignore\n    let loader = this.props.loader || this.props.loaders;\n    if (Array.isArray(loader)) {\n      loader = loader[0];\n    }\n\n    const options = {loadOptions: {...loadOptions}};\n    if (loader.preload) {\n      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);\n\n      if (preloadOptions.headers) {\n        options.loadOptions.fetch = {\n          ...options.loadOptions.fetch,\n          headers: preloadOptions.headers\n        };\n      }\n      Object.assign(options, preloadOptions);\n    }\n    const tilesetJson = await load(tilesetUrl, loader, options.loadOptions);\n\n    const tileset3d = new Tileset3D(tilesetJson, {\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileUnload: this._onTileUnload.bind(this),\n      onTileError: this.props.onTileError,\n      ...options\n    });\n\n    this.setState({\n      tileset3d,\n      layerMap: {}\n    });\n\n    this._updateTileset(this.state.activeViewports);\n    this.props.onTilesetLoad(tileset3d);\n  }\n\n  private _onTileLoad(tileHeader: Tile3D): void {\n    const {lastUpdatedViewports} = this.state;\n    this.props.onTileLoad(tileHeader);\n    this._updateTileset(lastUpdatedViewports);\n    this.setNeedsUpdate();\n  }\n\n  private _onTileUnload(tileHeader: Tile3D): void {\n    // Was cleaned up from tileset cache. We no longer need to track it.\n    delete this.state.layerMap[tileHeader.id];\n    this.props.onTileUnload(tileHeader);\n  }\n\n  private _updateTileset(viewports: {[viewportId: string]: Viewport} | null): void {\n    if (!viewports) {\n      return;\n    }\n    const {tileset3d} = this.state;\n    const {timeline} = this.context;\n    const viewportsNumber = Object.keys(viewports).length;\n    if (!timeline || !viewportsNumber || !tileset3d) {\n      return;\n    }\n    tileset3d.selectTiles(Object.values(viewports)).then(frameNumber => {\n      const tilesetChanged = this.state.frameNumber !== frameNumber;\n      if (tilesetChanged) {\n        this.setState({frameNumber});\n      }\n    });\n  }\n\n  private _getSubLayer(\n    tileHeader: Tile3D,\n    oldLayer?: Layer\n  ): MeshLayer<DataT> | PointCloudLayer<DataT> | ScenegraphLayer<DataT> | null {\n    if (!tileHeader.content) {\n      return null;\n    }\n\n    switch (tileHeader.type) {\n      case TILE_TYPE.POINTCLOUD:\n        return this._makePointCloudLayer(tileHeader, oldLayer as PointCloudLayer<DataT>);\n      case TILE_TYPE.SCENEGRAPH:\n        return this._make3DModelLayer(tileHeader);\n      case TILE_TYPE.MESH:\n        return this._makeSimpleMeshLayer(tileHeader, oldLayer as MeshLayer<DataT>);\n      default:\n        throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);\n    }\n  }\n\n  private _makePointCloudLayer(\n    tileHeader: Tile3D,\n    oldLayer?: PointCloudLayer<DataT>\n  ): PointCloudLayer<DataT> | null {\n    const {attributes, pointCount, constantRGBA, cartographicOrigin, modelMatrix} =\n      tileHeader.content;\n    const {positions, normals, colors} = attributes;\n\n    if (!positions) {\n      return null;\n    }\n    const data = (oldLayer && oldLayer.props.data) || {\n      header: {\n        vertexCount: pointCount\n      },\n      attributes: {\n        POSITION: positions,\n        NORMAL: normals,\n        COLOR_0: colors\n      }\n    };\n\n    const {pointSize, getPointColor} = this.props;\n    const SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n    return new SubLayerClass(\n      {\n        pointSize\n      },\n      this.getSubLayerProps({\n        id: 'pointcloud'\n      }),\n      {\n        id: `${this.id}-pointcloud-${tileHeader.id}`,\n        tile: tileHeader,\n        data,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getColor: constantRGBA || getPointColor,\n        _offset: 0\n      }\n    );\n  }\n\n  private _make3DModelLayer(tileHeader: Tile3D): ScenegraphLayer<DataT> {\n    const {gltf, instances, cartographicOrigin, modelMatrix} = tileHeader.content;\n\n    const SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n\n    return new SubLayerClass(\n      {\n        _lighting: 'pbr'\n      },\n      this.getSubLayerProps({\n        id: 'scenegraph'\n      }),\n      {\n        id: `${this.id}-scenegraph-${tileHeader.id}`,\n        tile: tileHeader,\n        data: instances || SINGLE_DATA,\n        scenegraph: gltf,\n\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getTransformMatrix: instance => instance.modelMatrix,\n        getPosition: [0, 0, 0],\n        _offset: 0\n      }\n    );\n  }\n\n  private _makeSimpleMeshLayer(tileHeader: Tile3D, oldLayer?: MeshLayer<DataT>): MeshLayer<DataT> {\n    const content = tileHeader.content;\n    const {\n      attributes,\n      indices,\n      modelMatrix,\n      cartographicOrigin,\n      coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS,\n      material,\n      featureIds\n    } = content;\n    const {_getMeshColor} = this.props;\n\n    const geometry =\n      (oldLayer && oldLayer.props.mesh) ||\n      new Geometry({\n        drawMode: GL.TRIANGLES,\n        attributes: getMeshGeometry(attributes),\n        indices\n      });\n\n    const SubLayerClass = this.getSubLayerClass('mesh', MeshLayer);\n\n    return new SubLayerClass(\n      this.getSubLayerProps({\n        id: 'mesh'\n      }),\n      {\n        id: `${this.id}-mesh-${tileHeader.id}`,\n        tile: tileHeader,\n        mesh: geometry,\n        data: SINGLE_DATA,\n        getColor: _getMeshColor(tileHeader),\n        pbrMaterial: material,\n        modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem,\n        featureIds,\n        _offset: 0\n      }\n    );\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    const {tileset3d, layerMap} = this.state;\n    if (!tileset3d) {\n      return null;\n    }\n\n    // loaders.gl doesn't provide a type for tileset3d.tiles\n    return (tileset3d.tiles as Tile3D[])\n      .map(tile => {\n        const layerCache = (layerMap[tile.id] = layerMap[tile.id] || {tile});\n        let {layer} = layerCache;\n        if (tile.selected) {\n          // render selected tiles\n          if (!layer) {\n            // create layer\n            layer = this._getSubLayer(tile);\n          } else if (layerCache.needsUpdate) {\n            // props have changed, rerender layer\n            layer = this._getSubLayer(tile, layer);\n            layerCache.needsUpdate = false;\n          }\n        }\n        layerCache.layer = layer;\n        return layer;\n      })\n      .filter(Boolean);\n  }\n}\n\nfunction getMeshGeometry(contentAttributes: MeshAttributes): MeshAttributes {\n  const attributes: MeshAttributes = {};\n  attributes.positions = {\n    ...contentAttributes.positions,\n    value: new Float32Array(contentAttributes.positions.value)\n  };\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n  if (contentAttributes.colors) {\n    attributes.colors = contentAttributes.colors;\n  }\n  if (contentAttributes.uvRegions) {\n    attributes.uvRegions = contentAttributes.uvRegions;\n  }\n  return attributes;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}