{"ast":null,"code":"// This is a fork of papaparse\n// https://github.com/mholt/PapaParse\n/* @license\nPapa Parse\nv5.0.0-beta.0\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/\n// FORK SUMMARY:\n// - Adopt ES6 exports\n// - Implement new AsyncIteratorStreamer\n// - Remove non Async Iterator streamers (can all be handled by new streamer)\n// - Remove unused Worker support (loaders.gl worker system used instead)\n// - Remove unused jQuery plugin support\n\n/* eslint-disable */\n// @ts-nocheck\nvar global = function () {\n  // alternative method, similar to `Function('return this')()`\n  // but without using `eval` (which is disabled when\n  // using Content Security Policy).\n\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  // When running tests none of the above have been defined\n  return {};\n}();\nvar IS_PAPA_WORKER = false;\nvar Papa = {};\nmodule.exports = Papa;\nPapa.parse = CsvToJson;\nPapa.unparse = JsonToCsv;\nPapa.RECORD_SEP = String.fromCharCode(30);\nPapa.UNIT_SEP = String.fromCharCode(31);\nPapa.BYTE_ORDER_MARK = \"\\uFEFF\";\nPapa.BAD_DELIMITERS = ['\\r', '\\n', '\"', Papa.BYTE_ORDER_MARK];\nPapa.WORKERS_SUPPORTED = false; // !IS_WORKER && !!global.Worker;\nPapa.NODE_STREAM_INPUT = 1;\n\n// Configurable chunk sizes for local and remote files, respectively\nPapa.LocalChunkSize = 1024 * 1024 * 10; // 10 MB\nPapa.RemoteChunkSize = 1024 * 1024 * 5; // 5 MB\nPapa.DefaultDelimiter = ','; // Used if not specified and detection fails\n\n// Exposed for testing and development only\nPapa.Parser = Parser;\nPapa.ParserHandle = ParserHandle;\n\n// BEGIN FORK\nPapa.ChunkStreamer = ChunkStreamer;\nPapa.StringStreamer = StringStreamer;\n/*\nPapa.NetworkStreamer = NetworkStreamer;\nPapa.FileStreamer = FileStreamer;\nPapa.ReadableStreamStreamer = ReadableStreamStreamer;\nif (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n  Papa.DuplexStreamStreamer = DuplexStreamStreamer;\n}\n*/\n// END FORK\n\n// BEGIN FORK\n// Adds an argument to papa.parse\n// function CsvToJson(_input, _config)\nfunction CsvToJson(_input, _config, UserDefinedStreamer // BEGIN FORK\n) {\n  _config = _config || {};\n  var dynamicTyping = _config.dynamicTyping || false;\n  if (isFunction(dynamicTyping)) {\n    _config.dynamicTypingFunction = dynamicTyping;\n    // Will be filled on first row call\n    dynamicTyping = {};\n  }\n  _config.dynamicTyping = dynamicTyping;\n  _config.transform = isFunction(_config.transform) ? _config.transform : false;\n  if (_config.worker && Papa.WORKERS_SUPPORTED) {\n    var w = newWorker();\n    w.userStep = _config.step;\n    w.userChunk = _config.chunk;\n    w.userComplete = _config.complete;\n    w.userError = _config.error;\n    _config.step = isFunction(_config.step);\n    _config.chunk = isFunction(_config.chunk);\n    _config.complete = isFunction(_config.complete);\n    _config.error = isFunction(_config.error);\n    delete _config.worker; // prevent infinite loop\n\n    w.postMessage({\n      input: _input,\n      config: _config,\n      workerId: w.id\n    });\n    return;\n  }\n  var streamer = null;\n  /*\n  if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n    // create a node Duplex stream for use\n    // with .pipe\n    streamer = new DuplexStreamStreamer(_config);\n    return streamer.getStream();\n  } else\n  */\n  if (typeof _input === 'string') {\n    // if (_config.download) streamer = new NetworkStreamer(_config);\n    // else\n    streamer = new StringStreamer(_config);\n  }\n  /*\n  else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on)) {\n    streamer = new ReadableStreamStreamer(_config);\n  } else if ((global.File && _input instanceof File) || _input instanceof Object)\n    // ...Safari. (see issue #106)\n    streamer = new FileStreamer(_config);\n  */\n\n  // BEGIN FORK\n  if (!streamer) {\n    streamer = new UserDefinedStreamer(_config);\n  }\n  // END FORK\n\n  return streamer.stream(_input);\n}\nfunction JsonToCsv(_input, _config) {\n  // Default configuration\n\n  /** whether to surround every datum with quotes */\n  var _quotes = false;\n\n  /** whether to write headers */\n  var _writeHeader = true;\n\n  /** delimiting character(s) */\n  var _delimiter = ',';\n\n  /** newline character(s) */\n  var _newline = '\\r\\n';\n\n  /** quote character */\n  var _quoteChar = '\"';\n\n  /** escaped quote character, either \"\" or <config.escapeChar>\" */\n  var _escapedQuote = _quoteChar + _quoteChar;\n\n  /** whether to skip empty lines */\n  var _skipEmptyLines = false;\n\n  /** the columns (keys) we expect when we unparse objects */\n  var _columns = null;\n  unpackConfig();\n  var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');\n  if (typeof _input === 'string') _input = JSON.parse(_input);\n  if (Array.isArray(_input)) {\n    if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);else if (typeof _input[0] === 'object') return serialize(_columns || objectKeys(_input[0]), _input, _skipEmptyLines);\n  } else if (typeof _input === 'object') {\n    if (typeof _input.data === 'string') _input.data = JSON.parse(_input.data);\n    if (Array.isArray(_input.data)) {\n      if (!_input.fields) _input.fields = _input.meta && _input.meta.fields;\n      if (!_input.fields) _input.fields = Array.isArray(_input.data[0]) ? _input.fields : objectKeys(_input.data[0]);\n      if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== 'object') _input.data = [_input.data]; // handles input like [1,2,3] or ['asdf']\n    }\n\n    return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);\n  }\n\n  // Default (any valid paths should return before this)\n  throw new Error('Unable to serialize unrecognized input');\n  function unpackConfig() {\n    if (typeof _config !== 'object') return;\n    if (typeof _config.delimiter === 'string' && !Papa.BAD_DELIMITERS.filter(function (value) {\n      return _config.delimiter.indexOf(value) !== -1;\n    }).length) {\n      _delimiter = _config.delimiter;\n    }\n    if (typeof _config.quotes === 'boolean' || Array.isArray(_config.quotes)) _quotes = _config.quotes;\n    if (typeof _config.skipEmptyLines === 'boolean' || typeof _config.skipEmptyLines === 'string') _skipEmptyLines = _config.skipEmptyLines;\n    if (typeof _config.newline === 'string') _newline = _config.newline;\n    if (typeof _config.quoteChar === 'string') _quoteChar = _config.quoteChar;\n    if (typeof _config.header === 'boolean') _writeHeader = _config.header;\n    if (Array.isArray(_config.columns)) {\n      if (_config.columns.length === 0) throw new Error('Option columns is empty');\n      _columns = _config.columns;\n    }\n    if (_config.escapeChar !== undefined) {\n      _escapedQuote = _config.escapeChar + _quoteChar;\n    }\n  }\n\n  /** Turns an object's keys into an array */\n  function objectKeys(obj) {\n    if (typeof obj !== 'object') return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    return keys;\n  }\n\n  /** The double for loop that iterates the data and writes out a CSV string including header row */\n  function serialize(fields, data, skipEmptyLines) {\n    var csv = '';\n    if (typeof fields === 'string') fields = JSON.parse(fields);\n    if (typeof data === 'string') data = JSON.parse(data);\n    var hasHeader = Array.isArray(fields) && fields.length > 0;\n    var dataKeyedByField = !Array.isArray(data[0]);\n\n    // If there a header row, write it first\n    if (hasHeader && _writeHeader) {\n      for (var i = 0; i < fields.length; i++) {\n        if (i > 0) csv += _delimiter;\n        csv += safe(fields[i], i);\n      }\n      if (data.length > 0) csv += _newline;\n    }\n\n    // Then write out the data\n    for (var row = 0; row < data.length; row++) {\n      var maxCol = hasHeader ? fields.length : data[row].length;\n      var emptyLine = false;\n      var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;\n      if (skipEmptyLines && !hasHeader) {\n        emptyLine = skipEmptyLines === 'greedy' ? data[row].join('').trim() === '' : data[row].length === 1 && data[row][0].length === 0;\n      }\n      if (skipEmptyLines === 'greedy' && hasHeader) {\n        var line = [];\n        for (var c = 0; c < maxCol; c++) {\n          var cx = dataKeyedByField ? fields[c] : c;\n          line.push(data[row][cx]);\n        }\n        emptyLine = line.join('').trim() === '';\n      }\n      if (!emptyLine) {\n        for (var col = 0; col < maxCol; col++) {\n          if (col > 0 && !nullLine) csv += _delimiter;\n          var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n          csv += safe(data[row][colIdx], col);\n        }\n        if (row < data.length - 1 && (!skipEmptyLines || maxCol > 0 && !nullLine)) {\n          csv += _newline;\n        }\n      }\n    }\n    return csv;\n  }\n\n  /** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n  function safe(str, col) {\n    if (typeof str === 'undefined' || str === null) return '';\n    if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);\n    str = str.toString().replace(quoteCharRegex, _escapedQuote);\n    var needsQuotes = typeof _quotes === 'boolean' && _quotes || Array.isArray(_quotes) && _quotes[col] || hasAny(str, Papa.BAD_DELIMITERS) || str.indexOf(_delimiter) > -1 || str.charAt(0) === ' ' || str.charAt(str.length - 1) === ' ';\n    return needsQuotes ? _quoteChar + str + _quoteChar : str;\n  }\n  function hasAny(str, substrings) {\n    for (var i = 0; i < substrings.length; i++) if (str.indexOf(substrings[i]) > -1) return true;\n    return false;\n  }\n}\n\n/** ChunkStreamer is the base prototype for various streamer implementations. */\nfunction ChunkStreamer(config) {\n  this._handle = null;\n  this._finished = false;\n  this._completed = false;\n  this._input = null;\n  this._baseIndex = 0;\n  this._partialLine = '';\n  this._rowCount = 0;\n  this._start = 0;\n  this._nextChunk = null;\n  this.isFirstChunk = true;\n  this._completeResults = {\n    data: [],\n    errors: [],\n    meta: {}\n  };\n  replaceConfig.call(this, config);\n  this.parseChunk = function (chunk, isFakeChunk) {\n    // First chunk pre-processing\n    if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {\n      var modifiedChunk = this._config.beforeFirstChunk(chunk);\n      if (modifiedChunk !== undefined) chunk = modifiedChunk;\n    }\n    this.isFirstChunk = false;\n\n    // Rejoin the line we likely just split in two by chunking the file\n    var aggregate = this._partialLine + chunk;\n    this._partialLine = '';\n    var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n    if (this._handle.paused() || this._handle.aborted()) return;\n    var lastIndex = results.meta.cursor;\n    if (!this._finished) {\n      this._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n      this._baseIndex = lastIndex;\n    }\n    if (results && results.data) this._rowCount += results.data.length;\n    var finishedIncludingPreview = this._finished || this._config.preview && this._rowCount >= this._config.preview;\n    if (IS_PAPA_WORKER) {\n      global.postMessage({\n        results: results,\n        workerId: Papa.WORKER_ID,\n        finished: finishedIncludingPreview\n      });\n    } else if (isFunction(this._config.chunk) && !isFakeChunk) {\n      this._config.chunk(results, this._handle);\n      if (this._handle.paused() || this._handle.aborted()) return;\n      results = undefined;\n      this._completeResults = undefined;\n    }\n    if (!this._config.step && !this._config.chunk) {\n      this._completeResults.data = this._completeResults.data.concat(results.data);\n      this._completeResults.errors = this._completeResults.errors.concat(results.errors);\n      this._completeResults.meta = results.meta;\n    }\n    if (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {\n      this._config.complete(this._completeResults, this._input);\n      this._completed = true;\n    }\n    if (!finishedIncludingPreview && (!results || !results.meta.paused)) this._nextChunk();\n    return results;\n  };\n  this._sendError = function (error) {\n    if (isFunction(this._config.error)) this._config.error(error);else if (IS_PAPA_WORKER && this._config.error) {\n      global.postMessage({\n        workerId: Papa.WORKER_ID,\n        error: error,\n        finished: false\n      });\n    }\n  };\n  function replaceConfig(config) {\n    // Deep-copy the config so we can edit it\n    var configCopy = copy(config);\n    configCopy.chunkSize = parseInt(configCopy.chunkSize); // parseInt VERY important so we don't concatenate strings!\n    if (!config.step && !config.chunk) configCopy.chunkSize = null; // disable Range header if not streaming; bad values break IIS - see issue #196\n    this._handle = new ParserHandle(configCopy);\n    this._handle.streamer = this;\n    this._config = configCopy; // persist the copy to the caller\n  }\n}\n\n/*\nfunction NetworkStreamer(config) {\n  config = config || {};\n  if (!config.chunkSize) config.chunkSize = Papa.RemoteChunkSize;\n  ChunkStreamer.call(this, config);\n\n  var xhr;\n\n  if (IS_WORKER) {\n    this._nextChunk = function() {\n      this._readChunk();\n      this._chunkLoaded();\n    };\n  } else {\n    this._nextChunk = function() {\n      this._readChunk();\n    };\n  }\n\n  this.stream = function(url) {\n    this._input = url;\n    this._nextChunk(); // Starts streaming\n  };\n\n  this._readChunk = function() {\n    if (this._finished) {\n      this._chunkLoaded();\n      return;\n    }\n\n    xhr = new XMLHttpRequest();\n\n    if (this._config.withCredentials) {\n      xhr.withCredentials = this._config.withCredentials;\n    }\n\n    if (!IS_WORKER) {\n      xhr.onload = bindFunction(this._chunkLoaded, this);\n      xhr.onerror = bindFunction(this._chunkError, this);\n    }\n\n    xhr.open('GET', this._input, !IS_WORKER);\n    // Headers can only be set when once the request state is OPENED\n    if (this._config.downloadRequestHeaders) {\n      var headers = this._config.downloadRequestHeaders;\n\n      for (var headerName in headers) {\n        xhr.setRequestHeader(headerName, headers[headerName]);\n      }\n    }\n\n    if (this._config.chunkSize) {\n      var end = this._start + this._config.chunkSize - 1; // minus one because byte range is inclusive\n      xhr.setRequestHeader('Range', 'bytes=' + this._start + '-' + end);\n    }\n\n    try {\n      xhr.send();\n    } catch (err) {\n      this._chunkError(err.message);\n    }\n\n    if (IS_WORKER && xhr.status === 0) this._chunkError();\n    else this._start += this._config.chunkSize;\n  };\n\n  this._chunkLoaded = function() {\n    if (xhr.readyState !== 4) return;\n\n    if (xhr.status < 200 || xhr.status >= 400) {\n      this._chunkError();\n      return;\n    }\n\n    this._finished = !this._config.chunkSize || this._start > getFileSize(xhr);\n    this.parseChunk(xhr.responseText);\n  };\n\n  this._chunkError = function(errorMessage) {\n    var errorText = xhr.statusText || errorMessage;\n    this._sendError(new Error(errorText));\n  };\n\n  function getFileSize(xhr) {\n    var contentRange = xhr.getResponseHeader('Content-Range');\n    if (contentRange === null) {\n      // no content range, then finish!\n      return -1;\n    }\n    return parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));\n  }\n}\nNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\nNetworkStreamer.prototype.constructor = NetworkStreamer;\n\nfunction FileStreamer(config) {\n  config = config || {};\n  if (!config.chunkSize) config.chunkSize = Papa.LocalChunkSize;\n  ChunkStreamer.call(this, config);\n\n  var reader, slice;\n\n  // FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n  // But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n  var usingAsyncReader = typeof FileReader !== 'undefined'; // Safari doesn't consider it a function - see issue #105\n\n  this.stream = function(file) {\n    this._input = file;\n    slice = file.slice || file.webkitSlice || file.mozSlice;\n\n    if (usingAsyncReader) {\n      reader = new FileReader(); // Preferred method of reading files, even in workers\n      reader.onload = bindFunction(this._chunkLoaded, this);\n      reader.onerror = bindFunction(this._chunkError, this);\n    } else reader = new FileReaderSync(); // Hack for running in a web worker in Firefox\n\n    this._nextChunk(); // Starts streaming\n  };\n\n  this._nextChunk = function() {\n    if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n      this._readChunk();\n  };\n\n  this._readChunk = function() {\n    var input = this._input;\n    if (this._config.chunkSize) {\n      var end = Math.min(this._start + this._config.chunkSize, this._input.size);\n      input = slice.call(input, this._start, end);\n    }\n    var txt = reader.readAsText(input, this._config.encoding);\n    if (!usingAsyncReader) this._chunkLoaded({target: {result: txt}}); // mimic the async signature\n  };\n\n  this._chunkLoaded = function(event) {\n    // Very important to increment start each time before handling results\n    this._start += this._config.chunkSize;\n    this._finished = !this._config.chunkSize || this._start >= this._input.size;\n    this.parseChunk(event.target.result);\n  };\n\n  this._chunkError = function() {\n    this._sendError(reader.error);\n  };\n}\nFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\nFileStreamer.prototype.constructor = FileStreamer;\n*/\n\nfunction StringStreamer(config) {\n  config = config || {};\n  ChunkStreamer.call(this, config);\n  var remaining;\n  this.stream = function (s) {\n    remaining = s;\n    return this._nextChunk();\n  };\n  this._nextChunk = function () {\n    if (this._finished) return;\n    var size = this._config.chunkSize;\n    var chunk = size ? remaining.substr(0, size) : remaining;\n    remaining = size ? remaining.substr(size) : '';\n    this._finished = !remaining;\n    return this.parseChunk(chunk);\n  };\n}\nStringStreamer.prototype = Object.create(StringStreamer.prototype);\nStringStreamer.prototype.constructor = StringStreamer;\n\n/*\nfunction ReadableStreamStreamer(config) {\n  config = config || {};\n\n  ChunkStreamer.call(this, config);\n\n  var queue = [];\n  var parseOnData = true;\n  var streamHasEnded = false;\n\n  this.pause = function() {\n    ChunkStreamer.prototype.pause.apply(this, arguments);\n    this._input.pause();\n  };\n\n  this.resume = function() {\n    ChunkStreamer.prototype.resume.apply(this, arguments);\n    this._input.resume();\n  };\n\n  this.stream = function(stream) {\n    this._input = stream;\n\n    this._input.on('data', this._streamData);\n    this._input.on('end', this._streamEnd);\n    this._input.on('error', this._streamError);\n  };\n\n  this._checkIsFinished = function() {\n    if (streamHasEnded && queue.length === 1) {\n      this._finished = true;\n    }\n  };\n\n  this._nextChunk = function() {\n    this._checkIsFinished();\n    if (queue.length) {\n      this.parseChunk(queue.shift());\n    } else {\n      parseOnData = true;\n    }\n  };\n\n  this._streamData = bindFunction(function(chunk) {\n    try {\n      queue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));\n\n      if (parseOnData) {\n        parseOnData = false;\n        this._checkIsFinished();\n        this.parseChunk(queue.shift());\n      }\n    } catch (error) {\n      this._streamError(error);\n    }\n  }, this);\n\n  this._streamError = bindFunction(function(error) {\n    this._streamCleanUp();\n    this._sendError(error);\n  }, this);\n\n  this._streamEnd = bindFunction(function() {\n    this._streamCleanUp();\n    streamHasEnded = true;\n    this._streamData('');\n  }, this);\n\n  this._streamCleanUp = bindFunction(function() {\n    this._input.removeListener('data', this._streamData);\n    this._input.removeListener('end', this._streamEnd);\n    this._input.removeListener('error', this._streamError);\n  }, this);\n}\nReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\nReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n\nfunction DuplexStreamStreamer(_config) {\n  var Duplex = require('stream').Duplex;\n  var config = copy(_config);\n  var parseOnWrite = true;\n  var writeStreamHasFinished = false;\n  var parseCallbackQueue = [];\n  var stream = null;\n\n  this._onCsvData = function(results) {\n    var data = results.data;\n    if (!stream.push(data) && !this._handle.paused()) {\n      // the writeable consumer buffer has filled up\n      // so we need to pause until more items\n      // can be processed\n      this._handle.pause();\n    }\n  };\n\n  this._onCsvComplete = function() {\n    // node will finish the read stream when\n    // null is pushed\n    stream.push(null);\n  };\n\n  config.step = bindFunction(this._onCsvData, this);\n  config.complete = bindFunction(this._onCsvComplete, this);\n  ChunkStreamer.call(this, config);\n\n  this._nextChunk = function() {\n    if (writeStreamHasFinished && parseCallbackQueue.length === 1) {\n      this._finished = true;\n    }\n    if (parseCallbackQueue.length) {\n      parseCallbackQueue.shift()();\n    } else {\n      parseOnWrite = true;\n    }\n  };\n\n  this._addToParseQueue = function(chunk, callback) {\n    // add to queue so that we can indicate\n    // completion via callback\n    // node will automatically pause the incoming stream\n    // when too many items have been added without their\n    // callback being invoked\n    parseCallbackQueue.push(\n      bindFunction(function() {\n        this.parseChunk(typeof chunk === 'string' ? chunk : chunk.toString(config.encoding));\n        if (isFunction(callback)) {\n          return callback();\n        }\n      }, this)\n    );\n    if (parseOnWrite) {\n      parseOnWrite = false;\n      this._nextChunk();\n    }\n  };\n\n  this._onRead = function() {\n    if (this._handle.paused()) {\n      // the writeable consumer can handle more data\n      // so resume the chunk parsing\n      this._handle.resume();\n    }\n  };\n\n  this._onWrite = function(chunk, encoding, callback) {\n    this._addToParseQueue(chunk, callback);\n  };\n\n  this._onWriteComplete = function() {\n    writeStreamHasFinished = true;\n    // have to write empty string\n    // so parser knows its done\n    this._addToParseQueue('');\n  };\n\n  this.getStream = function() {\n    return stream;\n  };\n  stream = new Duplex({\n    readableObjectMode: true,\n    decodeStrings: false,\n    read: bindFunction(this._onRead, this),\n    write: bindFunction(this._onWrite, this)\n  });\n  stream.once('finish', bindFunction(this._onWriteComplete, this));\n}\nif (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n  DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n  DuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;\n}\n*/\n\n// Use one ParserHandle per entire CSV file or string\nfunction ParserHandle(_config) {\n  // One goal is to minimize the use of regular expressions...\n  var FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n  var ISO_DATE = /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/;\n  var self = this;\n  var _stepCounter = 0; // Number of times step was called (number of rows parsed)\n  var _rowCounter = 0; // Number of rows that have been parsed so far\n  var _input; // The input being parsed\n  var _parser; // The core parser being used\n  var _paused = false; // Whether we are paused or not\n  var _aborted = false; // Whether the parser has aborted or not\n  var _delimiterError; // Temporary state between delimiter detection and processing results\n  var _fields = []; // Fields are from the header row of the input, if there is one\n  var _results = {\n    // The last results returned from the parser\n    data: [],\n    errors: [],\n    meta: {}\n  };\n  if (isFunction(_config.step)) {\n    var userStep = _config.step;\n    _config.step = function (results) {\n      _results = results;\n      if (needsHeaderRow()) processResults();\n      // only call user's step function after header row\n      else {\n        processResults();\n\n        // It's possbile that this line was empty and there's no row here after all\n        if (_results.data.length === 0) return;\n        _stepCounter += results.data.length;\n        if (_config.preview && _stepCounter > _config.preview) _parser.abort();else userStep(_results, self);\n      }\n    };\n  }\n\n  /**\n   * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n   * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n   * when an input comes in multiple chunks, like from a file.\n   */\n  this.parse = function (input, baseIndex, ignoreLastRow) {\n    var quoteChar = _config.quoteChar || '\"';\n    if (!_config.newline) _config.newline = guessLineEndings(input, quoteChar);\n    _delimiterError = false;\n    if (!_config.delimiter) {\n      var delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess);\n      if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;else {\n        _delimiterError = true; // add error after parsing (otherwise it would be overwritten)\n        _config.delimiter = Papa.DefaultDelimiter;\n      }\n      _results.meta.delimiter = _config.delimiter;\n    } else if (isFunction(_config.delimiter)) {\n      _config.delimiter = _config.delimiter(input);\n      _results.meta.delimiter = _config.delimiter;\n    }\n    var parserConfig = copy(_config);\n    if (_config.preview && _config.header) parserConfig.preview++; // to compensate for header row\n\n    _input = input;\n    _parser = new Parser(parserConfig);\n    _results = _parser.parse(_input, baseIndex, ignoreLastRow);\n    processResults();\n    return _paused ? {\n      meta: {\n        paused: true\n      }\n    } : _results || {\n      meta: {\n        paused: false\n      }\n    };\n  };\n  this.paused = function () {\n    return _paused;\n  };\n  this.pause = function () {\n    _paused = true;\n    _parser.abort();\n    _input = _input.substr(_parser.getCharIndex());\n  };\n  this.resume = function () {\n    _paused = false;\n    self.streamer.parseChunk(_input, true);\n  };\n  this.aborted = function () {\n    return _aborted;\n  };\n  this.abort = function () {\n    _aborted = true;\n    _parser.abort();\n    _results.meta.aborted = true;\n    if (isFunction(_config.complete)) _config.complete(_results);\n    _input = '';\n  };\n  function testEmptyLine(s) {\n    return _config.skipEmptyLines === 'greedy' ? s.join('').trim() === '' : s.length === 1 && s[0].length === 0;\n  }\n  function processResults() {\n    if (_results && _delimiterError) {\n      addError('Delimiter', 'UndetectableDelimiter', \"Unable to auto-detect delimiting character; defaulted to '\" + Papa.DefaultDelimiter + \"'\");\n      _delimiterError = false;\n    }\n    if (_config.skipEmptyLines) {\n      for (var i = 0; i < _results.data.length; i++) if (testEmptyLine(_results.data[i])) _results.data.splice(i--, 1);\n    }\n    if (needsHeaderRow()) fillHeaderFields();\n    return applyHeaderAndDynamicTypingAndTransformation();\n  }\n  function needsHeaderRow() {\n    return _config.header && _fields.length === 0;\n  }\n  function fillHeaderFields() {\n    if (!_results) return;\n    function addHeder(header) {\n      if (isFunction(_config.transformHeader)) header = _config.transformHeader(header);\n      _fields.push(header);\n    }\n    if (Array.isArray(_results.data[0])) {\n      for (var i = 0; needsHeaderRow() && i < _results.data.length; i++) _results.data[i].forEach(addHeder);\n      _results.data.splice(0, 1);\n    }\n    // if _results.data[0] is not an array, we are in a step where _results.data is the row.\n    else _results.data.forEach(addHeder);\n  }\n  function shouldApplyDynamicTyping(field) {\n    // Cache function values to avoid calling it for each row\n    if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n      _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n    }\n    return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;\n  }\n  function parseDynamic(field, value) {\n    if (shouldApplyDynamicTyping(field)) {\n      if (value === 'true' || value === 'TRUE') return true;else if (value === 'false' || value === 'FALSE') return false;else if (FLOAT.test(value)) return parseFloat(value);else if (ISO_DATE.test(value)) return new Date(value);else return value === '' ? null : value;\n    }\n    return value;\n  }\n  function applyHeaderAndDynamicTypingAndTransformation() {\n    if (!_results || !_config.header && !_config.dynamicTyping && !_config.transform) return _results;\n    function processRow(rowSource, i) {\n      var row = _config.header ? {} : [];\n      var j;\n      for (j = 0; j < rowSource.length; j++) {\n        var field = j;\n        var value = rowSource[j];\n        if (_config.header) field = j >= _fields.length ? '__parsed_extra' : _fields[j];\n        if (_config.transform) value = _config.transform(value, field);\n        value = parseDynamic(field, value);\n        if (field === '__parsed_extra') {\n          row[field] = row[field] || [];\n          row[field].push(value);\n        } else row[field] = value;\n      }\n      if (_config.header) {\n        if (j > _fields.length) addError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);else if (j < _fields.length) addError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);\n      }\n      return row;\n    }\n    var incrementBy = 1;\n    if (!_results.data[0] || Array.isArray(_results.data[0])) {\n      _results.data = _results.data.map(processRow);\n      incrementBy = _results.data.length;\n    } else _results.data = processRow(_results.data, 0);\n    if (_config.header && _results.meta) _results.meta.fields = _fields;\n    _rowCounter += incrementBy;\n    return _results;\n  }\n  function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {\n    var bestDelim, bestDelta, fieldCountPrevRow;\n    delimitersToGuess = delimitersToGuess || [',', '\\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];\n    for (var i = 0; i < delimitersToGuess.length; i++) {\n      var delim = delimitersToGuess[i];\n      var delta = 0,\n        avgFieldCount = 0,\n        emptyLinesCount = 0;\n      fieldCountPrevRow = undefined;\n      var preview = new Parser({\n        comments: comments,\n        delimiter: delim,\n        newline: newline,\n        preview: 10\n      }).parse(input);\n      for (var j = 0; j < preview.data.length; j++) {\n        if (skipEmptyLines && testEmptyLine(preview.data[j])) {\n          emptyLinesCount++;\n          continue;\n        }\n        var fieldCount = preview.data[j].length;\n        avgFieldCount += fieldCount;\n        if (typeof fieldCountPrevRow === 'undefined') {\n          fieldCountPrevRow = 0;\n          continue;\n        } else if (fieldCount > 1) {\n          delta += Math.abs(fieldCount - fieldCountPrevRow);\n          fieldCountPrevRow = fieldCount;\n        }\n      }\n      if (preview.data.length > 0) avgFieldCount /= preview.data.length - emptyLinesCount;\n      if ((typeof bestDelta === 'undefined' || delta > bestDelta) && avgFieldCount > 1.99) {\n        bestDelta = delta;\n        bestDelim = delim;\n      }\n    }\n    _config.delimiter = bestDelim;\n    return {\n      successful: !!bestDelim,\n      bestDelimiter: bestDelim\n    };\n  }\n  function guessLineEndings(input, quoteChar) {\n    input = input.substr(0, 1024 * 1024); // max length 1 MB\n    // Replace all the text inside quotes\n    var re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');\n    input = input.replace(re, '');\n    var r = input.split('\\r');\n    var n = input.split('\\n');\n    var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;\n    if (r.length === 1 || nAppearsFirst) return '\\n';\n    var numWithN = 0;\n    for (var i = 0; i < r.length; i++) {\n      if (r[i][0] === '\\n') numWithN++;\n    }\n    return numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n  }\n  function addError(type, code, msg, row) {\n    _results.errors.push({\n      type: type,\n      code: code,\n      message: msg,\n      row: row\n    });\n  }\n}\n\n/** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\n/** The core parser implements speedy and correct CSV parsing */\nfunction Parser(config) {\n  // Unpack the config object\n  config = config || {};\n  var delim = config.delimiter;\n  var newline = config.newline;\n  var comments = config.comments;\n  var step = config.step;\n  var preview = config.preview;\n  var fastMode = config.fastMode;\n  var quoteChar;\n  /** Allows for no quoteChar by setting quoteChar to undefined in config */\n  if (config.quoteChar === undefined) {\n    quoteChar = '\"';\n  } else {\n    quoteChar = config.quoteChar;\n  }\n  var escapeChar = quoteChar;\n  if (config.escapeChar !== undefined) {\n    escapeChar = config.escapeChar;\n  }\n\n  // Delimiter must be valid\n  if (typeof delim !== 'string' || Papa.BAD_DELIMITERS.indexOf(delim) > -1) delim = ',';\n\n  // Comment character must be valid\n  if (comments === delim) throw new Error('Comment character same as delimiter');else if (comments === true) comments = '#';else if (typeof comments !== 'string' || Papa.BAD_DELIMITERS.indexOf(comments) > -1) comments = false;\n\n  // Newline must be valid: \\r, \\n, or \\r\\n\n  if (newline !== '\\n' && newline !== '\\r' && newline !== '\\r\\n') newline = '\\n';\n\n  // We're gonna need these at the Parser scope\n  var cursor = 0;\n  var aborted = false;\n  this.parse = function (input, baseIndex, ignoreLastRow) {\n    // For some reason, in Chrome, this speeds things up (!?)\n    if (typeof input !== 'string') throw new Error('Input must be a string');\n\n    // We don't need to compute some of these every time parse() is called,\n    // but having them in a more local scope seems to perform better\n    var inputLen = input.length,\n      delimLen = delim.length,\n      newlineLen = newline.length,\n      commentsLen = comments.length;\n    var stepIsFunction = isFunction(step);\n\n    // Establish starting state\n    cursor = 0;\n    var data = [],\n      errors = [],\n      row = [],\n      lastCursor = 0;\n    if (!input) return returnable();\n    if (fastMode || fastMode !== false && input.indexOf(quoteChar) === -1) {\n      var rows = input.split(newline);\n      for (var i = 0; i < rows.length; i++) {\n        row = rows[i];\n        cursor += row.length;\n        if (i !== rows.length - 1) cursor += newline.length;else if (ignoreLastRow) return returnable();\n        if (comments && row.substr(0, commentsLen) === comments) continue;\n        if (stepIsFunction) {\n          data = [];\n          pushRow(row.split(delim));\n          doStep();\n          if (aborted) return returnable();\n        } else pushRow(row.split(delim));\n        if (preview && i >= preview) {\n          data = data.slice(0, preview);\n          return returnable(true);\n        }\n      }\n      return returnable();\n    }\n    var nextDelim = input.indexOf(delim, cursor);\n    var nextNewline = input.indexOf(newline, cursor);\n    var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');\n    var quoteSearch;\n\n    // Parser loop\n    for (;;) {\n      // Field has opening quote\n      if (input[cursor] === quoteChar) {\n        // Start our search for the closing quote where the cursor is\n        quoteSearch = cursor;\n\n        // Skip the opening quote\n        cursor++;\n        for (;;) {\n          // Find closing quote\n          quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);\n\n          //No other quotes are found - no other delimiters\n          if (quoteSearch === -1) {\n            if (!ignoreLastRow) {\n              // No closing quote... what a pity\n              errors.push({\n                type: 'Quotes',\n                code: 'MissingQuotes',\n                message: 'Quoted field unterminated',\n                row: data.length,\n                // row has yet to be inserted\n                index: cursor\n              });\n            }\n            return finish();\n          }\n\n          // Closing quote at EOF\n          if (quoteSearch === inputLen - 1) {\n            var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n            return finish(value);\n          }\n\n          // If this quote is escaped, it's part of the data; skip it\n          // If the quote character is the escape character, then check if the next character is the escape character\n          if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {\n            quoteSearch++;\n            continue;\n          }\n\n          // If the quote character is not the escape character, then check if the previous character was the escape character\n          if (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar) {\n            continue;\n          }\n\n          // Check up to nextDelim or nextNewline, whichever is closest\n          var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);\n          var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);\n\n          // Closing quote followed by delimiter or 'unnecessary spaces + delimiter'\n          if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim) {\n            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n            cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;\n            nextDelim = input.indexOf(delim, cursor);\n            nextNewline = input.indexOf(newline, cursor);\n            break;\n          }\n          var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);\n\n          // Closing quote followed by newline or 'unnecessary spaces + newLine'\n          if (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, newlineLen) === newline) {\n            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n            saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);\n            nextDelim = input.indexOf(delim, cursor); // because we may have skipped the nextDelim in the quoted field\n\n            if (stepIsFunction) {\n              doStep();\n              if (aborted) return returnable();\n            }\n            if (preview && data.length >= preview) return returnable(true);\n            break;\n          }\n\n          // Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string\n          errors.push({\n            type: 'Quotes',\n            code: 'InvalidQuotes',\n            message: 'Trailing quote on quoted field is malformed',\n            row: data.length,\n            // row has yet to be inserted\n            index: cursor\n          });\n          quoteSearch++;\n          continue;\n        }\n        continue;\n      }\n\n      // Comment found at start of new line\n      if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments) {\n        if (nextNewline === -1)\n          // Comment ends at EOF\n          return returnable();\n        cursor = nextNewline + newlineLen;\n        nextNewline = input.indexOf(newline, cursor);\n        nextDelim = input.indexOf(delim, cursor);\n        continue;\n      }\n\n      // Next delimiter comes before next newline, so we've reached end of field\n      if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {\n        row.push(input.substring(cursor, nextDelim));\n        cursor = nextDelim + delimLen;\n        nextDelim = input.indexOf(delim, cursor);\n        continue;\n      }\n\n      // End of row\n      if (nextNewline !== -1) {\n        row.push(input.substring(cursor, nextNewline));\n        saveRow(nextNewline + newlineLen);\n        if (stepIsFunction) {\n          doStep();\n          if (aborted) return returnable();\n        }\n        if (preview && data.length >= preview) return returnable(true);\n        continue;\n      }\n      break;\n    }\n    return finish();\n    function pushRow(row) {\n      data.push(row);\n      lastCursor = cursor;\n    }\n\n    /**\n     * checks if there are extra spaces after closing quote and given index without any text\n     * if Yes, returns the number of spaces\n     */\n    function extraSpaces(index) {\n      var spaceLength = 0;\n      if (index !== -1) {\n        var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);\n        if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {\n          spaceLength = textBetweenClosingQuoteAndIndex.length;\n        }\n      }\n      return spaceLength;\n    }\n\n    /**\n     * Appends the remaining input from cursor to the end into\n     * row, saves the row, calls step, and returns the results.\n     */\n    function finish(value) {\n      if (ignoreLastRow) return returnable();\n      if (typeof value === 'undefined') value = input.substr(cursor);\n      row.push(value);\n      cursor = inputLen; // important in case parsing is paused\n      pushRow(row);\n      if (stepIsFunction) doStep();\n      return returnable();\n    }\n\n    /**\n     * Appends the current row to the results. It sets the cursor\n     * to newCursor and finds the nextNewline. The caller should\n     * take care to execute user's step function and check for\n     * preview and end parsing if necessary.\n     */\n    function saveRow(newCursor) {\n      cursor = newCursor;\n      pushRow(row);\n      row = [];\n      nextNewline = input.indexOf(newline, cursor);\n    }\n\n    /** Returns an object with the results, errors, and meta. */\n    function returnable(stopped, step) {\n      var isStep = step || false;\n      return {\n        data: isStep ? data[0] : data,\n        errors: errors,\n        meta: {\n          delimiter: delim,\n          linebreak: newline,\n          aborted: aborted,\n          truncated: !!stopped,\n          cursor: lastCursor + (baseIndex || 0)\n        }\n      };\n    }\n\n    /** Executes the user's step function and resets data & errors. */\n    function doStep() {\n      step(returnable(undefined, true));\n      data = [];\n      errors = [];\n    }\n  };\n\n  /** Sets the abort flag */\n  this.abort = function () {\n    aborted = true;\n  };\n\n  /** Gets the cursor position */\n  this.getCharIndex = function () {\n    return cursor;\n  };\n}\n\n/*\nfunction getWorkerBlob() {\n\tvar URL = global.URL || global.webkitURL || null;\n\tvar code = moduleFactory.toString();\n\treturn Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob(['(', code, ')();'], {type: 'text/javascript'})));\n}\n\nvar IS_WORKER = !global.document && !!global.postMessage,\n\tIS_PAPA_WORKER = IS_WORKER && /blob:/i.test((global.location || {}).protocol);\nvar workers = {}, workerIdCounter = 0;\n\nfunction newWorker()\n{\n\tif (!Papa.WORKERS_SUPPORTED)\n\t\treturn false;\n\n\tvar workerUrl = getWorkerBlob();\n\tvar w = new global.Worker(workerUrl);\n\tw.onmessage = mainThreadReceivedMessage;\n\tw.id = workerIdCounter++;\n\tworkers[w.id] = w;\n\treturn w;\n}\n\n// Callback when main thread receives a message\nfunction mainThreadReceivedMessage(e)\n{\n\tvar msg = e.data;\n\tvar worker = workers[msg.workerId];\n\tvar aborted = false;\n\n\tif (msg.error)\n\t\tworker.userError(msg.error, msg.file);\n\telse if (msg.results && msg.results.data)\n\t{\n\t\tvar abort = function() {\n\t\t\taborted = true;\n\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t};\n\n\t\tvar handle = {\n\t\t\tabort: abort,\n\t\t\tpause: notImplemented,\n\t\t\tresume: notImplemented\n\t\t};\n\n\t\tif (isFunction(worker.userStep))\n\t\t{\n\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t{\n\t\t\t\tworker.userStep({\n\t\t\t\t\tdata: msg.results.data[i],\n\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t}, handle);\n\t\t\t\tif (aborted)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t}\n\t\telse if (isFunction(worker.userChunk))\n\t\t{\n\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\tdelete msg.results;\n\t\t}\n\t}\n\n\tif (msg.finished && !aborted)\n\t\tcompleteWorker(msg.workerId, msg.results);\n}\n\nfunction completeWorker(workerId, results) {\n\tvar worker = workers[workerId];\n\tif (isFunction(worker.userComplete))\n\t\tworker.userComplete(results);\n\tworker.terminate();\n\tdelete workers[workerId];\n}\n\n// Callback when worker thread receives a message\nfunction workerThreadReceivedMessage(e)\n{\n\tvar msg = e.data;\n\n\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\tPapa.WORKER_ID = msg.workerId;\n\n\tif (typeof msg.input === 'string')\n\t{\n\t\tglobal.postMessage({\n\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\tfinished: true\n\t\t});\n\t}\n\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t{\n\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\tif (results)\n\t\t\tglobal.postMessage({\n\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\tresults: results,\n\t\t\t\tfinished: true\n\t\t\t});\n\t}\n}\n*/\n\nfunction notImplemented() {\n  throw new Error('Not implemented.');\n}\n\n/** Makes a deep copy of an array or object (mostly) */\nfunction copy(obj) {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  var cpy = Array.isArray(obj) ? [] : {};\n  for (var key in obj) cpy[key] = copy(obj[key]);\n  return cpy;\n}\nfunction bindFunction(f, self) {\n  return function () {\n    f.apply(self, arguments);\n  };\n}\nfunction isFunction(func) {\n  return typeof func === 'function';\n}","map":{"version":3,"names":["global","self","window","IS_PAPA_WORKER","Papa","module","exports","parse","CsvToJson","unparse","JsonToCsv","RECORD_SEP","String","fromCharCode","UNIT_SEP","BYTE_ORDER_MARK","BAD_DELIMITERS","WORKERS_SUPPORTED","NODE_STREAM_INPUT","LocalChunkSize","RemoteChunkSize","DefaultDelimiter","Parser","ParserHandle","ChunkStreamer","StringStreamer","_input","_config","UserDefinedStreamer","dynamicTyping","isFunction","dynamicTypingFunction","transform","worker","w","newWorker","userStep","step","userChunk","chunk","userComplete","complete","userError","error","postMessage","input","config","workerId","id","streamer","stream","_quotes","_writeHeader","_delimiter","_newline","_quoteChar","_escapedQuote","_skipEmptyLines","_columns","unpackConfig","quoteCharRegex","RegExp","escapeRegExp","JSON","Array","isArray","length","serialize","objectKeys","data","fields","meta","Error","delimiter","filter","value","indexOf","quotes","skipEmptyLines","newline","quoteChar","header","columns","escapeChar","undefined","obj","keys","key","push","csv","hasHeader","dataKeyedByField","i","safe","row","maxCol","emptyLine","nullLine","Object","join","trim","line","c","cx","col","colIdx","str","constructor","Date","stringify","slice","toString","replace","needsQuotes","hasAny","charAt","substrings","_handle","_finished","_completed","_baseIndex","_partialLine","_rowCount","_start","_nextChunk","isFirstChunk","_completeResults","errors","replaceConfig","call","parseChunk","isFakeChunk","beforeFirstChunk","modifiedChunk","aggregate","results","paused","aborted","lastIndex","cursor","substring","finishedIncludingPreview","preview","WORKER_ID","finished","concat","_sendError","configCopy","copy","chunkSize","parseInt","remaining","s","size","substr","prototype","create","FLOAT","ISO_DATE","_stepCounter","_rowCounter","_parser","_paused","_aborted","_delimiterError","_fields","_results","needsHeaderRow","processResults","abort","baseIndex","ignoreLastRow","guessLineEndings","delimGuess","guessDelimiter","comments","delimitersToGuess","successful","bestDelimiter","parserConfig","pause","getCharIndex","resume","testEmptyLine","addError","splice","fillHeaderFields","applyHeaderAndDynamicTypingAndTransformation","addHeder","transformHeader","forEach","shouldApplyDynamicTyping","field","parseDynamic","test","parseFloat","processRow","rowSource","j","incrementBy","map","bestDelim","bestDelta","fieldCountPrevRow","delim","delta","avgFieldCount","emptyLinesCount","fieldCount","Math","abs","re","r","split","n","nAppearsFirst","numWithN","type","code","msg","message","string","fastMode","inputLen","delimLen","newlineLen","commentsLen","stepIsFunction","lastCursor","returnable","rows","pushRow","doStep","nextDelim","nextNewline","quoteSearch","index","finish","checkUpTo","min","spacesBetweenQuoteAndDelimiter","extraSpaces","spacesBetweenQuoteAndNewLine","saveRow","spaceLength","textBetweenClosingQuoteAndIndex","newCursor","stopped","isStep","linebreak","truncated","notImplemented","cpy","bindFunction","f","apply","arguments","func"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/csv/dist/esm/libs/papaparse.js"],"sourcesContent":["// This is a fork of papaparse\n// https://github.com/mholt/PapaParse\n/* @license\nPapa Parse\nv5.0.0-beta.0\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/\n// FORK SUMMARY:\n// - Adopt ES6 exports\n// - Implement new AsyncIteratorStreamer\n// - Remove non Async Iterator streamers (can all be handled by new streamer)\n// - Remove unused Worker support (loaders.gl worker system used instead)\n// - Remove unused jQuery plugin support\n\n/* eslint-disable */\n// @ts-nocheck\nvar global = (function() {\n  // alternative method, similar to `Function('return this')()`\n  // but without using `eval` (which is disabled when\n  // using Content Security Policy).\n\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  // When running tests none of the above have been defined\n  return {};\n})();\n\nvar IS_PAPA_WORKER = false;\n\nvar Papa = {};\nmodule.exports = Papa;\nPapa.parse = CsvToJson;\nPapa.unparse = JsonToCsv;\n\nPapa.RECORD_SEP = String.fromCharCode(30);\nPapa.UNIT_SEP = String.fromCharCode(31);\nPapa.BYTE_ORDER_MARK = '\\ufeff';\nPapa.BAD_DELIMITERS = ['\\r', '\\n', '\"', Papa.BYTE_ORDER_MARK];\nPapa.WORKERS_SUPPORTED = false; // !IS_WORKER && !!global.Worker;\nPapa.NODE_STREAM_INPUT = 1;\n\n// Configurable chunk sizes for local and remote files, respectively\nPapa.LocalChunkSize = 1024 * 1024 * 10; // 10 MB\nPapa.RemoteChunkSize = 1024 * 1024 * 5; // 5 MB\nPapa.DefaultDelimiter = ','; // Used if not specified and detection fails\n\n// Exposed for testing and development only\nPapa.Parser = Parser;\nPapa.ParserHandle = ParserHandle;\n\n// BEGIN FORK\nPapa.ChunkStreamer = ChunkStreamer;\nPapa.StringStreamer = StringStreamer;\n/*\nPapa.NetworkStreamer = NetworkStreamer;\nPapa.FileStreamer = FileStreamer;\nPapa.ReadableStreamStreamer = ReadableStreamStreamer;\nif (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n  Papa.DuplexStreamStreamer = DuplexStreamStreamer;\n}\n*/\n// END FORK\n\n// BEGIN FORK\n// Adds an argument to papa.parse\n// function CsvToJson(_input, _config)\nfunction CsvToJson(\n  _input,\n  _config,\n  UserDefinedStreamer // BEGIN FORK\n) {\n  _config = _config || {};\n  var dynamicTyping = _config.dynamicTyping || false;\n  if (isFunction(dynamicTyping)) {\n    _config.dynamicTypingFunction = dynamicTyping;\n    // Will be filled on first row call\n    dynamicTyping = {};\n  }\n  _config.dynamicTyping = dynamicTyping;\n\n  _config.transform = isFunction(_config.transform) ? _config.transform : false;\n\n  if (_config.worker && Papa.WORKERS_SUPPORTED) {\n    var w = newWorker();\n\n    w.userStep = _config.step;\n    w.userChunk = _config.chunk;\n    w.userComplete = _config.complete;\n    w.userError = _config.error;\n\n    _config.step = isFunction(_config.step);\n    _config.chunk = isFunction(_config.chunk);\n    _config.complete = isFunction(_config.complete);\n    _config.error = isFunction(_config.error);\n    delete _config.worker; // prevent infinite loop\n\n    w.postMessage({\n      input: _input,\n      config: _config,\n      workerId: w.id\n    });\n\n    return;\n  }\n\n  var streamer = null;\n  /*\n  if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n    // create a node Duplex stream for use\n    // with .pipe\n    streamer = new DuplexStreamStreamer(_config);\n    return streamer.getStream();\n  } else\n  */\n  if (typeof _input === 'string') {\n    // if (_config.download) streamer = new NetworkStreamer(_config);\n    // else\n    streamer = new StringStreamer(_config);\n  }\n  /*\n  else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on)) {\n    streamer = new ReadableStreamStreamer(_config);\n  } else if ((global.File && _input instanceof File) || _input instanceof Object)\n    // ...Safari. (see issue #106)\n    streamer = new FileStreamer(_config);\n  */\n\n  // BEGIN FORK\n  if (!streamer) {\n    streamer = new UserDefinedStreamer(_config);\n  }\n  // END FORK\n\n  return streamer.stream(_input);\n}\n\nfunction JsonToCsv(_input, _config) {\n  // Default configuration\n\n  /** whether to surround every datum with quotes */\n  var _quotes = false;\n\n  /** whether to write headers */\n  var _writeHeader = true;\n\n  /** delimiting character(s) */\n  var _delimiter = ',';\n\n  /** newline character(s) */\n  var _newline = '\\r\\n';\n\n  /** quote character */\n  var _quoteChar = '\"';\n\n  /** escaped quote character, either \"\" or <config.escapeChar>\" */\n  var _escapedQuote = _quoteChar + _quoteChar;\n\n  /** whether to skip empty lines */\n  var _skipEmptyLines = false;\n\n  /** the columns (keys) we expect when we unparse objects */\n  var _columns = null;\n\n  unpackConfig();\n\n  var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');\n\n  if (typeof _input === 'string') _input = JSON.parse(_input);\n\n  if (Array.isArray(_input)) {\n    if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);\n    else if (typeof _input[0] === 'object')\n      return serialize(_columns || objectKeys(_input[0]), _input, _skipEmptyLines);\n  } else if (typeof _input === 'object') {\n    if (typeof _input.data === 'string') _input.data = JSON.parse(_input.data);\n\n    if (Array.isArray(_input.data)) {\n      if (!_input.fields) _input.fields = _input.meta && _input.meta.fields;\n\n      if (!_input.fields)\n        _input.fields = Array.isArray(_input.data[0]) ? _input.fields : objectKeys(_input.data[0]);\n\n      if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== 'object')\n        _input.data = [_input.data]; // handles input like [1,2,3] or ['asdf']\n    }\n\n    return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);\n  }\n\n  // Default (any valid paths should return before this)\n  throw new Error('Unable to serialize unrecognized input');\n\n  function unpackConfig() {\n    if (typeof _config !== 'object') return;\n\n    if (\n      typeof _config.delimiter === 'string' &&\n      !Papa.BAD_DELIMITERS.filter(function(value) {\n        return _config.delimiter.indexOf(value) !== -1;\n      }).length\n    ) {\n      _delimiter = _config.delimiter;\n    }\n\n    if (typeof _config.quotes === 'boolean' || Array.isArray(_config.quotes))\n      _quotes = _config.quotes;\n\n    if (typeof _config.skipEmptyLines === 'boolean' || typeof _config.skipEmptyLines === 'string')\n      _skipEmptyLines = _config.skipEmptyLines;\n\n    if (typeof _config.newline === 'string') _newline = _config.newline;\n\n    if (typeof _config.quoteChar === 'string') _quoteChar = _config.quoteChar;\n\n    if (typeof _config.header === 'boolean') _writeHeader = _config.header;\n\n    if (Array.isArray(_config.columns)) {\n      if (_config.columns.length === 0) throw new Error('Option columns is empty');\n\n      _columns = _config.columns;\n    }\n\n    if (_config.escapeChar !== undefined) {\n      _escapedQuote = _config.escapeChar + _quoteChar;\n    }\n  }\n\n  /** Turns an object's keys into an array */\n  function objectKeys(obj) {\n    if (typeof obj !== 'object') return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    return keys;\n  }\n\n  /** The double for loop that iterates the data and writes out a CSV string including header row */\n  function serialize(fields, data, skipEmptyLines) {\n    var csv = '';\n\n    if (typeof fields === 'string') fields = JSON.parse(fields);\n    if (typeof data === 'string') data = JSON.parse(data);\n\n    var hasHeader = Array.isArray(fields) && fields.length > 0;\n    var dataKeyedByField = !Array.isArray(data[0]);\n\n    // If there a header row, write it first\n    if (hasHeader && _writeHeader) {\n      for (var i = 0; i < fields.length; i++) {\n        if (i > 0) csv += _delimiter;\n        csv += safe(fields[i], i);\n      }\n      if (data.length > 0) csv += _newline;\n    }\n\n    // Then write out the data\n    for (var row = 0; row < data.length; row++) {\n      var maxCol = hasHeader ? fields.length : data[row].length;\n\n      var emptyLine = false;\n      var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;\n      if (skipEmptyLines && !hasHeader) {\n        emptyLine =\n          skipEmptyLines === 'greedy'\n            ? data[row].join('').trim() === ''\n            : data[row].length === 1 && data[row][0].length === 0;\n      }\n      if (skipEmptyLines === 'greedy' && hasHeader) {\n        var line = [];\n        for (var c = 0; c < maxCol; c++) {\n          var cx = dataKeyedByField ? fields[c] : c;\n          line.push(data[row][cx]);\n        }\n        emptyLine = line.join('').trim() === '';\n      }\n      if (!emptyLine) {\n        for (var col = 0; col < maxCol; col++) {\n          if (col > 0 && !nullLine) csv += _delimiter;\n          var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n          csv += safe(data[row][colIdx], col);\n        }\n        if (row < data.length - 1 && (!skipEmptyLines || (maxCol > 0 && !nullLine))) {\n          csv += _newline;\n        }\n      }\n    }\n    return csv;\n  }\n\n  /** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n  function safe(str, col) {\n    if (typeof str === 'undefined' || str === null) return '';\n\n    if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);\n\n    str = str.toString().replace(quoteCharRegex, _escapedQuote);\n\n    var needsQuotes =\n      (typeof _quotes === 'boolean' && _quotes) ||\n      (Array.isArray(_quotes) && _quotes[col]) ||\n      hasAny(str, Papa.BAD_DELIMITERS) ||\n      str.indexOf(_delimiter) > -1 ||\n      str.charAt(0) === ' ' ||\n      str.charAt(str.length - 1) === ' ';\n\n    return needsQuotes ? _quoteChar + str + _quoteChar : str;\n  }\n\n  function hasAny(str, substrings) {\n    for (var i = 0; i < substrings.length; i++) if (str.indexOf(substrings[i]) > -1) return true;\n    return false;\n  }\n}\n\n/** ChunkStreamer is the base prototype for various streamer implementations. */\nfunction ChunkStreamer(config) {\n  this._handle = null;\n  this._finished = false;\n  this._completed = false;\n  this._input = null;\n  this._baseIndex = 0;\n  this._partialLine = '';\n  this._rowCount = 0;\n  this._start = 0;\n  this._nextChunk = null;\n  this.isFirstChunk = true;\n  this._completeResults = {\n    data: [],\n    errors: [],\n    meta: {}\n  };\n  replaceConfig.call(this, config);\n\n  this.parseChunk = function(chunk, isFakeChunk) {\n    // First chunk pre-processing\n    if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {\n      var modifiedChunk = this._config.beforeFirstChunk(chunk);\n      if (modifiedChunk !== undefined) chunk = modifiedChunk;\n    }\n    this.isFirstChunk = false;\n\n    // Rejoin the line we likely just split in two by chunking the file\n    var aggregate = this._partialLine + chunk;\n    this._partialLine = '';\n\n    var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\n    if (this._handle.paused() || this._handle.aborted()) return;\n\n    var lastIndex = results.meta.cursor;\n\n    if (!this._finished) {\n      this._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n      this._baseIndex = lastIndex;\n    }\n\n    if (results && results.data) this._rowCount += results.data.length;\n\n    var finishedIncludingPreview =\n      this._finished || (this._config.preview && this._rowCount >= this._config.preview);\n\n    if (IS_PAPA_WORKER) {\n      global.postMessage({\n        results: results,\n        workerId: Papa.WORKER_ID,\n        finished: finishedIncludingPreview\n      });\n    } else if (isFunction(this._config.chunk) && !isFakeChunk) {\n      this._config.chunk(results, this._handle);\n      if (this._handle.paused() || this._handle.aborted()) return;\n      results = undefined;\n      this._completeResults = undefined;\n    }\n\n    if (!this._config.step && !this._config.chunk) {\n      this._completeResults.data = this._completeResults.data.concat(results.data);\n      this._completeResults.errors = this._completeResults.errors.concat(results.errors);\n      this._completeResults.meta = results.meta;\n    }\n\n    if (\n      !this._completed &&\n      finishedIncludingPreview &&\n      isFunction(this._config.complete) &&\n      (!results || !results.meta.aborted)\n    ) {\n      this._config.complete(this._completeResults, this._input);\n      this._completed = true;\n    }\n\n    if (!finishedIncludingPreview && (!results || !results.meta.paused)) this._nextChunk();\n\n    return results;\n  };\n\n  this._sendError = function(error) {\n    if (isFunction(this._config.error)) this._config.error(error);\n    else if (IS_PAPA_WORKER && this._config.error) {\n      global.postMessage({\n        workerId: Papa.WORKER_ID,\n        error: error,\n        finished: false\n      });\n    }\n  };\n\n  function replaceConfig(config) {\n    // Deep-copy the config so we can edit it\n    var configCopy = copy(config);\n    configCopy.chunkSize = parseInt(configCopy.chunkSize); // parseInt VERY important so we don't concatenate strings!\n    if (!config.step && !config.chunk) configCopy.chunkSize = null; // disable Range header if not streaming; bad values break IIS - see issue #196\n    this._handle = new ParserHandle(configCopy);\n    this._handle.streamer = this;\n    this._config = configCopy; // persist the copy to the caller\n  }\n}\n\n/*\nfunction NetworkStreamer(config) {\n  config = config || {};\n  if (!config.chunkSize) config.chunkSize = Papa.RemoteChunkSize;\n  ChunkStreamer.call(this, config);\n\n  var xhr;\n\n  if (IS_WORKER) {\n    this._nextChunk = function() {\n      this._readChunk();\n      this._chunkLoaded();\n    };\n  } else {\n    this._nextChunk = function() {\n      this._readChunk();\n    };\n  }\n\n  this.stream = function(url) {\n    this._input = url;\n    this._nextChunk(); // Starts streaming\n  };\n\n  this._readChunk = function() {\n    if (this._finished) {\n      this._chunkLoaded();\n      return;\n    }\n\n    xhr = new XMLHttpRequest();\n\n    if (this._config.withCredentials) {\n      xhr.withCredentials = this._config.withCredentials;\n    }\n\n    if (!IS_WORKER) {\n      xhr.onload = bindFunction(this._chunkLoaded, this);\n      xhr.onerror = bindFunction(this._chunkError, this);\n    }\n\n    xhr.open('GET', this._input, !IS_WORKER);\n    // Headers can only be set when once the request state is OPENED\n    if (this._config.downloadRequestHeaders) {\n      var headers = this._config.downloadRequestHeaders;\n\n      for (var headerName in headers) {\n        xhr.setRequestHeader(headerName, headers[headerName]);\n      }\n    }\n\n    if (this._config.chunkSize) {\n      var end = this._start + this._config.chunkSize - 1; // minus one because byte range is inclusive\n      xhr.setRequestHeader('Range', 'bytes=' + this._start + '-' + end);\n    }\n\n    try {\n      xhr.send();\n    } catch (err) {\n      this._chunkError(err.message);\n    }\n\n    if (IS_WORKER && xhr.status === 0) this._chunkError();\n    else this._start += this._config.chunkSize;\n  };\n\n  this._chunkLoaded = function() {\n    if (xhr.readyState !== 4) return;\n\n    if (xhr.status < 200 || xhr.status >= 400) {\n      this._chunkError();\n      return;\n    }\n\n    this._finished = !this._config.chunkSize || this._start > getFileSize(xhr);\n    this.parseChunk(xhr.responseText);\n  };\n\n  this._chunkError = function(errorMessage) {\n    var errorText = xhr.statusText || errorMessage;\n    this._sendError(new Error(errorText));\n  };\n\n  function getFileSize(xhr) {\n    var contentRange = xhr.getResponseHeader('Content-Range');\n    if (contentRange === null) {\n      // no content range, then finish!\n      return -1;\n    }\n    return parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));\n  }\n}\nNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\nNetworkStreamer.prototype.constructor = NetworkStreamer;\n\nfunction FileStreamer(config) {\n  config = config || {};\n  if (!config.chunkSize) config.chunkSize = Papa.LocalChunkSize;\n  ChunkStreamer.call(this, config);\n\n  var reader, slice;\n\n  // FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n  // But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n  var usingAsyncReader = typeof FileReader !== 'undefined'; // Safari doesn't consider it a function - see issue #105\n\n  this.stream = function(file) {\n    this._input = file;\n    slice = file.slice || file.webkitSlice || file.mozSlice;\n\n    if (usingAsyncReader) {\n      reader = new FileReader(); // Preferred method of reading files, even in workers\n      reader.onload = bindFunction(this._chunkLoaded, this);\n      reader.onerror = bindFunction(this._chunkError, this);\n    } else reader = new FileReaderSync(); // Hack for running in a web worker in Firefox\n\n    this._nextChunk(); // Starts streaming\n  };\n\n  this._nextChunk = function() {\n    if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n      this._readChunk();\n  };\n\n  this._readChunk = function() {\n    var input = this._input;\n    if (this._config.chunkSize) {\n      var end = Math.min(this._start + this._config.chunkSize, this._input.size);\n      input = slice.call(input, this._start, end);\n    }\n    var txt = reader.readAsText(input, this._config.encoding);\n    if (!usingAsyncReader) this._chunkLoaded({target: {result: txt}}); // mimic the async signature\n  };\n\n  this._chunkLoaded = function(event) {\n    // Very important to increment start each time before handling results\n    this._start += this._config.chunkSize;\n    this._finished = !this._config.chunkSize || this._start >= this._input.size;\n    this.parseChunk(event.target.result);\n  };\n\n  this._chunkError = function() {\n    this._sendError(reader.error);\n  };\n}\nFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\nFileStreamer.prototype.constructor = FileStreamer;\n*/\n\nfunction StringStreamer(config) {\n  config = config || {};\n  ChunkStreamer.call(this, config);\n\n  var remaining;\n  this.stream = function(s) {\n    remaining = s;\n    return this._nextChunk();\n  };\n  this._nextChunk = function() {\n    if (this._finished) return;\n    var size = this._config.chunkSize;\n    var chunk = size ? remaining.substr(0, size) : remaining;\n    remaining = size ? remaining.substr(size) : '';\n    this._finished = !remaining;\n    return this.parseChunk(chunk);\n  };\n}\nStringStreamer.prototype = Object.create(StringStreamer.prototype);\nStringStreamer.prototype.constructor = StringStreamer;\n\n/*\nfunction ReadableStreamStreamer(config) {\n  config = config || {};\n\n  ChunkStreamer.call(this, config);\n\n  var queue = [];\n  var parseOnData = true;\n  var streamHasEnded = false;\n\n  this.pause = function() {\n    ChunkStreamer.prototype.pause.apply(this, arguments);\n    this._input.pause();\n  };\n\n  this.resume = function() {\n    ChunkStreamer.prototype.resume.apply(this, arguments);\n    this._input.resume();\n  };\n\n  this.stream = function(stream) {\n    this._input = stream;\n\n    this._input.on('data', this._streamData);\n    this._input.on('end', this._streamEnd);\n    this._input.on('error', this._streamError);\n  };\n\n  this._checkIsFinished = function() {\n    if (streamHasEnded && queue.length === 1) {\n      this._finished = true;\n    }\n  };\n\n  this._nextChunk = function() {\n    this._checkIsFinished();\n    if (queue.length) {\n      this.parseChunk(queue.shift());\n    } else {\n      parseOnData = true;\n    }\n  };\n\n  this._streamData = bindFunction(function(chunk) {\n    try {\n      queue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));\n\n      if (parseOnData) {\n        parseOnData = false;\n        this._checkIsFinished();\n        this.parseChunk(queue.shift());\n      }\n    } catch (error) {\n      this._streamError(error);\n    }\n  }, this);\n\n  this._streamError = bindFunction(function(error) {\n    this._streamCleanUp();\n    this._sendError(error);\n  }, this);\n\n  this._streamEnd = bindFunction(function() {\n    this._streamCleanUp();\n    streamHasEnded = true;\n    this._streamData('');\n  }, this);\n\n  this._streamCleanUp = bindFunction(function() {\n    this._input.removeListener('data', this._streamData);\n    this._input.removeListener('end', this._streamEnd);\n    this._input.removeListener('error', this._streamError);\n  }, this);\n}\nReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\nReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n\nfunction DuplexStreamStreamer(_config) {\n  var Duplex = require('stream').Duplex;\n  var config = copy(_config);\n  var parseOnWrite = true;\n  var writeStreamHasFinished = false;\n  var parseCallbackQueue = [];\n  var stream = null;\n\n  this._onCsvData = function(results) {\n    var data = results.data;\n    if (!stream.push(data) && !this._handle.paused()) {\n      // the writeable consumer buffer has filled up\n      // so we need to pause until more items\n      // can be processed\n      this._handle.pause();\n    }\n  };\n\n  this._onCsvComplete = function() {\n    // node will finish the read stream when\n    // null is pushed\n    stream.push(null);\n  };\n\n  config.step = bindFunction(this._onCsvData, this);\n  config.complete = bindFunction(this._onCsvComplete, this);\n  ChunkStreamer.call(this, config);\n\n  this._nextChunk = function() {\n    if (writeStreamHasFinished && parseCallbackQueue.length === 1) {\n      this._finished = true;\n    }\n    if (parseCallbackQueue.length) {\n      parseCallbackQueue.shift()();\n    } else {\n      parseOnWrite = true;\n    }\n  };\n\n  this._addToParseQueue = function(chunk, callback) {\n    // add to queue so that we can indicate\n    // completion via callback\n    // node will automatically pause the incoming stream\n    // when too many items have been added without their\n    // callback being invoked\n    parseCallbackQueue.push(\n      bindFunction(function() {\n        this.parseChunk(typeof chunk === 'string' ? chunk : chunk.toString(config.encoding));\n        if (isFunction(callback)) {\n          return callback();\n        }\n      }, this)\n    );\n    if (parseOnWrite) {\n      parseOnWrite = false;\n      this._nextChunk();\n    }\n  };\n\n  this._onRead = function() {\n    if (this._handle.paused()) {\n      // the writeable consumer can handle more data\n      // so resume the chunk parsing\n      this._handle.resume();\n    }\n  };\n\n  this._onWrite = function(chunk, encoding, callback) {\n    this._addToParseQueue(chunk, callback);\n  };\n\n  this._onWriteComplete = function() {\n    writeStreamHasFinished = true;\n    // have to write empty string\n    // so parser knows its done\n    this._addToParseQueue('');\n  };\n\n  this.getStream = function() {\n    return stream;\n  };\n  stream = new Duplex({\n    readableObjectMode: true,\n    decodeStrings: false,\n    read: bindFunction(this._onRead, this),\n    write: bindFunction(this._onWrite, this)\n  });\n  stream.once('finish', bindFunction(this._onWriteComplete, this));\n}\nif (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n  DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n  DuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;\n}\n*/\n\n// Use one ParserHandle per entire CSV file or string\nfunction ParserHandle(_config) {\n  // One goal is to minimize the use of regular expressions...\n  var FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n  var ISO_DATE = /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/;\n\n  var self = this;\n  var _stepCounter = 0; // Number of times step was called (number of rows parsed)\n  var _rowCounter = 0; // Number of rows that have been parsed so far\n  var _input; // The input being parsed\n  var _parser; // The core parser being used\n  var _paused = false; // Whether we are paused or not\n  var _aborted = false; // Whether the parser has aborted or not\n  var _delimiterError; // Temporary state between delimiter detection and processing results\n  var _fields = []; // Fields are from the header row of the input, if there is one\n  var _results = {\n    // The last results returned from the parser\n    data: [],\n    errors: [],\n    meta: {}\n  };\n\n  if (isFunction(_config.step)) {\n    var userStep = _config.step;\n    _config.step = function(results) {\n      _results = results;\n\n      if (needsHeaderRow()) processResults();\n      // only call user's step function after header row\n      else {\n        processResults();\n\n        // It's possbile that this line was empty and there's no row here after all\n        if (_results.data.length === 0) return;\n\n        _stepCounter += results.data.length;\n        if (_config.preview && _stepCounter > _config.preview) _parser.abort();\n        else userStep(_results, self);\n      }\n    };\n  }\n\n  /**\n   * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n   * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n   * when an input comes in multiple chunks, like from a file.\n   */\n  this.parse = function(input, baseIndex, ignoreLastRow) {\n    var quoteChar = _config.quoteChar || '\"';\n    if (!_config.newline) _config.newline = guessLineEndings(input, quoteChar);\n\n    _delimiterError = false;\n    if (!_config.delimiter) {\n      var delimGuess = guessDelimiter(\n        input,\n        _config.newline,\n        _config.skipEmptyLines,\n        _config.comments,\n        _config.delimitersToGuess\n      );\n      if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;\n      else {\n        _delimiterError = true; // add error after parsing (otherwise it would be overwritten)\n        _config.delimiter = Papa.DefaultDelimiter;\n      }\n      _results.meta.delimiter = _config.delimiter;\n    } else if (isFunction(_config.delimiter)) {\n      _config.delimiter = _config.delimiter(input);\n      _results.meta.delimiter = _config.delimiter;\n    }\n\n    var parserConfig = copy(_config);\n    if (_config.preview && _config.header) parserConfig.preview++; // to compensate for header row\n\n    _input = input;\n    _parser = new Parser(parserConfig);\n    _results = _parser.parse(_input, baseIndex, ignoreLastRow);\n    processResults();\n    return _paused ? {meta: {paused: true}} : _results || {meta: {paused: false}};\n  };\n\n  this.paused = function() {\n    return _paused;\n  };\n\n  this.pause = function() {\n    _paused = true;\n    _parser.abort();\n    _input = _input.substr(_parser.getCharIndex());\n  };\n\n  this.resume = function() {\n    _paused = false;\n    self.streamer.parseChunk(_input, true);\n  };\n\n  this.aborted = function() {\n    return _aborted;\n  };\n\n  this.abort = function() {\n    _aborted = true;\n    _parser.abort();\n    _results.meta.aborted = true;\n    if (isFunction(_config.complete)) _config.complete(_results);\n    _input = '';\n  };\n\n  function testEmptyLine(s) {\n    return _config.skipEmptyLines === 'greedy'\n      ? s.join('').trim() === ''\n      : s.length === 1 && s[0].length === 0;\n  }\n\n  function processResults() {\n    if (_results && _delimiterError) {\n      addError(\n        'Delimiter',\n        'UndetectableDelimiter',\n        \"Unable to auto-detect delimiting character; defaulted to '\" + Papa.DefaultDelimiter + \"'\"\n      );\n      _delimiterError = false;\n    }\n\n    if (_config.skipEmptyLines) {\n      for (var i = 0; i < _results.data.length; i++)\n        if (testEmptyLine(_results.data[i])) _results.data.splice(i--, 1);\n    }\n\n    if (needsHeaderRow()) fillHeaderFields();\n\n    return applyHeaderAndDynamicTypingAndTransformation();\n  }\n\n  function needsHeaderRow() {\n    return _config.header && _fields.length === 0;\n  }\n\n  function fillHeaderFields() {\n    if (!_results) return;\n\n    function addHeder(header) {\n      if (isFunction(_config.transformHeader)) header = _config.transformHeader(header);\n\n      _fields.push(header);\n    }\n\n    if (Array.isArray(_results.data[0])) {\n      for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)\n        _results.data[i].forEach(addHeder);\n\n      _results.data.splice(0, 1);\n    }\n    // if _results.data[0] is not an array, we are in a step where _results.data is the row.\n    else _results.data.forEach(addHeder);\n  }\n\n  function shouldApplyDynamicTyping(field) {\n    // Cache function values to avoid calling it for each row\n    if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n      _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n    }\n    return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;\n  }\n\n  function parseDynamic(field, value) {\n    if (shouldApplyDynamicTyping(field)) {\n      if (value === 'true' || value === 'TRUE') return true;\n      else if (value === 'false' || value === 'FALSE') return false;\n      else if (FLOAT.test(value)) return parseFloat(value);\n      else if (ISO_DATE.test(value)) return new Date(value);\n      else return value === '' ? null : value;\n    }\n    return value;\n  }\n\n  function applyHeaderAndDynamicTypingAndTransformation() {\n    if (!_results || (!_config.header && !_config.dynamicTyping && !_config.transform))\n      return _results;\n\n    function processRow(rowSource, i) {\n      var row = _config.header ? {} : [];\n\n      var j;\n      for (j = 0; j < rowSource.length; j++) {\n        var field = j;\n        var value = rowSource[j];\n\n        if (_config.header) field = j >= _fields.length ? '__parsed_extra' : _fields[j];\n\n        if (_config.transform) value = _config.transform(value, field);\n\n        value = parseDynamic(field, value);\n\n        if (field === '__parsed_extra') {\n          row[field] = row[field] || [];\n          row[field].push(value);\n        } else row[field] = value;\n      }\n\n      if (_config.header) {\n        if (j > _fields.length)\n          addError(\n            'FieldMismatch',\n            'TooManyFields',\n            'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j,\n            _rowCounter + i\n          );\n        else if (j < _fields.length)\n          addError(\n            'FieldMismatch',\n            'TooFewFields',\n            'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j,\n            _rowCounter + i\n          );\n      }\n\n      return row;\n    }\n\n    var incrementBy = 1;\n    if (!_results.data[0] || Array.isArray(_results.data[0])) {\n      _results.data = _results.data.map(processRow);\n      incrementBy = _results.data.length;\n    } else _results.data = processRow(_results.data, 0);\n\n    if (_config.header && _results.meta) _results.meta.fields = _fields;\n\n    _rowCounter += incrementBy;\n    return _results;\n  }\n\n  function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {\n    var bestDelim, bestDelta, fieldCountPrevRow;\n\n    delimitersToGuess = delimitersToGuess || [',', '\\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];\n\n    for (var i = 0; i < delimitersToGuess.length; i++) {\n      var delim = delimitersToGuess[i];\n      var delta = 0,\n        avgFieldCount = 0,\n        emptyLinesCount = 0;\n      fieldCountPrevRow = undefined;\n\n      var preview = new Parser({\n        comments: comments,\n        delimiter: delim,\n        newline: newline,\n        preview: 10\n      }).parse(input);\n\n      for (var j = 0; j < preview.data.length; j++) {\n        if (skipEmptyLines && testEmptyLine(preview.data[j])) {\n          emptyLinesCount++;\n          continue;\n        }\n        var fieldCount = preview.data[j].length;\n        avgFieldCount += fieldCount;\n\n        if (typeof fieldCountPrevRow === 'undefined') {\n          fieldCountPrevRow = 0;\n          continue;\n        } else if (fieldCount > 1) {\n          delta += Math.abs(fieldCount - fieldCountPrevRow);\n          fieldCountPrevRow = fieldCount;\n        }\n      }\n\n      if (preview.data.length > 0) avgFieldCount /= preview.data.length - emptyLinesCount;\n\n      if ((typeof bestDelta === 'undefined' || delta > bestDelta) && avgFieldCount > 1.99) {\n        bestDelta = delta;\n        bestDelim = delim;\n      }\n    }\n\n    _config.delimiter = bestDelim;\n\n    return {\n      successful: !!bestDelim,\n      bestDelimiter: bestDelim\n    };\n  }\n\n  function guessLineEndings(input, quoteChar) {\n    input = input.substr(0, 1024 * 1024); // max length 1 MB\n    // Replace all the text inside quotes\n    var re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');\n    input = input.replace(re, '');\n\n    var r = input.split('\\r');\n\n    var n = input.split('\\n');\n\n    var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;\n\n    if (r.length === 1 || nAppearsFirst) return '\\n';\n\n    var numWithN = 0;\n    for (var i = 0; i < r.length; i++) {\n      if (r[i][0] === '\\n') numWithN++;\n    }\n\n    return numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n  }\n\n  function addError(type, code, msg, row) {\n    _results.errors.push({\n      type: type,\n      code: code,\n      message: msg,\n      row: row\n    });\n  }\n}\n\n/** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\n/** The core parser implements speedy and correct CSV parsing */\nfunction Parser(config) {\n  // Unpack the config object\n  config = config || {};\n  var delim = config.delimiter;\n  var newline = config.newline;\n  var comments = config.comments;\n  var step = config.step;\n  var preview = config.preview;\n  var fastMode = config.fastMode;\n  var quoteChar;\n  /** Allows for no quoteChar by setting quoteChar to undefined in config */\n  if (config.quoteChar === undefined) {\n    quoteChar = '\"';\n  } else {\n    quoteChar = config.quoteChar;\n  }\n  var escapeChar = quoteChar;\n  if (config.escapeChar !== undefined) {\n    escapeChar = config.escapeChar;\n  }\n\n  // Delimiter must be valid\n  if (typeof delim !== 'string' || Papa.BAD_DELIMITERS.indexOf(delim) > -1) delim = ',';\n\n  // Comment character must be valid\n  if (comments === delim) throw new Error('Comment character same as delimiter');\n  else if (comments === true) comments = '#';\n  else if (typeof comments !== 'string' || Papa.BAD_DELIMITERS.indexOf(comments) > -1)\n    comments = false;\n\n  // Newline must be valid: \\r, \\n, or \\r\\n\n  if (newline !== '\\n' && newline !== '\\r' && newline !== '\\r\\n') newline = '\\n';\n\n  // We're gonna need these at the Parser scope\n  var cursor = 0;\n  var aborted = false;\n\n  this.parse = function(input, baseIndex, ignoreLastRow) {\n    // For some reason, in Chrome, this speeds things up (!?)\n    if (typeof input !== 'string') throw new Error('Input must be a string');\n\n    // We don't need to compute some of these every time parse() is called,\n    // but having them in a more local scope seems to perform better\n    var inputLen = input.length,\n      delimLen = delim.length,\n      newlineLen = newline.length,\n      commentsLen = comments.length;\n    var stepIsFunction = isFunction(step);\n\n    // Establish starting state\n    cursor = 0;\n    var data = [],\n      errors = [],\n      row = [],\n      lastCursor = 0;\n\n    if (!input) return returnable();\n\n    if (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1)) {\n      var rows = input.split(newline);\n      for (var i = 0; i < rows.length; i++) {\n        row = rows[i];\n        cursor += row.length;\n        if (i !== rows.length - 1) cursor += newline.length;\n        else if (ignoreLastRow) return returnable();\n        if (comments && row.substr(0, commentsLen) === comments) continue;\n        if (stepIsFunction) {\n          data = [];\n          pushRow(row.split(delim));\n          doStep();\n          if (aborted) return returnable();\n        } else pushRow(row.split(delim));\n        if (preview && i >= preview) {\n          data = data.slice(0, preview);\n          return returnable(true);\n        }\n      }\n      return returnable();\n    }\n\n    var nextDelim = input.indexOf(delim, cursor);\n    var nextNewline = input.indexOf(newline, cursor);\n    var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');\n    var quoteSearch;\n\n    // Parser loop\n    for (;;) {\n      // Field has opening quote\n      if (input[cursor] === quoteChar) {\n        // Start our search for the closing quote where the cursor is\n        quoteSearch = cursor;\n\n        // Skip the opening quote\n        cursor++;\n\n        for (;;) {\n          // Find closing quote\n          quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);\n\n          //No other quotes are found - no other delimiters\n          if (quoteSearch === -1) {\n            if (!ignoreLastRow) {\n              // No closing quote... what a pity\n              errors.push({\n                type: 'Quotes',\n                code: 'MissingQuotes',\n                message: 'Quoted field unterminated',\n                row: data.length, // row has yet to be inserted\n                index: cursor\n              });\n            }\n            return finish();\n          }\n\n          // Closing quote at EOF\n          if (quoteSearch === inputLen - 1) {\n            var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n            return finish(value);\n          }\n\n          // If this quote is escaped, it's part of the data; skip it\n          // If the quote character is the escape character, then check if the next character is the escape character\n          if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {\n            quoteSearch++;\n            continue;\n          }\n\n          // If the quote character is not the escape character, then check if the previous character was the escape character\n          if (\n            quoteChar !== escapeChar &&\n            quoteSearch !== 0 &&\n            input[quoteSearch - 1] === escapeChar\n          ) {\n            continue;\n          }\n\n          // Check up to nextDelim or nextNewline, whichever is closest\n          var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);\n          var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);\n\n          // Closing quote followed by delimiter or 'unnecessary spaces + delimiter'\n          if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim) {\n            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n            cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;\n            nextDelim = input.indexOf(delim, cursor);\n            nextNewline = input.indexOf(newline, cursor);\n            break;\n          }\n\n          var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);\n\n          // Closing quote followed by newline or 'unnecessary spaces + newLine'\n          if (\n            input.substr(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, newlineLen) === newline\n          ) {\n            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n            saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);\n            nextDelim = input.indexOf(delim, cursor); // because we may have skipped the nextDelim in the quoted field\n\n            if (stepIsFunction) {\n              doStep();\n              if (aborted) return returnable();\n            }\n\n            if (preview && data.length >= preview) return returnable(true);\n\n            break;\n          }\n\n          // Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string\n          errors.push({\n            type: 'Quotes',\n            code: 'InvalidQuotes',\n            message: 'Trailing quote on quoted field is malformed',\n            row: data.length, // row has yet to be inserted\n            index: cursor\n          });\n\n          quoteSearch++;\n          continue;\n        }\n\n        continue;\n      }\n\n      // Comment found at start of new line\n      if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments) {\n        if (nextNewline === -1)\n          // Comment ends at EOF\n          return returnable();\n        cursor = nextNewline + newlineLen;\n        nextNewline = input.indexOf(newline, cursor);\n        nextDelim = input.indexOf(delim, cursor);\n        continue;\n      }\n\n      // Next delimiter comes before next newline, so we've reached end of field\n      if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {\n        row.push(input.substring(cursor, nextDelim));\n        cursor = nextDelim + delimLen;\n        nextDelim = input.indexOf(delim, cursor);\n        continue;\n      }\n\n      // End of row\n      if (nextNewline !== -1) {\n        row.push(input.substring(cursor, nextNewline));\n        saveRow(nextNewline + newlineLen);\n\n        if (stepIsFunction) {\n          doStep();\n          if (aborted) return returnable();\n        }\n\n        if (preview && data.length >= preview) return returnable(true);\n\n        continue;\n      }\n\n      break;\n    }\n\n    return finish();\n\n    function pushRow(row) {\n      data.push(row);\n      lastCursor = cursor;\n    }\n\n    /**\n     * checks if there are extra spaces after closing quote and given index without any text\n     * if Yes, returns the number of spaces\n     */\n    function extraSpaces(index) {\n      var spaceLength = 0;\n      if (index !== -1) {\n        var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);\n        if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {\n          spaceLength = textBetweenClosingQuoteAndIndex.length;\n        }\n      }\n      return spaceLength;\n    }\n\n    /**\n     * Appends the remaining input from cursor to the end into\n     * row, saves the row, calls step, and returns the results.\n     */\n    function finish(value) {\n      if (ignoreLastRow) return returnable();\n      if (typeof value === 'undefined') value = input.substr(cursor);\n      row.push(value);\n      cursor = inputLen; // important in case parsing is paused\n      pushRow(row);\n      if (stepIsFunction) doStep();\n      return returnable();\n    }\n\n    /**\n     * Appends the current row to the results. It sets the cursor\n     * to newCursor and finds the nextNewline. The caller should\n     * take care to execute user's step function and check for\n     * preview and end parsing if necessary.\n     */\n    function saveRow(newCursor) {\n      cursor = newCursor;\n      pushRow(row);\n      row = [];\n      nextNewline = input.indexOf(newline, cursor);\n    }\n\n    /** Returns an object with the results, errors, and meta. */\n    function returnable(stopped, step) {\n      var isStep = step || false;\n      return {\n        data: isStep ? data[0] : data,\n        errors: errors,\n        meta: {\n          delimiter: delim,\n          linebreak: newline,\n          aborted: aborted,\n          truncated: !!stopped,\n          cursor: lastCursor + (baseIndex || 0)\n        }\n      };\n    }\n\n    /** Executes the user's step function and resets data & errors. */\n    function doStep() {\n      step(returnable(undefined, true));\n      data = [];\n      errors = [];\n    }\n  };\n\n  /** Sets the abort flag */\n  this.abort = function() {\n    aborted = true;\n  };\n\n  /** Gets the cursor position */\n  this.getCharIndex = function() {\n    return cursor;\n  };\n}\n\n/*\nfunction getWorkerBlob() {\n\tvar URL = global.URL || global.webkitURL || null;\n\tvar code = moduleFactory.toString();\n\treturn Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob(['(', code, ')();'], {type: 'text/javascript'})));\n}\n\nvar IS_WORKER = !global.document && !!global.postMessage,\n\tIS_PAPA_WORKER = IS_WORKER && /blob:/i.test((global.location || {}).protocol);\nvar workers = {}, workerIdCounter = 0;\n\nfunction newWorker()\n{\n\tif (!Papa.WORKERS_SUPPORTED)\n\t\treturn false;\n\n\tvar workerUrl = getWorkerBlob();\n\tvar w = new global.Worker(workerUrl);\n\tw.onmessage = mainThreadReceivedMessage;\n\tw.id = workerIdCounter++;\n\tworkers[w.id] = w;\n\treturn w;\n}\n\n// Callback when main thread receives a message\nfunction mainThreadReceivedMessage(e)\n{\n\tvar msg = e.data;\n\tvar worker = workers[msg.workerId];\n\tvar aborted = false;\n\n\tif (msg.error)\n\t\tworker.userError(msg.error, msg.file);\n\telse if (msg.results && msg.results.data)\n\t{\n\t\tvar abort = function() {\n\t\t\taborted = true;\n\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t};\n\n\t\tvar handle = {\n\t\t\tabort: abort,\n\t\t\tpause: notImplemented,\n\t\t\tresume: notImplemented\n\t\t};\n\n\t\tif (isFunction(worker.userStep))\n\t\t{\n\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t{\n\t\t\t\tworker.userStep({\n\t\t\t\t\tdata: msg.results.data[i],\n\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t}, handle);\n\t\t\t\tif (aborted)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t}\n\t\telse if (isFunction(worker.userChunk))\n\t\t{\n\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\tdelete msg.results;\n\t\t}\n\t}\n\n\tif (msg.finished && !aborted)\n\t\tcompleteWorker(msg.workerId, msg.results);\n}\n\nfunction completeWorker(workerId, results) {\n\tvar worker = workers[workerId];\n\tif (isFunction(worker.userComplete))\n\t\tworker.userComplete(results);\n\tworker.terminate();\n\tdelete workers[workerId];\n}\n\n// Callback when worker thread receives a message\nfunction workerThreadReceivedMessage(e)\n{\n\tvar msg = e.data;\n\n\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\tPapa.WORKER_ID = msg.workerId;\n\n\tif (typeof msg.input === 'string')\n\t{\n\t\tglobal.postMessage({\n\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\tfinished: true\n\t\t});\n\t}\n\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t{\n\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\tif (results)\n\t\t\tglobal.postMessage({\n\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\tresults: results,\n\t\t\t\tfinished: true\n\t\t\t});\n\t}\n}\n*/\n\nfunction notImplemented() {\n  throw new Error('Not implemented.');\n}\n\n/** Makes a deep copy of an array or object (mostly) */\nfunction copy(obj) {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  var cpy = Array.isArray(obj) ? [] : {};\n  for (var key in obj) cpy[key] = copy(obj[key]);\n  return cpy;\n}\n\nfunction bindFunction(f, self) {\n  return function() {\n    f.apply(self, arguments);\n  };\n}\n\nfunction isFunction(func) {\n  return typeof func === 'function';\n}\n"],"mappings":"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gB,KAAK,EAAE;MAC7C3C,MAAM,CAAC4C,WAAW,CAAC;QACjBG,QAAQ,EAAE3C,IAAI,CAAC2I,SAAS;QACxBpG,KAAK,EAAEA,KAAK;QACZqG,QAAQ,EAAE;MACZ,CAAC,CAAC;IACJ;EACF,CAAC;EAED,SAAShB,aAAaA,CAAClF,MAAM,EAAE;IAC7B;IACA,IAAIqG,UAAU,GAAGC,IAAI,CAACtG,MAAM,CAAC;IAC7BqG,UAAU,CAACE,SAAS,GAAGC,QAAQ,CAACH,UAAU,CAACE,SAAS,CAAC,CAAC,CAAC;IACvD,IAAI,CAACvG,MAAM,CAACT,IAAI,IAAI,CAACS,MAAM,CAACP,KAAK,EAAE4G,UAAU,CAACE,SAAS,GAAG,IAAI,CAAC,CAAC;IAChE,IAAI,CAAChC,OAAO,GAAG,IAAI9F,YAAY,CAAC4H,UAAU,CAAC;IAC3C,IAAI,CAAC9B,OAAO,CAACpE,QAAQ,GAAG,IAAI;IAC5B,IAAI,CAACtB,OAAO,GAAGwH,UAAU,CAAC,CAAC;EAC7B;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS1H,cAAcA,CAACqB,MAAM,EAAE;EAC9BA,MAAM,GAAGA,MAAM,IAAI,CAAC,CAAC;EACrBtB,aAAa,CAACyG,IAAI,CAAC,IAAI,EAAEnF,MAAM,CAAC;EAEhC,IAAIyG,SAAS;EACb,IAAI,CAACrG,MAAM,GAAG,UAASsG,CAAC,EAAE;IACxBD,SAAS,GAAGC,CAAC;IACb,OAAO,IAAI,CAAC5B,UAAU,EAAE;EAC1B,CAAC;EACD,IAAI,CAACA,UAAU,GAAG,YAAW;IAC3B,IAAI,IAAI,CAACN,SAAS,EAAE;IACpB,IAAImC,IAAI,GAAG,IAAI,CAAC9H,OAAO,CAAC0H,SAAS;IACjC,IAAI9G,KAAK,GAAGkH,IAAI,GAAGF,SAAS,CAACG,MAAM,CAAC,CAAC,EAAED,IAAI,CAAC,GAAGF,SAAS;IACxDA,SAAS,GAAGE,IAAI,GAAGF,SAAS,CAACG,MAAM,CAACD,IAAI,CAAC,GAAG,EAAE;IAC9C,IAAI,CAACnC,SAAS,GAAG,CAACiC,SAAS;IAC3B,OAAO,IAAI,CAACrB,UAAU,CAAC3F,KAAK,CAAC;EAC/B,CAAC;AACH;AACAd,cAAc,CAACkI,SAAS,GAAGzD,MAAM,CAAC0D,MAAM,CAACnI,cAAc,CAACkI,SAAS,CAAC;AAClElI,cAAc,CAACkI,SAAS,CAAChD,WAAW,GAAGlF,cAAc;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAASF,YAAYA,CAACI,OAAO,EAAE;EAC7B;EACA,IAAIkI,KAAK,GAAG,8CAA8C;EAC1D,IAAIC,QAAQ,GAAG,gNAAgN;EAE/N,IAAI7J,IAAI,GAAG,IAAI;EACf,IAAI8J,YAAY,GAAG,CAAC,CAAC,CAAC;EACtB,IAAIC,WAAW,GAAG,CAAC,CAAC,CAAC;EACrB,IAAItI,MAAM,CAAC,CAAC;EACZ,IAAIuI,OAAO,CAAC,CAAC;EACb,IAAIC,OAAO,GAAG,KAAK,CAAC,CAAC;EACrB,IAAIC,QAAQ,GAAG,KAAK,CAAC,CAAC;EACtB,IAAIC,eAAe,CAAC,CAAC;EACrB,IAAIC,OAAO,GAAG,EAAE,CAAC,CAAC;EAClB,IAAIC,QAAQ,GAAG;IACb;IACAjG,IAAI,EAAE,EAAE;IACR0D,MAAM,EAAE,EAAE;IACVxD,IAAI,EAAE,CAAC;EACT,CAAC;EAED,IAAIzC,UAAU,CAACH,OAAO,CAACU,IAAI,CAAC,EAAE;IAC5B,IAAID,QAAQ,GAAGT,OAAO,CAACU,IAAI;IAC3BV,OAAO,CAACU,IAAI,GAAG,UAASkG,OAAO,EAAE;MAC/B+B,QAAQ,GAAG/B,OAAO;MAElB,IAAIgC,cAAc,E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ACgM,UAAU,CAACjJ,SAAS,EAAE,IAAI,CAAC,CAAC;MACjCf,IAAI,GAAG,EAAE;MACT0D,MAAM,GAAG,EAAE;IACb;EACF,CAAC;;EAED;EACA,IAAI,CAAC0C,KAAK,GAAG,YAAW;IACtBhC,OAAO,GAAG,IAAI;EAChB,CAAC;;EAED;EACA,IAAI,CAAC4C,YAAY,GAAG,YAAW;IAC7B,OAAO1C,MAAM;EACf,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASgH,cAAcA,CAAA,EAAG;EACxB,MAAM,IAAInL,KAAK,CAAC,kBAAkB,CAAC;AACrC;;AAEA;AACA,SAAS4E,IAAIA,CAAC/D,GAAG,EAAE;EACjB,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,KAAK,IAAI,EAAE,OAAOA,GAAG;EACvD,IAAIuK,GAAG,GAAG5L,KAAK,CAACC,OAAO,CAACoB,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;EACtC,KAAK,IAAIE,GAAG,IAAIF,GAAG,EAAEuK,GAAG,CAACrK,GAAG,CAAC,GAAG6D,IAAI,CAAC/D,GAAG,CAACE,GAAG,CAAC,CAAC;EAC9C,OAAOqK,GAAG;AACZ;AAEA,SAASC,YAAYA,CAACC,CAAC,EAAE7P,IAAI,EAAE;EAC7B,OAAO,YAAW;IAChB6P,CAAC,CAACC,KAAK,CAAC9P,IAAI,EAAE+P,SAAS,CAAC;EAC1B,CAAC;AACH;AAEA,SAASlO,UAAUA,CAACmO,IAAI,EAAE;EACxB,OAAO,OAAOA,IAAI,KAAK,UAAU;AACnC"},"metadata":{},"sourceType":"script","externalDependencies":[]}