{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nexport function binaryToGeoJson(data, type, format) {\n  if (format === 'geometry') {\n    return parseGeometry(data);\n  }\n  var dataArray = normalizeInput(data, type);\n  switch (deduceReturnType(dataArray)) {\n    case 'Geometry':\n      return parseGeometry(dataArray[0]);\n    case 'FeatureCollection':\n      return parseFeatureCollection(dataArray);\n    default:\n      break;\n  }\n  return null;\n}\nfunction normalizeInput(data, type) {\n  var isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);\n  if (!isHeterogeneousType) {\n    data.type = type || parseType(data);\n    return [data];\n  }\n  var features = [];\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n  return features;\n}\nfunction deduceReturnType(dataArray) {\n  if (dataArray.length > 1) {\n    return 'FeatureCollection';\n  }\n  var data = dataArray[0];\n  if (!(data.featureIds || data.globalFeatureIds || data.numericProps || data.properties)) {\n    return 'Geometry';\n  }\n  return 'FeatureCollection';\n}\nfunction parseFeatureCollection(dataArray) {\n  var features = [];\n  var _iterator = _createForOfIteratorHelper(dataArray),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var data = _step.value;\n      if (data.featureIds.value.length === 0) {\n        continue;\n      }\n      var lastIndex = 0;\n      var lastValue = data.featureIds.value[0];\n      for (var i = 0; i < data.featureIds.value.length; i++) {\n        var currValue = data.featureIds.value[i];\n        if (currValue === lastValue) {\n          continue;\n        }\n        features.push(parseFeature(data, lastIndex, i));\n        lastIndex = i;\n        lastValue = currValue;\n      }\n      features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return features;\n}\nfunction parseFeature(data, startIndex, endIndex) {\n  var geometry = parseGeometry(data, startIndex, endIndex);\n  var properties = parseProperties(data, startIndex, endIndex);\n  return {\n    type: 'Feature',\n    geometry: geometry,\n    properties: properties\n  };\n}\nfunction parseProperties(data, startIndex, endIndex) {\n  var properties = Object.assign(data.properties[data.featureIds.value[startIndex]]);\n  for (var key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n  return properties;\n}\nfunction parseGeometry(data, startIndex, endIndex) {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n    default:\n      throw new Error(\"Unsupported geometry type: \".concat(data.type));\n  }\n}\nfunction polygonToGeoJson(data) {\n  var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n  var endIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  var positions = data.positions;\n  var polygonIndices = data.polygonIndices.value.filter(function (x) {\n    return x >= startIndex && x <= endIndex;\n  });\n  var primitivePolygonIndices = data.primitivePolygonIndices.value.filter(function (x) {\n    return x >= startIndex && x <= endIndex;\n  });\n  var multi = polygonIndices.length > 2;\n  var coordinates = [];\n  if (!multi) {\n    for (var i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      var startRingIndex = primitivePolygonIndices[i];\n      var endRingIndex = primitivePolygonIndices[i + 1];\n      var ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n    return {\n      type: 'Polygon',\n      coordinates: coordinates\n    };\n  }\n  for (var _i = 0; _i < polygonIndices.length - 1; _i++) {\n    var startPolygonIndex = polygonIndices[_i];\n    var endPolygonIndex = polygonIndices[_i + 1];\n    var polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;\n    coordinates.push(polygonCoordinates);\n  }\n  return {\n    type: 'MultiPolygon',\n    coordinates: coordinates\n  };\n}\nfunction lineStringToGeoJson(data) {\n  var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n  var endIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  var positions = data.positions;\n  var pathIndices = data.pathIndices.value.filter(function (x) {\n    return x >= startIndex && x <= endIndex;\n  });\n  var multi = pathIndices.length > 2;\n  if (!multi) {\n    var _coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n    return {\n      type: 'LineString',\n      coordinates: _coordinates\n    };\n  }\n  var coordinates = [];\n  for (var i = 0; i < pathIndices.length - 1; i++) {\n    var ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n  return {\n    type: 'MultiLineString',\n    coordinates: coordinates\n  };\n}\nfunction pointToGeoJson(data, startIndex, endIndex) {\n  var positions = data.positions;\n  var coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  var multi = coordinates.length > 1;\n  if (multi) {\n    return {\n      type: 'MultiPoint',\n      coordinates: coordinates\n    };\n  }\n  return {\n    type: 'Point',\n    coordinates: coordinates[0]\n  };\n}\nfunction ringToGeoJson(positions, startIndex, endIndex) {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n  var ringCoordinates = [];\n  for (var j = startIndex; j < endIndex; j++) {\n    ringCoordinates.push(Array.from(positions.value.subarray(j * positions.size, (j + 1) * positions.size)));\n  }\n  return ringCoordinates;\n}\nfunction parseType(data) {\n  if (data.pathIndices) {\n    return 'LineString';\n  }\n  if (data.polygonIndices) {\n    return 'Polygon';\n  }\n  return 'Point';\n}","map":{"version":3,"names":["binaryToGeoJson","data","type","format","parseGeometry","dataArray","normalizeInput","deduceReturnType","parseFeatureCollection","isHeterogeneousType","Boolean","points","lines","polygons","parseType","features","push","length","featureIds","globalFeatureIds","numericProps","properties","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","lastIndex","lastValue","i","currValue","parseFeature","err","e","f","startIndex","endIndex","geometry","parseProperties","Object","assign","key","pointToGeoJson","lineStringToGeoJson","polygonToGeoJson","Error","concat","arguments","undefined","Infinity","positions","polygonIndices","filter","x","primitivePolygonIndices","multi","coordinates","startRingIndex","endRingIndex","ringCoordinates","ringToGeoJson","_i","startPolygonIndex","endPolygonIndex","polygonCoordinates","pathIndices","_coordinates","size","j","Array","from","subarray"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/json/node_modules/@loaders.gl/gis/src/lib/binary-to-geojson.js"],"sourcesContent":["export function binaryToGeoJson(data, type, format) {\n  if (format === 'geometry') {\n    return parseGeometry(data);\n  }\n\n  const dataArray = normalizeInput(data, type);\n\n  switch (deduceReturnType(dataArray)) {\n    case 'Geometry':\n      return parseGeometry(dataArray[0]);\n    case 'FeatureCollection':\n      return parseFeatureCollection(dataArray);\n    default:\n      break;\n  }\n\n  return null;\n}\n\n// Normalize features\n// Return an array of data objects, each of which have a type key\nfunction normalizeInput(data, type) {\n  const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);\n\n  if (!isHeterogeneousType) {\n    data.type = type || parseType(data);\n    return [data];\n  }\n\n  const features = [];\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n  return features;\n}\n\n// Determine whether a geometry or feature collection should be returned\n// If the input data doesn't have property identifiers, returns a single geometry\nfunction deduceReturnType(dataArray) {\n  // If more than one item in dataArray, multiple geometry types, must be a featurecollection\n  if (dataArray.length > 1) {\n    return 'FeatureCollection';\n  }\n\n  const data = dataArray[0];\n  if (!(data.featureIds || data.globalFeatureIds || data.numericProps || data.properties)) {\n    return 'Geometry';\n  }\n\n  return 'FeatureCollection';\n}\n\n/** Parse input binary data and return an array of GeoJSON Features */\nfunction parseFeatureCollection(dataArray) {\n  const features = [];\n  for (const data of dataArray) {\n    if (data.featureIds.value.length === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    // Need to deduce start, end indices of each feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      features.push(parseFeature(data, lastIndex, i));\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    // Last feature\n    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n  }\n  return features;\n}\n\n/** Parse input binary data and return a single GeoJSON Feature */\nfunction parseFeature(data, startIndex, endIndex) {\n  const geometry = parseGeometry(data, startIndex, endIndex);\n  const properties = parseProperties(data, startIndex, endIndex);\n  return {type: 'Feature', geometry, properties};\n}\n\n/** Parse input binary data and return an object of properties */\nfunction parseProperties(data, startIndex, endIndex) {\n  const properties = Object.assign(data.properties[data.featureIds.value[startIndex]]);\n  for (const key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n  return properties;\n}\n\n/** Parse input binary data and return a valid GeoJSON geometry object */\nfunction parseGeometry(data, startIndex, endIndex) {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n    default:\n      throw new Error(`Unsupported geometry type: ${data.type}`);\n  }\n}\n\n/** Parse binary data of type Polygon */\nfunction polygonToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {\n  const {positions} = data;\n  const polygonIndices = data.polygonIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter(\n    x => x >= startIndex && x <= endIndex\n  );\n  const multi = polygonIndices.length > 2;\n\n  const coordinates = [];\n  // Polygon\n  if (!multi) {\n    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      const startRingIndex = primitivePolygonIndices[i];\n      const endRingIndex = primitivePolygonIndices[i + 1];\n      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n\n    return {type: 'Polygon', coordinates};\n  }\n\n  // MultiPolygon\n  for (let i = 0; i < polygonIndices.length - 1; i++) {\n    const startPolygonIndex = polygonIndices[i];\n    const endPolygonIndex = polygonIndices[i + 1];\n    const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex)\n      .coordinates;\n    coordinates.push(polygonCoordinates);\n  }\n\n  return {type: 'MultiPolygon', coordinates};\n}\n\n/** Parse binary data of type LineString */\nfunction lineStringToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {\n  const {positions} = data;\n  const pathIndices = data.pathIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const multi = pathIndices.length > 2;\n\n  if (!multi) {\n    const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n    return {type: 'LineString', coordinates};\n  }\n\n  const coordinates = [];\n  for (let i = 0; i < pathIndices.length - 1; i++) {\n    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n\n  return {type: 'MultiLineString', coordinates};\n}\n\n/** Parse binary data of type Point */\nfunction pointToGeoJson(data, startIndex, endIndex) {\n  const {positions} = data;\n  const coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  const multi = coordinates.length > 1;\n\n  if (multi) {\n    return {type: 'MultiPoint', coordinates};\n  }\n\n  return {type: 'Point', coordinates: coordinates[0]};\n}\n\n/**\n * Parse a linear ring of positions to a GeoJSON linear ring\n *\n * @param positions Positions TypedArray\n * @param  {number?} startIndex Start index to include in ring\n * @param  {number?} endIndex End index to include in ring\n * @return {number[][]} GeoJSON ring\n */\nfunction ringToGeoJson(positions, startIndex, endIndex) {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n\n  const ringCoordinates = [];\n  for (let j = startIndex; j < endIndex; j++) {\n    ringCoordinates.push(\n      Array.from(positions.value.subarray(j * positions.size, (j + 1) * positions.size))\n    );\n  }\n  return ringCoordinates;\n}\n\n// Deduce geometry type of data object\nfunction parseType(data) {\n  if (data.pathIndices) {\n    return 'LineString';\n  }\n\n  if (data.polygonIndices) {\n    return 'Polygon';\n  }\n\n  return 'Point';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}