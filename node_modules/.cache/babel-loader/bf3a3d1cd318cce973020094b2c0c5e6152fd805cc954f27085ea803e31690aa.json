{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeFilters = mergeFilters;\nexports.createLayerFromConfig = createLayerFromConfig;\nexports.serializeLayer = serializeLayer;\nexports.mergeLayers = mergeLayers;\nexports.insertLayerAtRightOrder = insertLayerAtRightOrder;\nexports.mergeInteractions = mergeInteractions;\nexports.mergeSplitMaps = mergeSplitMaps;\nexports.mergeInteractionTooltipConfig = mergeInteractionTooltipConfig;\nexports.mergeLayerBlending = mergeLayerBlending;\nexports.mergeAnimationConfig = mergeAnimationConfig;\nexports.validateSavedLayerColumns = validateSavedLayerColumns;\nexports.validateColumn = validateColumn;\nexports.validateSavedTextLabel = validateSavedTextLabel;\nexports.validateSavedVisualChannels = validateSavedVisualChannels;\nexports.validateLayersByDatasets = validateLayersByDatasets;\nexports.validateLayerWithData = validateLayerWithData;\nexports.isValidMerger = isValidMerger;\nexports.VIS_STATE_MERGERS = void 0;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.uniq\"));\nvar _lodash2 = _interopRequireDefault(require(\"lodash.pick\"));\nvar _lodash3 = _interopRequireDefault(require(\"lodash.flattendeep\"));\nvar _utils = require(\"@kepler.gl/utils\");\nvar _constants = require(\"@kepler.gl/constants\");\nvar _schemas = require(\"@kepler.gl/schemas\");\nvar _table = require(\"@kepler.gl/table\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n/**\n * Merge loaded filters with current state, if no fields or data are loaded\n * save it for later\n *\n */\nfunction mergeFilters(state, filtersToMerge, fromConfig) {\n  if (!Array.isArray(filtersToMerge) || !filtersToMerge.length) {\n    return state;\n  }\n  var _validateFiltersUpdat = (0, _utils.validateFiltersUpdateDatasets)(state, filtersToMerge),\n    validated = _validateFiltersUpdat.validated,\n    failed = _validateFiltersUpdat.failed,\n    updatedDatasets = _validateFiltersUpdat.updatedDatasets; // merge filter with existing\n\n  var updatedFilters = [].concat((0, _toConsumableArray2[\"default\"])(state.filters || []), (0, _toConsumableArray2[\"default\"])(validated));\n  updatedFilters = (0, _table.resetFilterGpuMode)(updatedFilters);\n  updatedFilters = (0, _table.assignGpuChannels)(updatedFilters); // filter data\n\n  var datasetsToFilter = (0, _lodash[\"default\"])((0, _lodash3[\"default\"])(validated.map(function (f) {\n    return f.dataId;\n  })));\n  var filtered = (0, _utils.applyFiltersToDatasets)(datasetsToFilter, updatedDatasets, updatedFilters, state.layers);\n  return _objectSpread(_objectSpread({}, state), {}, {\n    filters: updatedFilters,\n    datasets: filtered,\n    filterToBeMerged: [].concat((0, _toConsumableArray2[\"default\"])(state.filterToBeMerged), (0, _toConsumableArray2[\"default\"])(failed))\n  });\n}\nfunction createLayerFromConfig(state, layerConfig) {\n  // first validate config against dataset\n  var _validateLayersByData = validateLayersByDatasets(state.datasets, state.layerClasses, [layerConfig]),\n    validated = _validateLayersByData.validated,\n    failed = _validateLayersByData.failed;\n  if (failed !== null && failed !== void 0 && failed.length || !validated.length) {\n    // failed\n    return null;\n  }\n  var newLayer = validated[0];\n  newLayer.updateLayerDomain(state.datasets);\n  return newLayer;\n}\nfunction serializeLayer(newLayer) {\n  var _visStateSchema$CURRE, _visStateSchema$CURRE2;\n  var savedVisState = _schemas.visStateSchema[_schemas.CURRENT_VERSION].save(\n  // @ts-expect-error not all expected properties are provided\n  {\n    layers: [newLayer],\n    layerOrder: [0]\n  }).visState;\n  var loadedLayer = (_visStateSchema$CURRE = _schemas.visStateSchema[_schemas.CURRENT_VERSION].load(savedVisState).visState) === null || _visStateSchema$CURRE === void 0 ? void 0 : (_visStateSchema$CURRE2 = _visStateSchema$CURRE.layers) === null || _visStateSchema$CURRE2 === void 0 ? void 0 : _visStateSchema$CURRE2[0]; // @ts-expect-error\n\n  return loadedLayer;\n}\n/**\n * Merge layers from de-serialized state, if no fields or data are loaded\n * save it for later\n *\n */\n\nfunction mergeLayers(state) {\n  var layersToMerge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var fromConfig = arguments.length > 2 ? arguments[2] : undefined;\n  var preserveLayerOrder = fromConfig ? layersToMerge.map(function (l) {\n    return l.id;\n  }) : state.preserveLayerOrder;\n  if (!Array.isArray(layersToMerge) || !layersToMerge.length) {\n    return state;\n  }\n  var _validateLayersByData2 = validateLayersByDatasets(state.datasets, state.layerClasses, layersToMerge),\n    mergedLayer = _validateLayersByData2.validated,\n    unmerged = _validateLayersByData2.failed; // put new layers in front of current layers\n\n  var _insertLayerAtRightOr = insertLayerAtRightOrder(state.layers, mergedLayer, state.layerOrder,\n    // @ts-expect-error\n    preserveLayerOrder),\n    newLayerOrder = _insertLayerAtRightOr.newLayerOrder,\n    newLayers = _insertLayerAtRightOr.newLayers;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    layers: newLayers,\n    layerOrder: newLayerOrder,\n    preserveLayerOrder: preserveLayerOrder,\n    layerToBeMerged: [].concat((0, _toConsumableArray2[\"default\"])(state.layerToBeMerged), (0, _toConsumableArray2[\"default\"])(unmerged))\n  });\n}\nfunction insertLayerAtRightOrder(currentLayers, layersToInsert, currentOrder) {\n  var preservedOrder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  // perservedOrder ['a', 'b', 'c'];\n  // layerOrder [1, 0, 3]\n  // layerOrderMap ['a', 'c']\n  var layerOrderQueue = currentOrder.map(function (i) {\n    return currentLayers[i].id;\n  });\n  var newLayers = currentLayers;\n  var _iterator = _createForOfIteratorHelper(layersToInsert),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var newLayer = _step.value;\n      // find where to insert it\n      var expectedIdx = preservedOrder.indexOf(newLayer.id); // if cant find place to insert, insert at the front\n\n      var insertAt = 0;\n      if (expectedIdx > 0) {\n        // look for layer to insert after\n        var i = expectedIdx + 1;\n        var preceedIdx = -1;\n        while (i-- > 0 && preceedIdx < 0) {\n          // keep looking for preceed layer that is already loaded\n          var preceedLayer = preservedOrder[i - 1];\n          preceedIdx = layerOrderQueue.indexOf(preceedLayer);\n        }\n        if (preceedIdx > -1) {\n          // if found\n          insertAt = preceedIdx + 1;\n        }\n      }\n      layerOrderQueue = (0, _utils.arrayInsert)(layerOrderQueue, insertAt, newLayer.id);\n      newLayers = newLayers.concat(newLayer);\n    } // reconstruct layerOrder after insert\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var newLayerOrder = layerOrderQueue.map(function (id) {\n    return newLayers.findIndex(function (l) {\n      return l.id === id;\n    });\n  });\n  return {\n    newLayerOrder: newLayerOrder,\n    newLayers: newLayers\n  };\n}\n/**\n * Merge interactions with saved config\n *\n */\n\nfunction mergeInteractions(state, interactionToBeMerged, fromConfig) {\n  var merged = {};\n  var unmerged = {};\n  if (interactionToBeMerged) {\n    Object.keys(interactionToBeMerged).forEach(function (key) {\n      if (!state.interactionConfig[key]) {\n        return;\n      }\n      var currentConfig = key === 'tooltip' || key === 'brush' ? state.interactionConfig[key].config : null;\n      var _ref = interactionToBeMerged[key] || {},\n        enabled = _ref.enabled,\n        configSaved = (0, _objectWithoutProperties2[\"default\"])(_ref, [\"enabled\"]);\n      var configToMerge = configSaved;\n      if (key === 'tooltip') {\n        var _mergeInteractionTool = mergeInteractionTooltipConfig(state, configSaved),\n          mergedTooltip = _mergeInteractionTool.mergedTooltip,\n          unmergedTooltip = _mergeInteractionTool.unmergedTooltip; // merge new dataset tooltips with original dataset tooltips\n\n        configToMerge = {\n          fieldsToShow: _objectSpread(_objectSpread({}, currentConfig.fieldsToShow), mergedTooltip)\n        };\n        if (Object.keys(unmergedTooltip).length) {\n          // @ts-expect-error\n          unmerged.tooltip = {\n            fieldsToShow: unmergedTooltip,\n            enabled: Boolean(enabled)\n          };\n        }\n      }\n      merged[key] = _objectSpread(_objectSpread({}, state.interactionConfig[key]), {}, {\n        enabled: Boolean(enabled)\n      }, currentConfig ? {\n        config: (0, _lodash2[\"default\"])(_objectSpread(_objectSpread({}, currentConfig), configToMerge), Object.keys(currentConfig))\n      } : {});\n    });\n  }\n  return _objectSpread(_objectSpread({}, state), {}, {\n    interactionConfig: _objectSpread(_objectSpread({}, state.interactionConfig), merged),\n    interactionToBeMerged: unmerged\n  });\n}\n/**\n * Merge splitMaps config with current visStete.\n * 1. if current map is split, but splitMap DOESNOT contain maps\n *    : don't merge anything\n * 2. if current map is NOT split, but splitMaps contain maps\n *    : add to splitMaps, and add current layers to splitMaps\n */\n\nfunction mergeSplitMaps(state) {\n  var splitMaps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var fromConfig = arguments.length > 2 ? arguments[2] : undefined;\n  var merged = (0, _toConsumableArray2[\"default\"])(state.splitMaps);\n  var unmerged = [];\n  splitMaps.forEach(function (sm, i) {\n    Object.entries(sm.layers).forEach(function (_ref2) {\n      var _ref3 = (0, _slicedToArray2[\"default\"])(_ref2, 2),\n        id = _ref3[0],\n        value = _ref3[1];\n\n      // check if layer exists\n      var pushTo = state.layers.find(function (l) {\n        return l.id === id;\n      }) ? merged : unmerged; // create map panel if current map is not split\n\n      pushTo[i] = pushTo[i] || {\n        layers: pushTo === merged ? (0, _utils.getInitialMapLayersForSplitMap)(state.layers) : []\n      };\n      pushTo[i].layers = _objectSpread(_objectSpread({}, pushTo[i].layers), {}, (0, _defineProperty2[\"default\"])({}, id, value));\n    });\n  });\n  return _objectSpread(_objectSpread({}, state), {}, {\n    splitMaps: merged,\n    splitMapsToBeMerged: [].concat((0, _toConsumableArray2[\"default\"])(state.splitMapsToBeMerged), unmerged)\n  });\n}\n/**\n * Merge interactionConfig.tooltip with saved config,\n * validate fieldsToShow\n *\n * @param state\n * @param tooltipConfig\n * @return - {mergedTooltip: {}, unmergedTooltip: {}}\n */\n\nfunction mergeInteractionTooltipConfig(state) {\n  var tooltipConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var unmergedTooltip = {};\n  var mergedTooltip = {};\n  if (!tooltipConfig || !tooltipConfig.fieldsToShow || !Object.keys(tooltipConfig.fieldsToShow).length) {\n    return {\n      mergedTooltip: mergedTooltip,\n      unmergedTooltip: unmergedTooltip\n    };\n  }\n  for (var dataId in tooltipConfig.fieldsToShow) {\n    if (!state.datasets[dataId]) {\n      // is not yet loaded\n      unmergedTooltip[dataId] = tooltipConfig.fieldsToShow[dataId];\n    } else {\n      (function () {\n        // if dataset is loaded\n        var allFields = state.datasets[dataId].fields.map(function (d) {\n          return d.name;\n        });\n        var foundFieldsToShow = tooltipConfig.fieldsToShow[dataId].filter(function (field) {\n          return allFields.includes(field.name);\n        });\n        mergedTooltip[dataId] = foundFieldsToShow;\n      })();\n    }\n  }\n  return {\n    mergedTooltip: mergedTooltip,\n    unmergedTooltip: unmergedTooltip\n  };\n}\n/**\n * Merge layerBlending with saved\n *\n */\n\nfunction mergeLayerBlending(state, layerBlending, fromConfig) {\n  if (layerBlending && _constants.LAYER_BLENDINGS[layerBlending]) {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      layerBlending: layerBlending\n    });\n  }\n  return state;\n}\n/**\n * Merge animation config\n */\n\nfunction mergeAnimationConfig(state, animation, fromConfig) {\n  if (animation && animation.currentTime) {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      animationConfig: _objectSpread(_objectSpread(_objectSpread({}, state.animationConfig), animation), {}, {\n        domain: null\n      })\n    });\n  }\n  return state;\n}\n/**\n * Validate saved layer columns with new data,\n * update fieldIdx based on new fields\n *\n * @param fields\n * @param savedCols\n * @param emptyCols\n * @return - validated columns or null\n */\n\nfunction validateSavedLayerColumns(fields) {\n  var savedCols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var emptyCols = arguments.length > 2 ? arguments[2] : undefined;\n  // Prepare columns for the validator\n  var columns = {};\n  var _loop = function _loop() {\n    var key = _Object$keys[_i];\n    columns[key] = _objectSpread({}, emptyCols[key]);\n    var saved = savedCols[key];\n    if (saved) {\n      var fieldIdx = fields.findIndex(function (_ref4) {\n        var name = _ref4.name;\n        return name === saved;\n      });\n      if (fieldIdx > -1) {\n        // update found columns\n        columns[key].fieldIdx = fieldIdx;\n        columns[key].value = saved;\n      }\n    }\n  };\n  for (var _i = 0, _Object$keys = Object.keys(emptyCols); _i < _Object$keys.length; _i++) {\n    _loop();\n  } // find actual column fieldIdx, in case it has changed\n\n  var allColFound = Object.keys(columns).every(function (key) {\n    return validateColumn(columns[key], columns, fields);\n  });\n  if (allColFound) {\n    return columns;\n  }\n  return null;\n}\nfunction validateColumn(column, columns, allFields) {\n  if (column.optional || column.value) {\n    return true;\n  }\n  if (column.validator) {\n    return column.validator(column, columns, allFields);\n  }\n  return false;\n}\n/**\n * Validate saved text label config with new data\n * refer to vis-state-schema.js TextLabelSchemaV1\n *\n * @param {Array<Object>} fields\n * @param {Object} savedTextLabel\n * @return {Object} - validated textlabel\n */\n\nfunction validateSavedTextLabel(fields, _ref5, savedTextLabel) {\n  var _ref6 = (0, _slicedToArray2[\"default\"])(_ref5, 1),\n    layerTextLabel = _ref6[0];\n  var savedTextLabels = Array.isArray(savedTextLabel) ? savedTextLabel : [savedTextLabel]; // validate field\n\n  return savedTextLabels.map(function (textLabel) {\n    var field = textLabel.field ? fields.find(function (fd) {\n      return Object.keys(textLabel.field).every(function (key) {\n        return textLabel.field[key] === fd[key];\n      });\n    }) : null;\n    return Object.keys(layerTextLabel).reduce(function (accu, key) {\n      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, key === 'field' ? field : textLabel[key] || layerTextLabel[key]));\n    }, {});\n  });\n}\n/**\n * Validate saved visual channels config with new data,\n * refer to vis-state-schema.js VisualChannelSchemaV1\n */\n\nfunction validateSavedVisualChannels(fields, newLayer, savedLayer) {\n  Object.values(newLayer.visualChannels).forEach(function (_ref7) {\n    var field = _ref7.field,\n      scale = _ref7.scale,\n      key = _ref7.key;\n    var foundField;\n    if (savedLayer.config) {\n      if (savedLayer.config[field]) {\n        foundField = fields.find(function (fd) {\n          return savedLayer.config && fd.name === savedLayer.config[field].name;\n        });\n      }\n      var foundChannel = _objectSpread(_objectSpread({}, foundField ? (0, _defineProperty2[\"default\"])({}, field, foundField) : {}), savedLayer.config[scale] ? (0, _defineProperty2[\"default\"])({}, scale, savedLayer.config[scale]) : {});\n      if (Object.keys(foundChannel).length) {\n        newLayer.updateLayerConfig(foundChannel);\n      }\n      newLayer.validateVisualChannel(key);\n    }\n  });\n  return newLayer;\n}\nfunction validateLayersByDatasets(datasets, layerClasses) {\n  var layers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var validated = [];\n  var failed = [];\n  layers.forEach(function (layer) {\n    var _layer$config;\n    var validateLayer = null;\n    if (layer !== null && layer !== void 0 && (_layer$config = layer.config) !== null && _layer$config !== void 0 && _layer$config.dataId) {\n      if (datasets[layer.config.dataId]) {\n        // datasets are already loaded\n        validateLayer = validateLayerWithData(datasets[layer.config.dataId], layer, layerClasses);\n      }\n    }\n    if (validateLayer) {\n      validated.push(validateLayer);\n    } else {\n      // datasets not yet loaded\n      failed.push(layer);\n    }\n  });\n  return {\n    validated: validated,\n    failed: failed\n  };\n}\n/**\n * Validate saved layer config with new data,\n * update fieldIdx based on new fields\n */\n\nfunction validateLayerWithData(_ref10, savedLayer, layerClasses) {\n  var fields = _ref10.fields,\n    dataId = _ref10.id;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var type = savedLayer.type; // layer doesnt have a valid type\n\n  if (!type || !layerClasses.hasOwnProperty(type) || !savedLayer.config) {\n    return null;\n  }\n  var newLayer = new layerClasses[type]({\n    id: savedLayer.id,\n    dataId: dataId,\n    label: savedLayer.config.label,\n    color: savedLayer.config.color,\n    isVisible: savedLayer.config.isVisible,\n    hidden: savedLayer.config.hidden,\n    highlightColor: savedLayer.config.highlightColor\n  }); // find column fieldIdx\n\n  var columnConfig = newLayer.getLayerColumns();\n  if (Object.keys(columnConfig).length) {\n    var columns = validateSavedLayerColumns(fields, savedLayer.config.columns, columnConfig);\n    if (columns) {\n      newLayer.updateLayerConfig({\n        columns: columns\n      });\n    } else if (!options.allowEmptyColumn) {\n      return null;\n    }\n  } // visual channel field is saved to be {name, type}\n  // find visual channel field by matching both name and type\n  // refer to vis-state-schema.js VisualChannelSchemaV1\n\n  newLayer = validateSavedVisualChannels(fields, newLayer, savedLayer);\n  var textLabel = savedLayer.config.textLabel && newLayer.config.textLabel ? validateSavedTextLabel(fields, newLayer.config.textLabel, savedLayer.config.textLabel) : newLayer.config.textLabel; // copy visConfig over to emptyLayer to make sure it has all the props\n\n  var visConfig = newLayer.copyLayerConfig(newLayer.config.visConfig, savedLayer.config.visConfig || {}, {\n    shallowCopy: ['colorRange', 'strokeColorRange']\n  });\n  newLayer.updateLayerConfig({\n    visConfig: visConfig,\n    textLabel: textLabel\n  });\n  return newLayer;\n}\nfunction isValidMerger(merger) {\n  return (0, _utils.isObject)(merger) && typeof merger.merge === 'function' && typeof merger.prop === 'string';\n}\nvar VIS_STATE_MERGERS = [{\n  merge: mergeLayers,\n  prop: 'layers',\n  toMergeProp: 'layerToBeMerged'\n}, {\n  merge: mergeFilters,\n  prop: 'filters',\n  toMergeProp: 'filterToBeMerged'\n}, {\n  merge: mergeInteractions,\n  prop: 'interactionConfig',\n  toMergeProp: 'interactionToBeMerged'\n}, {\n  merge: mergeLayerBlending,\n  prop: 'layerBlending'\n}, {\n  merge: mergeSplitMaps,\n  prop: 'splitMaps',\n  toMergeProp: 'splitMapsToBeMerged'\n}, {\n  merge: mergeAnimationConfig,\n  prop: 'animationConfig'\n}];\nexports.VIS_STATE_MERGERS = VIS_STATE_MERGERS;","map":{"version":3,"names":["exports","mergeInteractionTooltipConfig","mergeAnimationConfig","validateColumn","validateSavedVisualChannels","validateLayerWithData","VIS_STATE_MERGERS","_slicedToArray2","_interopRequireDefault","require","_lodash3","_utils","_constants","_schemas","_table","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","failed","minLen","_arrayLikeToArray","Object","prototype","toString","call","slice","constructor","name","from","test","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","updatedFilters","target","arguments","source","forEach","key","_defineProperty2","getOwnPropertyDescriptors","defineProperties","defineProperty","mergeFilters","state","filtersToMerge","fromConfig","validated","_validateFiltersUpdat","updatedDatasets","resetFilterGpuMode","assignGpuChannels","datasetsToFilter","_lodash","map","filtered","applyFiltersToDatasets","layers","filters","filterToBeMerged","concat","_toConsumableArray2","createLayerFromConfig","layerConfig","_validateLayersByData","validateLayersByDatasets","datasets","layerClasses","newLayer","updateLayerDomain","serializeLayer","_visStateSchema$CURRE","_visStateSchema$CURRE2","savedVisState","visStateSchema","CURRENT_VERSION","save","visState","loadedLayer","load","layersToMerge","undefined","preserveLayerOrder","l","id","_validateLayersByData2","mergedLayer","unmerged","_insertLayerAtRightOr","insertLayerAtRightOrder","layerOrder","newLayers","newLayerOrder","layerToBeMerged","preservedOrder","currentLayers","_iterator","layersToInsert","_step","insertAt","expectedIdx","preceedIdx","preceedLayer","layerOrderQueue","indexOf","arrayInsert","findIndex","mergeInteractions","interactionToBeMerged","merged","interactionConfig","currentConfig","config","_ref","enabled","configSaved","_objectWithoutProperties2","_mergeInteractionTool","mergedTooltip","unmergedTooltip","fieldsToShow","tooltip","Boolean","_lodash2","configToMerge","mergeSplitMaps","splitMaps","sm","entries","_ref2","_ref3","pushTo","find","getInitialMapLayersForSplitMap","splitMapsToBeMerged","tooltipConfig","dataId","foundFieldsToShow","field","allFields","includes","mergeLayerBlending","layerBlending","LAYER_BLENDINGS","animationConfig","animation","domain","validateSavedLayerColumns","columns","fields","savedCols","emptyCols","_loop","_Object$keys","_i","saved","fieldIdx","_ref4","allColFound","every","column","optional","validator","validateSavedTextLabel","_ref5","savedTextLabel","savedTextLabels","textLabel","fd","layerTextLabel","reduce","accu","savedLayer","values","visualChannels","_ref7","scale","foundField","foundChannel","updateLayerConfig","validateVisualChannel","layer","_layer$config","validateLayer","_ref10","options","type","hasOwnProperty","label","color","highlightColor","columnConfig","getLayerColumns","visConfig","copyLayerConfig","shallowCopy","isValidMerger","merger","isObject","merge","prop","mergeLayers"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/reducers/src/vis-state-merger.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport uniq from 'lodash.uniq';\nimport pick from 'lodash.pick';\nimport flattenDeep from 'lodash.flattendeep';\nimport {\n  isObject,\n  arrayInsert,\n  getInitialMapLayersForSplitMap,\n  applyFiltersToDatasets,\n  validateFiltersUpdateDatasets\n} from '@kepler.gl/utils';\n\nimport {LayerColumns, LayerColumn, Layer} from '@kepler.gl/layers';\nimport {LAYER_BLENDINGS} from '@kepler.gl/constants';\nimport {\n  CURRENT_VERSION,\n  Merger,\n  VisState,\n  VisStateMergers,\n  visStateSchema,\n  ParsedConfig\n} from '@kepler.gl/schemas';\n\nimport {ParsedLayer, SavedInteractionConfig, TooltipInfo} from '@kepler.gl/types';\nimport {KeplerTable, Datasets, assignGpuChannels, resetFilterGpuMode} from '@kepler.gl/table';\n\n/**\n * Merge loaded filters with current state, if no fields or data are loaded\n * save it for later\n *\n */\nexport function mergeFilters<S extends VisState>(\n  state: S,\n  filtersToMerge: NonNullable<ParsedConfig['visState']>['filters'],\n  fromConfig?: boolean\n): S {\n  if (!Array.isArray(filtersToMerge) || !filtersToMerge.length) {\n    return state;\n  }\n\n  const {validated, failed, updatedDatasets} = validateFiltersUpdateDatasets(state, filtersToMerge);\n\n  // merge filter with existing\n  let updatedFilters = [...(state.filters || []), ...validated];\n  updatedFilters = resetFilterGpuMode(updatedFilters);\n  updatedFilters = assignGpuChannels(updatedFilters);\n  // filter data\n  const datasetsToFilter = uniq(flattenDeep(validated.map(f => f.dataId)));\n\n  const filtered = applyFiltersToDatasets(\n    datasetsToFilter,\n    updatedDatasets,\n    updatedFilters,\n    state.layers\n  );\n\n  return {\n    ...state,\n    filters: updatedFilters,\n    datasets: filtered,\n    filterToBeMerged: [...state.filterToBeMerged, ...failed]\n  };\n}\n\nexport function createLayerFromConfig(state: VisState, layerConfig: any): Layer | null {\n  // first validate config against dataset\n  const {validated, failed} = validateLayersByDatasets(state.datasets, state.layerClasses, [\n    layerConfig\n  ]);\n\n  if (failed?.length || !validated.length) {\n    // failed\n    return null;\n  }\n\n  const newLayer = validated[0];\n  newLayer.updateLayerDomain(state.datasets);\n  return newLayer;\n}\n\nexport function serializeLayer(newLayer): ParsedLayer {\n  const savedVisState = visStateSchema[CURRENT_VERSION].save(\n    // @ts-expect-error not all expected properties are provided\n    {\n      layers: [newLayer],\n      layerOrder: [0]\n    }\n  ).visState;\n  const loadedLayer = visStateSchema[CURRENT_VERSION].load(savedVisState).visState?.layers?.[0];\n  // @ts-expect-error\n  return loadedLayer;\n}\n\n/**\n * Merge layers from de-serialized state, if no fields or data are loaded\n * save it for later\n *\n */\nexport function mergeLayers<S extends VisState>(\n  state: S,\n  layersToMerge: NonNullable<ParsedConfig['visState']>['layers'] = [],\n  fromConfig?: boolean\n): S {\n  const preserveLayerOrder = fromConfig ? layersToMerge.map(l => l.id) : state.preserveLayerOrder;\n\n  if (!Array.isArray(layersToMerge) || !layersToMerge.length) {\n    return state;\n  }\n\n  const {validated: mergedLayer, failed: unmerged} = validateLayersByDatasets(\n    state.datasets,\n    state.layerClasses,\n    layersToMerge\n  );\n\n  // put new layers in front of current layers\n  const {newLayerOrder, newLayers} = insertLayerAtRightOrder(\n    state.layers,\n    mergedLayer,\n    state.layerOrder,\n    // @ts-expect-error\n    preserveLayerOrder\n  );\n\n  return {\n    ...state,\n    layers: newLayers,\n    layerOrder: newLayerOrder,\n    preserveLayerOrder,\n    layerToBeMerged: [...state.layerToBeMerged, ...unmerged]\n  };\n}\n\nexport function insertLayerAtRightOrder(\n  currentLayers,\n  layersToInsert,\n  currentOrder,\n  preservedOrder: string[] = []\n) {\n  // perservedOrder ['a', 'b', 'c'];\n  // layerOrder [1, 0, 3]\n  // layerOrderMap ['a', 'c']\n  let layerOrderQueue = currentOrder.map(i => currentLayers[i].id);\n  let newLayers = currentLayers;\n\n  for (const newLayer of layersToInsert) {\n    // find where to insert it\n    const expectedIdx = preservedOrder.indexOf(newLayer.id);\n    // if cant find place to insert, insert at the front\n    let insertAt = 0;\n\n    if (expectedIdx > 0) {\n      // look for layer to insert after\n      let i = expectedIdx + 1;\n      let preceedIdx = -1;\n      while (i-- > 0 && preceedIdx < 0) {\n        // keep looking for preceed layer that is already loaded\n        const preceedLayer = preservedOrder[i - 1];\n        preceedIdx = layerOrderQueue.indexOf(preceedLayer);\n      }\n      if (preceedIdx > -1) {\n        // if found\n        insertAt = preceedIdx + 1;\n      }\n    }\n\n    layerOrderQueue = arrayInsert(layerOrderQueue, insertAt, newLayer.id);\n    newLayers = newLayers.concat(newLayer);\n  }\n\n  // reconstruct layerOrder after insert\n  const newLayerOrder = layerOrderQueue.map(id => newLayers.findIndex(l => l.id === id));\n\n  return {\n    newLayerOrder,\n    newLayers\n  };\n}\n\n/**\n * Merge interactions with saved config\n *\n */\nexport function mergeInteractions<S extends VisState>(\n  state: S,\n  interactionToBeMerged: Partial<SavedInteractionConfig> | undefined,\n  fromConfig?: boolean\n): S {\n  const merged: Partial<SavedInteractionConfig> = {};\n  const unmerged: Partial<SavedInteractionConfig> = {};\n\n  if (interactionToBeMerged) {\n    (Object.keys(interactionToBeMerged) as Array<keyof SavedInteractionConfig>).forEach(key => {\n      if (!state.interactionConfig[key]) {\n        return;\n      }\n\n      const currentConfig =\n        key === 'tooltip' || key === 'brush' ? state.interactionConfig[key].config : null;\n\n      const {enabled, ...configSaved} = interactionToBeMerged[key] || {};\n\n      let configToMerge = configSaved;\n\n      if (key === 'tooltip') {\n        const {mergedTooltip, unmergedTooltip} = mergeInteractionTooltipConfig(\n          state,\n          configSaved as SavedInteractionConfig['tooltip']\n        );\n\n        // merge new dataset tooltips with original dataset tooltips\n        configToMerge = {\n          fieldsToShow: {\n            ...(currentConfig as TooltipInfo['config']).fieldsToShow,\n            ...mergedTooltip\n          }\n        };\n\n        if (Object.keys(unmergedTooltip).length) {\n          // @ts-expect-error\n          unmerged.tooltip = {fieldsToShow: unmergedTooltip, enabled: Boolean(enabled)};\n        }\n      }\n\n      merged[key] = {\n        ...state.interactionConfig[key],\n        enabled: Boolean(enabled),\n        ...(currentConfig\n          ? {\n              config: pick(\n                {\n                  ...currentConfig,\n                  ...configToMerge\n                },\n                Object.keys(currentConfig)\n              )\n            }\n          : {})\n      };\n    });\n  }\n\n  return {\n    ...state,\n    interactionConfig: {\n      ...state.interactionConfig,\n      ...merged\n    },\n    interactionToBeMerged: unmerged\n  };\n}\n\n/**\n * Merge splitMaps config with current visStete.\n * 1. if current map is split, but splitMap DOESNOT contain maps\n *    : don't merge anything\n * 2. if current map is NOT split, but splitMaps contain maps\n *    : add to splitMaps, and add current layers to splitMaps\n */\nexport function mergeSplitMaps<S extends VisState>(\n  state: S,\n  splitMaps: NonNullable<ParsedConfig['visState']>['splitMaps'] = [],\n  fromConfig?: boolean\n): S {\n  const merged = [...state.splitMaps];\n  const unmerged = [];\n  splitMaps.forEach((sm, i) => {\n    Object.entries(sm.layers).forEach(([id, value]) => {\n      // check if layer exists\n      const pushTo = state.layers.find(l => l.id === id) ? merged : unmerged;\n\n      // create map panel if current map is not split\n      pushTo[i] = pushTo[i] || {\n        layers: pushTo === merged ? getInitialMapLayersForSplitMap(state.layers) : []\n      };\n      pushTo[i].layers = {\n        ...pushTo[i].layers,\n        [id]: value\n      };\n    });\n  });\n\n  return {\n    ...state,\n    splitMaps: merged,\n    splitMapsToBeMerged: [...state.splitMapsToBeMerged, ...unmerged]\n  };\n}\n\n/**\n * Merge interactionConfig.tooltip with saved config,\n * validate fieldsToShow\n *\n * @param state\n * @param tooltipConfig\n * @return - {mergedTooltip: {}, unmergedTooltip: {}}\n */\nexport function mergeInteractionTooltipConfig(\n  state: VisState,\n  tooltipConfig: Pick<TooltipInfo['config'], 'fieldsToShow'> | null = null\n) {\n  const unmergedTooltip: TooltipInfo['config']['fieldsToShow'] = {};\n  const mergedTooltip: TooltipInfo['config']['fieldsToShow'] = {};\n\n  if (\n    !tooltipConfig ||\n    !tooltipConfig.fieldsToShow ||\n    !Object.keys(tooltipConfig.fieldsToShow).length\n  ) {\n    return {mergedTooltip, unmergedTooltip};\n  }\n\n  for (const dataId in tooltipConfig.fieldsToShow) {\n    if (!state.datasets[dataId]) {\n      // is not yet loaded\n      unmergedTooltip[dataId] = tooltipConfig.fieldsToShow[dataId];\n    } else {\n      // if dataset is loaded\n      const allFields = state.datasets[dataId].fields.map(d => d.name);\n      const foundFieldsToShow = tooltipConfig.fieldsToShow[dataId].filter(field =>\n        allFields.includes(field.name)\n      );\n\n      mergedTooltip[dataId] = foundFieldsToShow;\n    }\n  }\n\n  return {mergedTooltip, unmergedTooltip};\n}\n/**\n * Merge layerBlending with saved\n *\n */\nexport function mergeLayerBlending<S extends VisState>(\n  state: S,\n  layerBlending: NonNullable<ParsedConfig['visState']>['layerBlending'],\n  fromConfig?: boolean\n): S {\n  if (layerBlending && LAYER_BLENDINGS[layerBlending]) {\n    return {\n      ...state,\n      layerBlending\n    };\n  }\n\n  return state;\n}\n\n/**\n * Merge animation config\n */\nexport function mergeAnimationConfig<S extends VisState>(\n  state: S,\n  animation: NonNullable<ParsedConfig['visState']>['animationConfig'],\n  fromConfig?: boolean\n): S {\n  if (animation && animation.currentTime) {\n    return {\n      ...state,\n      animationConfig: {\n        ...state.animationConfig,\n        ...animation,\n        domain: null\n      }\n    };\n  }\n\n  return state;\n}\n\n/**\n * Validate saved layer columns with new data,\n * update fieldIdx based on new fields\n *\n * @param fields\n * @param savedCols\n * @param emptyCols\n * @return - validated columns or null\n */\n\nexport function validateSavedLayerColumns(\n  fields: KeplerTable['fields'],\n  savedCols: {\n    [key: string]: string;\n  } = {},\n  emptyCols: LayerColumns\n) {\n  // Prepare columns for the validator\n  const columns: typeof emptyCols = {};\n  for (const key of Object.keys(emptyCols)) {\n    columns[key] = {...emptyCols[key]};\n\n    const saved = savedCols[key];\n    if (saved) {\n      const fieldIdx = fields.findIndex(({name}) => name === saved);\n\n      if (fieldIdx > -1) {\n        // update found columns\n        columns[key].fieldIdx = fieldIdx;\n        columns[key].value = saved;\n      }\n    }\n  }\n\n  // find actual column fieldIdx, in case it has changed\n  const allColFound = Object.keys(columns).every(key =>\n    validateColumn(columns[key], columns, fields)\n  );\n\n  if (allColFound) {\n    return columns;\n  }\n\n  return null;\n}\n\nexport function validateColumn(\n  column: LayerColumn & {validator?: typeof validateColumn},\n  columns: LayerColumns,\n  allFields: KeplerTable['fields']\n): boolean {\n  if (column.optional || column.value) {\n    return true;\n  }\n  if (column.validator) {\n    return column.validator(column, columns, allFields);\n  }\n  return false;\n}\n\n/**\n * Validate saved text label config with new data\n * refer to vis-state-schema.js TextLabelSchemaV1\n *\n * @param {Array<Object>} fields\n * @param {Object} savedTextLabel\n * @return {Object} - validated textlabel\n */\nexport function validateSavedTextLabel(fields, [layerTextLabel], savedTextLabel) {\n  const savedTextLabels = Array.isArray(savedTextLabel) ? savedTextLabel : [savedTextLabel];\n\n  // validate field\n  return savedTextLabels.map(textLabel => {\n    const field = textLabel.field\n      ? fields.find(fd =>\n          Object.keys(textLabel.field).every(key => textLabel.field[key] === fd[key])\n        )\n      : null;\n\n    return Object.keys(layerTextLabel).reduce(\n      (accu, key) => ({\n        ...accu,\n        [key]: key === 'field' ? field : textLabel[key] || layerTextLabel[key]\n      }),\n      {}\n    );\n  });\n}\n\n/**\n * Validate saved visual channels config with new data,\n * refer to vis-state-schema.js VisualChannelSchemaV1\n */\nexport function validateSavedVisualChannels(\n  fields: KeplerTable['fields'],\n  newLayer: Layer,\n  savedLayer: ParsedLayer\n): null | Layer {\n  Object.values(newLayer.visualChannels).forEach(({field, scale, key}) => {\n    let foundField;\n    if (savedLayer.config) {\n      if (savedLayer.config[field]) {\n        foundField = fields.find(\n          fd => savedLayer.config && fd.name === savedLayer.config[field].name\n        );\n      }\n\n      const foundChannel = {\n        ...(foundField ? {[field]: foundField} : {}),\n        ...(savedLayer.config[scale] ? {[scale]: savedLayer.config[scale]} : {})\n      };\n      if (Object.keys(foundChannel).length) {\n        newLayer.updateLayerConfig(foundChannel);\n      }\n\n      newLayer.validateVisualChannel(key);\n    }\n  });\n  return newLayer;\n}\n\nexport function validateLayersByDatasets(\n  datasets: Datasets,\n  layerClasses: VisState['layerClasses'],\n  layers: NonNullable<ParsedConfig['visState']>['layers'] = []\n) {\n  const validated: Layer[] = [];\n  const failed: NonNullable<ParsedConfig['visState']>['layers'] = [];\n\n  layers.forEach(layer => {\n    let validateLayer: Layer | null = null;\n\n    if (layer?.config?.dataId) {\n      if (datasets[layer.config.dataId]) {\n        // datasets are already loaded\n        validateLayer = validateLayerWithData(datasets[layer.config.dataId], layer, layerClasses);\n      }\n    }\n\n    if (validateLayer) {\n      validated.push(validateLayer);\n    } else {\n      // datasets not yet loaded\n      failed.push(layer);\n    }\n  });\n\n  return {validated, failed};\n}\n/**\n * Validate saved layer config with new data,\n * update fieldIdx based on new fields\n */\nexport function validateLayerWithData(\n  {fields, id: dataId}: KeplerTable,\n  savedLayer: ParsedLayer,\n  layerClasses: VisState['layerClasses'],\n  options: {\n    allowEmptyColumn?: boolean;\n  } = {}\n): Layer | null {\n  const {type} = savedLayer;\n  // layer doesnt have a valid type\n  if (!type || !layerClasses.hasOwnProperty(type) || !savedLayer.config) {\n    return null;\n  }\n\n  let newLayer = new layerClasses[type]({\n    id: savedLayer.id,\n    dataId,\n    label: savedLayer.config.label,\n    color: savedLayer.config.color,\n    isVisible: savedLayer.config.isVisible,\n    hidden: savedLayer.config.hidden,\n    highlightColor: savedLayer.config.highlightColor\n  });\n\n  // find column fieldIdx\n  const columnConfig = newLayer.getLayerColumns();\n  if (Object.keys(columnConfig).length) {\n    const columns = validateSavedLayerColumns(fields, savedLayer.config.columns, columnConfig);\n    if (columns) {\n      newLayer.updateLayerConfig({columns});\n    } else if (!options.allowEmptyColumn) {\n      return null;\n    }\n  }\n\n  // visual channel field is saved to be {name, type}\n  // find visual channel field by matching both name and type\n  // refer to vis-state-schema.js VisualChannelSchemaV1\n  newLayer = validateSavedVisualChannels(fields, newLayer, savedLayer);\n\n  const textLabel =\n    savedLayer.config.textLabel && newLayer.config.textLabel\n      ? validateSavedTextLabel(fields, newLayer.config.textLabel, savedLayer.config.textLabel)\n      : newLayer.config.textLabel;\n\n  // copy visConfig over to emptyLayer to make sure it has all the props\n  const visConfig = newLayer.copyLayerConfig(\n    newLayer.config.visConfig,\n    savedLayer.config.visConfig || {},\n    {shallowCopy: ['colorRange', 'strokeColorRange']}\n  );\n\n  newLayer.updateLayerConfig({\n    visConfig,\n    textLabel\n  });\n\n  return newLayer;\n}\n\nexport function isValidMerger(merger: Merger): boolean {\n  return isObject(merger) && typeof merger.merge === 'function' && typeof merger.prop === 'string';\n}\n\nexport const VIS_STATE_MERGERS: VisStateMergers = [\n  {merge: mergeLayers, prop: 'layers', toMergeProp: 'layerToBeMerged'},\n  {merge: mergeFilters, prop: 'filters', toMergeProp: 'filterToBeMerged'},\n  {merge: mergeInteractions, prop: 'interactionConfig', toMergeProp: 'interactionToBeMerged'},\n  {merge: mergeLayerBlending, prop: 'layerBlending'},\n  {merge: mergeSplitMaps, prop: 'splitMaps', toMergeProp: 'splitMapsToBeMerged'},\n  {merge: mergeAnimationConfig, prop: 'animationConfig'}\n];\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}