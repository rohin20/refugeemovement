{"ast":null,"code":"import _regeneratorRuntime from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Vector3, Matrix3 } from '@math.gl/core';\nimport { getAccessorArrayTypeAndLength } from '../gltf-utils/gltf-utils';\nimport { BYTES, COMPONENTS } from '../gltf-utils/gltf-constants';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nvar EXT_MESHOPT_TRANSFORM = 'KHR_texture_transform';\nexport var name = EXT_MESHOPT_TRANSFORM;\nvar scratchVector = new Vector3();\nvar scratchRotationMatrix = new Matrix3();\nvar scratchScaleMatrix = new Matrix3();\nexport function decode(_x, _x2) {\n  return _decode.apply(this, arguments);\n}\nfunction _decode() {\n  _decode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(gltfData, options) {\n    var gltfScenegraph, extension, materials, i;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          gltfScenegraph = new GLTFScenegraph(gltfData);\n          extension = gltfScenegraph.getExtension(EXT_MESHOPT_TRANSFORM);\n          if (extension) {\n            _context.next = 4;\n            break;\n          }\n          return _context.abrupt(\"return\");\n        case 4:\n          materials = gltfData.json.materials || [];\n          for (i = 0; i < materials.length; i++) {\n            transformTexCoords(i, gltfData);\n          }\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _decode.apply(this, arguments);\n}\nfunction transformTexCoords(materialIndex, gltfData) {\n  var _gltfData$json$materi, _material$pbrMetallic, _material$pbrMetallic2;\n  var processedTexCoords = [];\n  var material = (_gltfData$json$materi = gltfData.json.materials) === null || _gltfData$json$materi === void 0 ? void 0 : _gltfData$json$materi[materialIndex];\n  var baseColorTexture = material === null || material === void 0 ? void 0 : (_material$pbrMetallic = material.pbrMetallicRoughness) === null || _material$pbrMetallic === void 0 ? void 0 : _material$pbrMetallic.baseColorTexture;\n  if (baseColorTexture) {\n    transformPrimitives(gltfData, materialIndex, baseColorTexture, processedTexCoords);\n  }\n  var emisiveTexture = material === null || material === void 0 ? void 0 : material.emissiveTexture;\n  if (emisiveTexture) {\n    transformPrimitives(gltfData, materialIndex, emisiveTexture, processedTexCoords);\n  }\n  var normalTexture = material === null || material === void 0 ? void 0 : material.normalTexture;\n  if (normalTexture) {\n    transformPrimitives(gltfData, materialIndex, normalTexture, processedTexCoords);\n  }\n  var occlusionTexture = material === null || material === void 0 ? void 0 : material.occlusionTexture;\n  if (occlusionTexture) {\n    transformPrimitives(gltfData, materialIndex, occlusionTexture, processedTexCoords);\n  }\n  var metallicRoughnessTexture = material === null || material === void 0 ? void 0 : (_material$pbrMetallic2 = material.pbrMetallicRoughness) === null || _material$pbrMetallic2 === void 0 ? void 0 : _material$pbrMetallic2.metallicRoughnessTexture;\n  if (metallicRoughnessTexture) {\n    transformPrimitives(gltfData, materialIndex, metallicRoughnessTexture, processedTexCoords);\n  }\n}\nfunction transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {\n  var transformParameters = getTransformParameters(texture, processedTexCoords);\n  if (!transformParameters) {\n    return;\n  }\n  var meshes = gltfData.json.meshes || [];\n  var _iterator = _createForOfIteratorHelper(meshes),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var mesh = _step.value;\n      var _iterator2 = _createForOfIteratorHelper(mesh.primitives),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var primitive = _step2.value;\n          var material = primitive.material;\n          if (Number.isFinite(material) && materialIndex === material) {\n            transformPrimitive(gltfData, primitive, transformParameters);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nfunction getTransformParameters(texture, processedTexCoords) {\n  var _texture$extensions;\n  var textureInfo = (_texture$extensions = texture.extensions) === null || _texture$extensions === void 0 ? void 0 : _texture$extensions[EXT_MESHOPT_TRANSFORM];\n  var _texture$texCoord = texture.texCoord,\n    originalTexCoord = _texture$texCoord === void 0 ? 0 : _texture$texCoord;\n  var _textureInfo$texCoord = textureInfo.texCoord,\n    texCoord = _textureInfo$texCoord === void 0 ? originalTexCoord : _textureInfo$texCoord;\n  var isProcessed = processedTexCoords.findIndex(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      original = _ref2[0],\n      newTexCoord = _ref2[1];\n    return original === originalTexCoord && newTexCoord === texCoord;\n  }) !== -1;\n  if (!isProcessed) {\n    var matrix = makeTransformationMatrix(textureInfo);\n    if (originalTexCoord !== texCoord) {\n      texture.texCoord = texCoord;\n    }\n    processedTexCoords.push([originalTexCoord, texCoord]);\n    return {\n      originalTexCoord: originalTexCoord,\n      texCoord: texCoord,\n      matrix: matrix\n    };\n  }\n  return null;\n}\nfunction transformPrimitive(gltfData, primitive, transformParameters) {\n  var originalTexCoord = transformParameters.originalTexCoord,\n    texCoord = transformParameters.texCoord,\n    matrix = transformParameters.matrix;\n  var texCoordAccessor = primitive.attributes[\"TEXCOORD_\".concat(originalTexCoord)];\n  if (Number.isFinite(texCoordAccessor)) {\n    var _gltfData$json$access;\n    var accessor = (_gltfData$json$access = gltfData.json.accessors) === null || _gltfData$json$access === void 0 ? void 0 : _gltfData$json$access[texCoordAccessor];\n    if (accessor && accessor.bufferView) {\n      var _gltfData$json$buffer;\n      var bufferView = (_gltfData$json$buffer = gltfData.json.bufferViews) === null || _gltfData$json$buffer === void 0 ? void 0 : _gltfData$json$buffer[accessor.bufferView];\n      if (bufferView) {\n        var _gltfData$buffers$buf = gltfData.buffers[bufferView.buffer],\n          arrayBuffer = _gltfData$buffers$buf.arrayBuffer,\n          bufferByteOffset = _gltfData$buffers$buf.byteOffset;\n        var byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);\n        var _getAccessorArrayType = getAccessorArrayTypeAndLength(accessor, bufferView),\n          ArrayType = _getAccessorArrayType.ArrayType,\n          length = _getAccessorArrayType.length;\n        var bytes = BYTES[accessor.componentType];\n        var components = COMPONENTS[accessor.type];\n        var elementAddressScale = bufferView.byteStride || bytes * components;\n        var result = new Float32Array(length);\n        for (var i = 0; i < accessor.count; i++) {\n          var uv = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, 2);\n          scratchVector.set(uv[0], uv[1], 1);\n          scratchVector.transformByMatrix3(matrix);\n          result.set([scratchVector[0], scratchVector[1]], i * components);\n        }\n        if (originalTexCoord === texCoord) {\n          updateGltf(accessor, bufferView, gltfData.buffers, result);\n        } else {\n          createAttribute(texCoord, accessor, primitive, gltfData, result);\n        }\n      }\n    }\n  }\n}\nfunction updateGltf(accessor, bufferView, buffers, newTexCoordArray) {\n  accessor.componentType = 5126;\n  buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  bufferView.buffer = buffers.length - 1;\n  bufferView.byteLength = newTexCoordArray.buffer.byteLength;\n  bufferView.byteOffset = 0;\n  delete bufferView.byteStride;\n}\nfunction createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {\n  gltfData.buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  var bufferViews = gltfData.json.bufferViews;\n  if (!bufferViews) {\n    return;\n  }\n  bufferViews.push({\n    buffer: gltfData.buffers.length - 1,\n    byteLength: newTexCoordArray.buffer.byteLength,\n    byteOffset: 0\n  });\n  var accessors = gltfData.json.accessors;\n  if (!accessors) {\n    return;\n  }\n  accessors.push({\n    bufferView: (bufferViews === null || bufferViews === void 0 ? void 0 : bufferViews.length) - 1,\n    byteOffset: 0,\n    componentType: 5126,\n    count: originalAccessor.count,\n    type: 'VEC2'\n  });\n  primitive.attributes[\"TEXCOORD_\".concat(newTexCoord)] = accessors.length - 1;\n}\nfunction makeTransformationMatrix(extensionData) {\n  var _extensionData$offset = extensionData.offset,\n    offset = _extensionData$offset === void 0 ? [0, 0] : _extensionData$offset,\n    _extensionData$rotati = extensionData.rotation,\n    rotation = _extensionData$rotati === void 0 ? 0 : _extensionData$rotati,\n    _extensionData$scale = extensionData.scale,\n    scale = _extensionData$scale === void 0 ? [1, 1] : _extensionData$scale;\n  var translationMatirx = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);\n  var rotationMatirx = scratchRotationMatrix.set(Math.cos(rotation), Math.sin(rotation), 0, -Math.sin(rotation), Math.cos(rotation), 0, 0, 0, 1);\n  var scaleMatrix = scratchScaleMatrix.set(scale[0], 0, 0, 0, scale[1], 0, 0, 0, 1);\n  return translationMatirx.multiplyRight(rotationMatirx).multiplyRight(scaleMatrix);\n}","map":{"version":3,"names":["Vector3","Matrix3","getAccessorArrayTypeAndLength","BYTES","COMPONENTS","GLTFScenegraph","EXT_MESHOPT_TRANSFORM","name","scratchVector","scratchRotationMatrix","scratchScaleMatrix","decode","_x","_x2","_decode","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","gltfData","options","gltfScenegraph","extension","materials","i","wrap","_callee$","_context","prev","next","getExtension","abrupt","json","length","transformTexCoords","stop","materialIndex","_gltfData$json$materi","_material$pbrMetallic","_material$pbrMetallic2","processedTexCoords","material","baseColorTexture","pbrMetallicRoughness","transformPrimitives","emisiveTexture","emissiveTexture","normalTexture","occlusionTexture","metallicRoughnessTexture","texture","transformParameters","getTransformParameters","meshes","_iterator","_createForOfIteratorHelper","_step","s","n","done","mesh","value","_iterator2","primitives","_step2","primitive","Number","isFinite","transformPrimitive","err","e","f","_texture$extensions","textureInfo","extensions","_texture$texCoord","texCoord","originalTexCoord","_textureInfo$texCoord","isProcessed","findIndex","_ref","_ref2","_slicedToArray","original","newTexCoord","matrix","makeTransformationMatrix","push","texCoordAccessor","attributes","concat","_gltfData$json$access","accessor","accessors","bufferView","_gltfData$json$buffer","bufferViews","_gltfData$buffers$buf","buffers","buffer","arrayBuffer","bufferByteOffset","byteOffset","_getAccessorArrayType","ArrayType","bytes","componentType","components","type","elementAddressScale","byteStride","result","Float32Array","count","uv","set","transformByMatrix3","updateGltf","createAttribute","newTexCoordArray","byteLength","originalAccessor","extensionData","_extensionData$offset","offset","_extensionData$rotati","rotation","_extensionData$scale","scale","translationMatirx","rotationMatirx","Math","cos","sin","scaleMatrix","multiplyRight"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/gltf/src/lib/extensions/KHR_texture_transform.ts"],"sourcesContent":["/**\n * https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md\n */\n\nimport {Vector3, Matrix3} from '@math.gl/core';\nimport type {GLTFMeshPrimitive, GLTFWithBuffers} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\nimport {BYTES, COMPONENTS} from '../gltf-utils/gltf-constants';\nimport {\n  Accessor,\n  BufferView,\n  MaterialNormalTextureInfo,\n  MaterialOcclusionTextureInfo,\n  TextureInfo as GLTFTextureInfo\n} from '../types/gltf-json-schema';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\n/** Extension name */\nconst EXT_MESHOPT_TRANSFORM = 'KHR_texture_transform';\n\nexport const name = EXT_MESHOPT_TRANSFORM;\n\nconst scratchVector = new Vector3();\nconst scratchRotationMatrix = new Matrix3();\nconst scratchScaleMatrix = new Matrix3();\n\n/** Extension textureInfo https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates */\ntype TextureInfo = {\n  /** The offset of the UV coordinate origin as a factor of the texture dimensions. */\n  offset?: [number, number];\n  /** Rotate the UVs by this many radians counter-clockwise around the origin. This is equivalent to a similar rotation of the image clockwise. */\n  rotation?: number;\n  /** The scale factor applied to the components of the UV coordinates. */\n  scale?: [number, number];\n  /** Overrides the textureInfo texCoord value if supplied, and if this extension is supported. */\n  texCoord?: number;\n};\n/** Intersection of all GLTF textures */\ntype CompoundGLTFTextureInfo = GLTFTextureInfo &\n  MaterialNormalTextureInfo &\n  MaterialOcclusionTextureInfo;\n/** Parameters for TEXCOORD transformation */\ntype TransformParameters = {\n  /** Original texCoord value https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#_textureinfo_texcoord */\n  originalTexCoord: number;\n  /** New texCoord value from extension https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates */\n  texCoord: number;\n  /** Transformation matrix */\n  matrix: Matrix3;\n};\n\n/**\n * The extension entry to process the transformation\n * @param gltfData gltf buffers and json\n * @param options GLTFLoader options\n */\nexport async function decode(gltfData: GLTFWithBuffers, options: GLTFLoaderOptions) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const extension = gltfScenegraph.getExtension(EXT_MESHOPT_TRANSFORM);\n  if (!extension) {\n    return;\n  }\n  const materials = gltfData.json.materials || [];\n  for (let i = 0; i < materials.length; i++) {\n    transformTexCoords(i, gltfData);\n  }\n}\n\n/**\n * Transform TEXCOORD by material\n * @param materialIndex processing material index\n * @param gltfData gltf buffers and json\n */\nfunction transformTexCoords(materialIndex: number, gltfData: GLTFWithBuffers): void {\n  // Save processed texCoords in order no to process the same twice\n  const processedTexCoords: [number, number][] = [];\n  const material = gltfData.json.materials?.[materialIndex];\n  const baseColorTexture = material?.pbrMetallicRoughness?.baseColorTexture;\n  if (baseColorTexture) {\n    transformPrimitives(gltfData, materialIndex, baseColorTexture, processedTexCoords);\n  }\n  const emisiveTexture = material?.emissiveTexture;\n  if (emisiveTexture) {\n    transformPrimitives(gltfData, materialIndex, emisiveTexture, processedTexCoords);\n  }\n  const normalTexture = material?.normalTexture;\n  if (normalTexture) {\n    transformPrimitives(gltfData, materialIndex, normalTexture, processedTexCoords);\n  }\n  const occlusionTexture = material?.occlusionTexture;\n  if (occlusionTexture) {\n    transformPrimitives(gltfData, materialIndex, occlusionTexture, processedTexCoords);\n  }\n  const metallicRoughnessTexture = material?.pbrMetallicRoughness?.metallicRoughnessTexture;\n  if (metallicRoughnessTexture) {\n    transformPrimitives(gltfData, materialIndex, metallicRoughnessTexture, processedTexCoords);\n  }\n}\n\n/**\n * Transform primitives of the particular material\n * @param gltfData gltf data\n * @param materialIndex primitives with this material will be transformed\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n */\nfunction transformPrimitives(\n  gltfData: GLTFWithBuffers,\n  materialIndex: number,\n  texture: CompoundGLTFTextureInfo,\n  processedTexCoords: [number, number][]\n) {\n  const transformParameters = getTransformParameters(texture, processedTexCoords);\n  if (!transformParameters) {\n    return;\n  }\n  const meshes = gltfData.json.meshes || [];\n  for (const mesh of meshes) {\n    for (const primitive of mesh.primitives) {\n      const material = primitive.material;\n      if (Number.isFinite(material) && materialIndex === material) {\n        transformPrimitive(gltfData, primitive, transformParameters);\n      }\n    }\n  }\n}\n\n/**\n * Get parameters for TEXCOORD transformation\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n * @returns texCoord couple and transformation matrix\n */\nfunction getTransformParameters(\n  texture: CompoundGLTFTextureInfo,\n  processedTexCoords: [number, number][]\n): TransformParameters | null {\n  const textureInfo = texture.extensions?.[EXT_MESHOPT_TRANSFORM];\n  const {texCoord: originalTexCoord = 0} = texture;\n  // If texCoord is not set in the extension, original attribute data will be replaced\n  const {texCoord = originalTexCoord} = textureInfo;\n  // Make sure that couple [originalTexCoord, extensionTexCoord] is not processed twice\n  const isProcessed =\n    processedTexCoords.findIndex(\n      ([original, newTexCoord]) => original === originalTexCoord && newTexCoord === texCoord\n    ) !== -1;\n  if (!isProcessed) {\n    const matrix = makeTransformationMatrix(textureInfo);\n    if (originalTexCoord !== texCoord) {\n      texture.texCoord = texCoord;\n    }\n    processedTexCoords.push([originalTexCoord, texCoord]);\n    return {originalTexCoord, texCoord, matrix};\n  }\n  return null;\n}\n\n/**\n * Transform `TEXCOORD_0` attribute in the primitive\n * @param gltfData gltf data\n * @param primitive primitive object\n * @param transformParameters texCoord couple and transformation matrix\n */\nfunction transformPrimitive(\n  gltfData: GLTFWithBuffers,\n  primitive: GLTFMeshPrimitive,\n  transformParameters: TransformParameters\n) {\n  const {originalTexCoord, texCoord, matrix} = transformParameters;\n  const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];\n  if (Number.isFinite(texCoordAccessor)) {\n    // Get accessor of the `TEXCOORD_0` attribute\n    const accessor = gltfData.json.accessors?.[texCoordAccessor];\n    if (accessor && accessor.bufferView) {\n      // Get `bufferView` of the `accessor`\n      const bufferView = gltfData.json.bufferViews?.[accessor.bufferView];\n      if (bufferView) {\n        // Get `arrayBuffer` the `bufferView` look at\n        const {arrayBuffer, byteOffset: bufferByteOffset} = gltfData.buffers[bufferView.buffer];\n        // Resulting byteOffset is sum of the buffer, accessor and bufferView byte offsets\n        const byteOffset =\n          (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);\n        // Deduce TypedArray type and its length from `accessor` and `bufferView` data\n        const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n        // Number of bytes each component occupies\n        const bytes = BYTES[accessor.componentType];\n        // Number of components. For the `TEXCOORD_0` with `VEC2` type, it must return 2\n        const components = COMPONENTS[accessor.type];\n        // Multiplier to calculate the address of the `TEXCOORD_0` element in the arrayBuffer\n        const elementAddressScale = bufferView.byteStride || bytes * components;\n        // Data transform to Float32Array\n        const result = new Float32Array(length);\n        for (let i = 0; i < accessor.count; i++) {\n          // Take [u, v] couple from the arrayBuffer\n          const uv = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, 2);\n          // Set and transform Vector3 per https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#overview\n          scratchVector.set(uv[0], uv[1], 1);\n          scratchVector.transformByMatrix3(matrix);\n          // Save result in Float32Array\n          result.set([scratchVector[0], scratchVector[1]], i * components);\n        }\n        // If texCoord the same, replace gltf structural data\n        if (originalTexCoord === texCoord) {\n          updateGltf(accessor, bufferView, gltfData.buffers, result);\n        } else {\n          // If texCoord change, create new attribute\n          createAttribute(texCoord, accessor, primitive, gltfData, result);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Update GLTF structural objects with new data as we create new `Float32Array` for `TEXCOORD_0`.\n * @param accessor accessor to change\n * @param bufferView bufferView to change\n * @param buffers binary buffers\n * @param newTexcoordArray typed array with data after transformation\n */\nfunction updateGltf(\n  accessor: Accessor,\n  bufferView: BufferView,\n  buffers: {arrayBuffer: ArrayBuffer; byteOffset: number; byteLength: number}[],\n  newTexCoordArray: Float32Array\n): void {\n  accessor.componentType = 5126;\n  buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  bufferView.buffer = buffers.length - 1;\n  bufferView.byteLength = newTexCoordArray.buffer.byteLength;\n  bufferView.byteOffset = 0;\n  delete bufferView.byteStride;\n}\n\n/**\n *\n * @param newTexCoord new `texCoord` value\n * @param originalAccessor original accessor object, that store data before transformation\n * @param primitive primitive object\n * @param gltfData gltf data\n * @param newTexCoordArray typed array with data after transformation\n * @returns\n */\nfunction createAttribute(\n  newTexCoord: number,\n  originalAccessor: Accessor,\n  primitive: GLTFMeshPrimitive,\n  gltfData: GLTFWithBuffers,\n  newTexCoordArray: Float32Array\n) {\n  gltfData.buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  const bufferViews = gltfData.json.bufferViews;\n  if (!bufferViews) {\n    return;\n  }\n  bufferViews.push({\n    buffer: gltfData.buffers.length - 1,\n    byteLength: newTexCoordArray.buffer.byteLength,\n    byteOffset: 0\n  });\n  const accessors = gltfData.json.accessors;\n  if (!accessors) {\n    return;\n  }\n  accessors.push({\n    bufferView: bufferViews?.length - 1,\n    byteOffset: 0,\n    componentType: 5126,\n    count: originalAccessor.count,\n    type: 'VEC2'\n  });\n  primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;\n}\n\n/**\n * Construct transformation matrix from the extension data (transition, rotation, scale)\n * @param extensionData extension data\n * @returns transformation matrix\n */\nfunction makeTransformationMatrix(extensionData: TextureInfo): Matrix3 {\n  const {offset = [0, 0], rotation = 0, scale = [1, 1]} = extensionData;\n  const translationMatirx = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);\n  const rotationMatirx = scratchRotationMatrix.set(\n    Math.cos(rotation),\n    Math.sin(rotation),\n    0,\n    -Math.sin(rotation),\n    Math.cos(rotation),\n    0,\n    0,\n    0,\n    1\n  );\n  const scaleMatrix = scratchScaleMatrix.set(scale[0], 0, 0, 0, scale[1], 0, 0, 0, 1);\n  return translationMatirx.multiplyRight(rotationMatirx).multiplyRight(scaleMatrix);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}