{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport createIntervalTree from '../vendor/intervalTree';\n\n// Position cache requirements:\n//   O(log(n)) lookup of cells to render for a given viewport size\n//   O(1) lookup of shortest measured column (so we know when to enter phase 1)\nvar PositionCache = /*#__PURE__*/\nfunction () {\n  function PositionCache() {\n    _classCallCheck(this, PositionCache);\n    _defineProperty(this, \"_columnSizeMap\", {});\n    _defineProperty(this, \"_intervalTree\", createIntervalTree());\n    _defineProperty(this, \"_leftMap\", {});\n  }\n  _createClass(PositionCache, [{\n    key: \"estimateTotalHeight\",\n    value: function estimateTotalHeight(cellCount, columnCount, defaultCellHeight) {\n      var unmeasuredCellCount = cellCount - this.count;\n      return this.tallestColumnSize + Math.ceil(unmeasuredCellCount / columnCount) * defaultCellHeight;\n    } // Render all cells visible within the viewport range defined.\n  }, {\n    key: \"range\",\n    value: function range(scrollTop, clientHeight, renderCallback) {\n      var _this = this;\n      this._intervalTree.queryInterval(scrollTop, scrollTop + clientHeight, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n          top = _ref2[0],\n          _ = _ref2[1],\n          index = _ref2[2];\n        return renderCallback(index, _this._leftMap[index], top);\n      });\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(index, left, top, height) {\n      this._intervalTree.insert([top, top + height, index]);\n      this._leftMap[index] = left;\n      var columnSizeMap = this._columnSizeMap;\n      var columnHeight = columnSizeMap[left];\n      if (columnHeight === undefined) {\n        columnSizeMap[left] = top + height;\n      } else {\n        columnSizeMap[left] = Math.max(columnHeight, top + height);\n      }\n    }\n  }, {\n    key: \"count\",\n    get: function get() {\n      return this._intervalTree.count;\n    }\n  }, {\n    key: \"shortestColumnSize\",\n    get: function get() {\n      var columnSizeMap = this._columnSizeMap;\n      var size = 0;\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[i];\n        size = size === 0 ? height : Math.min(size, height);\n      }\n      return size;\n    }\n  }, {\n    key: \"tallestColumnSize\",\n    get: function get() {\n      var columnSizeMap = this._columnSizeMap;\n      var size = 0;\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[i];\n        size = Math.max(size, height);\n      }\n      return size;\n    }\n  }]);\n  return PositionCache;\n}();\nexport { PositionCache as default };","map":{"version":3,"names":["_slicedToArray","_classCallCheck","_createClass","_defineProperty","createIntervalTree","PositionCache","key","value","estimateTotalHeight","cellCount","columnCount","defaultCellHeight","unmeasuredCellCount","count","tallestColumnSize","Math","ceil","range","scrollTop","clientHeight","renderCallback","_this","_intervalTree","queryInterval","_ref","_ref2","top","_","index","_leftMap","setPosition","left","height","insert","columnSizeMap","_columnSizeMap","columnHeight","undefined","max","get","size","i","min","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/react-virtualized/dist/es/Masonry/PositionCache.js"],"sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport createIntervalTree from '../vendor/intervalTree';\n\n// Position cache requirements:\n//   O(log(n)) lookup of cells to render for a given viewport size\n//   O(1) lookup of shortest measured column (so we know when to enter phase 1)\nvar PositionCache =\n/*#__PURE__*/\nfunction () {\n  function PositionCache() {\n    _classCallCheck(this, PositionCache);\n\n    _defineProperty(this, \"_columnSizeMap\", {});\n\n    _defineProperty(this, \"_intervalTree\", createIntervalTree());\n\n    _defineProperty(this, \"_leftMap\", {});\n  }\n\n  _createClass(PositionCache, [{\n    key: \"estimateTotalHeight\",\n    value: function estimateTotalHeight(cellCount, columnCount, defaultCellHeight) {\n      var unmeasuredCellCount = cellCount - this.count;\n      return this.tallestColumnSize + Math.ceil(unmeasuredCellCount / columnCount) * defaultCellHeight;\n    } // Render all cells visible within the viewport range defined.\n\n  }, {\n    key: \"range\",\n    value: function range(scrollTop, clientHeight, renderCallback) {\n      var _this = this;\n\n      this._intervalTree.queryInterval(scrollTop, scrollTop + clientHeight, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n            top = _ref2[0],\n            _ = _ref2[1],\n            index = _ref2[2];\n\n        return renderCallback(index, _this._leftMap[index], top);\n      });\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(index, left, top, height) {\n      this._intervalTree.insert([top, top + height, index]);\n\n      this._leftMap[index] = left;\n      var columnSizeMap = this._columnSizeMap;\n      var columnHeight = columnSizeMap[left];\n\n      if (columnHeight === undefined) {\n        columnSizeMap[left] = top + height;\n      } else {\n        columnSizeMap[left] = Math.max(columnHeight, top + height);\n      }\n    }\n  }, {\n    key: \"count\",\n    get: function get() {\n      return this._intervalTree.count;\n    }\n  }, {\n    key: \"shortestColumnSize\",\n    get: function get() {\n      var columnSizeMap = this._columnSizeMap;\n      var size = 0;\n\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[i];\n        size = size === 0 ? height : Math.min(size, height);\n      }\n\n      return size;\n    }\n  }, {\n    key: \"tallestColumnSize\",\n    get: function get() {\n      var columnSizeMap = this._columnSizeMap;\n      var size = 0;\n\n      for (var i in columnSizeMap) {\n        var height = columnSizeMap[i];\n        size = Math.max(size, height);\n      }\n\n      return size;\n    }\n  }]);\n\n  return PositionCache;\n}();\n\nexport { PositionCache as default };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}