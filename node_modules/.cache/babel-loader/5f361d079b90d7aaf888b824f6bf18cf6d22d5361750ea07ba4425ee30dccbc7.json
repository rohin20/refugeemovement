{"ast":null,"code":"import _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nexport function binaryToFeatureForAccesor(data, index) {\n  if (!data) {\n    return null;\n  }\n  var featureIndex = 'startIndices' in data ? data.startIndices[index] : index;\n  var geometryIndex = data.featureIds.value[featureIndex];\n  if (featureIndex !== -1) {\n    return getPropertiesForIndex(data, geometryIndex, featureIndex);\n  }\n  return null;\n}\nfunction getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {\n  var feature = {\n    properties: _objectSpread({}, data.properties[propertiesIndex])\n  };\n  for (var prop in data.numericProps) {\n    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];\n  }\n  return feature;\n}\nexport function calculatePickingColors(geojsonBinary, encodePickingColor) {\n  var pickingColors = {\n    points: null,\n    lines: null,\n    polygons: null\n  };\n  for (var key in pickingColors) {\n    var featureIds = geojsonBinary[key].globalFeatureIds.value;\n    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);\n    var pickingColor = [];\n    for (var i = 0; i < featureIds.length; i++) {\n      encodePickingColor(featureIds[i], pickingColor);\n      pickingColors[key][i * 3 + 0] = pickingColor[0];\n      pickingColors[key][i * 3 + 1] = pickingColor[1];\n      pickingColors[key][i * 3 + 2] = pickingColor[2];\n    }\n  }\n  return pickingColors;\n}","map":{"version":3,"names":["binaryToFeatureForAccesor","data","index","featureIndex","startIndices","geometryIndex","featureIds","value","getPropertiesForIndex","propertiesIndex","numericPropsIndex","feature","properties","_objectSpread","prop","numericProps","calculatePickingColors","geojsonBinary","encodePickingColor","pickingColors","points","lines","polygons","key","globalFeatureIds","Uint8ClampedArray","length","pickingColor","i"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/layers/src/geojson-layer/geojson-binary.ts"],"sourcesContent":["// This module implement some utility functions to work with\n// the geojson-binary format defined at loaders.gl:\n// https://github.com/visgl/loaders.gl/blob/master/modules/gis/docs/api-reference/geojson-to-binary.md\n\nimport {\n  BinaryFeatures,\n  BinaryLineFeatures,\n  BinaryPointFeatures,\n  BinaryPolygonFeatures,\n  Feature\n} from '@loaders.gl/schema';\n\nexport type BinaryFeatureTypes = BinaryPointFeatures | BinaryLineFeatures | BinaryPolygonFeatures;\n\ntype FeaureOnlyProperties = Pick<Feature, 'properties'>;\n\n/**\n * Return the feature for an accesor\n */\nexport function binaryToFeatureForAccesor(\n  data: BinaryFeatureTypes,\n  index: number\n): FeaureOnlyProperties | null {\n  if (!data) {\n    return null;\n  }\n\n  const featureIndex = 'startIndices' in data ? (data as any).startIndices[index] : index;\n  const geometryIndex = data.featureIds.value[featureIndex];\n\n  if (featureIndex !== -1) {\n    return getPropertiesForIndex(data, geometryIndex, featureIndex);\n  }\n\n  return null;\n}\n\nfunction getPropertiesForIndex(\n  data: BinaryFeatureTypes,\n  propertiesIndex: number,\n  numericPropsIndex: number\n): FeaureOnlyProperties {\n  const feature = {\n    properties: {...data.properties[propertiesIndex]}\n  };\n\n  for (const prop in data.numericProps) {\n    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];\n  }\n\n  return feature;\n}\n\n// Custom picking color to keep binary indexes\nexport function calculatePickingColors(\n  geojsonBinary: BinaryFeatures,\n  encodePickingColor: (id: number, result: number[]) => void\n): Record<string, Uint8ClampedArray | null> {\n  const pickingColors: Record<string, Uint8ClampedArray | null> = {\n    points: null,\n    lines: null,\n    polygons: null\n  };\n  for (const key in pickingColors) {\n    const featureIds = geojsonBinary[key].globalFeatureIds.value;\n    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);\n    const pickingColor = [];\n    for (let i = 0; i < featureIds.length; i++) {\n      encodePickingColor(featureIds[i], pickingColor);\n      pickingColors[key]![i * 3 + 0] = pickingColor[0];\n      pickingColors[key]![i * 3 + 1] = pickingColor[1];\n      pickingColors[key]![i * 3 + 2] = pickingColor[2];\n    }\n  }\n\n  return pickingColors;\n}\n"],"mappings":";AAmBA,OAAO,SAASA,yBAATA,CACLC,IADK,EAELC,KAFK,EAGwB;EAC7B,IAAI,CAACD,IAAL,EAAW;IACT,OAAO,IAAP;EACD;EAED,IAAME,YAAY,GAAG,kBAAkBF,IAAlB,GAA0BA,IAAD,CAAcG,YAAd,CAA2BF,KAA3B,CAAzB,GAA6DA,KAAlF;EACA,IAAMG,aAAa,GAAGJ,IAAI,CAACK,UAAL,CAAgBC,KAAhB,CAAsBJ,YAAtB,CAAtB;EAEA,IAAIA,YAAY,KAAK,CAAC,CAAtB,EAAyB;IACvB,OAAOK,qBAAqB,CAACP,IAAD,EAAOI,aAAP,EAAsBF,YAAtB,CAA5B;EACD;EAED,OAAO,IAAP;AACD;AAED,SAASK,qBAATA,CACEP,IADF,EAEEQ,eAFF,EAGEC,iBAHF,EAIwB;EACtB,IAAMC,OAAO,GAAG;IACdC,UAAU,EAAAC,aAAA,KAAMZ,IAAI,CAACW,UAAL,CAAgBH,eAAhB;EADF,CAAhB;EAIA,KAAK,IAAMK,IAAX,IAAmBb,IAAI,CAACc,YAAxB,EAAsC;IACpCJ,OAAO,CAACC,UAAR,CAAmBE,IAAnB,IAA2Bb,IAAI,CAACc,YAAL,CAAkBD,IAAlB,EAAwBP,KAAxB,CAA8BG,iBAA9B,CAA3B;EACD;EAED,OAAOC,OAAP;AACD;AAGD,OAAO,SAASK,sBAATA,CACLC,aADK,EAELC,kBAFK,EAGqC;EAC1C,IAAMC,aAAuD,GAAG;IAC9DC,MAAM,EAAE,IADsD;IAE9DC,KAAK,EAAE,IAFuD;IAG9DC,QAAQ,EAAE;EAHoD,CAAhE;EAKA,KAAK,IAAMC,GAAX,IAAkBJ,aAAlB,EAAiC;IAC/B,IAAMb,UAAU,GAAGW,aAAa,CAACM,GAAD,CAAb,CAAmBC,gBAAnB,CAAoCjB,KAAvD;IACAY,aAAa,CAACI,GAAD,CAAb,GAAqB,IAAIE,iBAAJ,CAAsBnB,UAAU,CAACoB,MAAX,GAAoB,CAA1C,CAArB;IACA,IAAMC,YAAY,GAAG,EAArB;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtB,UAAU,CAACoB,MAA/B,EAAuCE,CAAC,EAAxC,EAA4C;MAC1CV,kBAAkB,CAACZ,UAAU,CAACsB,CAAD,CAAX,EAAgBD,YAAhB,CAAlB;MACAR,aAAa,CAACI,GAAD,CAAb,CAAoBK,CAAC,GAAG,CAAJ,GAAQ,CAA5B,IAAiCD,YAAY,CAAC,CAAD,CAA7C;MACAR,aAAa,CAACI,GAAD,CAAb,CAAoBK,CAAC,GAAG,CAAJ,GAAQ,CAA5B,IAAiCD,YAAY,CAAC,CAAD,CAA7C;MACAR,aAAa,CAACI,GAAD,CAAb,CAAoBK,CAAC,GAAG,CAAJ,GAAQ,CAA5B,IAAiCD,YAAY,CAAC,CAAD,CAA7C;IACD;EACF;EAED,OAAOR,aAAP;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}