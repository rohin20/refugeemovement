{"ast":null,"code":"import _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar Martini = /*#__PURE__*/function () {\n  function Martini() {\n    var gridSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 257;\n    _classCallCheck(this, Martini);\n    this.gridSize = gridSize;\n    var tileSize = gridSize - 1;\n    if (tileSize & tileSize - 1) throw new Error(\"Expected grid size to be 2^n+1, got \".concat(gridSize, \".\"));\n    this.numTriangles = tileSize * tileSize * 2 - 2;\n    this.numParentTriangles = this.numTriangles - tileSize * tileSize;\n    this.indices = new Uint32Array(this.gridSize * this.gridSize);\n\n    // coordinates for all possible triangles in an RTIN tile\n    this.coords = new Uint16Array(this.numTriangles * 4);\n\n    // get triangle coordinates from its index in an implicit binary tree\n    for (var i = 0; i < this.numTriangles; i++) {\n      var id = i + 2;\n      var ax = 0,\n        ay = 0,\n        bx = 0,\n        by = 0,\n        cx = 0,\n        cy = 0;\n      if (id & 1) {\n        bx = by = cx = tileSize; // bottom-left triangle\n      } else {\n        ax = ay = cy = tileSize; // top-right triangle\n      }\n\n      while ((id >>= 1) > 1) {\n        var mx = ax + bx >> 1;\n        var my = ay + by >> 1;\n        if (id & 1) {\n          // left half\n          bx = ax;\n          by = ay;\n          ax = cx;\n          ay = cy;\n        } else {\n          // right half\n          ax = bx;\n          ay = by;\n          bx = cx;\n          by = cy;\n        }\n        cx = mx;\n        cy = my;\n      }\n      var k = i * 4;\n      this.coords[k + 0] = ax;\n      this.coords[k + 1] = ay;\n      this.coords[k + 2] = bx;\n      this.coords[k + 3] = by;\n    }\n  }\n  _createClass(Martini, [{\n    key: \"createTile\",\n    value: function createTile(terrain) {\n      return new Tile(terrain, this);\n    }\n  }]);\n  return Martini;\n}();\nexport { Martini as default };\nvar Tile = /*#__PURE__*/function () {\n  function Tile(terrain, martini) {\n    _classCallCheck(this, Tile);\n    var size = martini.gridSize;\n    if (terrain.length !== size * size) throw new Error(\"Expected terrain data of length \".concat(size * size, \" (\").concat(size, \" x \").concat(size, \"), got \").concat(terrain.length, \".\"));\n    this.terrain = terrain;\n    this.martini = martini;\n    this.errors = new Float32Array(terrain.length);\n    this.update();\n  }\n  _createClass(Tile, [{\n    key: \"update\",\n    value: function update() {\n      var _this$martini = this.martini,\n        numTriangles = _this$martini.numTriangles,\n        numParentTriangles = _this$martini.numParentTriangles,\n        coords = _this$martini.coords,\n        size = _this$martini.gridSize;\n      var terrain = this.terrain,\n        errors = this.errors;\n\n      // iterate over all possible triangles, starting from the smallest level\n      for (var i = numTriangles - 1; i >= 0; i--) {\n        var k = i * 4;\n        var ax = coords[k + 0];\n        var ay = coords[k + 1];\n        var bx = coords[k + 2];\n        var by = coords[k + 3];\n        var mx = ax + bx >> 1;\n        var my = ay + by >> 1;\n        var cx = mx + my - ay;\n        var cy = my + ax - mx;\n\n        // calculate error in the middle of the long edge of the triangle\n        var interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;\n        var middleIndex = my * size + mx;\n        var middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);\n        errors[middleIndex] = Math.max(errors[middleIndex], middleError);\n        if (i < numParentTriangles) {\n          // bigger triangles; accumulate error with children\n          var leftChildIndex = (ay + cy >> 1) * size + (ax + cx >> 1);\n          var rightChildIndex = (by + cy >> 1) * size + (bx + cx >> 1);\n          errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);\n        }\n      }\n    }\n  }, {\n    key: \"getMesh\",\n    value: function getMesh() {\n      var maxError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var _this$martini2 = this.martini,\n        size = _this$martini2.gridSize,\n        indices = _this$martini2.indices;\n      var errors = this.errors;\n      var numVertices = 0;\n      var numTriangles = 0;\n      var max = size - 1;\n\n      // use an index grid to keep track of vertices that were already used to avoid duplication\n      indices.fill(0);\n\n      // retrieve mesh in two stages that both traverse the error map:\n      // - countElements: find used vertices (and assign each an index), and count triangles (for minimum allocation)\n      // - processTriangle: fill the allocated vertices & triangles typed arrays\n\n      function countElements(ax, ay, bx, by, cx, cy) {\n        var mx = ax + bx >> 1;\n        var my = ay + by >> 1;\n        if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {\n          countElements(cx, cy, ax, ay, mx, my);\n          countElements(bx, by, cx, cy, mx, my);\n        } else {\n          indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;\n          indices[by * size + bx] = indices[by * size + bx] || ++numVertices;\n          indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;\n          numTriangles++;\n        }\n      }\n      countElements(0, 0, max, max, max, 0);\n      countElements(max, max, 0, 0, 0, max);\n      var vertices = new Uint16Array(numVertices * 2);\n      var triangles = new Uint32Array(numTriangles * 3);\n      var triIndex = 0;\n      function processTriangle(ax, ay, bx, by, cx, cy) {\n        var mx = ax + bx >> 1;\n        var my = ay + by >> 1;\n        if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {\n          // triangle doesn't approximate the surface well enough; drill down further\n          processTriangle(cx, cy, ax, ay, mx, my);\n          processTriangle(bx, by, cx, cy, mx, my);\n        } else {\n          // add a triangle\n          var a = indices[ay * size + ax] - 1;\n          var b = indices[by * size + bx] - 1;\n          var c = indices[cy * size + cx] - 1;\n          vertices[2 * a] = ax;\n          vertices[2 * a + 1] = ay;\n          vertices[2 * b] = bx;\n          vertices[2 * b + 1] = by;\n          vertices[2 * c] = cx;\n          vertices[2 * c + 1] = cy;\n          triangles[triIndex++] = a;\n          triangles[triIndex++] = b;\n          triangles[triIndex++] = c;\n        }\n      }\n      processTriangle(0, 0, max, max, max, 0);\n      processTriangle(max, max, 0, 0, 0, max);\n      return {\n        vertices: vertices,\n        triangles: triangles\n      };\n    }\n  }]);\n  return Tile;\n}();","map":{"version":3,"names":["Martini","gridSize","arguments","length","undefined","_classCallCheck","tileSize","Error","concat","numTriangles","numParentTriangles","indices","Uint32Array","coords","Uint16Array","i","id","ax","ay","bx","by","cx","cy","mx","my","k","_createClass","key","value","createTile","terrain","Tile","default","martini","size","errors","Float32Array","update","_this$martini","interpolatedHeight","middleIndex","middleError","Math","abs","max","leftChildIndex","rightChildIndex","getMesh","maxError","_this$martini2","numVertices","fill","countElements","vertices","triangles","triIndex","processTriangle","a","b","c"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@mapbox/martini/index.js"],"sourcesContent":["\nexport default class Martini {\n    constructor(gridSize = 257) {\n        this.gridSize = gridSize;\n        const tileSize = gridSize - 1;\n        if (tileSize & (tileSize - 1)) throw new Error(\n            `Expected grid size to be 2^n+1, got ${gridSize}.`);\n\n        this.numTriangles = tileSize * tileSize * 2 - 2;\n        this.numParentTriangles = this.numTriangles - tileSize * tileSize;\n\n        this.indices = new Uint32Array(this.gridSize * this.gridSize);\n\n        // coordinates for all possible triangles in an RTIN tile\n        this.coords = new Uint16Array(this.numTriangles * 4);\n\n        // get triangle coordinates from its index in an implicit binary tree\n        for (let i = 0; i < this.numTriangles; i++) {\n            let id = i + 2;\n            let ax = 0, ay = 0, bx = 0, by = 0, cx = 0, cy = 0;\n            if (id & 1) {\n                bx = by = cx = tileSize; // bottom-left triangle\n            } else {\n                ax = ay = cy = tileSize; // top-right triangle\n            }\n            while ((id >>= 1) > 1) {\n                const mx = (ax + bx) >> 1;\n                const my = (ay + by) >> 1;\n\n                if (id & 1) { // left half\n                    bx = ax; by = ay;\n                    ax = cx; ay = cy;\n                } else { // right half\n                    ax = bx; ay = by;\n                    bx = cx; by = cy;\n                }\n                cx = mx; cy = my;\n            }\n            const k = i * 4;\n            this.coords[k + 0] = ax;\n            this.coords[k + 1] = ay;\n            this.coords[k + 2] = bx;\n            this.coords[k + 3] = by;\n        }\n    }\n\n    createTile(terrain) {\n        return new Tile(terrain, this);\n    }\n}\n\nclass Tile {\n    constructor(terrain, martini) {\n        const size = martini.gridSize;\n        if (terrain.length !== size * size) throw new Error(\n            `Expected terrain data of length ${size * size} (${size} x ${size}), got ${terrain.length}.`);\n\n        this.terrain = terrain;\n        this.martini = martini;\n        this.errors = new Float32Array(terrain.length);\n        this.update();\n    }\n\n    update() {\n        const {numTriangles, numParentTriangles, coords, gridSize: size} = this.martini;\n        const {terrain, errors} = this;\n\n        // iterate over all possible triangles, starting from the smallest level\n        for (let i = numTriangles - 1; i >= 0; i--) {\n            const k = i * 4;\n            const ax = coords[k + 0];\n            const ay = coords[k + 1];\n            const bx = coords[k + 2];\n            const by = coords[k + 3];\n            const mx = (ax + bx) >> 1;\n            const my = (ay + by) >> 1;\n            const cx = mx + my - ay;\n            const cy = my + ax - mx;\n\n            // calculate error in the middle of the long edge of the triangle\n            const interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;\n            const middleIndex = my * size + mx;\n            const middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);\n\n            errors[middleIndex] = Math.max(errors[middleIndex], middleError);\n\n            if (i < numParentTriangles) { // bigger triangles; accumulate error with children\n                const leftChildIndex = ((ay + cy) >> 1) * size + ((ax + cx) >> 1);\n                const rightChildIndex = ((by + cy) >> 1) * size + ((bx + cx) >> 1);\n                errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);\n            }\n        }\n    }\n\n    getMesh(maxError = 0) {\n        const {gridSize: size, indices} = this.martini;\n        const {errors} = this;\n        let numVertices = 0;\n        let numTriangles = 0;\n        const max = size - 1;\n\n        // use an index grid to keep track of vertices that were already used to avoid duplication\n        indices.fill(0);\n\n        // retrieve mesh in two stages that both traverse the error map:\n        // - countElements: find used vertices (and assign each an index), and count triangles (for minimum allocation)\n        // - processTriangle: fill the allocated vertices & triangles typed arrays\n\n        function countElements(ax, ay, bx, by, cx, cy) {\n            const mx = (ax + bx) >> 1;\n            const my = (ay + by) >> 1;\n\n            if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {\n                countElements(cx, cy, ax, ay, mx, my);\n                countElements(bx, by, cx, cy, mx, my);\n            } else {\n                indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;\n                indices[by * size + bx] = indices[by * size + bx] || ++numVertices;\n                indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;\n                numTriangles++;\n            }\n        }\n        countElements(0, 0, max, max, max, 0);\n        countElements(max, max, 0, 0, 0, max);\n\n        const vertices = new Uint16Array(numVertices * 2);\n        const triangles = new Uint32Array(numTriangles * 3);\n        let triIndex = 0;\n\n        function processTriangle(ax, ay, bx, by, cx, cy) {\n            const mx = (ax + bx) >> 1;\n            const my = (ay + by) >> 1;\n\n            if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {\n                // triangle doesn't approximate the surface well enough; drill down further\n                processTriangle(cx, cy, ax, ay, mx, my);\n                processTriangle(bx, by, cx, cy, mx, my);\n\n            } else {\n                // add a triangle\n                const a = indices[ay * size + ax] - 1;\n                const b = indices[by * size + bx] - 1;\n                const c = indices[cy * size + cx] - 1;\n\n                vertices[2 * a] = ax;\n                vertices[2 * a + 1] = ay;\n\n                vertices[2 * b] = bx;\n                vertices[2 * b + 1] = by;\n\n                vertices[2 * c] = cx;\n                vertices[2 * c + 1] = cy;\n\n                triangles[triIndex++] = a;\n                triangles[triIndex++] = b;\n                triangles[triIndex++] = c;\n            }\n        }\n        processTriangle(0, 0, max, max, max, 0);\n        processTriangle(max, max, 0, 0, 0, max);\n\n        return {vertices, triangles};\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}