{"ast":null,"code":"import { assert } from '@luma.gl/webgl';\nimport { combineInjects, getQualifierDetails, typeToChannelSuffix } from '@luma.gl/shadertools';\nvar SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';\nvar SIZE_UNIFORM_PREFIX = 'transform_uSize_';\nvar VS_POS_VARIABLE = 'transform_position';\nexport function updateForTextures(_ref) {\n  var vs = _ref.vs,\n    sourceTextureMap = _ref.sourceTextureMap,\n    targetTextureVarying = _ref.targetTextureVarying,\n    targetTexture = _ref.targetTexture;\n  var texAttributeNames = Object.keys(sourceTextureMap);\n  var sourceCount = texAttributeNames.length;\n  var targetTextureType = null;\n  var samplerTextureMap = {};\n  var updatedVs = vs;\n  var finalInject = {};\n  if (sourceCount > 0 || targetTextureVarying) {\n    var vsLines = updatedVs.split('\\n');\n    var updateVsLines = vsLines.slice();\n    vsLines.forEach(function (line, index, lines) {\n      if (sourceCount > 0) {\n        var updated = processAttributeDefinition(line, sourceTextureMap);\n        if (updated) {\n          var updatedLine = updated.updatedLine,\n            inject = updated.inject;\n          updateVsLines[index] = updatedLine;\n          finalInject = combineInjects([finalInject, inject]);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n    if (targetTextureVarying) {\n      assert(targetTexture);\n      var sizeName = \"\".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);\n      var uniformDeclaration = \"uniform vec2 \".concat(sizeName, \";\\n\");\n      var posInstructions = \"     vec2 \".concat(VS_POS_VARIABLE, \" = transform_getPos(\").concat(sizeName, \");\\n     gl_Position = vec4(\").concat(VS_POS_VARIABLE, \", 0, 1.);\\n\");\n      var inject = {\n        'vs:#decl': uniformDeclaration,\n        'vs:#main-start': posInstructions\n      };\n      finalInject = combineInjects([finalInject, inject]);\n    }\n    updatedVs = updateVsLines.join('\\n');\n  }\n  return {\n    vs: updatedVs,\n    targetTextureType: targetTextureType,\n    inject: finalInject,\n    samplerTextureMap: samplerTextureMap\n  };\n}\nexport function getSizeUniforms(_ref2) {\n  var sourceTextureMap = _ref2.sourceTextureMap,\n    targetTextureVarying = _ref2.targetTextureVarying,\n    targetTexture = _ref2.targetTexture;\n  var uniforms = {};\n  var width;\n  var height;\n  if (targetTextureVarying) {\n    width = targetTexture.width;\n    height = targetTexture.height;\n    uniforms[\"\".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];\n  }\n  for (var textureName in sourceTextureMap) {\n    var _sourceTextureMap$tex = sourceTextureMap[textureName];\n    width = _sourceTextureMap$tex.width;\n    height = _sourceTextureMap$tex.height;\n    uniforms[\"\".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];\n  }\n  return uniforms;\n}\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, ['attribute', 'in']);\n}\nfunction getSamplerDeclerations(textureName) {\n  var samplerName = \"\".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);\n  var sizeName = \"\".concat(SIZE_UNIFORM_PREFIX).concat(textureName);\n  var uniformDeclerations = \"  uniform sampler2D \".concat(samplerName, \";\\n  uniform vec2 \").concat(sizeName, \";\");\n  return {\n    samplerName: samplerName,\n    sizeName: sizeName,\n    uniformDeclerations: uniformDeclerations\n  };\n}\nexport function getVaryingType(line, varying) {\n  var qualaiferDetails = getQualifierDetails(line, ['varying', 'out']);\n  if (!qualaiferDetails) {\n    return null;\n  }\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n}\nexport function processAttributeDefinition(line, textureMap) {\n  var samplerTextureMap = {};\n  var attributeData = getAttributeDefinition(line);\n  if (!attributeData) {\n    return null;\n  }\n  var type = attributeData.type,\n    name = attributeData.name;\n  if (name && textureMap[name]) {\n    var updatedLine = \"// \".concat(line, \" => Replaced by Transform with a sampler\");\n    var _getSamplerDecleratio = getSamplerDeclerations(name),\n      samplerName = _getSamplerDecleratio.samplerName,\n      sizeName = _getSamplerDecleratio.sizeName,\n      uniformDeclerations = _getSamplerDecleratio.uniformDeclerations;\n    var channels = typeToChannelSuffix(type);\n    var sampleInstruction = \"  \".concat(type, \" \").concat(name, \" = transform_getInput(\").concat(samplerName, \", \").concat(sizeName, \").\").concat(channels, \";\\n\");\n    samplerTextureMap[samplerName] = name;\n    var inject = {\n      'vs:#decl': uniformDeclerations,\n      'vs:#main-start': sampleInstruction\n    };\n    return {\n      updatedLine: updatedLine,\n      inject: inject,\n      samplerTextureMap: samplerTextureMap\n    };\n  }\n  return null;\n}","map":{"version":3,"names":["assert","combineInjects","getQualifierDetails","typeToChannelSuffix","SAMPLER_UNIFORM_PREFIX","SIZE_UNIFORM_PREFIX","VS_POS_VARIABLE","updateForTextures","_ref","vs","sourceTextureMap","targetTextureVarying","targetTexture","texAttributeNames","Object","keys","sourceCount","length","targetTextureType","samplerTextureMap","updatedVs","finalInject","vsLines","split","updateVsLines","slice","forEach","line","index","lines","updated","processAttributeDefinition","updatedLine","inject","assign","getVaryingType","sizeName","concat","uniformDeclaration","posInstructions","join","getSizeUniforms","_ref2","uniforms","width","height","textureName","_sourceTextureMap$tex","getAttributeDefinition","getSamplerDeclerations","samplerName","uniformDeclerations","varying","qualaiferDetails","name","type","textureMap","attributeData","_getSamplerDecleratio","channels","sampleInstruction"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@luma.gl/engine/src/transform/transform-shader-utils.js"],"sourcesContent":["import {assert} from '@luma.gl/webgl';\nimport {combineInjects, getQualifierDetails, typeToChannelSuffix} from '@luma.gl/shadertools';\n\nconst SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';\nconst SIZE_UNIFORM_PREFIX = 'transform_uSize_';\nconst VS_POS_VARIABLE = 'transform_position';\n\n// Scan provided vertex shader\n// for each texture attribute, inject sampler instructions and build uniforms for sampler\n// for texture target, get varying type and inject position instruction\nexport function updateForTextures({vs, sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const texAttributeNames = Object.keys(sourceTextureMap);\n  let sourceCount = texAttributeNames.length;\n  let targetTextureType = null;\n  const samplerTextureMap = {};\n  let updatedVs = vs;\n  let finalInject = {};\n\n  if (sourceCount > 0 || targetTextureVarying) {\n    const vsLines = updatedVs.split('\\n');\n    const updateVsLines = vsLines.slice();\n    vsLines.forEach((line, index, lines) => {\n      // TODO add early exit\n      if (sourceCount > 0) {\n        const updated = processAttributeDefinition(line, sourceTextureMap);\n        if (updated) {\n          const {updatedLine, inject} = updated;\n          updateVsLines[index] = updatedLine;\n          // sampleInstructions.push(sampleInstruction);\n          finalInject = combineInjects([finalInject, inject]);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n\n    if (targetTextureVarying) {\n      assert(targetTexture);\n      const sizeName = `${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`;\n\n      const uniformDeclaration = `uniform vec2 ${sizeName};\\n`;\n      const posInstructions = `\\\n     vec2 ${VS_POS_VARIABLE} = transform_getPos(${sizeName});\n     gl_Position = vec4(${VS_POS_VARIABLE}, 0, 1.);\\n`;\n      const inject = {\n        'vs:#decl': uniformDeclaration,\n        'vs:#main-start': posInstructions\n      };\n      finalInject = combineInjects([finalInject, inject]);\n    }\n    updatedVs = updateVsLines.join('\\n');\n  }\n  return {\n    // updated vertex shader (commented texture attribute definition)\n    vs: updatedVs,\n    // type (float, vec2, vec3 of vec4) target texture varying\n    targetTextureType,\n    // required vertex and fragment shader injects\n    inject: finalInject,\n    // map of sampler name to texture name, can be used to set attributes\n    // usefull when swapping textures, as source and destination texture change when swap is called.\n    samplerTextureMap\n  };\n}\n\n// builds and returns an object contaning size uniform for each texture\nexport function getSizeUniforms({sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const uniforms = {};\n  let width;\n  let height;\n  if (targetTextureVarying) {\n    ({width, height} = targetTexture);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`] = [width, height];\n  }\n  for (const textureName in sourceTextureMap) {\n    ({width, height} = sourceTextureMap[textureName]);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${textureName}`] = [width, height];\n  }\n  return uniforms;\n}\n\n// Checks if provided line is defining an attribute, if so returns details otherwise null\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, ['attribute', 'in']);\n}\n\nfunction getSamplerDeclerations(textureName) {\n  const samplerName = `${SAMPLER_UNIFORM_PREFIX}${textureName}`;\n  const sizeName = `${SIZE_UNIFORM_PREFIX}${textureName}`;\n  const uniformDeclerations = `\\\n  uniform sampler2D ${samplerName};\n  uniform vec2 ${sizeName};`;\n  return {samplerName, sizeName, uniformDeclerations};\n}\n\n// Return size (float, vec2 etc) of a given varying, null if doens't exist.\nexport function getVaryingType(line, varying) {\n  const qualaiferDetails = getQualifierDetails(line, ['varying', 'out']);\n  if (!qualaiferDetails) {\n    return null;\n  }\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n}\n\n// build required definitions, sample instructions for each texture attribute\nexport function processAttributeDefinition(line, textureMap) {\n  const samplerTextureMap = {};\n  const attributeData = getAttributeDefinition(line);\n  if (!attributeData) {\n    return null;\n  }\n  const {type, name} = attributeData;\n  if (name && textureMap[name]) {\n    // eslint-disable-next-line no-useless-escape\n    const updatedLine = `\\// ${line} => Replaced by Transform with a sampler`;\n    const {samplerName, sizeName, uniformDeclerations} = getSamplerDeclerations(name);\n\n    const channels = typeToChannelSuffix(type);\n    const sampleInstruction = `  ${type} ${name} = transform_getInput(${samplerName}, ${sizeName}).${channels};\\n`;\n\n    samplerTextureMap[samplerName] = name;\n    const inject = {\n      'vs:#decl': uniformDeclerations,\n      'vs:#main-start': sampleInstruction\n    };\n\n    // samplerNameMap\n    return {\n      // update vertex shader line.\n      updatedLine,\n      // inject object with sampler instructions.\n      inject,\n      // sampler name to texture name map\n      samplerTextureMap\n    };\n  }\n  return null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}