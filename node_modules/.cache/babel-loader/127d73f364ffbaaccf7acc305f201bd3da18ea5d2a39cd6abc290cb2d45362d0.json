{"ast":null,"code":"import _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { DracoLoader } from '@loaders.gl/draco';\nimport { GL } from '@loaders.gl/math';\nimport { Vector3 } from '@math.gl/core';\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport { parse3DTileHeaderSync } from './helpers/parse-3d-tile-header';\nimport { parse3DTileTablesHeaderSync, parse3DTileTablesSync } from './helpers/parse-3d-tile-tables';\nimport { normalize3DTileColorAttribute } from './helpers/normalize-3d-tile-colors';\nimport { normalize3DTileNormalAttribute } from './helpers/normalize-3d-tile-normals';\nimport { normalize3DTilePositionAttribute } from './helpers/normalize-3d-tile-positions';\nexport function parsePointCloud3DTile(_x, _x2, _x3, _x4, _x5) {\n  return _parsePointCloud3DTile.apply(this, arguments);\n}\nfunction _parsePointCloud3DTile() {\n  _parsePointCloud3DTile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tile, arrayBuffer, byteOffset, options, context) {\n    var _parsePointCloudTable, featureTable, batchTable;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n          byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n          byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n          initializeTile(tile);\n          _parsePointCloudTable = parsePointCloudTables(tile), featureTable = _parsePointCloudTable.featureTable, batchTable = _parsePointCloudTable.batchTable;\n          _context.next = 7;\n          return parseDraco(tile, featureTable, batchTable, options, context);\n        case 7:\n          parsePositions(tile, featureTable, options);\n          parseColors(tile, featureTable, batchTable);\n          parseNormals(tile, featureTable);\n          return _context.abrupt(\"return\", byteOffset);\n        case 11:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _parsePointCloud3DTile.apply(this, arguments);\n}\nfunction initializeTile(tile) {\n  tile.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  };\n  tile.isQuantized = false;\n  tile.isTranslucent = false;\n  tile.isRGB565 = false;\n  tile.isOctEncoded16P = false;\n}\nfunction parsePointCloudTables(tile) {\n  var featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n  var pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');\n  if (!Number.isFinite(pointsLength)) {\n    throw new Error('POINTS_LENGTH must be defined');\n  }\n  featureTable.featuresLength = pointsLength;\n  tile.featuresLength = pointsLength;\n  tile.pointsLength = pointsLength;\n  tile.pointCount = pointsLength;\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n  var batchTable = parseBatchIds(tile, featureTable);\n  return {\n    featureTable: featureTable,\n    batchTable: batchTable\n  };\n}\nfunction parsePositions(tile, featureTable, options) {\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      var positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n      tile.isQuantized = true;\n      tile.quantizedRange = (1 << 16) - 1;\n      tile.quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL.FLOAT, 3);\n      if (!tile.quantizedVolumeScale) {\n        throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n      tile.quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL.FLOAT, 3);\n      if (!tile.quantizedVolumeOffset) {\n        throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);\n    }\n  }\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\nfunction parseColors(tile, featureTable, batchTable) {\n  if (!tile.attributes.colors) {\n    var colors = null;\n    if (featureTable.hasProperty('RGBA')) {\n      colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasProperty('RGB565')) {\n      colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);\n  }\n  if (featureTable.hasProperty('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n}\nfunction parseNormals(tile, featureTable) {\n  if (!tile.attributes.normals) {\n    var normals = null;\n    if (featureTable.hasProperty('NORMAL')) {\n      normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('NORMAL_OCT16P')) {\n      normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);\n  }\n}\nfunction parseBatchIds(tile, featureTable) {\n  var batchTable = null;\n  if (!tile.batchIds && featureTable.hasProperty('BATCH_ID')) {\n    tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n    if (tile.batchIds) {\n      var batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n      if (!batchFeatureLength) {\n        throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n      }\n      var batchTableJson = tile.batchTableJson,\n        batchTableBinary = tile.batchTableBinary;\n      batchTable = new Tile3DBatchTable(batchTableJson, batchTableBinary, batchFeatureLength);\n    }\n  }\n  return batchTable;\n}\nfunction parseDraco(_x6, _x7, _x8, _x9, _x10) {\n  return _parseDraco.apply(this, arguments);\n}\nfunction _parseDraco() {\n  _parseDraco = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tile, featureTable, batchTable, options, context) {\n    var dracoBuffer, dracoFeatureTableProperties, dracoBatchTableProperties, batchTableDraco, featureTableDraco, dracoByteOffset, dracoByteLength, dracoData;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          batchTableDraco = tile.batchTableJson && tile.batchTableJson.extensions && tile.batchTableJson.extensions['3DTILES_draco_point_compression'];\n          if (batchTableDraco) {\n            dracoBatchTableProperties = batchTableDraco.properties;\n          }\n          featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n          if (!featureTableDraco) {\n            _context2.next = 15;\n            break;\n          }\n          dracoFeatureTableProperties = featureTableDraco.properties;\n          dracoByteOffset = featureTableDraco.byteOffset;\n          dracoByteLength = featureTableDraco.byteLength;\n          if (!(!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength)) {\n            _context2.next = 9;\n            break;\n          }\n          throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n        case 9:\n          dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n          tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);\n          tile.hasColors = Number.isFinite(dracoFeatureTableProperties.RGB) || Number.isFinite(dracoFeatureTableProperties.RGBA);\n          tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);\n          tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);\n          tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);\n        case 15:\n          if (dracoBuffer) {\n            _context2.next = 17;\n            break;\n          }\n          return _context2.abrupt(\"return\", true);\n        case 17:\n          dracoData = {\n            buffer: dracoBuffer,\n            properties: _objectSpread(_objectSpread({}, dracoFeatureTableProperties), dracoBatchTableProperties),\n            featureTableProperties: dracoFeatureTableProperties,\n            batchTableProperties: dracoBatchTableProperties,\n            dequantizeInShader: false\n          };\n          _context2.next = 20;\n          return loadDraco(tile, dracoData, options, context);\n        case 20:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 21:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _parseDraco.apply(this, arguments);\n}\nexport function loadDraco(_x11, _x12, _x13, _x14) {\n  return _loadDraco.apply(this, arguments);\n}\nfunction _loadDraco() {\n  _loadDraco = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tile, dracoData, options, context) {\n    var parse, dracoOptions, data, decodedPositions, decodedColors, decodedNormals, decodedBatchIds, isQuantizedDraco, isOctEncodedDraco, quantization, range, batchTableAttributes, _i, _Object$keys, attributeName;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          parse = context.parse;\n          dracoOptions = _objectSpread(_objectSpread({}, options), {}, {\n            draco: _objectSpread(_objectSpread({}, options.draco), {}, {\n              extraAttributes: dracoData.batchTableProperties || {}\n            })\n          });\n          delete dracoOptions['3d-tiles'];\n          _context3.next = 5;\n          return parse(dracoData.buffer, DracoLoader, dracoOptions);\n        case 5:\n          data = _context3.sent;\n          decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;\n          decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;\n          decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;\n          decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;\n          isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;\n          isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;\n          if (isQuantizedDraco) {\n            quantization = data.POSITION.data.quantization;\n            range = quantization.range;\n            tile.quantizedVolumeScale = new Vector3(range, range, range);\n            tile.quantizedVolumeOffset = new Vector3(quantization.minValues);\n            tile.quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n            tile.isQuantizedDraco = true;\n          }\n          if (isOctEncodedDraco) {\n            tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1.0;\n            tile.isOctEncodedDraco = true;\n          }\n          batchTableAttributes = {};\n          if (dracoData.batchTableProperties) {\n            for (_i = 0, _Object$keys = Object.keys(dracoData.batchTableProperties); _i < _Object$keys.length; _i++) {\n              attributeName = _Object$keys[_i];\n              if (data.attributes[attributeName] && data.attributes[attributeName].value) {\n                batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;\n              }\n            }\n          }\n          tile.attributes = _objectSpread({\n            positions: decodedPositions,\n            colors: normalize3DTileColorAttribute(tile, decodedColors, undefined),\n            normals: decodedNormals,\n            batchIds: decodedBatchIds\n          }, batchTableAttributes);\n        case 17:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _loadDraco.apply(this, arguments);\n}","map":{"version":3,"names":["DracoLoader","GL","Vector3","Tile3DFeatureTable","Tile3DBatchTable","parse3DTileHeaderSync","parse3DTileTablesHeaderSync","parse3DTileTablesSync","normalize3DTileColorAttribute","normalize3DTileNormalAttribute","normalize3DTilePositionAttribute","parsePointCloud3DTile","_x","_x2","_x3","_x4","_x5","_parsePointCloud3DTile","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","tile","arrayBuffer","byteOffset","options","context","_parsePointCloudTable","featureTable","batchTable","wrap","_callee$","_context","prev","next","initializeTile","parsePointCloudTables","parseDraco","parsePositions","parseColors","parseNormals","abrupt","stop","attributes","positions","colors","normals","batchIds","isQuantized","isTranslucent","isRGB565","isOctEncoded16P","featureTableJson","featureTableBinary","pointsLength","getGlobalProperty","Number","isFinite","Error","featuresLength","pointCount","rtcCenter","FLOAT","parseBatchIds","hasProperty","getPropertyArray","UNSIGNED_SHORT","quantizedRange","quantizedVolumeScale","quantizedVolumeOffset","UNSIGNED_BYTE","constantRGBA","batchFeatureLength","batchTableJson","batchTableBinary","_x6","_x7","_x8","_x9","_x10","_parseDraco","_callee2","dracoBuffer","dracoFeatureTableProperties","dracoBatchTableProperties","batchTableDraco","featureTableDraco","dracoByteOffset","dracoByteLength","dracoData","_callee2$","_context2","extensions","properties","getExtension","byteLength","slice","hasPositions","POSITION","hasColors","RGB","RGBA","hasNormals","NORMAL","hasBatchIds","BATCH_ID","buffer","_objectSpread","featureTableProperties","batchTableProperties","dequantizeInShader","loadDraco","sent","_x11","_x12","_x13","_x14","_loadDraco","_callee3","parse","dracoOptions","data","decodedPositions","decodedColors","decodedNormals","decodedBatchIds","isQuantizedDraco","isOctEncodedDraco","quantization","range","batchTableAttributes","_i","_Object$keys","attributeName","_callee3$","_context3","draco","extraAttributes","value","COLOR_0","minValues","quantizationBits","octEncodedRange","Object","keys","length","toLowerCase","undefined"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/geo-layers/node_modules/@loaders.gl/3d-tiles/src/lib/parsers/parse-3d-tile-point-cloud.ts"],"sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {GL} from '@loaders.gl/math';\nimport {Vector3} from '@math.gl/core';\n\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\nimport {parse3DTileTablesHeaderSync, parse3DTileTablesSync} from './helpers/parse-3d-tile-tables';\nimport {normalize3DTileColorAttribute} from './helpers/normalize-3d-tile-colors';\nimport {normalize3DTileNormalAttribute} from './helpers/normalize-3d-tile-normals';\nimport {normalize3DTilePositionAttribute} from './helpers/normalize-3d-tile-positions';\n\nexport async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n  initializeTile(tile);\n\n  const {featureTable, batchTable} = parsePointCloudTables(tile);\n\n  await parseDraco(tile, featureTable, batchTable, options, context);\n\n  parsePositions(tile, featureTable, options);\n  parseColors(tile, featureTable, batchTable);\n  parseNormals(tile, featureTable);\n\n  return byteOffset;\n}\n\nfunction initializeTile(tile) {\n  // Initialize point cloud tile defaults\n  tile.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  };\n  tile.isQuantized = false;\n  tile.isTranslucent = false;\n  tile.isRGB565 = false;\n  tile.isOctEncoded16P = false;\n}\n\nfunction parsePointCloudTables(tile) {\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n\n  const pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');\n  if (!Number.isFinite(pointsLength)) {\n    throw new Error('POINTS_LENGTH must be defined');\n  }\n  featureTable.featuresLength = pointsLength;\n\n  tile.featuresLength = pointsLength;\n  tile.pointsLength = pointsLength;\n  tile.pointCount = pointsLength;\n\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n\n  const batchTable = parseBatchIds(tile, featureTable);\n\n  return {featureTable, batchTable};\n}\n\nfunction parsePositions(tile, featureTable, options) {\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      const positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n      tile.isQuantized = true;\n      tile.quantizedRange = (1 << 16) - 1;\n\n      tile.quantizedVolumeScale = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_SCALE',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeScale) {\n        throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n\n      tile.quantizedVolumeOffset = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_OFFSET',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeOffset) {\n        throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n\n      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n\nfunction parseColors(tile, featureTable, batchTable) {\n  if (!tile.attributes.colors) {\n    let colors = null;\n    if (featureTable.hasProperty('RGBA')) {\n      colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasProperty('RGB565')) {\n      colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n\n    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);\n  }\n\n  if (featureTable.hasProperty('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n}\n\nfunction parseNormals(tile, featureTable) {\n  if (!tile.attributes.normals) {\n    let normals = null;\n    if (featureTable.hasProperty('NORMAL')) {\n      normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('NORMAL_OCT16P')) {\n      normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n\n    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);\n  }\n}\n\nfunction parseBatchIds(tile, featureTable) {\n  let batchTable: Tile3DBatchTable | null = null;\n  if (!tile.batchIds && featureTable.hasProperty('BATCH_ID')) {\n    tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n\n    if (tile.batchIds) {\n      const batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n      if (!batchFeatureLength) {\n        throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n      }\n      const {batchTableJson, batchTableBinary} = tile;\n      batchTable = new Tile3DBatchTable(batchTableJson, batchTableBinary, batchFeatureLength);\n    }\n  }\n  return batchTable;\n}\n\n// eslint-disable-next-line complexity\nasync function parseDraco(tile, featureTable, batchTable, options, context) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n  const batchTableDraco =\n    tile.batchTableJson &&\n    tile.batchTableJson.extensions &&\n    tile.batchTableJson.extensions['3DTILES_draco_point_compression'];\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n\n    tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);\n    tile.hasColors =\n      Number.isFinite(dracoFeatureTableProperties.RGB) ||\n      Number.isFinite(dracoFeatureTableProperties.RGBA);\n    tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);\n    tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);\n    tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);\n  }\n\n  if (!dracoBuffer) {\n    return true;\n  }\n\n  const dracoData = {\n    buffer: dracoBuffer,\n    properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n    featureTableProperties: dracoFeatureTableProperties,\n    batchTableProperties: dracoBatchTableProperties,\n    dequantizeInShader: false\n  };\n\n  return await loadDraco(tile, dracoData, options, context);\n}\n\n// eslint-disable-next-line complexity, max-statements\nexport async function loadDraco(tile, dracoData, options, context) {\n  const {parse} = context;\n  const dracoOptions = {\n    ...options,\n    draco: {\n      ...options.draco,\n      extraAttributes: dracoData.batchTableProperties || {}\n    }\n  };\n\n  // The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n\n  const data = await parse(dracoData.buffer, DracoLoader, dracoOptions);\n\n  const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;\n  const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;\n  const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;\n  const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;\n  const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;\n  const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;\n  if (isQuantizedDraco) {\n    // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n    // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n    const quantization = data.POSITION.data.quantization;\n    const range = quantization.range;\n    tile.quantizedVolumeScale = new Vector3(range, range, range);\n    tile.quantizedVolumeOffset = new Vector3(quantization.minValues);\n    tile.quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n    tile.isQuantizedDraco = true;\n  }\n  if (isOctEncodedDraco) {\n    tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1.0;\n    tile.isOctEncodedDraco = true;\n  }\n\n  // Extra batch table attributes\n  const batchTableAttributes = {};\n  if (dracoData.batchTableProperties) {\n    for (const attributeName of Object.keys(dracoData.batchTableProperties)) {\n      if (data.attributes[attributeName] && data.attributes[attributeName].value) {\n        batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;\n      }\n    }\n  }\n\n  tile.attributes = {\n    positions: decodedPositions,\n    colors: normalize3DTileColorAttribute(tile, decodedColors, undefined),\n    normals: decodedNormals,\n    batchIds: decodedBatchIds,\n    ...batchTableAttributes\n  };\n}\n\n// TODO - this is the remaining code from Cesium's parser\n/*\n  const batchTable = new Tile3DBatchTable(tile);\n\n  // parseDracoBuffer(tile, featureTable, batchTable);\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n/*\n\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n\n  if (!tile.colors) {\n    if (featureTable.hasProperty('RGBA')) {\n      tile.colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      tile.colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasPropertry('RGB565')) {\n      tile.colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n  }\n\n  if (!tile.attributes.normals) {\n    if (featureTable.getPropertry('NORMAL')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.getProperty('NORMAL_OCT16P')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n  }\n\n  if (!tile.batchIds) {\n    if (featureTable.hasProperty('BATCH_ID')) {\n      tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n\n  if (featureTable.getPropertry('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n\n  if (tile.batchIds) {\n    const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n    if (!defined(batchLength)) {\n      throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n    }\n\n    if (defined(batchTableBinary)) {\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n\n    if (defined(pointCloud._batchTableLoaded)) {\n      pointCloud._batchTableLoaded(batchLength, batchTableJson, batchTableBinary);\n    }\n  }\n\n  // If points are not batched and there are per-point properties, use these properties for styling purposes\n  var styleableProperties;\n  if (!hasBatchIds && defined(batchTableBinary)) {\n    tile.styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(\n      pointsLength,\n      batchTableJson,\n      batchTableBinary\n    );\n  }\n\n  tile.draco = draco;\n}\n\n// Separate parsing and decoding of Draco\nexport function parseDracoBuffer(tile, featureTable, batchTable) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n\n  const batchTableDraco = batchTable.getExtension('3DTILES_draco_point_compression');\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !dracoByteOffset || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = arraySlice(\n      featureTableBinary,\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength\n    );\n    tile.hasPositions = dracoFeatureTableProperties.POSITION;\n    tile.hasColors = dracoFeatureTableProperties.RGB || dracoFeatureTableProperties.RGBA;\n    tile.hasNormals = dracoFeatureTableProperties.NORMAL;\n    tile.hasBatchIds = dracoFeatureTableProperties.BATCH_ID;\n    tile.isTranslucent = dracoFeatureTableProperties.RGBA;\n  }\n\n  if (dracoBuffer) {\n    tile.draco = {\n      buffer: dracoBuffer,\n      properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      dequantizeInShader: false\n    };\n\n    tile.decodingState = DECODING_STATE.NEEDS_DECODE;\n  }\n}\n\n/*\nfunction decodeDraco(tile, context) {\n  if (tile.decodingState === DECODING_STATE.READY) {\n    return false;\n  }\n  if (tile.decodingState === DECODING_STATE.NEEDS_DECODE) {\n    var parsedContent = tile._parsedContent;\n    var draco = parsedContent.draco;\n    var decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      tile.decodingState = DECODING_STATE.DECODING;\n      decodePromise.then(function(result) {\n        tile.decodingState = DECODING_STATE.READY;\n        var decodedPositions = defined(result.POSITION) ? result.POSITION.array : undefined;\n        var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n        var decodedRgba = defined(result.RGBA) ? result.RGBA.array : undefined;\n        var decodedNormals = defined(result.NORMAL) ? result.NORMAL.array : undefined;\n        var decodedBatchIds = defined(result.BATCH_ID) ? result.BATCH_ID.array : undefined;\n        var isQuantizedDraco = defined(decodedPositions) && defined(result.POSITION.data.quantization);\n        var isOctEncodedDraco = defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n        if (isQuantizedDraco) {\n          // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n          // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n          var quantization = result.POSITION.data.quantization;\n          var range = quantization.range;\n          tile._quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n          tile._quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n          tile._quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n          tile._isQuantizedDraco = true;\n        }\n        if (isOctEncodedDraco) {\n          tile._octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n          tile._isOctEncodedDraco = true;\n        }\n        var styleableProperties = parsedContent.styleableProperties;\n        var batchTableProperties = draco.batchTableProperties;\n        for (var name in batchTableProperties) {\n          if (batchTableProperties.hasOwnProperty(name)) {\n            var property = result[name];\n            if (!defined(styleableProperties)) {\n              styleableProperties = {};\n            }\n            styleableProperties[name] = {\n              typedArray : property.array,\n              componentCount : property.data.componentsPerAttribute\n            };\n          }\n        }\n        parsedContent.positions = defaultValue(decodedPositions, parsedContent.positions);\n        parsedContent.colors = defaultValue(defaultValue(decodedRgba, decodedRgb), parsedContent.colors);\n        parsedContent.normals = defaultValue(decodedNormals, parsedContent.normals);\n        parsedContent.batchIds = defaultValue(decodedBatchIds, parsedContent.batchIds);\n        parsedContent.styleableProperties = styleableProperties;\n      }).otherwise(function(error) {\n        tile.decodingState = DECODING_STATE.FAILED;\n        tile._readyPromise.reject(error);\n      });\n    }\n  }\n  return true;\n}\n*/\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}