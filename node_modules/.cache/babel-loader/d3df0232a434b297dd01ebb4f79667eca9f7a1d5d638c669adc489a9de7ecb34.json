{"ast":null,"code":"import _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Vector3 } from '@math.gl/core';\nimport { INTERSECTION } from '../../constants';\nvar scratchVector = new Vector3();\nvar scratchNormal = new Vector3();\nvar AxisAlignedBoundingBox = /*#__PURE__*/function () {\n  function AxisAlignedBoundingBox() {\n    var minimum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    var maximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    var center = arguments.length > 2 ? arguments[2] : undefined;\n    _classCallCheck(this, AxisAlignedBoundingBox);\n    _defineProperty(this, \"center\", void 0);\n    _defineProperty(this, \"halfDiagonal\", void 0);\n    _defineProperty(this, \"minimum\", void 0);\n    _defineProperty(this, \"maximum\", void 0);\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.center = new Vector3(center);\n    this.halfDiagonal = new Vector3(maximum).subtract(this.center);\n    this.minimum = new Vector3(minimum);\n    this.maximum = new Vector3(maximum);\n  }\n  _createClass(AxisAlignedBoundingBox, [{\n    key: \"clone\",\n    value: function clone() {\n      return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(_transform) {\n      this.center.transformAsPoint(_transform);\n      this.halfDiagonal.transform(_transform);\n      this.minimum.transform(_transform);\n      this.maximum.transform(_transform);\n      return this;\n    }\n  }, {\n    key: \"intersectPlane\",\n    value: function intersectPlane(plane) {\n      var halfDiagonal = this.halfDiagonal;\n      var normal = scratchNormal.from(plane.normal);\n      var e = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);\n      var s = this.center.dot(normal) + plane.distance;\n      if (s - e > 0) {\n        return INTERSECTION.INSIDE;\n      }\n      if (s + e < 0) {\n        return INTERSECTION.OUTSIDE;\n      }\n      return INTERSECTION.INTERSECTING;\n    }\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(point) {\n      return Math.sqrt(this.distanceSquaredTo(point));\n    }\n  }, {\n    key: \"distanceSquaredTo\",\n    value: function distanceSquaredTo(point) {\n      var offset = scratchVector.from(point).subtract(this.center);\n      var halfDiagonal = this.halfDiagonal;\n      var distanceSquared = 0.0;\n      var d;\n      d = Math.abs(offset.x) - halfDiagonal.x;\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n      d = Math.abs(offset.y) - halfDiagonal.y;\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n      d = Math.abs(offset.z) - halfDiagonal.z;\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n      return distanceSquared;\n    }\n  }]);\n  return AxisAlignedBoundingBox;\n}();\nexport { AxisAlignedBoundingBox as default };","map":{"version":3,"names":["Vector3","INTERSECTION","scratchVector","scratchNormal","AxisAlignedBoundingBox","minimum","arguments","length","undefined","maximum","center","_classCallCheck","_defineProperty","copy","add","scale","halfDiagonal","subtract","_createClass","key","value","clone","equals","right","Boolean","transform","transformAsPoint","intersectPlane","plane","normal","from","e","x","Math","abs","y","z","s","dot","distance","INSIDE","OUTSIDE","INTERSECTING","distanceTo","point","sqrt","distanceSquaredTo","offset","distanceSquared","d","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@math.gl/culling/src/lib/bounding-volumes/axis-aligned-bounding-box.ts"],"sourcesContent":["import {BoundingVolume} from './bounding-volume';\nimport {Vector3} from '@math.gl/core';\nimport Plane from '../plane';\nimport {INTERSECTION} from '../../constants';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\n\n/**\n * An axis aligned bounding box - aligned with coordinate axes\n * @see BoundingVolume\n * @see BoundingRectangle\n * @see OrientedBoundingBox\n */\nexport default class AxisAlignedBoundingBox implements BoundingVolume {\n  /** The center point of the bounding box. */\n  readonly center: Vector3;\n  /** The positive half diagonal of the bounding box. */\n  readonly halfDiagonal: Vector3;\n  /** The minimum point defining the bounding box. [0, 0, 0] for empty box */\n  readonly minimum: Vector3;\n  /** The maximum point defining the bounding box. [0, 0, 0] for empty box */\n  readonly maximum: Vector3;\n\n  /**\n   * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n   * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.\n   * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.\n   * @param center The center of the box; automatically computed if not supplied.\n   */\n  constructor(\n    minimum: readonly number[] = [0, 0, 0],\n    maximum: readonly number[] = [0, 0, 0],\n    center?: readonly number[]\n  ) {\n    // If center was not defined, compute it.\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.center = new Vector3(center);\n    this.halfDiagonal = new Vector3(maximum).subtract(this.center);\n\n    /**\n     * The minimum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.minimum = new Vector3(minimum);\n\n    /**\n     * The maximum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.maximum = new Vector3(maximum);\n  }\n\n  /**\n   * Duplicates a AxisAlignedBoundingBox instance.\n   *\n   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.\n   */\n  clone(): AxisAlignedBoundingBox {\n    return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n  }\n\n  /**\n   * Compares the provided AxisAlignedBoundingBox componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.\n   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n   */\n  equals(right: AxisAlignedBoundingBox): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum))\n    );\n  }\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns itself, i.e. the modified BoundingVolume.\n   */\n  transform(transform: readonly number[]): this {\n    this.center.transformAsPoint(transform);\n    // TODO - this.halfDiagonal.transformAsVector(transform);\n    this.halfDiagonal.transform(transform);\n    this.minimum.transform(transform);\n    this.maximum.transform(transform);\n    return this;\n  }\n\n  /**\n   * Determines which side of a plane a box is located.\n   */\n  intersectPlane(plane: Plane): number {\n    const {halfDiagonal} = this;\n    const normal = scratchNormal.from(plane.normal);\n    const e =\n      halfDiagonal.x * Math.abs(normal.x) +\n      halfDiagonal.y * Math.abs(normal.y) +\n      halfDiagonal.z * Math.abs(normal.z);\n    const s = this.center.dot(normal) + plane.distance; // signed distance from center\n\n    if (s - e > 0) {\n      return INTERSECTION.INSIDE;\n    }\n\n    if (s + e < 0) {\n      // Not in front because normals point inward\n      return INTERSECTION.OUTSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding box to a point. */\n  distanceTo(point: readonly number[]): number {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  /** Computes the estimated distance squared from the closest point on a bounding box to a point. */\n  distanceSquaredTo(point: readonly number[]): number {\n    const offset = scratchVector.from(point).subtract(this.center);\n    const {halfDiagonal} = this;\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.x) - halfDiagonal.x;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.y) - halfDiagonal.y;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.z) - halfDiagonal.z;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}