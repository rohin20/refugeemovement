{"ast":null,"code":"import _defineProperty from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Model, Transform, FEATURES, hasFeatures, isWebGL2, readPixelsToBuffer, withParameters } from '@luma.gl/core';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { log, project32, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { DEFAULT_RUN_PARAMS, MAX_32_BIT_FLOAT, MIN_BLEND_EQUATION, MAX_BLEND_EQUATION, MAX_MIN_BLEND_EQUATION, EQUATION_MAP, DEFAULT_WEIGHT_PARAMS, PIXEL_SIZE } from './gpu-grid-aggregator-constants';\nimport { AGGREGATION_OPERATION } from '../aggregation-operation-utils';\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport { getFloatTexture, getFramebuffer } from './../resource-utils.js';\nvar BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nvar ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\nvar REQUIRED_FEATURES = [FEATURES.WEBGL2, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.FLOAT_BLEND, FEATURES.TEXTURE_FLOAT];\nvar GPUGridAggregator = /*#__PURE__*/function () {\n  function GPUGridAggregator(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, GPUGridAggregator);\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n      resources: {},\n      results: {}\n    };\n    this._hasGPUSupport = isWebGL2(gl) && hasFeatures(this.gl, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.TEXTURE_FLOAT);\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n  _createClass(GPUGridAggregator, [{\n    key: \"delete\",\n    value: function _delete() {\n      var gridAggregationModel = this.gridAggregationModel,\n        allAggregationModel = this.allAggregationModel,\n        meanTransform = this.meanTransform;\n      var _this$state = this.state,\n        textures = _this$state.textures,\n        framebuffers = _this$state.framebuffers,\n        maxMinFramebuffers = _this$state.maxMinFramebuffers,\n        minFramebuffers = _this$state.minFramebuffers,\n        maxFramebuffers = _this$state.maxFramebuffers,\n        meanTextures = _this$state.meanTextures,\n        resources = _this$state.resources;\n      gridAggregationModel === null || gridAggregationModel === void 0 ? void 0 : gridAggregationModel.delete();\n      allAggregationModel === null || allAggregationModel === void 0 ? void 0 : allAggregationModel.delete();\n      meanTransform === null || meanTransform === void 0 ? void 0 : meanTransform.delete();\n      deleteResources([framebuffers, textures, maxMinFramebuffers, minFramebuffers, maxFramebuffers, meanTextures, resources]);\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.setState({\n        results: {}\n      });\n      var aggregationParams = this._normalizeAggregationParams(opts);\n      if (!this._hasGPUSupport) {\n        log.log(1, 'GPUGridAggregator: not supported')();\n      }\n      return this._runAggregation(aggregationParams);\n    }\n  }, {\n    key: \"getData\",\n    value: function getData(weightId) {\n      var data = {};\n      var results = this.state.results;\n      if (!results[weightId].aggregationData) {\n        results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n      }\n      data.aggregationData = results[weightId].aggregationData;\n      for (var arrayName in ARRAY_BUFFER_MAP) {\n        var bufferName = ARRAY_BUFFER_MAP[arrayName];\n        if (results[weightId][arrayName] || results[weightId][bufferName]) {\n          results[weightId][arrayName] = results[weightId][arrayName] || results[weightId][bufferName].getData();\n          data[arrayName] = results[weightId][arrayName];\n        }\n      }\n      return data;\n    }\n  }, {\n    key: \"updateShaders\",\n    value: function updateShaders() {\n      var shaderOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.setState({\n        shaderOptions: shaderOptions,\n        modelDirty: true\n      });\n    }\n  }, {\n    key: \"_normalizeAggregationParams\",\n    value: function _normalizeAggregationParams(opts) {\n      var aggregationParams = _objectSpread(_objectSpread({}, DEFAULT_RUN_PARAMS), opts);\n      var weights = aggregationParams.weights;\n      if (weights) {\n        aggregationParams.weights = normalizeWeightParams(weights);\n      }\n      return aggregationParams;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(updateObject) {\n      Object.assign(this.state, updateObject);\n    }\n  }, {\n    key: \"_getAggregateData\",\n    value: function _getAggregateData(opts) {\n      var results = {};\n      var _this$state2 = this.state,\n        textures = _this$state2.textures,\n        framebuffers = _this$state2.framebuffers,\n        maxMinFramebuffers = _this$state2.maxMinFramebuffers,\n        minFramebuffers = _this$state2.minFramebuffers,\n        maxFramebuffers = _this$state2.maxFramebuffers,\n        resources = _this$state2.resources;\n      var weights = opts.weights;\n      for (var id in weights) {\n        results[id] = {};\n        var _weights$id = weights[id],\n          needMin = _weights$id.needMin,\n          needMax = _weights$id.needMax,\n          combineMaxMin = _weights$id.combineMaxMin;\n        results[id].aggregationTexture = textures[id];\n        results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n          target: weights[id].aggregationBuffer,\n          sourceType: 5126\n        });\n        if (needMin && needMax && combineMaxMin) {\n          results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n            target: weights[id].maxMinBuffer,\n            sourceType: 5126\n          });\n          results[id].maxMinTexture = resources[\"\".concat(id, \"-maxMinTexture\")];\n        } else {\n          if (needMin) {\n            results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n              target: weights[id].minBuffer,\n              sourceType: 5126\n            });\n            results[id].minTexture = resources[\"\".concat(id, \"-minTexture\")];\n          }\n          if (needMax) {\n            results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n              target: weights[id].maxBuffer,\n              sourceType: 5126\n            });\n            results[id].maxTexture = resources[\"\".concat(id, \"-maxTexture\")];\n          }\n        }\n      }\n      this._trackGPUResultBuffers(results, weights);\n      return results;\n    }\n  }, {\n    key: \"_renderAggregateData\",\n    value: function _renderAggregateData(opts) {\n      var cellSize = opts.cellSize,\n        projectPoints = opts.projectPoints,\n        attributes = opts.attributes,\n        moduleSettings = opts.moduleSettings,\n        numCol = opts.numCol,\n        numRow = opts.numRow,\n        weights = opts.weights,\n        translation = opts.translation,\n        scaling = opts.scaling;\n      var _this$state3 = this.state,\n        maxMinFramebuffers = _this$state3.maxMinFramebuffers,\n        minFramebuffers = _this$state3.minFramebuffers,\n        maxFramebuffers = _this$state3.maxFramebuffers;\n      var gridSize = [numCol, numRow];\n      var parameters = {\n        blend: true,\n        depthTest: false,\n        blendFunc: [1, 1]\n      };\n      var uniforms = {\n        cellSize: cellSize,\n        gridSize: gridSize,\n        projectPoints: projectPoints,\n        translation: translation,\n        scaling: scaling\n      };\n      for (var id in weights) {\n        var _weights$id2 = weights[id],\n          needMin = _weights$id2.needMin,\n          needMax = _weights$id2.needMax;\n        var combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n        this._renderToWeightsTexture({\n          id: id,\n          parameters: parameters,\n          moduleSettings: moduleSettings,\n          uniforms: uniforms,\n          gridSize: gridSize,\n          attributes: attributes,\n          weights: weights\n        });\n        if (combineMaxMin) {\n          this._renderToMaxMinTexture({\n            id: id,\n            parameters: _objectSpread(_objectSpread({}, parameters), {}, {\n              blendEquation: MAX_MIN_BLEND_EQUATION\n            }),\n            gridSize: gridSize,\n            minOrMaxFb: maxMinFramebuffers[id],\n            clearParams: {\n              clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]\n            },\n            combineMaxMin: combineMaxMin\n          });\n        } else {\n          if (needMin) {\n            this._renderToMaxMinTexture({\n              id: id,\n              parameters: _objectSpread(_objectSpread({}, parameters), {}, {\n                blendEquation: MIN_BLEND_EQUATION\n              }),\n              gridSize: gridSize,\n              minOrMaxFb: minFramebuffers[id],\n              clearParams: {\n                clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n              },\n              combineMaxMin: combineMaxMin\n            });\n          }\n          if (needMax) {\n            this._renderToMaxMinTexture({\n              id: id,\n              parameters: _objectSpread(_objectSpread({}, parameters), {}, {\n                blendEquation: MAX_BLEND_EQUATION\n              }),\n              gridSize: gridSize,\n              minOrMaxFb: maxFramebuffers[id],\n              clearParams: {\n                clearColor: [0, 0, 0, 0]\n              },\n              combineMaxMin: combineMaxMin\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_renderToMaxMinTexture\",\n    value: function _renderToMaxMinTexture(opts) {\n      var id = opts.id,\n        parameters = opts.parameters,\n        gridSize = opts.gridSize,\n        minOrMaxFb = opts.minOrMaxFb,\n        combineMaxMin = opts.combineMaxMin,\n        _opts$clearParams = opts.clearParams,\n        clearParams = _opts$clearParams === void 0 ? {} : _opts$clearParams;\n      var framebuffers = this.state.framebuffers;\n      var gl = this.gl,\n        allAggregationModel = this.allAggregationModel;\n      withParameters(gl, _objectSpread(_objectSpread({}, clearParams), {}, {\n        framebuffer: minOrMaxFb,\n        viewport: [0, 0, gridSize[0], gridSize[1]]\n      }), function () {\n        gl.clear(16384);\n        allAggregationModel.draw({\n          parameters: parameters,\n          uniforms: {\n            uSampler: framebuffers[id].texture,\n            gridSize: gridSize,\n            combineMaxMin: combineMaxMin\n          }\n        });\n      });\n    }\n  }, {\n    key: \"_renderToWeightsTexture\",\n    value: function _renderToWeightsTexture(opts) {\n      var id = opts.id,\n        parameters = opts.parameters,\n        moduleSettings = opts.moduleSettings,\n        uniforms = opts.uniforms,\n        gridSize = opts.gridSize,\n        weights = opts.weights;\n      var _this$state4 = this.state,\n        framebuffers = _this$state4.framebuffers,\n        equations = _this$state4.equations,\n        weightAttributes = _this$state4.weightAttributes;\n      var gl = this.gl,\n        gridAggregationModel = this.gridAggregationModel;\n      var operation = weights[id].operation;\n      var clearColor = operation === AGGREGATION_OPERATION.MIN ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] : [0, 0, 0, 0];\n      withParameters(gl, {\n        framebuffer: framebuffers[id],\n        viewport: [0, 0, gridSize[0], gridSize[1]],\n        clearColor: clearColor\n      }, function () {\n        gl.clear(16384);\n        var attributes = {\n          weights: weightAttributes[id]\n        };\n        gridAggregationModel.draw({\n          parameters: _objectSpread(_objectSpread({}, parameters), {}, {\n            blendEquation: equations[id]\n          }),\n          moduleSettings: moduleSettings,\n          uniforms: uniforms,\n          attributes: attributes\n        });\n      });\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        var _this$state5 = this.state,\n          meanTextures = _this$state5.meanTextures,\n          textures = _this$state5.textures;\n        var transformOptions = {\n          _sourceTextures: {\n            aggregationValues: meanTextures[id]\n          },\n          _targetTexture: textures[id],\n          elementCount: textures[id].width * textures[id].height\n        };\n        if (this.meanTransform) {\n          this.meanTransform.update(transformOptions);\n        } else {\n          this.meanTransform = getMeanTransform(gl, transformOptions);\n        }\n        this.meanTransform.run({\n          parameters: {\n            blend: false,\n            depthTest: false\n          }\n        });\n        framebuffers[id].attach(_defineProperty({}, 36064, textures[id]));\n      }\n    }\n  }, {\n    key: \"_runAggregation\",\n    value: function _runAggregation(opts) {\n      this._updateModels(opts);\n      this._setupFramebuffers(opts);\n      this._renderAggregateData(opts);\n      var results = this._getAggregateData(opts);\n      this.setState({\n        results: results\n      });\n      return results;\n    }\n  }, {\n    key: \"_setupFramebuffers\",\n    value: function _setupFramebuffers(opts) {\n      var _this$state6 = this.state,\n        textures = _this$state6.textures,\n        framebuffers = _this$state6.framebuffers,\n        maxMinFramebuffers = _this$state6.maxMinFramebuffers,\n        minFramebuffers = _this$state6.minFramebuffers,\n        maxFramebuffers = _this$state6.maxFramebuffers,\n        meanTextures = _this$state6.meanTextures,\n        equations = _this$state6.equations;\n      var weights = opts.weights;\n      var numCol = opts.numCol,\n        numRow = opts.numRow;\n      var framebufferSize = {\n        width: numCol,\n        height: numRow\n      };\n      for (var id in weights) {\n        var _weights$id3 = weights[id],\n          needMin = _weights$id3.needMin,\n          needMax = _weights$id3.needMax,\n          combineMaxMin = _weights$id3.combineMaxMin,\n          operation = _weights$id3.operation;\n        textures[id] = weights[id].aggregationTexture || textures[id] || getFloatTexture(this.gl, {\n          id: \"\".concat(id, \"-texture\"),\n          width: numCol,\n          height: numRow\n        });\n        textures[id].resize(framebufferSize);\n        var texture = textures[id];\n        if (operation === AGGREGATION_OPERATION.MEAN) {\n          meanTextures[id] = meanTextures[id] || getFloatTexture(this.gl, {\n            id: \"\".concat(id, \"-mean-texture\"),\n            width: numCol,\n            height: numRow\n          });\n          meanTextures[id].resize(framebufferSize);\n          texture = meanTextures[id];\n        }\n        if (framebuffers[id]) {\n          framebuffers[id].attach(_defineProperty({}, 36064, texture));\n        } else {\n          framebuffers[id] = getFramebuffer(this.gl, {\n            id: \"\".concat(id, \"-fb\"),\n            width: numCol,\n            height: numRow,\n            texture: texture\n          });\n        }\n        framebuffers[id].resize(framebufferSize);\n        equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n        if (needMin || needMax) {\n          if (needMin && needMax && combineMaxMin) {\n            if (!maxMinFramebuffers[id]) {\n              texture = weights[id].maxMinTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxMinTexture\"));\n              maxMinFramebuffers[id] = getFramebuffer(this.gl, {\n                id: \"\".concat(id, \"-maxMinFb\"),\n                texture: texture\n              });\n            }\n          } else {\n            if (needMin) {\n              if (!minFramebuffers[id]) {\n                texture = weights[id].minTexture || this._getMinMaxTexture(\"\".concat(id, \"-minTexture\"));\n                minFramebuffers[id] = getFramebuffer(this.gl, {\n                  id: \"\".concat(id, \"-minFb\"),\n                  texture: texture\n                });\n              }\n            }\n            if (needMax) {\n              if (!maxFramebuffers[id]) {\n                texture = weights[id].maxTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxTexture\"));\n                maxFramebuffers[id] = getFramebuffer(this.gl, {\n                  id: \"\".concat(id, \"-maxFb\"),\n                  texture: texture\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_getMinMaxTexture\",\n    value: function _getMinMaxTexture(name) {\n      var resources = this.state.resources;\n      if (!resources[name]) {\n        resources[name] = getFloatTexture(this.gl, {\n          id: \"resourceName\"\n        });\n      }\n      return resources[name];\n    }\n  }, {\n    key: \"_setupModels\",\n    value: function _setupModels() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$numCol = _ref.numCol,\n        numCol = _ref$numCol === void 0 ? 0 : _ref$numCol,\n        _ref$numRow = _ref.numRow,\n        numRow = _ref$numRow === void 0 ? 0 : _ref$numRow;\n      var _this$gridAggregation;\n      var gl = this.gl;\n      var shaderOptions = this.state.shaderOptions;\n      (_this$gridAggregation = this.gridAggregationModel) === null || _this$gridAggregation === void 0 ? void 0 : _this$gridAggregation.delete();\n      this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n      if (!this.allAggregationModel) {\n        var instanceCount = numCol * numRow;\n        this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n      }\n    }\n  }, {\n    key: \"_setupWeightAttributes\",\n    value: function _setupWeightAttributes(opts) {\n      var weightAttributes = this.state.weightAttributes;\n      var weights = opts.weights;\n      for (var id in weights) {\n        weightAttributes[id] = opts.attributes[id];\n      }\n    }\n  }, {\n    key: \"_trackGPUResultBuffers\",\n    value: function _trackGPUResultBuffers(results, weights) {\n      var resources = this.state.resources;\n      for (var id in results) {\n        if (results[id]) {\n          for (var _i = 0, _BUFFER_NAMES = BUFFER_NAMES; _i < _BUFFER_NAMES.length; _i++) {\n            var bufferName = _BUFFER_NAMES[_i];\n            if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n              var name = \"gpu-result-\".concat(id, \"-\").concat(bufferName);\n              if (resources[name]) {\n                resources[name].delete();\n              }\n              resources[name] = results[id][bufferName];\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_updateModels\",\n    value: function _updateModels(opts) {\n      var vertexCount = opts.vertexCount,\n        attributes = opts.attributes,\n        numCol = opts.numCol,\n        numRow = opts.numRow;\n      var modelDirty = this.state.modelDirty;\n      if (modelDirty) {\n        this._setupModels(opts);\n        this.setState({\n          modelDirty: false\n        });\n      }\n      this._setupWeightAttributes(opts);\n      this.gridAggregationModel.setVertexCount(vertexCount);\n      this.gridAggregationModel.setAttributes(attributes);\n      this.allAggregationModel.setInstanceCount(numCol * numRow);\n    }\n  }], [{\n    key: \"getAggregationData\",\n    value: function getAggregationData(_ref2) {\n      var aggregationData = _ref2.aggregationData,\n        maxData = _ref2.maxData,\n        minData = _ref2.minData,\n        maxMinData = _ref2.maxMinData,\n        pixelIndex = _ref2.pixelIndex;\n      var index = pixelIndex * PIXEL_SIZE;\n      var results = {};\n      if (aggregationData) {\n        results.cellCount = aggregationData[index + 3];\n        results.cellWeight = aggregationData[index];\n      }\n      if (maxMinData) {\n        results.maxCellWieght = maxMinData[0];\n        results.minCellWeight = maxMinData[3];\n      } else {\n        if (maxData) {\n          results.maxCellWieght = maxData[0];\n          results.totalCount = maxData[3];\n        }\n        if (minData) {\n          results.minCellWeight = minData[0];\n          results.totalCount = maxData[3];\n        }\n      }\n      return results;\n    }\n  }, {\n    key: \"getCellData\",\n    value: function getCellData(_ref3) {\n      var countsData = _ref3.countsData,\n        _ref3$size = _ref3.size,\n        size = _ref3$size === void 0 ? 1 : _ref3$size;\n      var numCells = countsData.length / 4;\n      var cellWeights = new Float32Array(numCells * size);\n      var cellCounts = new Uint32Array(numCells);\n      for (var i = 0; i < numCells; i++) {\n        for (var sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n          cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n        }\n        cellCounts[i] = countsData[i * 4 + 3];\n      }\n      return {\n        cellCounts: cellCounts,\n        cellWeights: cellWeights\n      };\n    }\n  }, {\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      return hasFeatures(gl, REQUIRED_FEATURES);\n    }\n  }]);\n  return GPUGridAggregator;\n}();\nexport { GPUGridAggregator as default };\nfunction normalizeWeightParams(weights) {\n  var result = {};\n  for (var id in weights) {\n    result[id] = _objectSpread(_objectSpread({}, DEFAULT_WEIGHT_PARAMS), weights[id]);\n  }\n  return result;\n}\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(function (obj) {\n    for (var name in obj) {\n      obj[name].delete();\n    }\n  });\n}\nfunction getAggregationModel(gl, shaderOptions) {\n  var shaders = mergeShaders({\n    vs: AGGREGATE_TO_GRID_VS,\n    fs: AGGREGATE_TO_GRID_FS,\n    modules: [fp64arithmetic, project32]\n  }, shaderOptions);\n  return new Model(gl, _objectSpread({\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: 0\n  }, shaders));\n}\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: 0,\n    isInstanced: true,\n    instanceCount: instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, _objectSpread({\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues'\n  }, opts));\n}","map":{"version":3,"names":["Model","Transform","FEATURES","hasFeatures","isWebGL2","readPixelsToBuffer","withParameters","fp64arithmetic","log","project32","_mergeShaders","mergeShaders","DEFAULT_RUN_PARAMS","MAX_32_BIT_FLOAT","MIN_BLEND_EQUATION","MAX_BLEND_EQUATION","MAX_MIN_BLEND_EQUATION","EQUATION_MAP","DEFAULT_WEIGHT_PARAMS","PIXEL_SIZE","AGGREGATION_OPERATION","AGGREGATE_TO_GRID_VS","AGGREGATE_TO_GRID_FS","AGGREGATE_ALL_VS","AGGREGATE_ALL_FS","TRANSFORM_MEAN_VS","getFloatTexture","getFramebuffer","BUFFER_NAMES","ARRAY_BUFFER_MAP","maxData","minData","maxMinData","REQUIRED_FEATURES","WEBGL2","COLOR_ATTACHMENT_RGBA32F","BLEND_EQUATION_MINMAX","FLOAT_BLEND","TEXTURE_FLOAT","GPUGridAggregator","gl","opts","arguments","length","undefined","_classCallCheck","id","state","weightAttributes","textures","meanTextures","buffers","framebuffers","maxMinFramebuffers","minFramebuffers","maxFramebuffers","equations","resources","results","_hasGPUSupport","_setupModels","_createClass","key","value","_delete","gridAggregationModel","allAggregationModel","meanTransform","_this$state","delete","deleteResources","run","setState","aggregationParams","_normalizeAggregationParams","_runAggregation","getData","weightId","data","aggregationData","aggregationBuffer","arrayName","bufferName","updateShaders","shaderOptions","modelDirty","_objectSpread","weights","normalizeWeightParams","updateObject","Object","assign","_getAggregateData","_this$state2","_weights$id","needMin","needMax","combineMaxMin","aggregationTexture","target","sourceType","maxMinBuffer","maxMinTexture","concat","minBuffer","minTexture","maxBuffer","maxTexture","_trackGPUResultBuffers","_renderAggregateData","cellSize","projectPoints","attributes","moduleSettings","numCol","numRow","translation","scaling","_this$state3","gridSize","parameters","blend","depthTest","blendFunc","uniforms","_weights$id2","_renderToWeightsTexture","_renderToMaxMinTexture","blendEquation","minOrMaxFb","clearParams","clearColor","_opts$clearParams","framebuffer","viewport","clear","draw","uSampler","texture","_this$state4","operation","MIN","MEAN","_this$state5","transformOptions","_sourceTextures","aggregationValues","_targetTexture","elementCount","width","height","update","getMeanTransform","attach","_defineProperty","_updateModels","_setupFramebuffers","_this$state6","framebufferSize","_weights$id3","resize","SUM","_getMinMaxTexture","name","_ref","_ref$numCol","_ref$numRow","_this$gridAggregation","getAggregationModel","instanceCount","getAllAggregationModel","_setupWeightAttributes","_i","_BUFFER_NAMES","vertexCount","setVertexCount","setAttributes","setInstanceCount","getAggregationData","_ref2","pixelIndex","index","cellCount","cellWeight","maxCellWieght","minCellWeight","totalCount","getCellData","_ref3","countsData","_ref3$size","size","numCells","cellWeights","Float32Array","cellCounts","Uint32Array","i","sizeIndex","isSupported","default","result","Array","isArray","forEach","obj","shaders","vs","fs","modules","drawMode","isInstanced","position","_targetTextureVarying"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/aggregation-layers/src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js"],"sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {\n  Model,\n  Transform,\n  FEATURES,\n  hasFeatures,\n  isWebGL2,\n  readPixelsToBuffer,\n  withParameters\n} from '@luma.gl/core';\nimport {fp64arithmetic} from '@luma.gl/shadertools';\nimport {log, project32, _mergeShaders as mergeShaders} from '@deck.gl/core';\n\nimport {\n  DEFAULT_RUN_PARAMS,\n  MAX_32_BIT_FLOAT,\n  MIN_BLEND_EQUATION,\n  MAX_BLEND_EQUATION,\n  MAX_MIN_BLEND_EQUATION,\n  EQUATION_MAP,\n  DEFAULT_WEIGHT_PARAMS,\n  PIXEL_SIZE\n} from './gpu-grid-aggregator-constants';\nimport {AGGREGATION_OPERATION} from '../aggregation-operation-utils';\n\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport {getFloatTexture, getFramebuffer} from './../resource-utils.js';\n\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\n\nconst REQUIRED_FEATURES = [\n  FEATURES.WEBGL2, // TODO: Remove after trannsform refactor\n  FEATURES.COLOR_ATTACHMENT_RGBA32F,\n  FEATURES.BLEND_EQUATION_MINMAX,\n  FEATURES.FLOAT_BLEND,\n  FEATURES.TEXTURE_FLOAT\n];\n\nexport default class GPUGridAggregator {\n  // Decode and return aggregation data of given pixel.\n  static getAggregationData({aggregationData, maxData, minData, maxMinData, pixelIndex}) {\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n    return results;\n  }\n\n  // Decodes and retuns counts and weights of all cells\n  static getCellData({countsData, size = 1}) {\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n    for (let i = 0; i < numCells; i++) {\n      // weights in RGB channels\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n      // count in Alpha channel\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n    return {cellCounts, cellWeights};\n  }\n\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n\n  // DEBUG ONLY\n  // static logData({aggregationBuffer, minBuffer, maxBuffer, maxMinBuffer, limit = 10}) {\n  //   if (aggregationBuffer) {\n  //     console.log('Aggregation Data:');\n  //     const agrData = aggregationBuffer.getData();\n  //     for (let index = 0; index < agrData.length && limit > 0; index += 4) {\n  //       if (agrData[index + 3] > 0) {\n  //         console.log(\n  //           `index: ${index} weights: ${agrData[index]} ${agrData[index + 1]} ${\n  //             agrData[index + 2]\n  //           } count: ${agrData[index + 3]}`\n  //         );\n  //         limit--;\n  //       }\n  //     }\n  //   }\n  //   const obj = {minBuffer, maxBuffer, maxMinBuffer};\n  //   for (const key in obj) {\n  //     if (obj[key]) {\n  //       const data = obj[key].getData();\n  //       console.log(`${key} data : R: ${data[0]} G: ${data[1]} B: ${data[2]} A: ${data[3]}`);\n  //     }\n  //   }\n  // }\n\n  constructor(gl, opts = {}) {\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      // per weight GPU resources\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n\n      // common resources to be deleted\n      resources: {},\n\n      // results\n      results: {}\n    };\n    this._hasGPUSupport =\n      isWebGL2(gl) && // gl_InstanceID usage in min/max calculation shaders\n      hasFeatures(\n        this.gl,\n        FEATURES.BLEND_EQUATION_MINMAX, // set min/max blend modes\n        FEATURES.COLOR_ATTACHMENT_RGBA32F, // render to float texture\n        FEATURES.TEXTURE_FLOAT // sample from a float texture\n      );\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {gridAggregationModel, allAggregationModel, meanTransform} = this;\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n\n    gridAggregationModel?.delete();\n    allAggregationModel?.delete();\n    meanTransform?.delete();\n\n    deleteResources([\n      framebuffers,\n      textures,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    ]);\n  }\n\n  // Perform aggregation and retun the results\n  run(opts = {}) {\n    // reset results\n    this.setState({results: {}});\n    const aggregationParams = this._normalizeAggregationParams(opts);\n    if (!this._hasGPUSupport) {\n      log.log(1, 'GPUGridAggregator: not supported')();\n    }\n    return this._runAggregation(aggregationParams);\n  }\n\n  // Reads aggregation data into JS Array object\n  // For WebGL1, data is available in JS Array objects already.\n  // For WebGL2, data is read from Buffer objects and cached for subsequent queries.\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n    if (!results[weightId].aggregationData) {\n      // cache the results if reading from the buffer (WebGL2 path)\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n    data.aggregationData = results[weightId].aggregationData;\n\n    // Check for optional results\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        // cache the result\n        results[weightId][arrayName] =\n          results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n    return data;\n  }\n\n  updateShaders(shaderOptions = {}) {\n    this.setState({shaderOptions, modelDirty: true});\n  }\n\n  // PRIVATE\n\n  _normalizeAggregationParams(opts) {\n    const aggregationParams = {...DEFAULT_RUN_PARAMS, ...opts};\n    const {weights} = aggregationParams;\n    if (weights) {\n      aggregationParams.weights = normalizeWeightParams(weights);\n    }\n    return aggregationParams;\n  }\n\n  // Update priveate state\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n\n  // GPU Aggregation methods\n\n  _getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      resources\n    } = this.state;\n    const {weights} = opts;\n\n    for (const id in weights) {\n      results[id] = {};\n      const {needMin, needMax, combineMaxMin} = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer, // update if a buffer is provided\n        sourceType: GL.FLOAT\n      });\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer, // update if a buffer is provided\n          sourceType: GL.FLOAT\n        });\n        results[id].maxMinTexture = resources[`${id}-maxMinTexture`];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].minTexture = resources[`${id}-minTexture`];\n        }\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].maxTexture = resources[`${id}-maxTexture`];\n        }\n      }\n    }\n    this._trackGPUResultBuffers(results, weights);\n    return results;\n  }\n\n  _renderAggregateData(opts) {\n    const {\n      cellSize,\n      projectPoints,\n      attributes,\n      moduleSettings,\n      numCol,\n      numRow,\n      weights,\n      translation,\n      scaling\n    } = opts;\n    const {maxMinFramebuffers, minFramebuffers, maxFramebuffers} = this.state;\n\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [GL.ONE, GL.ONE]\n    };\n    const uniforms = {\n      cellSize,\n      gridSize,\n      projectPoints,\n      translation,\n      scaling\n    };\n\n    for (const id in weights) {\n      const {needMin, needMax} = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n      this._renderToWeightsTexture({\n        id,\n        parameters,\n        moduleSettings,\n        uniforms,\n        gridSize,\n        attributes,\n        weights\n      });\n      if (combineMaxMin) {\n        this._renderToMaxMinTexture({\n          id,\n          parameters: {...parameters, blendEquation: MAX_MIN_BLEND_EQUATION},\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]},\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {...parameters, blendEquation: MIN_BLEND_EQUATION},\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]},\n            combineMaxMin\n          });\n        }\n        if (needMax) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {...parameters, blendEquation: MAX_BLEND_EQUATION},\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            clearParams: {clearColor: [0, 0, 0, 0]},\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n\n  // render all aggregated grid-cells to generate Min, Max or MaxMin data texture\n  _renderToMaxMinTexture(opts) {\n    const {id, parameters, gridSize, minOrMaxFb, combineMaxMin, clearParams = {}} = opts;\n    const {framebuffers} = this.state;\n    const {gl, allAggregationModel} = this;\n\n    withParameters(\n      gl,\n      {\n        ...clearParams,\n        framebuffer: minOrMaxFb,\n        viewport: [0, 0, gridSize[0], gridSize[1]]\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        allAggregationModel.draw({\n          parameters,\n          uniforms: {\n            uSampler: framebuffers[id].texture,\n            gridSize,\n            combineMaxMin\n          }\n        });\n      }\n    );\n  }\n\n  // render all data points to aggregate weights\n  _renderToWeightsTexture(opts) {\n    const {id, parameters, moduleSettings, uniforms, gridSize, weights} = opts;\n    const {framebuffers, equations, weightAttributes} = this.state;\n    const {gl, gridAggregationModel} = this;\n    const {operation} = weights[id];\n\n    const clearColor =\n      operation === AGGREGATION_OPERATION.MIN\n        ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n        : [0, 0, 0, 0];\n    withParameters(\n      gl,\n      {\n        framebuffer: framebuffers[id],\n        viewport: [0, 0, gridSize[0], gridSize[1]],\n        clearColor\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        const attributes = {weights: weightAttributes[id]};\n        gridAggregationModel.draw({\n          parameters: {...parameters, blendEquation: equations[id]},\n          moduleSettings,\n          uniforms,\n          attributes\n        });\n      }\n    );\n\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {meanTextures, textures} = this.state;\n      const transformOptions = {\n        _sourceTextures: {aggregationValues: meanTextures[id]}, // contains aggregated data\n        _targetTexture: textures[id], // store mean values,\n        elementCount: textures[id].width * textures[id].height\n      };\n      if (this.meanTransform) {\n        this.meanTransform.update(transformOptions);\n      } else {\n        this.meanTransform = getMeanTransform(gl, transformOptions);\n      }\n      this.meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n\n      // update framebuffer with mean results so readPixelsToBuffer returns mean values\n      framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: textures[id]});\n    }\n  }\n\n  _runAggregation(opts) {\n    this._updateModels(opts);\n    this._setupFramebuffers(opts);\n    this._renderAggregateData(opts);\n    const results = this._getAggregateData(opts);\n    this.setState({results});\n    return results;\n  }\n\n  // set up framebuffer for each weight\n  /* eslint-disable complexity, max-depth, max-statements*/\n  _setupFramebuffers(opts) {\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations\n    } = this.state;\n    const {weights} = opts;\n    const {numCol, numRow} = opts;\n    const framebufferSize = {width: numCol, height: numRow};\n    for (const id in weights) {\n      const {needMin, needMax, combineMaxMin, operation} = weights[id];\n      textures[id] =\n        weights[id].aggregationTexture ||\n        textures[id] ||\n        getFloatTexture(this.gl, {id: `${id}-texture`, width: numCol, height: numRow});\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        // For MEAN, we first aggregatet into a temp texture\n        meanTextures[id] =\n          meanTextures[id] ||\n          getFloatTexture(this.gl, {id: `${id}-mean-texture`, width: numCol, height: numRow});\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n      if (framebuffers[id]) {\n        framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: texture});\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: `${id}-fb`,\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n      // For min/max framebuffers will use default size 1X1\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = weights[id].maxMinTexture || this._getMinMaxTexture(`${id}-maxMinTexture`);\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {id: `${id}-maxMinFb`, texture});\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = weights[id].minTexture || this._getMinMaxTexture(`${id}-minTexture`);\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-minFb`,\n                texture\n              });\n            }\n          }\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = weights[id].maxTexture || this._getMinMaxTexture(`${id}-maxTexture`);\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-maxFb`,\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable complexity, max-depth, max-statements */\n\n  _getMinMaxTexture(name) {\n    const {resources} = this.state;\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {id: `resourceName`});\n    }\n    return resources[name];\n  }\n\n  _setupModels({numCol = 0, numRow = 0} = {}) {\n    const {gl} = this;\n    const {shaderOptions} = this.state;\n    this.gridAggregationModel?.delete();\n    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n    if (!this.allAggregationModel) {\n      const instanceCount = numCol * numRow;\n      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n    }\n  }\n\n  // set up buffers for all weights\n  _setupWeightAttributes(opts) {\n    const {weightAttributes} = this.state;\n    const {weights} = opts;\n    for (const id in weights) {\n      weightAttributes[id] = opts.attributes[id];\n    }\n  }\n\n  // GPU Aggregation results are provided in Buffers, if new Buffer objects are created track them for later deletion.\n  /* eslint-disable max-depth */\n  _trackGPUResultBuffers(results, weights) {\n    const {resources} = this.state;\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            // No result buffer is provided in weights object, `readPixelsToBuffer` has created a new Buffer object\n            // collect the new buffer for garabge collection\n            const name = `gpu-result-${id}-${bufferName}`;\n            if (resources[name]) {\n              resources[name].delete();\n            }\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable max-depth */\n\n  _updateModels(opts) {\n    const {vertexCount, attributes, numCol, numRow} = opts;\n    const {modelDirty} = this.state;\n\n    if (modelDirty) {\n      this._setupModels(opts);\n      this.setState({modelDirty: false});\n    }\n\n    // this maps color/elevation to weight name.\n    this._setupWeightAttributes(opts);\n\n    this.gridAggregationModel.setVertexCount(vertexCount);\n    this.gridAggregationModel.setAttributes(attributes);\n\n    this.allAggregationModel.setInstanceCount(numCol * numRow);\n  }\n}\n\n// HELPER METHODS\n\nfunction normalizeWeightParams(weights) {\n  const result = {};\n  for (const id in weights) {\n    result[id] = {...DEFAULT_WEIGHT_PARAMS, ...weights[id]};\n  }\n  return result;\n}\n\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(obj => {\n    for (const name in obj) {\n      obj[name].delete();\n    }\n  });\n}\n\nfunction getAggregationModel(gl, shaderOptions) {\n  const shaders = mergeShaders(\n    {\n      vs: AGGREGATE_TO_GRID_VS,\n      fs: AGGREGATE_TO_GRID_FS,\n      modules: [fp64arithmetic, project32]\n    },\n    shaderOptions\n  );\n\n  return new Model(gl, {\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    ...shaders\n  });\n}\n\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    isInstanced: true,\n    instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\n\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, {\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues',\n    ...opts\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}