{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexedDataContainer = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _dataRow = require(\"./data-row\");\nvar _marked = /*#__PURE__*/_regenerator[\"default\"].mark(rowsIterator),\n  _marked2 = /*#__PURE__*/_regenerator[\"default\"].mark(columnIterator);\n\n/**\n * @param dataContainer\n * @param indices\n * @param sharedRow\n * @returns\n */\nfunction rowsIterator(dataContainer, indices, sharedRow) {\n  var numRows, rowIndex, mappedRowIndex;\n  return _regenerator[\"default\"].wrap(function rowsIterator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          numRows = indices.length;\n          rowIndex = 0;\n        case 2:\n          if (!(rowIndex < numRows)) {\n            _context.next = 9;\n            break;\n          }\n          mappedRowIndex = indices[rowIndex];\n          _context.next = 6;\n          return dataContainer.row(mappedRowIndex, sharedRow);\n        case 6:\n          ++rowIndex;\n          _context.next = 2;\n          break;\n        case 9:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n/**\n * @param dataContainer\n * @param indices\n * @param columnIndex\n * @returns\n */\n\nfunction columnIterator(dataContainer, indices, columnIndex) {\n  var numRows, rowIndex, mappedRowIndex;\n  return _regenerator[\"default\"].wrap(function columnIterator$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          numRows = indices.length;\n          rowIndex = 0;\n        case 2:\n          if (!(rowIndex < numRows)) {\n            _context2.next = 9;\n            break;\n          }\n          mappedRowIndex = indices[rowIndex];\n          _context2.next = 6;\n          return dataContainer.valueAt(mappedRowIndex, columnIndex);\n        case 6:\n          ++rowIndex;\n          _context2.next = 2;\n          break;\n        case 9:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n/**\n * A data container wrapper around another data container.\n * You have to pass an array of indices to reference rows in the parent data container.\n * For example indices [3, 4, 6, 8] means that IndexedDataContainer is going to have\n * 4 rows and row(2) points to 6th row in the referenced data container.\n */\n\nvar IndexedDataContainer = /*#__PURE__*/function () {\n  function IndexedDataContainer(parentDataContainer, indices) {\n    (0, _classCallCheck2[\"default\"])(this, IndexedDataContainer);\n    (0, _defineProperty2[\"default\"])(this, \"_parentDataContainer\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"_indices\", void 0);\n    this._parentDataContainer = parentDataContainer;\n    this._indices = indices;\n  }\n  (0, _createClass2[\"default\"])(IndexedDataContainer, [{\n    key: \"numRows\",\n    value: function numRows() {\n      return this._indices.length;\n    }\n  }, {\n    key: \"numColumns\",\n    value: function numColumns() {\n      return this._parentDataContainer.numColumns();\n    }\n    /**\n     * Remaps a local index to an index in the parent dataset\n     * @param rowIndex\n     * @returns number\n     */\n  }, {\n    key: \"_mappedRowIndex\",\n    value: function _mappedRowIndex(rowIndex) {\n      return this._indices[rowIndex];\n    }\n  }, {\n    key: \"valueAt\",\n    value: function valueAt(rowIndex, columnIndex) {\n      return this._parentDataContainer.valueAt(this._mappedRowIndex(rowIndex), columnIndex);\n    }\n  }, {\n    key: \"row\",\n    value: function row(rowIndex, sharedRow) {\n      return this._parentDataContainer.row(this._mappedRowIndex(rowIndex), sharedRow);\n    }\n  }, {\n    key: \"rowAsArray\",\n    value: function rowAsArray(rowIndex) {\n      return this._parentDataContainer.rowAsArray(this._mappedRowIndex(rowIndex));\n    }\n  }, {\n    key: \"rows\",\n    value: function rows(sharedRow) {\n      return rowsIterator(this._parentDataContainer, this._indices, sharedRow);\n    }\n  }, {\n    key: \"column\",\n    value: function column(columnIndex) {\n      return columnIterator(this._parentDataContainer, this._indices, columnIndex);\n    }\n  }, {\n    key: \"getPlainIndex\",\n    value: function getPlainIndex() {\n      return this._indices.map(function (_, i) {\n        return i;\n      });\n    }\n  }, {\n    key: \"flattenData\",\n    value: function flattenData() {\n      var _this = this;\n      var tSharedRow = _dataRow.DataRow.createSharedRow(true);\n      return this._indices.map(function (_, i) {\n        return _this.row(i, tSharedRow).values();\n      }, this);\n    }\n  }, {\n    key: \"map\",\n    value: function map(func, sharedRow) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var _options$start = options.start,\n        start = _options$start === void 0 ? 0 : _options$start,\n        _options$end = options.end,\n        end = _options$end === void 0 ? this.numRows() : _options$end;\n      var endRow = Math.min(this.numRows(), end);\n      var tSharedRow = _dataRow.DataRow.createSharedRow(sharedRow);\n      var out = [];\n      for (var rowIndex = start; rowIndex < endRow; ++rowIndex) {\n        var _row = this.row(rowIndex, tSharedRow);\n        out.push(func(_row, rowIndex));\n      }\n      return out;\n    }\n  }, {\n    key: \"mapIndex\",\n    value: function mapIndex(func) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$start2 = options.start,\n        start = _options$start2 === void 0 ? 0 : _options$start2,\n        _options$end2 = options.end,\n        end = _options$end2 === void 0 ? this.numRows() : _options$end2;\n      var endRow = Math.min(this.numRows(), end);\n      var out = [];\n      for (var rowIndex = start; rowIndex < endRow; ++rowIndex) {\n        out.push(func({\n          index: this._mappedRowIndex(rowIndex)\n        }, this._parentDataContainer));\n      }\n      return out;\n    }\n  }, {\n    key: \"find\",\n    value: function find(func, sharedRow) {\n      var tSharedRow = _dataRow.DataRow.createSharedRow(sharedRow);\n      for (var rowIndex = 0; rowIndex < this.numRows(); ++rowIndex) {\n        var _row2 = this.row(rowIndex, tSharedRow);\n        if (func(_row2, rowIndex)) {\n          return _row2;\n        }\n      }\n      return undefined;\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(func, initialValue, sharedRow) {\n      var tSharedRow = _dataRow.DataRow.createSharedRow(sharedRow);\n      for (var rowIndex = 0; rowIndex < this._indices.length; ++rowIndex) {\n        var _row3 = this.row(rowIndex, tSharedRow);\n        initialValue = func(initialValue, _row3, rowIndex);\n      }\n      return initialValue;\n    }\n  }]);\n  return IndexedDataContainer;\n}();\nexports.IndexedDataContainer = IndexedDataContainer;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","IndexedDataContainer","_classCallCheck2","_createClass2","_defineProperty2","_regenerator","_dataRow","_marked","mark","rowsIterator","_marked2","columnIterator","dataContainer","indices","sharedRow","numRows","rowIndex","mappedRowIndex","wrap","rowsIterator$","_context","prev","next","length","stop","columnIndex","columnIterator$","_context2","parentDataContainer","_indices","_parentDataContainer","numColumns","_mappedRowIndex","valueAt","row","key","rows","column","getPlainIndex","map","_","i","_this","tSharedRow","DataRow","createSharedRow","values","options","start","_options$start","_options$end","end","endRow","Math","min","_row","out","push","func","mapIndex","_options$start2","_options$end2","index","_row2"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/utils/src/indexed-data-container.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {DataContainerInterface, RangeOptions} from './data-container-interface';\nimport {DataRow, SharedRowOptions} from './data-row';\n\n/**\n * @param dataContainer\n * @param indices\n * @param sharedRow\n * @returns\n */\nfunction* rowsIterator(\n  dataContainer: DataContainerInterface,\n  indices: number[],\n  sharedRow: SharedRowOptions\n): Generator<DataRow> {\n  const numRows = indices.length;\n  for (let rowIndex = 0; rowIndex < numRows; ++rowIndex) {\n    const mappedRowIndex = indices[rowIndex];\n    yield dataContainer.row(mappedRowIndex, sharedRow);\n  }\n}\n\n/**\n * @param dataContainer\n * @param indices\n * @param columnIndex\n * @returns\n */\nfunction* columnIterator(\n  dataContainer: DataContainerInterface,\n  indices: number[],\n  columnIndex: number\n): Generator<any> {\n  const numRows = indices.length;\n  for (let rowIndex = 0; rowIndex < numRows; ++rowIndex) {\n    const mappedRowIndex = indices[rowIndex];\n    yield dataContainer.valueAt(mappedRowIndex, columnIndex);\n  }\n}\n\n/**\n * A data container wrapper around another data container.\n * You have to pass an array of indices to reference rows in the parent data container.\n * For example indices [3, 4, 6, 8] means that IndexedDataContainer is going to have\n * 4 rows and row(2) points to 6th row in the referenced data container.\n */\nexport class IndexedDataContainer implements DataContainerInterface {\n  _parentDataContainer: DataContainerInterface;\n  _indices: number[];\n\n  constructor(parentDataContainer: DataContainerInterface, indices: number[]) {\n    this._parentDataContainer = parentDataContainer;\n    this._indices = indices;\n  }\n\n  numRows(): number {\n    return this._indices.length;\n  }\n\n  numColumns(): number {\n    return this._parentDataContainer.numColumns();\n  }\n\n  /**\n   * Remaps a local index to an index in the parent dataset\n   * @param rowIndex\n   * @returns number\n   */\n  _mappedRowIndex(rowIndex: number): number {\n    return this._indices[rowIndex];\n  }\n\n  valueAt(rowIndex: number, columnIndex: number): any {\n    return this._parentDataContainer.valueAt(this._mappedRowIndex(rowIndex), columnIndex);\n  }\n\n  row(rowIndex: number, sharedRow?: SharedRowOptions): DataRow {\n    return this._parentDataContainer.row(this._mappedRowIndex(rowIndex), sharedRow);\n  }\n\n  rowAsArray(rowIndex: number): any[] {\n    return this._parentDataContainer.rowAsArray(this._mappedRowIndex(rowIndex));\n  }\n\n  rows(sharedRow?: SharedRowOptions) {\n    return rowsIterator(this._parentDataContainer, this._indices, sharedRow);\n  }\n\n  column(columnIndex: number) {\n    return columnIterator(this._parentDataContainer, this._indices, columnIndex);\n  }\n\n  getPlainIndex(): number[] {\n    return this._indices.map((_, i) => i);\n  }\n\n  flattenData(): any[][] {\n    const tSharedRow = DataRow.createSharedRow(true);\n\n    return this._indices.map((_, i) => {\n      return this.row(i, tSharedRow).values();\n    }, this);\n  }\n\n  map<T>(\n    func: (row: DataRow, index: number) => T,\n    sharedRow?: SharedRowOptions,\n    options: RangeOptions = {}\n  ): T[] {\n    const {start = 0, end = this.numRows()} = options;\n    const endRow = Math.min(this.numRows(), end);\n\n    const tSharedRow = DataRow.createSharedRow(sharedRow);\n\n    const out: T[] = [];\n    for (let rowIndex = start; rowIndex < endRow; ++rowIndex) {\n      const row = this.row(rowIndex, tSharedRow);\n      out.push(func(row, rowIndex));\n    }\n    return out;\n  }\n\n  mapIndex<T>(\n    func: ({index: number}, dc: DataContainerInterface) => T,\n    options: RangeOptions = {}\n  ): T[] {\n    const {start = 0, end = this.numRows()} = options;\n    const endRow = Math.min(this.numRows(), end);\n\n    const out: T[] = [];\n    for (let rowIndex = start; rowIndex < endRow; ++rowIndex) {\n      out.push(func({index: this._mappedRowIndex(rowIndex)}, this._parentDataContainer));\n    }\n    return out;\n  }\n\n  find(\n    func: (row: DataRow, index: number) => boolean,\n    sharedRow?: SharedRowOptions\n  ): DataRow | undefined {\n    const tSharedRow = DataRow.createSharedRow(sharedRow);\n\n    for (let rowIndex = 0; rowIndex < this.numRows(); ++rowIndex) {\n      const row = this.row(rowIndex, tSharedRow);\n      if (func(row, rowIndex)) {\n        return row;\n      }\n    }\n    return undefined;\n  }\n\n  reduce<T>(\n    func: (acc: T, row: DataRow, index: number) => T,\n    initialValue: T,\n    sharedRow?: SharedRowOptions\n  ): T {\n    const tSharedRow = DataRow.createSharedRow(sharedRow);\n\n    for (let rowIndex = 0; rowIndex < this._indices.length; ++rowIndex) {\n      const row = this.row(rowIndex, tSharedRow);\n      initialValue = func(initialValue, row, rowIndex);\n    }\n    return initialValue;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}