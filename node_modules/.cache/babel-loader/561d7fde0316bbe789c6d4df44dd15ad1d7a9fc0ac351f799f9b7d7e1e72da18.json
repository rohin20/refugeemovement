{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\n/**\n * Window Sections are used to group nearby cells.\n * This enables us to more quickly determine which cells to display in a given region of the Window.\n * \n */\nimport Section from './Section';\nvar SECTION_SIZE = 100;\n\n/**\n * Contains 0 to many Sections.\n * Grows (and adds Sections) dynamically as cells are registered.\n * Automatically adds cells to the appropriate Section(s).\n */\nvar SectionManager = /*#__PURE__*/\nfunction () {\n  function SectionManager() {\n    var sectionSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SECTION_SIZE;\n    _classCallCheck(this, SectionManager);\n    this._sectionSize = sectionSize;\n    this._cellMetadata = [];\n    this._sections = {};\n  }\n  /**\n   * Gets all cell indices contained in the specified region.\n   * A region may encompass 1 or more Sections.\n   */\n\n  _createClass(SectionManager, [{\n    key: \"getCellIndices\",\n    value: function getCellIndices(_ref) {\n      var height = _ref.height,\n        width = _ref.width,\n        x = _ref.x,\n        y = _ref.y;\n      var indices = {};\n      this.getSections({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      }).forEach(function (section) {\n        return section.getCellIndices().forEach(function (index) {\n          indices[index] = index;\n        });\n      }); // Object keys are strings; this function returns numbers\n\n      return Object.keys(indices).map(function (index) {\n        return indices[index];\n      });\n    }\n    /** Get size and position information for the cell specified. */\n  }, {\n    key: \"getCellMetadata\",\n    value: function getCellMetadata(_ref2) {\n      var index = _ref2.index;\n      return this._cellMetadata[index];\n    }\n    /** Get all Sections overlapping the specified region. */\n  }, {\n    key: \"getSections\",\n    value: function getSections(_ref3) {\n      var height = _ref3.height,\n        width = _ref3.width,\n        x = _ref3.x,\n        y = _ref3.y;\n      var sectionXStart = Math.floor(x / this._sectionSize);\n      var sectionXStop = Math.floor((x + width - 1) / this._sectionSize);\n      var sectionYStart = Math.floor(y / this._sectionSize);\n      var sectionYStop = Math.floor((y + height - 1) / this._sectionSize);\n      var sections = [];\n      for (var sectionX = sectionXStart; sectionX <= sectionXStop; sectionX++) {\n        for (var sectionY = sectionYStart; sectionY <= sectionYStop; sectionY++) {\n          var key = \"\".concat(sectionX, \".\").concat(sectionY);\n          if (!this._sections[key]) {\n            this._sections[key] = new Section({\n              height: this._sectionSize,\n              width: this._sectionSize,\n              x: sectionX * this._sectionSize,\n              y: sectionY * this._sectionSize\n            });\n          }\n          sections.push(this._sections[key]);\n        }\n      }\n      return sections;\n    }\n    /** Total number of Sections based on the currently registered cells. */\n  }, {\n    key: \"getTotalSectionCount\",\n    value: function getTotalSectionCount() {\n      return Object.keys(this._sections).length;\n    }\n    /** Intended for debugger/test purposes only */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var _this = this;\n      return Object.keys(this._sections).map(function (index) {\n        return _this._sections[index].toString();\n      });\n    }\n    /** Adds a cell to the appropriate Sections and registers it metadata for later retrievable. */\n  }, {\n    key: \"registerCell\",\n    value: function registerCell(_ref4) {\n      var cellMetadatum = _ref4.cellMetadatum,\n        index = _ref4.index;\n      this._cellMetadata[index] = cellMetadatum;\n      this.getSections(cellMetadatum).forEach(function (section) {\n        return section.addCellIndex({\n          index: index\n        });\n      });\n    }\n  }]);\n  return SectionManager;\n}();\nexport { SectionManager as default };\nimport { bpfrpt_proptype_Index } from \"./types\";\nimport { bpfrpt_proptype_SizeAndPositionInfo } from \"./types\";","map":{"version":3,"names":["_classCallCheck","_createClass","Section","SECTION_SIZE","SectionManager","sectionSize","arguments","length","undefined","_sectionSize","_cellMetadata","_sections","key","value","getCellIndices","_ref","height","width","x","y","indices","getSections","forEach","section","index","Object","keys","map","getCellMetadata","_ref2","_ref3","sectionXStart","Math","floor","sectionXStop","sectionYStart","sectionYStop","sections","sectionX","sectionY","concat","push","getTotalSectionCount","toString","_this","registerCell","_ref4","cellMetadatum","addCellIndex","default","bpfrpt_proptype_Index","bpfrpt_proptype_SizeAndPositionInfo"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/react-virtualized/dist/es/Collection/SectionManager.js"],"sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\n/**\n * Window Sections are used to group nearby cells.\n * This enables us to more quickly determine which cells to display in a given region of the Window.\n * \n */\nimport Section from './Section';\nvar SECTION_SIZE = 100;\n\n/**\n * Contains 0 to many Sections.\n * Grows (and adds Sections) dynamically as cells are registered.\n * Automatically adds cells to the appropriate Section(s).\n */\nvar SectionManager =\n/*#__PURE__*/\nfunction () {\n  function SectionManager() {\n    var sectionSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SECTION_SIZE;\n\n    _classCallCheck(this, SectionManager);\n\n    this._sectionSize = sectionSize;\n    this._cellMetadata = [];\n    this._sections = {};\n  }\n  /**\n   * Gets all cell indices contained in the specified region.\n   * A region may encompass 1 or more Sections.\n   */\n\n\n  _createClass(SectionManager, [{\n    key: \"getCellIndices\",\n    value: function getCellIndices(_ref) {\n      var height = _ref.height,\n          width = _ref.width,\n          x = _ref.x,\n          y = _ref.y;\n      var indices = {};\n      this.getSections({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      }).forEach(function (section) {\n        return section.getCellIndices().forEach(function (index) {\n          indices[index] = index;\n        });\n      }); // Object keys are strings; this function returns numbers\n\n      return Object.keys(indices).map(function (index) {\n        return indices[index];\n      });\n    }\n    /** Get size and position information for the cell specified. */\n\n  }, {\n    key: \"getCellMetadata\",\n    value: function getCellMetadata(_ref2) {\n      var index = _ref2.index;\n      return this._cellMetadata[index];\n    }\n    /** Get all Sections overlapping the specified region. */\n\n  }, {\n    key: \"getSections\",\n    value: function getSections(_ref3) {\n      var height = _ref3.height,\n          width = _ref3.width,\n          x = _ref3.x,\n          y = _ref3.y;\n      var sectionXStart = Math.floor(x / this._sectionSize);\n      var sectionXStop = Math.floor((x + width - 1) / this._sectionSize);\n      var sectionYStart = Math.floor(y / this._sectionSize);\n      var sectionYStop = Math.floor((y + height - 1) / this._sectionSize);\n      var sections = [];\n\n      for (var sectionX = sectionXStart; sectionX <= sectionXStop; sectionX++) {\n        for (var sectionY = sectionYStart; sectionY <= sectionYStop; sectionY++) {\n          var key = \"\".concat(sectionX, \".\").concat(sectionY);\n\n          if (!this._sections[key]) {\n            this._sections[key] = new Section({\n              height: this._sectionSize,\n              width: this._sectionSize,\n              x: sectionX * this._sectionSize,\n              y: sectionY * this._sectionSize\n            });\n          }\n\n          sections.push(this._sections[key]);\n        }\n      }\n\n      return sections;\n    }\n    /** Total number of Sections based on the currently registered cells. */\n\n  }, {\n    key: \"getTotalSectionCount\",\n    value: function getTotalSectionCount() {\n      return Object.keys(this._sections).length;\n    }\n    /** Intended for debugger/test purposes only */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var _this = this;\n\n      return Object.keys(this._sections).map(function (index) {\n        return _this._sections[index].toString();\n      });\n    }\n    /** Adds a cell to the appropriate Sections and registers it metadata for later retrievable. */\n\n  }, {\n    key: \"registerCell\",\n    value: function registerCell(_ref4) {\n      var cellMetadatum = _ref4.cellMetadatum,\n          index = _ref4.index;\n      this._cellMetadata[index] = cellMetadatum;\n      this.getSections(cellMetadatum).forEach(function (section) {\n        return section.addCellIndex({\n          index: index\n        });\n      });\n    }\n  }]);\n\n  return SectionManager;\n}();\n\nexport { SectionManager as default };\nimport { bpfrpt_proptype_Index } from \"./types\";\nimport { bpfrpt_proptype_SizeAndPositionInfo } from \"./types\";"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}