{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { ManagedArray } from '../utils/managed-array';\nimport { TILE_REFINEMENT } from '../constants';\nexport var DEFAULT_PROPS = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2,\n  updateTransforms: true,\n  onTraversalEnd: function onTraversalEnd() {},\n  viewportTraversersMap: {},\n  basePath: ''\n};\nexport var TilesetTraverser = /*#__PURE__*/function () {\n  function TilesetTraverser(options) {\n    _classCallCheck(this, TilesetTraverser);\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"root\", void 0);\n    _defineProperty(this, \"requestedTiles\", void 0);\n    _defineProperty(this, \"selectedTiles\", void 0);\n    _defineProperty(this, \"emptyTiles\", void 0);\n    _defineProperty(this, \"lastUpdate\", new Date().getTime());\n    _defineProperty(this, \"updateDebounceTime\", 1000);\n    _defineProperty(this, \"_traversalStack\", void 0);\n    _defineProperty(this, \"_emptyTraversalStack\", void 0);\n    _defineProperty(this, \"_frameNumber\", void 0);\n    this.options = _objectSpread(_objectSpread({}, DEFAULT_PROPS), options);\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n    this._frameNumber = null;\n    this.root = null;\n    this.selectedTiles = {};\n    this.requestedTiles = {};\n    this.emptyTiles = {};\n  }\n  _createClass(TilesetTraverser, [{\n    key: \"traversalFinished\",\n    value: function traversalFinished(frameState) {\n      return true;\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(root, frameState, options) {\n      this.root = root;\n      this.options = _objectSpread(_objectSpread({}, this.options), options);\n      this.reset();\n      this.updateTile(root, frameState);\n      this._frameNumber = frameState.frameNumber;\n      this.executeTraversal(root, frameState);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.requestedTiles = {};\n      this.selectedTiles = {};\n      this.emptyTiles = {};\n      this._traversalStack.reset();\n      this._emptyTraversalStack.reset();\n    }\n  }, {\n    key: \"executeTraversal\",\n    value: function executeTraversal(root, frameState) {\n      var stack = this._traversalStack;\n      root._selectionDepth = 1;\n      stack.push(root);\n      while (stack.length > 0) {\n        var tile = stack.pop();\n        var shouldRefine = false;\n        if (this.canTraverse(tile, frameState)) {\n          this.updateChildTiles(tile, frameState);\n          shouldRefine = this.updateAndPushChildren(tile, frameState, stack, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);\n        }\n        var parent = tile.parent;\n        var parentRefines = Boolean(!parent || parent._shouldRefine);\n        var stoppedRefining = !shouldRefine;\n        if (!tile.hasRenderContent) {\n          this.emptyTiles[tile.id] = tile;\n          this.loadTile(tile, frameState);\n          if (stoppedRefining) {\n            this.selectTile(tile, frameState);\n          }\n        } else if (tile.refine === TILE_REFINEMENT.ADD) {\n          this.loadTile(tile, frameState);\n          this.selectTile(tile, frameState);\n        } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n          this.loadTile(tile, frameState);\n          if (stoppedRefining) {\n            this.selectTile(tile, frameState);\n          }\n        }\n        this.touchTile(tile, frameState);\n        tile._shouldRefine = shouldRefine && parentRefines;\n      }\n      var newTime = new Date().getTime();\n      if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {\n        this.lastUpdate = newTime;\n        this.options.onTraversalEnd(frameState);\n      }\n    }\n  }, {\n    key: \"updateChildTiles\",\n    value: function updateChildTiles(tile, frameState) {\n      var children = tile.children;\n      var _iterator = _createForOfIteratorHelper(children),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          this.updateTile(child, frameState);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return true;\n    }\n  }, {\n    key: \"updateAndPushChildren\",\n    value: function updateAndPushChildren(tile, frameState, stack, depth) {\n      var _this$options = this.options,\n        loadSiblings = _this$options.loadSiblings,\n        skipLevelOfDetail = _this$options.skipLevelOfDetail;\n      var children = tile.children;\n      children.sort(this.compareDistanceToCamera.bind(this));\n      var checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n      var hasVisibleChild = false;\n      var refines = true;\n      var _iterator2 = _createForOfIteratorHelper(children),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var child = _step2.value;\n          child._selectionDepth = depth;\n          if (child.isVisibleAndInRequestVolume) {\n            if (stack.find(child)) {\n              stack.delete(child);\n            }\n            stack.push(child);\n            hasVisibleChild = true;\n          } else if (checkRefines || loadSiblings) {\n            this.loadTile(child, frameState);\n            this.touchTile(child, frameState);\n          }\n          if (checkRefines) {\n            var childRefines = void 0;\n            if (!child._inRequestVolume) {\n              childRefines = false;\n            } else if (!child.hasRenderContent) {\n              childRefines = this.executeEmptyTraversal(child, frameState);\n            } else {\n              childRefines = child.contentAvailable;\n            }\n            refines = refines && childRefines;\n            if (!refines) {\n              return false;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      if (!hasVisibleChild) {\n        refines = false;\n      }\n      return refines;\n    }\n  }, {\n    key: \"updateTile\",\n    value: function updateTile(tile, frameState) {\n      this.updateTileVisibility(tile, frameState);\n    }\n  }, {\n    key: \"selectTile\",\n    value: function selectTile(tile, frameState) {\n      if (this.shouldSelectTile(tile)) {\n        tile._selectedFrame = frameState.frameNumber;\n        this.selectedTiles[tile.id] = tile;\n      }\n    }\n  }, {\n    key: \"loadTile\",\n    value: function loadTile(tile, frameState) {\n      if (this.shouldLoadTile(tile)) {\n        tile._requestedFrame = frameState.frameNumber;\n        tile._priority = tile._getPriority();\n        this.requestedTiles[tile.id] = tile;\n      }\n    }\n  }, {\n    key: \"touchTile\",\n    value: function touchTile(tile, frameState) {\n      tile.tileset._cache.touch(tile);\n      tile._touchedFrame = frameState.frameNumber;\n    }\n  }, {\n    key: \"canTraverse\",\n    value: function canTraverse(tile, frameState) {\n      var useParentMetric = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var ignoreVisibility = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      if (!tile.hasChildren) {\n        return false;\n      }\n      if (tile.hasTilesetContent) {\n        return !tile.contentExpired;\n      }\n      if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n        return false;\n      }\n      return this.shouldRefine(tile, frameState, useParentMetric);\n    }\n  }, {\n    key: \"shouldLoadTile\",\n    value: function shouldLoadTile(tile) {\n      return tile.hasUnloadedContent || tile.contentExpired;\n    }\n  }, {\n    key: \"shouldSelectTile\",\n    value: function shouldSelectTile(tile) {\n      return tile.contentAvailable && !this.options.skipLevelOfDetail;\n    }\n  }, {\n    key: \"shouldRefine\",\n    value: function shouldRefine(tile, frameState, useParentMetric) {\n      var screenSpaceError = tile._screenSpaceError;\n      if (useParentMetric) {\n        screenSpaceError = tile.getScreenSpaceError(frameState, true);\n      }\n      return screenSpaceError > this.options.maximumScreenSpaceError;\n    }\n  }, {\n    key: \"updateTileVisibility\",\n    value: function updateTileVisibility(tile, frameState) {\n      var viewportIds = [];\n      if (this.options.viewportTraversersMap) {\n        for (var key in this.options.viewportTraversersMap) {\n          var value = this.options.viewportTraversersMap[key];\n          if (value === frameState.viewport.id) {\n            viewportIds.push(key);\n          }\n        }\n      } else {\n        viewportIds.push(frameState.viewport.id);\n      }\n      tile.updateVisibility(frameState, viewportIds);\n    }\n  }, {\n    key: \"compareDistanceToCamera\",\n    value: function compareDistanceToCamera(b, a) {\n      return b._distanceToCamera - a._distanceToCamera;\n    }\n  }, {\n    key: \"anyChildrenVisible\",\n    value: function anyChildrenVisible(tile, frameState) {\n      var anyVisible = false;\n      var _iterator3 = _createForOfIteratorHelper(tile.children),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var child = _step3.value;\n          child.updateVisibility(frameState);\n          anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return anyVisible;\n    }\n  }, {\n    key: \"executeEmptyTraversal\",\n    value: function executeEmptyTraversal(root, frameState) {\n      var allDescendantsLoaded = true;\n      var stack = this._emptyTraversalStack;\n      stack.push(root);\n      while (stack.length > 0 && allDescendantsLoaded) {\n        var tile = stack.pop();\n        this.updateTile(tile, frameState);\n        if (!tile.isVisibleAndInRequestVolume) {\n          this.loadTile(tile, frameState);\n        }\n        this.touchTile(tile, frameState);\n        var traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n        if (traverse) {\n          var children = tile.children;\n          var _iterator4 = _createForOfIteratorHelper(children),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var child = _step4.value;\n              if (stack.find(child)) {\n                stack.delete(child);\n              }\n              stack.push(child);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        } else if (!tile.contentAvailable) {\n          allDescendantsLoaded = false;\n        }\n      }\n      return allDescendantsLoaded;\n    }\n  }]);\n  return TilesetTraverser;\n}();","map":{"version":3,"names":["ManagedArray","TILE_REFINEMENT","DEFAULT_PROPS","loadSiblings","skipLevelOfDetail","maximumScreenSpaceError","updateTransforms","onTraversalEnd","viewportTraversersMap","basePath","TilesetTraverser","options","_classCallCheck","_defineProperty","Date","getTime","_objectSpread","_traversalStack","_emptyTraversalStack","_frameNumber","root","selectedTiles","requestedTiles","emptyTiles","_createClass","key","value","traversalFinished","frameState","traverse","reset","updateTile","frameNumber","executeTraversal","stack","_selectionDepth","push","length","tile","pop","shouldRefine","canTraverse","updateChildTiles","updateAndPushChildren","hasRenderContent","parent","parentRefines","Boolean","_shouldRefine","stoppedRefining","id","loadTile","selectTile","refine","ADD","REPLACE","touchTile","newTime","lastUpdate","updateDebounceTime","children","_iterator","_createForOfIteratorHelper","_step","s","n","done","child","err","e","f","depth","_this$options","sort","compareDistanceToCamera","bind","checkRefines","hasVisibleChild","refines","_iterator2","_step2","isVisibleAndInRequestVolume","find","delete","childRefines","_inRequestVolume","executeEmptyTraversal","contentAvailable","updateTileVisibility","shouldSelectTile","_selectedFrame","shouldLoadTile","_requestedFrame","_priority","_getPriority","tileset","_cache","touch","_touchedFrame","useParentMetric","arguments","undefined","ignoreVisibility","hasChildren","hasTilesetContent","contentExpired","hasUnloadedContent","screenSpaceError","_screenSpaceError","getScreenSpaceError","viewportIds","viewport","updateVisibility","b","a","_distanceToCamera","anyChildrenVisible","anyVisible","_iterator3","_step3","allDescendantsLoaded","_iterator4","_step4"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/geo-layers/node_modules/@loaders.gl/tiles/src/tileset/tileset-traverser.ts"],"sourcesContent":["import {ManagedArray} from '../utils/managed-array';\nimport {TILE_REFINEMENT} from '../constants';\nimport {FrameState} from './helpers/frame-state';\n\nexport type TilesetTraverserProps = {\n  loadSiblings?: boolean;\n  skipLevelOfDetail?: boolean;\n  maximumScreenSpaceError?: number;\n  onTraversalEnd?: (frameState) => any;\n  viewportTraversersMap?: {[key: string]: any};\n  basePath?: string;\n  updateTransforms?: boolean;\n};\n\n// export type Props = {\n//   loadSiblings: boolean;\n//   skipLevelOfDetail: boolean;\n//   updateTransforms: boolean;\n//   maximumScreenSpaceError: number;\n//   onTraversalEnd: (frameState) => any;\n//   viewportTraversersMap: {[key: string]: any};\n//   basePath: string;\n// };\n\nexport const DEFAULT_PROPS: Required<TilesetTraverserProps> = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2,\n  updateTransforms: true,\n  onTraversalEnd: () => {},\n  viewportTraversersMap: {},\n  basePath: ''\n};\n\nexport class TilesetTraverser {\n  options: Required<TilesetTraverserProps>;\n\n  root: any;\n  requestedTiles: object;\n  selectedTiles: object;\n  emptyTiles: object;\n\n  protected lastUpdate: number = new Date().getTime();\n  protected readonly updateDebounceTime = 1000;\n  protected _traversalStack: ManagedArray;\n  protected _emptyTraversalStack: ManagedArray;\n  protected _frameNumber: number | null;\n\n  protected traversalFinished(frameState: FrameState): boolean {\n    return true;\n  }\n\n  // TODO nested props\n  constructor(options: TilesetTraverserProps) {\n    this.options = {...DEFAULT_PROPS, ...options};\n    // TRAVERSAL\n    // temporary storage to hold the traversed tiles during a traversal\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n\n    // set in every traverse cycle\n    this._frameNumber = null;\n\n    // fulfill in traverse call\n    this.root = null;\n\n    // RESULT\n    // tiles should be rendered\n    this.selectedTiles = {};\n    // tiles should be loaded from server\n    this.requestedTiles = {};\n    // tiles does not have render content\n    this.emptyTiles = {};\n  }\n\n  // tiles should be visible\n  traverse(root, frameState, options) {\n    this.root = root; // for root screen space error\n    this.options = {...this.options, ...options};\n\n    // reset result\n    this.reset();\n\n    // update tile (visibility and expiration)\n    this.updateTile(root, frameState);\n\n    this._frameNumber = frameState.frameNumber;\n    this.executeTraversal(root, frameState);\n  }\n\n  reset() {\n    this.requestedTiles = {};\n    this.selectedTiles = {};\n    this.emptyTiles = {};\n    this._traversalStack.reset();\n    this._emptyTraversalStack.reset();\n  }\n\n  // execute traverse\n  // Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n  // If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n  // This is the traditional replacement refinement approach and is called the base traversal.\n  // Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n  // all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n  // and rendering children and parent tiles simultaneously.\n  /* eslint-disable-next-line complexity, max-statements */\n  executeTraversal(root, frameState: FrameState) {\n    // stack to store traversed tiles, only visible tiles should be added to stack\n    // visible: visible in the current view frustum\n    const stack = this._traversalStack;\n    root._selectionDepth = 1;\n\n    stack.push(root);\n    while (stack.length > 0) {\n      // 1. pop tile\n      const tile = stack.pop();\n\n      // 2. check if tile needs to be refine, needs refine if a tile's LoD is not sufficient and tile has available children (available content)\n      let shouldRefine = false;\n      if (this.canTraverse(tile, frameState)) {\n        this.updateChildTiles(tile, frameState);\n        shouldRefine = this.updateAndPushChildren(\n          tile,\n          frameState,\n          stack,\n          tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth\n        );\n      }\n\n      // 3. decide if should render (select) this tile\n      //   - tile does not have render content\n      //   - tile has render content and tile is `add` type (pointcloud)\n      //   - tile has render content and tile is `replace` type (photogrammetry) and can't refine any further\n      const parent = tile.parent;\n      const parentRefines = Boolean(!parent || parent._shouldRefine);\n      const stoppedRefining = !shouldRefine;\n\n      if (!tile.hasRenderContent) {\n        this.emptyTiles[tile.id] = tile;\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n        // additive tiles\n      } else if (tile.refine === TILE_REFINEMENT.ADD) {\n        // Additive tiles are always loaded and selected\n        this.loadTile(tile, frameState);\n        this.selectTile(tile, frameState);\n\n        // replace tiles\n      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      }\n\n      // 3. update cache, most recent touched tiles have higher priority to be fetched from server\n      this.touchTile(tile, frameState);\n\n      // 4. update tile refine prop and parent refinement status to trickle down to the descendants\n      tile._shouldRefine = shouldRefine && parentRefines;\n    }\n\n    const newTime = new Date().getTime();\n    if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {\n      this.lastUpdate = newTime;\n      this.options.onTraversalEnd(frameState);\n    }\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.children;\n    for (const child of children) {\n      this.updateTile(child, frameState);\n    }\n    return true;\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAndPushChildren(tile, frameState, stack, depth) {\n    const {loadSiblings, skipLevelOfDetail} = this.options;\n\n    const children = tile.children;\n\n    // sort children tiles\n    children.sort(this.compareDistanceToCamera.bind(this));\n\n    // For traditional replacement refinement only refine if all children are loaded.\n    // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n    const checkRefines =\n      tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n\n    let hasVisibleChild = false;\n    let refines = true;\n\n    for (const child of children) {\n      child._selectionDepth = depth;\n      if (child.isVisibleAndInRequestVolume) {\n        if (stack.find(child)) {\n          stack.delete(child);\n        }\n        stack.push(child);\n        hasVisibleChild = true;\n      } else if (checkRefines || loadSiblings) {\n        // Keep non-visible children loaded since they are still needed before the parent can refine.\n        // Or loadSiblings is true so always load tiles regardless of visibility.\n        this.loadTile(child, frameState);\n        this.touchTile(child, frameState);\n      }\n\n      if (checkRefines) {\n        let childRefines;\n        if (!child._inRequestVolume) {\n          childRefines = false;\n        } else if (!child.hasRenderContent) {\n          childRefines = this.executeEmptyTraversal(child, frameState);\n        } else {\n          childRefines = child.contentAvailable;\n        }\n        refines = refines && childRefines;\n\n        if (!refines) {\n          return false;\n        }\n      }\n    }\n\n    if (!hasVisibleChild) {\n      refines = false;\n    }\n    return refines;\n  }\n  /* eslint-enable complexity, max-statements */\n\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n  }\n\n  // tile to render in the browser\n  selectTile(tile, frameState) {\n    if (this.shouldSelectTile(tile)) {\n      // The tile can be selected right away and does not require traverseAndSelect\n      tile._selectedFrame = frameState.frameNumber;\n      this.selectedTiles[tile.id] = tile;\n    }\n  }\n\n  // tile to load from server\n  loadTile(tile, frameState) {\n    if (this.shouldLoadTile(tile)) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = tile._getPriority();\n      this.requestedTiles[tile.id] = tile;\n    }\n  }\n\n  // cache tile\n  touchTile(tile, frameState) {\n    tile.tileset._cache.touch(tile);\n    tile._touchedFrame = frameState.frameNumber;\n  }\n\n  // tile should be visible\n  // tile should have children\n  // tile LoD (level of detail) is not sufficient under current viewport\n  canTraverse(tile, frameState, useParentMetric = false, ignoreVisibility = false) {\n    if (!tile.hasChildren) {\n      return false;\n    }\n\n    // cesium specific\n    if (tile.hasTilesetContent) {\n      // Traverse external this to visit its root tile\n      // Don't traverse if the subtree is expired because it will be destroyed\n      return !tile.contentExpired;\n    }\n\n    if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n      return false;\n    }\n\n    return this.shouldRefine(tile, frameState, useParentMetric);\n  }\n\n  shouldLoadTile(tile) {\n    // if request tile is in current frame\n    // and has unexpired render content\n    return tile.hasUnloadedContent || tile.contentExpired;\n  }\n\n  shouldSelectTile(tile) {\n    // if select tile is in current frame\n    // and content available\n    return tile.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n\n  // Decide if tile LoD (level of detail) is not sufficient under current viewport\n  shouldRefine(tile, frameState, useParentMetric) {\n    let screenSpaceError = tile._screenSpaceError;\n    if (useParentMetric) {\n      screenSpaceError = tile.getScreenSpaceError(frameState, true);\n    }\n\n    return screenSpaceError > this.options.maximumScreenSpaceError;\n  }\n\n  updateTileVisibility(tile, frameState) {\n    const viewportIds: string[] = [];\n    if (this.options.viewportTraversersMap) {\n      for (const key in this.options.viewportTraversersMap) {\n        const value = this.options.viewportTraversersMap[key];\n        if (value === frameState.viewport.id) {\n          viewportIds.push(key);\n        }\n      }\n    } else {\n      viewportIds.push(frameState.viewport.id);\n    }\n    tile.updateVisibility(frameState, viewportIds);\n  }\n\n  // UTILITIES\n\n  compareDistanceToCamera(b, a) {\n    return b._distanceToCamera - a._distanceToCamera;\n  }\n\n  anyChildrenVisible(tile, frameState) {\n    let anyVisible = false;\n    for (const child of tile.children) {\n      child.updateVisibility(frameState);\n      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n    }\n    return anyVisible;\n  }\n\n  // Depth-first traversal that checks if all nearest descendants with content are loaded.\n  // Ignores visibility.\n  executeEmptyTraversal(root, frameState) {\n    let allDescendantsLoaded = true;\n    const stack = this._emptyTraversalStack;\n\n    stack.push(root);\n\n    while (stack.length > 0 && allDescendantsLoaded) {\n      const tile = stack.pop();\n\n      this.updateTile(tile, frameState);\n\n      if (!tile.isVisibleAndInRequestVolume) {\n        // Load tiles that aren't visible since they are still needed for the parent to refine\n        this.loadTile(tile, frameState);\n      }\n\n      this.touchTile(tile, frameState);\n\n      // Only traverse if the tile is empty - traversal stop at descendants with content\n      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n\n      if (traverse) {\n        const children = tile.children;\n        for (const child of children) {\n          // eslint-disable-next-line max-depth\n          if (stack.find(child)) {\n            stack.delete(child);\n          }\n          stack.push(child);\n        }\n      } else if (!tile.contentAvailable) {\n        allDescendantsLoaded = false;\n      }\n    }\n\n    return allDescendantsLoaded;\n  }\n}\n\n// TODO\n// enable expiration\n// enable optimization hint\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}