{"ast":null,"code":"import _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport decode, { DECODING_STEPS } from './decode-quantized-mesh';\nimport { addSkirt } from './helpers/skirt';\nfunction getMeshAttributes(vertexData, header, bounds) {\n  var minHeight = header.minHeight,\n    maxHeight = header.maxHeight;\n  var _ref = bounds || [0, 0, 1, 1],\n    _ref2 = _slicedToArray(_ref, 4),\n    minX = _ref2[0],\n    minY = _ref2[1],\n    maxX = _ref2[2],\n    maxY = _ref2[3];\n  var xScale = maxX - minX;\n  var yScale = maxY - minY;\n  var zScale = maxHeight - minHeight;\n  var nCoords = vertexData.length / 3;\n  var positions = new Float32Array(nCoords * 3);\n  var texCoords = new Float32Array(nCoords * 2);\n  for (var i = 0; i < nCoords; i++) {\n    var x = vertexData[i] / 32767;\n    var y = vertexData[i + nCoords] / 32767;\n    var z = vertexData[i + nCoords * 2] / 32767;\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = y * yScale + minY;\n    positions[3 * i + 2] = z * zScale + minHeight;\n    texCoords[2 * i + 0] = x;\n    texCoords[2 * i + 1] = y;\n  }\n  return {\n    POSITION: {\n      value: positions,\n      size: 3\n    },\n    TEXCOORD_0: {\n      value: texCoords,\n      size: 2\n    }\n  };\n}\nfunction getTileMesh(arrayBuffer, options) {\n  if (!arrayBuffer) {\n    return null;\n  }\n  var bounds = options.bounds;\n  var _decode = decode(arrayBuffer, DECODING_STEPS.triangleIndices),\n    header = _decode.header,\n    vertexData = _decode.vertexData,\n    originalTriangleIndices = _decode.triangleIndices,\n    westIndices = _decode.westIndices,\n    northIndices = _decode.northIndices,\n    eastIndices = _decode.eastIndices,\n    southIndices = _decode.southIndices;\n  var triangleIndices = originalTriangleIndices;\n  var attributes = getMeshAttributes(vertexData, header, bounds);\n  var boundingBox = getMeshBoundingBox(attributes);\n  if (options.skirtHeight) {\n    var _addSkirt = addSkirt(attributes, triangleIndices, options.skirtHeight, {\n        westIndices: westIndices,\n        northIndices: northIndices,\n        eastIndices: eastIndices,\n        southIndices: southIndices\n      }),\n      newAttributes = _addSkirt.attributes,\n      newTriangles = _addSkirt.triangles;\n    attributes = newAttributes;\n    triangleIndices = newTriangles;\n  }\n  return {\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangleIndices.length,\n      boundingBox: boundingBox\n    },\n    mode: 4,\n    indices: {\n      value: triangleIndices,\n      size: 1\n    },\n    attributes: attributes\n  };\n}\nexport default function loadQuantizedMesh(arrayBuffer, options) {\n  return getTileMesh(arrayBuffer, options['quantized-mesh']);\n}","map":{"version":3,"names":["getMeshBoundingBox","decode","DECODING_STEPS","addSkirt","getMeshAttributes","vertexData","header","bounds","minHeight","maxHeight","_ref","_ref2","_slicedToArray","minX","minY","maxX","maxY","xScale","yScale","zScale","nCoords","length","positions","Float32Array","texCoords","i","x","y","z","POSITION","value","size","TEXCOORD_0","getTileMesh","arrayBuffer","options","_decode","triangleIndices","originalTriangleIndices","westIndices","northIndices","eastIndices","southIndices","attributes","boundingBox","skirtHeight","_addSkirt","newAttributes","newTriangles","triangles","loaderData","vertexCount","mode","indices","loadQuantizedMesh"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/terrain/src/lib/parse-quantized-mesh.ts"],"sourcesContent":["import {getMeshBoundingBox} from '@loaders.gl/schema';\nimport decode, {DECODING_STEPS} from './decode-quantized-mesh';\nimport {addSkirt} from './helpers/skirt';\n\nfunction getMeshAttributes(vertexData, header, bounds) {\n  const {minHeight, maxHeight} = header;\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];\n  const xScale = maxX - minX;\n  const yScale = maxY - minY;\n  const zScale = maxHeight - minHeight;\n\n  const nCoords = vertexData.length / 3;\n  // vec3. x, y defined by bounds, z in meters\n  const positions = new Float32Array(nCoords * 3);\n\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(nCoords * 2);\n\n  // Data is not interleaved; all u, then all v, then all heights\n  for (let i = 0; i < nCoords; i++) {\n    const x = vertexData[i] / 32767;\n    const y = vertexData[i + nCoords] / 32767;\n    const z = vertexData[i + nCoords * 2] / 32767;\n\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = y * yScale + minY;\n    positions[3 * i + 2] = z * zScale + minHeight;\n\n    texCoords[2 * i + 0] = x;\n    texCoords[2 * i + 1] = y;\n  }\n\n  return {\n    POSITION: {value: positions, size: 3},\n    TEXCOORD_0: {value: texCoords, size: 2}\n    // TODO: Parse normals if they exist in the file\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}\n\nfunction getTileMesh(arrayBuffer, options) {\n  if (!arrayBuffer) {\n    return null;\n  }\n  const {bounds} = options;\n  // Don't parse edge indices or format extensions\n  const {\n    header,\n    vertexData,\n    triangleIndices: originalTriangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices\n  } = decode(arrayBuffer, DECODING_STEPS.triangleIndices);\n  let triangleIndices = originalTriangleIndices;\n  let attributes = getMeshAttributes(vertexData, header, bounds);\n\n  // Compute bounding box before adding skirt so that z values are not skewed\n  // TODO: Find bounding box from header, instead of doing extra pass over\n  // vertices.\n  const boundingBox = getMeshBoundingBox(attributes);\n\n  if (options.skirtHeight) {\n    const {attributes: newAttributes, triangles: newTriangles} = addSkirt(\n      attributes,\n      triangleIndices,\n      options.skirtHeight,\n      {\n        westIndices,\n        northIndices,\n        eastIndices,\n        southIndices\n      }\n    );\n    attributes = newAttributes;\n    triangleIndices = newTriangles;\n  }\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      // @ts-ignore\n      vertexCount: triangleIndices.length,\n      boundingBox\n    },\n    mode: 4, // TRIANGLES\n    indices: {value: triangleIndices, size: 1},\n    attributes\n  };\n}\n\nexport default function loadQuantizedMesh(arrayBuffer, options) {\n  return getTileMesh(arrayBuffer, options['quantized-mesh']);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}