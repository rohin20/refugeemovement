{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.visStateSchema = exports.visStateSchemaV1 = exports.visStateSchemaV0 = exports.VisStateSchemaV1 = exports.propertiesV1 = exports.propertiesV0 = exports.filterPropsV1 = exports.SplitMapsSchema = exports.DimensionFieldSchema = exports.filterPropsV0 = exports.InteractionSchemaV1 = exports.FilterSchemaV0 = exports.LayerSchemaV0 = exports.layerPropsV1 = exports.layerPropsV0 = exports.dimensionPropsV0 = void 0;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.pick\"));\nvar _versions = require(\"./versions\");\nvar _constants = require(\"@kepler.gl/constants\");\nvar _utils = require(\"@kepler.gl/utils\");\nvar _schema = _interopRequireDefault(require(\"./schema\"));\nvar _lodash2 = _interopRequireDefault(require(\"lodash.clonedeep\"));\nvar _visStateSchema;\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * V0 Schema\n */\nvar dimensionPropsV0 = ['name', 'type'];\nexports.dimensionPropsV0 = dimensionPropsV0;\n\n// in v0 geojson there is only sizeField\n// in v1 geojson\n// stroke base on -> sizeField\n// height based on -> heightField\n// radius based on -> radiusField\n// here we make our wiredst guess on which channel sizeField belongs to\nfunction geojsonSizeFieldV0ToV1(config) {\n  var defaultRaiuds = 10;\n  var defaultRadiusRange = [0, 50]; // if extruded, sizeField is most likely used for height\n\n  if (config.visConfig.extruded) {\n    return 'heightField';\n  } // if show stroke enabled, sizeField is most likely used for stroke\n\n  if (config.visConfig.stroked) {\n    return 'sizeField';\n  } // if radius changed, or radius Range Changed, sizeField is most likely used for radius\n  // this is the most unreliable guess, that's why we put it in the end\n\n  if (config.visConfig.radius !== defaultRaiuds || config.visConfig.radiusRange.some(function (d, i) {\n    return d !== defaultRadiusRange[i];\n  })) {\n    return 'radiusField';\n  }\n  return 'sizeField';\n} // convert v0 to v1 layer config\n\nvar DimensionFieldSchemaV0 = /*#__PURE__*/function (_Schema) {\n  (0, _inherits2[\"default\"])(DimensionFieldSchemaV0, _Schema);\n  var _super = _createSuper(DimensionFieldSchemaV0);\n  function DimensionFieldSchemaV0() {\n    var _this;\n    (0, _classCallCheck2[\"default\"])(this, DimensionFieldSchemaV0);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"version\", _versions.VERSIONS.v0);\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(DimensionFieldSchemaV0, [{\n    key: \"save\",\n    value: function save(field) {\n      // should not be called anymore\n      return (0, _defineProperty2[\"default\"])({}, this.key, field !== null ? this.savePropertiesOrApplySchema(field)[this.key] : null);\n    }\n  }, {\n    key: \"load\",\n    value: function load(field, parents, accumulated) {\n      var _parents$slice = parents.slice(-1),\n        _parents$slice2 = (0, _slicedToArray2[\"default\"])(_parents$slice, 1),\n        config = _parents$slice2[0];\n      var fieldName = this.key;\n      if (config.type === 'geojson' && this.key === 'sizeField' && field) {\n        fieldName = geojsonSizeFieldV0ToV1(config);\n      } // fold into visualChannels to be load by VisualChannelSchemaV1\n\n      return {\n        visualChannels: _objectSpread(_objectSpread({}, accumulated.visualChannels || {}), {}, (0, _defineProperty2[\"default\"])({}, fieldName, field))\n      };\n    }\n  }]);\n  return DimensionFieldSchemaV0;\n}(_schema[\"default\"]);\nvar DimensionScaleSchemaV0 = /*#__PURE__*/function (_Schema2) {\n  (0, _inherits2[\"default\"])(DimensionScaleSchemaV0, _Schema2);\n  var _super2 = _createSuper(DimensionScaleSchemaV0);\n  function DimensionScaleSchemaV0() {\n    var _this2;\n    (0, _classCallCheck2[\"default\"])(this, DimensionScaleSchemaV0);\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    _this2 = _super2.call.apply(_super2, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this2), \"version\", _versions.VERSIONS.v0);\n    return _this2;\n  }\n  (0, _createClass2[\"default\"])(DimensionScaleSchemaV0, [{\n    key: \"save\",\n    value: function save(scale) {\n      return (0, _defineProperty2[\"default\"])({}, this.key, scale);\n    }\n  }, {\n    key: \"load\",\n    value: function load(scale, parents, accumulated) {\n      var _parents$slice3 = parents.slice(-1),\n        _parents$slice4 = (0, _slicedToArray2[\"default\"])(_parents$slice3, 1),\n        config = _parents$slice4[0]; // fold into visualChannels to be load by VisualChannelSchemaV1\n\n      if (this.key === 'sizeScale' && config.type === 'geojson') {\n        // sizeScale now split into radiusScale, heightScale\n        // no user customization, just use default\n        return {};\n      }\n      return {\n        visualChannels: _objectSpread(_objectSpread({}, accumulated.visualChannels || {}), {}, (0, _defineProperty2[\"default\"])({}, this.key, scale))\n      };\n    }\n  }]);\n  return DimensionScaleSchemaV0;\n}(_schema[\"default\"]); // used to convert v0 to v1 layer config\n\nvar LayerConfigSchemaV0 = /*#__PURE__*/function (_Schema3) {\n  (0, _inherits2[\"default\"])(LayerConfigSchemaV0, _Schema3);\n  var _super3 = _createSuper(LayerConfigSchemaV0);\n  function LayerConfigSchemaV0() {\n    var _this3;\n    (0, _classCallCheck2[\"default\"])(this, LayerConfigSchemaV0);\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    _this3 = _super3.call.apply(_super3, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this3), \"version\", _versions.VERSIONS.v0);\n    return _this3;\n  }\n  (0, _createClass2[\"default\"])(LayerConfigSchemaV0, [{\n    key: \"load\",\n    value: function load(saved, parents, accumulated) {\n      // fold v0 layer property into config.key\n      return {\n        config: _objectSpread(_objectSpread({}, accumulated.config || {}), {}, (0, _defineProperty2[\"default\"])({}, this.key, saved))\n      };\n    }\n  }]);\n  return LayerConfigSchemaV0;\n}(_schema[\"default\"]); // used to convert v0 to v1 layer columns\n// only return column value for each column\n\nvar LayerColumnsSchemaV0 = /*#__PURE__*/function (_Schema4) {\n  (0, _inherits2[\"default\"])(LayerColumnsSchemaV0, _Schema4);\n  var _super4 = _createSuper(LayerColumnsSchemaV0);\n  function LayerColumnsSchemaV0() {\n    var _this4;\n    (0, _classCallCheck2[\"default\"])(this, LayerColumnsSchemaV0);\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    _this4 = _super4.call.apply(_super4, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this4), \"version\", _versions.VERSIONS.v0);\n    return _this4;\n  }\n  (0, _createClass2[\"default\"])(LayerColumnsSchemaV0, [{\n    key: \"load\",\n    value: function load(saved, parents, accumulated) {\n      // fold v0 layer property into config.key, flatten columns\n      return {\n        config: _objectSpread(_objectSpread({}, accumulated.config || {}), {}, {\n          columns: Object.keys(saved).reduce(function (accu, key) {\n            return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, saved[key].value));\n          }, {})\n        })\n      };\n    }\n  }]);\n  return LayerColumnsSchemaV0;\n}(_schema[\"default\"]); // used to convert v0 to v1 layer config.visConfig\n\nvar LayerConfigToVisConfigSchemaV0 = /*#__PURE__*/function (_Schema5) {\n  (0, _inherits2[\"default\"])(LayerConfigToVisConfigSchemaV0, _Schema5);\n  var _super5 = _createSuper(LayerConfigToVisConfigSchemaV0);\n  function LayerConfigToVisConfigSchemaV0() {\n    var _this5;\n    (0, _classCallCheck2[\"default\"])(this, LayerConfigToVisConfigSchemaV0);\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    _this5 = _super5.call.apply(_super5, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this5), \"version\", _versions.VERSIONS.v0);\n    return _this5;\n  }\n  (0, _createClass2[\"default\"])(LayerConfigToVisConfigSchemaV0, [{\n    key: \"load\",\n    value: function load(saved, parents, accumulated) {\n      // fold v0 layer property into config.visConfig\n      var accumulatedConfig = accumulated.config || {};\n      return {\n        config: _objectSpread(_objectSpread({}, accumulatedConfig), {}, {\n          visConfig: _objectSpread(_objectSpread({}, accumulatedConfig.visConfig || {}), {}, (0, _defineProperty2[\"default\"])({}, this.key, saved))\n        })\n      };\n    }\n  }]);\n  return LayerConfigToVisConfigSchemaV0;\n}(_schema[\"default\"]);\nvar LayerVisConfigSchemaV0 = /*#__PURE__*/function (_Schema6) {\n  (0, _inherits2[\"default\"])(LayerVisConfigSchemaV0, _Schema6);\n  var _super6 = _createSuper(LayerVisConfigSchemaV0);\n  function LayerVisConfigSchemaV0() {\n    var _this6;\n    (0, _classCallCheck2[\"default\"])(this, LayerVisConfigSchemaV0);\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n    _this6 = _super6.call.apply(_super6, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this6), \"version\", _versions.VERSIONS.v0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this6), \"key\", 'visConfig');\n    return _this6;\n  }\n  (0, _createClass2[\"default\"])(LayerVisConfigSchemaV0, [{\n    key: \"load\",\n    value: function load(visConfig, parents, accumulator) {\n      var _parents$slice5 = parents.slice(-1),\n        _parents$slice6 = (0, _slicedToArray2[\"default\"])(_parents$slice5, 1),\n        config = _parents$slice6[0];\n      var rename = {\n        geojson: {\n          extruded: 'enable3d',\n          elevationRange: 'heightRange'\n        }\n      };\n      if (config.type in rename) {\n        var propToRename = rename[config.type];\n        return {\n          config: _objectSpread(_objectSpread({}, accumulator.config || {}), {}, {\n            visConfig: Object.keys(visConfig).reduce(function (accu, key) {\n              return _objectSpread(_objectSpread({}, accu), propToRename[key] ? (0, _defineProperty2[\"default\"])({}, propToRename[key], visConfig[key]) : (0, _defineProperty2[\"default\"])({}, key, visConfig[key]));\n            }, {})\n          })\n        };\n      }\n      return {\n        config: _objectSpread(_objectSpread({}, accumulator.config || {}), {}, {\n          visConfig: visConfig\n        })\n      };\n    }\n  }]);\n  return LayerVisConfigSchemaV0;\n}(_schema[\"default\"]);\nvar LayerConfigSchemaDeleteV0 = /*#__PURE__*/function (_Schema7) {\n  (0, _inherits2[\"default\"])(LayerConfigSchemaDeleteV0, _Schema7);\n  var _super7 = _createSuper(LayerConfigSchemaDeleteV0);\n  function LayerConfigSchemaDeleteV0() {\n    var _this7;\n    (0, _classCallCheck2[\"default\"])(this, LayerConfigSchemaDeleteV0);\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    _this7 = _super7.call.apply(_super7, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this7), \"version\", _versions.VERSIONS.v0);\n    return _this7;\n  }\n  (0, _createClass2[\"default\"])(LayerConfigSchemaDeleteV0, [{\n    key: \"load\",\n    value: function load(value) {\n      return {};\n    }\n  }]);\n  return LayerConfigSchemaDeleteV0;\n}(_schema[\"default\"]);\n/**\n * V0 -> V1 Changes\n * - layer is now a class\n * - config saved in a config object\n * - id, type, isAggregated is outside layer.config\n * - visualChannels is outside config, it defines available visual channel and\n *   property names for field, scale, domain and range of each visual chanel.\n * - enable3d, colorAggregation and sizeAggregation are moved into visConfig\n * - GeojsonLayer - added height, radius specific properties\n */\n\nvar layerPropsV0 = {\n  id: null,\n  type: null,\n  // move into layer.config\n  dataId: new LayerConfigSchemaV0({\n    key: 'dataId'\n  }),\n  label: new LayerConfigSchemaV0({\n    key: 'label'\n  }),\n  color: new LayerConfigSchemaV0({\n    key: 'color'\n  }),\n  isVisible: new LayerConfigSchemaV0({\n    key: 'isVisible'\n  }),\n  hidden: new LayerConfigSchemaV0({\n    key: 'hidden'\n  }),\n  // convert visConfig\n  visConfig: new LayerVisConfigSchemaV0({\n    key: 'visConfig'\n  }),\n  // move into layer.config\n  // flatten\n  columns: new LayerColumnsSchemaV0(),\n  // save into visualChannels\n  colorField: new DimensionFieldSchemaV0({\n    properties: dimensionPropsV0,\n    key: 'colorField'\n  }),\n  colorScale: new DimensionScaleSchemaV0({\n    key: 'colorScale'\n  }),\n  sizeField: new DimensionFieldSchemaV0({\n    properties: dimensionPropsV0,\n    key: 'sizeField'\n  }),\n  sizeScale: new DimensionScaleSchemaV0({\n    key: 'sizeScale'\n  }),\n  // move into config.visConfig\n  enable3d: new LayerConfigToVisConfigSchemaV0({\n    key: 'enable3d'\n  }),\n  colorAggregation: new LayerConfigToVisConfigSchemaV0({\n    key: 'colorAggregation'\n  }),\n  sizeAggregation: new LayerConfigToVisConfigSchemaV0({\n    key: 'sizeAggregation'\n  }),\n  // delete\n  isAggregated: new LayerConfigSchemaDeleteV0()\n};\n/**\n * V1 Schema\n */\n\nexports.layerPropsV0 = layerPropsV0;\nvar ColumnSchemaV1 = /*#__PURE__*/function (_Schema8) {\n  (0, _inherits2[\"default\"])(ColumnSchemaV1, _Schema8);\n  var _super8 = _createSuper(ColumnSchemaV1);\n  function ColumnSchemaV1() {\n    (0, _classCallCheck2[\"default\"])(this, ColumnSchemaV1);\n    return _super8.apply(this, arguments);\n  }\n  (0, _createClass2[\"default\"])(ColumnSchemaV1, [{\n    key: \"save\",\n    value: function save(columns, state) {\n      // starting from v1, only save column value\n      // fieldIdx will be calculated during merge\n      return (0, _defineProperty2[\"default\"])({}, this.key, Object.keys(columns).reduce(function (accu, ckey) {\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, ckey, columns[ckey].value));\n      }, {}));\n    }\n  }, {\n    key: \"load\",\n    value: function load(columns) {\n      return {\n        columns: columns\n      };\n    }\n  }]);\n  return ColumnSchemaV1;\n}(_schema[\"default\"]);\nvar TextLabelSchemaV1 = /*#__PURE__*/function (_Schema9) {\n  (0, _inherits2[\"default\"])(TextLabelSchemaV1, _Schema9);\n  var _super9 = _createSuper(TextLabelSchemaV1);\n  function TextLabelSchemaV1() {\n    (0, _classCallCheck2[\"default\"])(this, TextLabelSchemaV1);\n    return _super9.apply(this, arguments);\n  }\n  (0, _createClass2[\"default\"])(TextLabelSchemaV1, [{\n    key: \"save\",\n    value: function save(textLabel) {\n      return (0, _defineProperty2[\"default\"])({}, this.key, textLabel.map(function (tl) {\n        return _objectSpread(_objectSpread({}, tl), {}, {\n          field: tl.field ? (0, _lodash[\"default\"])(tl.field, ['name', 'type']) : null\n        });\n      }));\n    }\n  }, {\n    key: \"load\",\n    value: function load(textLabel) {\n      return {\n        textLabel: Array.isArray(textLabel) ? textLabel : [textLabel]\n      };\n    }\n  }]);\n  return TextLabelSchemaV1;\n}(_schema[\"default\"]);\nvar visualChannelModificationV1 = {\n  geojson: function geojson(vc, parents, accumulator) {\n    var _parents$slice7 = parents.slice(-1),\n      _parents$slice8 = (0, _slicedToArray2[\"default\"])(_parents$slice7, 1),\n      layer = _parents$slice8[0];\n    var isOld = !vc.hasOwnProperty('strokeColorField'); // make our best guess if this geojson layer contains point\n\n    var isPoint = vc.radiusField || layer.config.visConfig.radius !== _constants.LAYER_VIS_CONFIGS.radius.defaultValue;\n    if (isOld && !isPoint && layer.config.visConfig.stroked) {\n      // if stroked is true, copy color config to stroke color config\n      return {\n        strokeColorField: vc.colorField,\n        strokeColorScale: vc.colorScale\n      };\n    }\n    return {};\n  }\n};\n/**\n * V1: save [field]: {name, type}, [scale]: '' for each channel\n */\n\nvar VisualChannelSchemaV1 = /*#__PURE__*/function (_Schema10) {\n  (0, _inherits2[\"default\"])(VisualChannelSchemaV1, _Schema10);\n  var _super10 = _createSuper(VisualChannelSchemaV1);\n  function VisualChannelSchemaV1() {\n    (0, _classCallCheck2[\"default\"])(this, VisualChannelSchemaV1);\n    return _super10.apply(this, arguments);\n  }\n  (0, _createClass2[\"default\"])(VisualChannelSchemaV1, [{\n    key: \"save\",\n    value: function save(visualChannels, parents) {\n      // only save field and scale of each channel\n      var _parents$slice9 = parents.slice(-1),\n        _parents$slice10 = (0, _slicedToArray2[\"default\"])(_parents$slice9, 1),\n        layer = _parents$slice10[0];\n      return (0, _defineProperty2[\"default\"])({}, this.key, Object.keys(visualChannels).reduce(\n      //  save channel to null if didn't select any field\n      function (accu, key) {\n        var _objectSpread8;\n        return _objectSpread(_objectSpread({}, accu), {}, (_objectSpread8 = {}, (0, _defineProperty2[\"default\"])(_objectSpread8, visualChannels[key].field, layer.config[visualChannels[key].field] ? (0, _lodash[\"default\"])(layer.config[visualChannels[key].field], ['name', 'type']) : null), (0, _defineProperty2[\"default\"])(_objectSpread8, visualChannels[key].scale, layer.config[visualChannels[key].scale]), _objectSpread8));\n      }, {}));\n    }\n  }, {\n    key: \"load\",\n    value: function load(vc, parents, accumulator) {\n      // fold channels into config\n      var _parents$slice11 = parents.slice(-1),\n        _parents$slice12 = (0, _slicedToArray2[\"default\"])(_parents$slice11, 1),\n        layer = _parents$slice12[0];\n      var modified = visualChannelModificationV1[layer.type] ? visualChannelModificationV1[layer.type](vc, parents, accumulator) : {};\n      return _objectSpread(_objectSpread({}, accumulator), {}, {\n        config: _objectSpread(_objectSpread(_objectSpread({}, accumulator.config || {}), vc), modified)\n      });\n    }\n  }]);\n  return VisualChannelSchemaV1;\n}(_schema[\"default\"]);\nvar visConfigModificationV1 = {\n  point: function point(visConfig, parents, accumulated) {\n    var modified = {};\n    var _parents$slice13 = parents.slice(-2, -1),\n      _parents$slice14 = (0, _slicedToArray2[\"default\"])(_parents$slice13, 1),\n      layer = _parents$slice14[0];\n    var isOld = !visConfig.hasOwnProperty('filled') && !visConfig.strokeColor && !visConfig.strokeColorRange;\n    if (isOld) {\n      // color color & color range to stroke color\n      modified.strokeColor = layer.config.color;\n      modified.strokeColorRange = (0, _lodash2[\"default\"])(visConfig.colorRange);\n      if (visConfig.outline) {\n        // point layer now supports both outline and fill\n        // for older schema where filled has not been added to point layer\n        // set it to false\n        modified.filled = false;\n      }\n    }\n    return modified;\n  },\n  geojson: function geojson(visConfig, parents, accumulated) {\n    // is points?\n    var modified = {};\n    var _parents$slice15 = parents.slice(-2, -1),\n      _parents$slice16 = (0, _slicedToArray2[\"default\"])(_parents$slice15, 1),\n      layer = _parents$slice16[0];\n    var isOld = layer.visualChannels && !layer.visualChannels.hasOwnProperty('strokeColorField') && !visConfig.strokeColor && !visConfig.strokeColorRange; // make our best guess if this geojson layer contains point\n\n    var isPoint = layer.visualChannels && layer.visualChannels.radiusField || visConfig && visConfig.radius !== _constants.LAYER_VIS_CONFIGS.radius.defaultValue;\n    if (isOld) {\n      // color color & color range to stroke color\n      modified.strokeColor = layer.config.color;\n      modified.strokeColorRange = (0, _lodash2[\"default\"])(visConfig.colorRange);\n      if (isPoint) {\n        // if is point, set stroke to false\n        modified.filled = true;\n        modified.stroked = false;\n      }\n    }\n    return modified;\n  }\n};\nvar VisConfigSchemaV1 = /*#__PURE__*/function (_Schema11) {\n  (0, _inherits2[\"default\"])(VisConfigSchemaV1, _Schema11);\n  var _super11 = _createSuper(VisConfigSchemaV1);\n  function VisConfigSchemaV1() {\n    var _this8;\n    (0, _classCallCheck2[\"default\"])(this, VisConfigSchemaV1);\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    _this8 = _super11.call.apply(_super11, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this8), \"key\", 'visConfig');\n    return _this8;\n  }\n  (0, _createClass2[\"default\"])(VisConfigSchemaV1, [{\n    key: \"load\",\n    value: function load(visConfig, parents, accumulated) {\n      var _parents$slice17 = parents.slice(-2, -1),\n        _parents$slice18 = (0, _slicedToArray2[\"default\"])(_parents$slice17, 1),\n        layer = _parents$slice18[0];\n      var modified = visConfigModificationV1[layer.type] ? visConfigModificationV1[layer.type](visConfig, parents, accumulated) : {};\n      return {\n        visConfig: _objectSpread(_objectSpread({}, visConfig), modified)\n      };\n    }\n  }]);\n  return VisConfigSchemaV1;\n}(_schema[\"default\"]);\nvar layerPropsV1 = {\n  id: null,\n  type: null,\n  config: new _schema[\"default\"]({\n    version: _versions.VERSIONS.v1,\n    key: 'config',\n    properties: {\n      dataId: null,\n      label: null,\n      color: null,\n      highlightColor: null,\n      columns: new ColumnSchemaV1({\n        version: _versions.VERSIONS.v1,\n        key: 'columns'\n      }),\n      isVisible: null,\n      visConfig: new VisConfigSchemaV1({\n        version: _versions.VERSIONS.v1\n      }),\n      hidden: null,\n      textLabel: new TextLabelSchemaV1({\n        version: _versions.VERSIONS.v1,\n        key: 'textLabel'\n      })\n    }\n  }),\n  visualChannels: new VisualChannelSchemaV1({\n    version: _versions.VERSIONS.v1,\n    key: 'visualChannels'\n  })\n};\nexports.layerPropsV1 = layerPropsV1;\nvar LayerSchemaV0 = /*#__PURE__*/function (_Schema12) {\n  (0, _inherits2[\"default\"])(LayerSchemaV0, _Schema12);\n  var _super12 = _createSuper(LayerSchemaV0);\n  function LayerSchemaV0() {\n    var _this9;\n    (0, _classCallCheck2[\"default\"])(this, LayerSchemaV0);\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n    _this9 = _super12.call.apply(_super12, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this9), \"key\", 'layers');\n    return _this9;\n  }\n  (0, _createClass2[\"default\"])(LayerSchemaV0, [{\n    key: \"save\",\n    value: function save(layers, parents) {\n      var _this10 = this;\n      var _parents$slice19 = parents.slice(-1),\n        _parents$slice20 = (0, _slicedToArray2[\"default\"])(_parents$slice19, 1),\n        visState = _parents$slice20[0];\n      return (0, _defineProperty2[\"default\"])({}, this.key, visState.layerOrder.reduce(function (saved, index) {\n        // save layers according to their rendering order\n        var layer = layers[index];\n        if (layer.isValidToSave()) {\n          saved.push(_this10.savePropertiesOrApplySchema(layer).layers);\n        }\n        return saved;\n      }, []));\n    }\n  }, {\n    key: \"load\",\n    value: function load(layers) {\n      var _this11 = this;\n      return (0, _defineProperty2[\"default\"])({}, this.key, layers ? layers.map(function (layer) {\n        return _this11.loadPropertiesOrApplySchema(layer, layers).layers;\n      }) : []);\n    }\n  }]);\n  return LayerSchemaV0;\n}(_schema[\"default\"]);\nexports.LayerSchemaV0 = LayerSchemaV0;\nvar FilterSchemaV0 = /*#__PURE__*/function (_Schema13) {\n  (0, _inherits2[\"default\"])(FilterSchemaV0, _Schema13);\n  var _super13 = _createSuper(FilterSchemaV0);\n  function FilterSchemaV0() {\n    var _this12;\n    (0, _classCallCheck2[\"default\"])(this, FilterSchemaV0);\n    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      args[_key10] = arguments[_key10];\n    }\n    _this12 = _super13.call.apply(_super13, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this12), \"key\", 'filters');\n    return _this12;\n  }\n  (0, _createClass2[\"default\"])(FilterSchemaV0, [{\n    key: \"save\",\n    value: function save(filters) {\n      var _this13 = this;\n      return {\n        filters: filters.filter(_utils.isFilterValidToSave).map(function (filter) {\n          return _this13.savePropertiesOrApplySchema(filter).filters;\n        })\n      };\n    }\n  }, {\n    key: \"load\",\n    value: function load(filters) {\n      return {\n        filters: filters\n      };\n    }\n  }]);\n  return FilterSchemaV0;\n}(_schema[\"default\"]);\nexports.FilterSchemaV0 = FilterSchemaV0;\nvar interactionPropsV0 = ['tooltip', 'brush'];\nvar InteractionSchemaV0 = /*#__PURE__*/function (_Schema14) {\n  (0, _inherits2[\"default\"])(InteractionSchemaV0, _Schema14);\n  var _super14 = _createSuper(InteractionSchemaV0);\n  function InteractionSchemaV0() {\n    var _this14;\n    (0, _classCallCheck2[\"default\"])(this, InteractionSchemaV0);\n    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      args[_key11] = arguments[_key11];\n    }\n    _this14 = _super14.call.apply(_super14, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this14), \"key\", 'interactionConfig');\n    return _this14;\n  }\n  (0, _createClass2[\"default\"])(InteractionSchemaV0, [{\n    key: \"save\",\n    value: function save(interactionConfig) {\n      return Array.isArray(this.properties) ? (0, _defineProperty2[\"default\"])({}, this.key, this.properties.reduce(function (accu, key) {\n        return _objectSpread(_objectSpread({}, accu), interactionConfig[key].enabled ? (0, _defineProperty2[\"default\"])({}, key, interactionConfig[key].config) : {});\n      }, {})) : {};\n    }\n  }, {\n    key: \"load\",\n    value: function load(interactionConfig) {\n      // convert v0 -> v1\n      // return enabled: false if disabled,\n      return Array.isArray(this.properties) ? (0, _defineProperty2[\"default\"])({}, this.key, this.properties.reduce(function (accu, key) {\n        return _objectSpread(_objectSpread({}, accu), (0, _defineProperty2[\"default\"])({}, key, _objectSpread(_objectSpread({}, interactionConfig[key] || {}), {}, {\n          enabled: Boolean(interactionConfig[key])\n        })));\n      }, {})) : {};\n    }\n  }]);\n  return InteractionSchemaV0;\n}(_schema[\"default\"]);\nvar interactionPropsV1 = [].concat(interactionPropsV0, ['geocoder', 'coordinate']);\nvar InteractionSchemaV1 = /*#__PURE__*/function (_Schema15) {\n  (0, _inherits2[\"default\"])(InteractionSchemaV1, _Schema15);\n  var _super15 = _createSuper(InteractionSchemaV1);\n  function InteractionSchemaV1() {\n    var _this15;\n    (0, _classCallCheck2[\"default\"])(this, InteractionSchemaV1);\n    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n      args[_key12] = arguments[_key12];\n    }\n    _this15 = _super15.call.apply(_super15, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this15), \"key\", 'interactionConfig');\n    return _this15;\n  }\n  (0, _createClass2[\"default\"])(InteractionSchemaV1, [{\n    key: \"save\",\n    value: function save(interactionConfig) {\n      // save config even if disabled,\n      return Array.isArray(this.properties) ? (0, _defineProperty2[\"default\"])({}, this.key, this.properties.reduce(function (accu, key) {\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, _objectSpread(_objectSpread({}, interactionConfig[key].config), {}, {\n          enabled: interactionConfig[key].enabled\n        })));\n      }, {})) : {};\n    }\n  }, {\n    key: \"load\",\n    value: function load(interactionConfig) {\n      var _this16 = this;\n      var modifiedConfig = interactionConfig;\n      Object.keys(interactionConfig).forEach(function (configType) {\n        if (configType === 'tooltip') {\n          var fieldsToShow = modifiedConfig[configType].fieldsToShow;\n          if (!(0, _utils.notNullorUndefined)(fieldsToShow)) {\n            return (0, _defineProperty2[\"default\"])({}, _this16.key, modifiedConfig);\n          }\n          Object.keys(fieldsToShow).forEach(function (key) {\n            // @ts-expect-error name: fieldData should be string\n            fieldsToShow[key] = fieldsToShow[key].map(function (fieldData) {\n              if (!fieldData.name) {\n                return {\n                  name: fieldData,\n                  format: null\n                };\n              }\n              return fieldData;\n            });\n          });\n        }\n        return;\n      });\n      return (0, _defineProperty2[\"default\"])({}, this.key, modifiedConfig);\n    }\n  }]);\n  return InteractionSchemaV1;\n}(_schema[\"default\"]);\nexports.InteractionSchemaV1 = InteractionSchemaV1;\nvar filterPropsV0 = {\n  dataId: null,\n  id: null,\n  name: null,\n  type: null,\n  value: null,\n  enlarged: null\n};\nexports.filterPropsV0 = filterPropsV0;\nvar DimensionFieldSchema = /*#__PURE__*/function (_Schema16) {\n  (0, _inherits2[\"default\"])(DimensionFieldSchema, _Schema16);\n  var _super16 = _createSuper(DimensionFieldSchema);\n  function DimensionFieldSchema() {\n    (0, _classCallCheck2[\"default\"])(this, DimensionFieldSchema);\n    return _super16.apply(this, arguments);\n  }\n  (0, _createClass2[\"default\"])(DimensionFieldSchema, [{\n    key: \"save\",\n    value: function save(field) {\n      return (0, _defineProperty2[\"default\"])({}, this.key, field ? this.savePropertiesOrApplySchema(field)[this.key] : null);\n    }\n  }, {\n    key: \"load\",\n    value: function load(field) {\n      return (0, _defineProperty2[\"default\"])({}, this.key, field);\n    }\n  }]);\n  return DimensionFieldSchema;\n}(_schema[\"default\"]);\nexports.DimensionFieldSchema = DimensionFieldSchema;\nvar SplitMapsSchema = /*#__PURE__*/function (_Schema17) {\n  (0, _inherits2[\"default\"])(SplitMapsSchema, _Schema17);\n  var _super17 = _createSuper(SplitMapsSchema);\n  function SplitMapsSchema() {\n    (0, _classCallCheck2[\"default\"])(this, SplitMapsSchema);\n    return _super17.apply(this, arguments);\n  }\n  (0, _createClass2[\"default\"])(SplitMapsSchema, [{\n    key: \"convertLayerSettings\",\n    value: function convertLayerSettings(accu, _ref18) {\n      var _ref19 = (0, _slicedToArray2[\"default\"])(_ref18, 2),\n        key = _ref19[0],\n        value = _ref19[1];\n      if (typeof value === 'boolean') {\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, value));\n      } else if (value && (0, _typeof2[\"default\"])(value) === 'object' && value.isAvailable) {\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, Boolean(value.isVisible)));\n      }\n      return accu;\n    }\n  }, {\n    key: \"load\",\n    value: function load(splitMaps) {\n      var _this17 = this;\n\n      // previous splitMaps Schema {layers: {layerId: {isVisible, isAvailable}}}\n      if (!Array.isArray(splitMaps) || !splitMaps.length) {\n        return {\n          splitMaps: []\n        };\n      }\n      return {\n        splitMaps: splitMaps.map(function (settings) {\n          return _objectSpread(_objectSpread({}, settings), {}, {\n            layers: Object.entries(settings.layers || {}).reduce(_this17.convertLayerSettings, {})\n          });\n        })\n      };\n    }\n  }]);\n  return SplitMapsSchema;\n}(_schema[\"default\"]);\nexports.SplitMapsSchema = SplitMapsSchema;\nvar filterPropsV1 = _objectSpread(_objectSpread({}, filterPropsV0), {}, {\n  plotType: null,\n  animationWindow: null,\n  yAxis: new DimensionFieldSchema({\n    version: _versions.VERSIONS.v1,\n    key: 'yAxis',\n    properties: {\n      name: null,\n      type: null\n    }\n  }),\n  // polygon filter properties\n  layerId: null,\n  speed: null\n});\nexports.filterPropsV1 = filterPropsV1;\nvar propertiesV0 = {\n  filters: new FilterSchemaV0({\n    version: _versions.VERSIONS.v0,\n    properties: filterPropsV0\n  }),\n  layers: new LayerSchemaV0({\n    version: _versions.VERSIONS.v0,\n    properties: layerPropsV0\n  }),\n  interactionConfig: new InteractionSchemaV0({\n    version: _versions.VERSIONS.v0,\n    properties: interactionPropsV0\n  }),\n  layerBlending: null\n};\nexports.propertiesV0 = propertiesV0;\nvar propertiesV1 = {\n  filters: new FilterSchemaV0({\n    version: _versions.VERSIONS.v1,\n    properties: filterPropsV1\n  }),\n  layers: new LayerSchemaV0({\n    version: _versions.VERSIONS.v1,\n    properties: layerPropsV1\n  }),\n  interactionConfig: new InteractionSchemaV1({\n    version: _versions.VERSIONS.v1,\n    properties: interactionPropsV1\n  }),\n  layerBlending: null,\n  splitMaps: new SplitMapsSchema({\n    key: 'splitMaps',\n    version: _versions.VERSIONS.v1\n  }),\n  animationConfig: new _schema[\"default\"]({\n    version: _versions.VERSIONS.v1,\n    properties: {\n      currentTime: null,\n      speed: null\n    },\n    key: 'animationConfig'\n  })\n};\nexports.propertiesV1 = propertiesV1;\nvar VisStateSchemaV1 = /*#__PURE__*/function (_Schema18) {\n  (0, _inherits2[\"default\"])(VisStateSchemaV1, _Schema18);\n  var _super18 = _createSuper(VisStateSchemaV1);\n  function VisStateSchemaV1() {\n    (0, _classCallCheck2[\"default\"])(this, VisStateSchemaV1);\n    return _super18.apply(this, arguments);\n  }\n  (0, _createClass2[\"default\"])(VisStateSchemaV1, [{\n    key: \"save\",\n    value: function save(node) {\n      var parents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var accumulator = arguments.length > 2 ? arguments[2] : undefined;\n      // @ts-expect-error\n      return this.savePropertiesOrApplySchema(node, parents, accumulator);\n    }\n  }, {\n    key: \"load\",\n    value: function load(node) {\n      // @ts-expect-error\n      return this.loadPropertiesOrApplySchema(node);\n    }\n  }]);\n  return VisStateSchemaV1;\n}(_schema[\"default\"]);\nexports.VisStateSchemaV1 = VisStateSchemaV1;\nvar visStateSchemaV0 = new _schema[\"default\"]({\n  version: _versions.VERSIONS.v0,\n  properties: propertiesV0,\n  key: 'visState'\n});\nexports.visStateSchemaV0 = visStateSchemaV0;\nvar visStateSchemaV1 = new VisStateSchemaV1({\n  version: _versions.VERSIONS.v1,\n  properties: propertiesV1,\n  key: 'visState'\n});\nexports.visStateSchemaV1 = visStateSchemaV1;\nvar visStateSchema = (_visStateSchema = {}, (0, _defineProperty2[\"default\"])(_visStateSchema, _versions.VERSIONS.v0, {\n  save: function save(toSave) {\n    return visStateSchemaV0.save(toSave);\n  },\n  load: function load(toLoad) {\n    var _visStateSchemaV0$loa;\n    return visStateSchemaV1.load((_visStateSchemaV0$loa = visStateSchemaV0.load(toLoad)) === null || _visStateSchemaV0$loa === void 0 ? void 0 : _visStateSchemaV0$loa.visState);\n  }\n}), (0, _defineProperty2[\"default\"])(_visStateSchema, _versions.VERSIONS.v1, visStateSchemaV1), _visStateSchema); // test load v0\n\nexports.visStateSchema = visStateSchema;\nvar _default = visStateSchema;\nexports[\"default\"] = _default;","map":{"version":3,"names":["exports","visStateSchema","visStateSchemaV1","visStateSchemaV0","VisStateSchemaV1","propertiesV1","propertiesV0","filterPropsV1","SplitMapsSchema","DimensionFieldSchema","filterPropsV0","InteractionSchemaV1","FilterSchemaV0","LayerSchemaV0","layerPropsV1","layerPropsV0","dimensionPropsV0","_typeof2","_interopRequireDefault","require","_slicedToArray2","_classCallCheck2","_createClass2","_assertThisInitialized2","_versions","_constants","_schema","_lodash2","_visStateSchema","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty2","getOwnPropertyDescriptors","defineProperties","defineProperty","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","_getPrototypeOf2","result","NewTarget","constructor","Reflect","construct","_possibleConstructorReturn2","sham","Proxy","Boolean","prototype","valueOf","call","e","defaultRaiuds","defaultRadiusRange","DimensionFieldSchemaV0","_Schema","_super","_len","args","Array","_key","_this","concat","VERSIONS","v0","value","save","field","load","DimensionScaleSchemaV0","_Schema2","_super2","_this2","scale","_parents$slice3","LayerConfigSchemaV0","_Schema3","_super3","_this3","_len3","_key3","LayerColumnsSchemaV0","_Schema4","_super4","_this4","_len4","_key4","LayerConfigToVisConfigSchemaV0","_Schema5","_super5","config","_this5","_super6","LayerVisConfigSchemaV0","_len6","_key6","_this6","visConfig","parents","accumulator","_parents$slice5","slice","_parents$slice6","rename","geojson","extruded","elevationRange","propToRename","LayerConfigSchemaDeleteV0","_Schema7","_super7","_this7","_len7","_key7","id","type","dataId","label","color","isVisible","hidden","columns","colorField","properties","colorScale","sizeField","ColumnSchemaV1","_Schema8","_super8","TextLabelSchemaV1","_Schema9","_super9","textLabel","map","tl","isArray","visualChannelModificationV1","vc","_parents$slice7","_parents$slice8","VisualChannelSchemaV1","_Schema10","_super10","_parents$slice9","_parents$slice10","layer","_objectSpread8","accu","visualChannels","_lodash","_parents$slice12","_parents$slice11","modified","visConfigModificationV1","point","accumulated","_parents$slice13","_parents$slice14","isOld","strokeColorRange","colorRange","outline","filled","stroked","_parents$slice15","_parents$slice16","VisConfigSchemaV1","_Schema11","_super11","_this8","_len8","_key8","_parents$slice17","_parents$slice18","version","v1","highlightColor","_Schema12","_this9","_len9","_key9","_super12","layers","_this10","_parents$slice19","_parents$slice20","visState","_Schema13","_this12","_super13","_this13","InteractionSchemaV0","_Schema14","_super14","_len11","_key11","_this14","interactionPropsV1","interactionConfig","_Schema15","_super15","_this15","_key12","reduce","enabled","modifiedConfig","configType","_utils","notNullorUndefined","fieldsToShow","_this16","name","fieldData","format","_Schema17","_inherits2","_super17","convertLayerSettings","_ref18","_ref19","isAvailable","splitMaps","settings","entries","_this17","plotType","animationWindow","yAxis","speed","filters","interactionPropsV0","layerBlending","_Schema18","_super18","node","undefined","savePropertiesOrApplySchema","loadPropertiesOrApplySchema"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/schemas/src/vis-state-schema.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport pick from 'lodash.pick';\nimport {VERSIONS} from './versions';\nimport {LAYER_VIS_CONFIGS} from '@kepler.gl/constants';\nimport {isFilterValidToSave, notNullorUndefined} from '@kepler.gl/utils';\nimport Schema from './schema';\nimport cloneDeep from 'lodash.clonedeep';\nimport {\n  AnimationConfig,\n  Editor,\n  FileLoading,\n  FileLoadingProgress,\n  Filter,\n  InteractionConfig,\n  MapInfo,\n  ParsedFilter,\n  ParsedLayer,\n  ParsedVisState,\n  SavedFilter,\n  SavedInteractionConfig,\n  SavedLayer,\n  SavedVisState,\n  SplitMap\n} from '@kepler.gl/types';\nimport {Datasets} from '@kepler.gl/table';\nimport {Layer, LayerClassesType} from '@kepler.gl/layers';\nimport {Loader} from '@loaders.gl/loader-utils';\nimport KeplerGLSchema from './schema-manager';\n\n/**\n * V0 Schema\n */\n\nexport const dimensionPropsV0 = ['name', 'type'];\n\nexport type modifiedType = {\n  strokeColor?: any;\n  strokeColorRange?: any;\n  filled?: boolean;\n  stroked?: boolean;\n};\n\nexport interface VisState {\n  mapInfo: MapInfo;\n  layers: Layer[];\n  layerData: any[];\n  layerToBeMerged: any[];\n  layerOrder: number[];\n  filters: Filter[];\n  filterToBeMerged: any[];\n  datasets: Datasets;\n  editingDataset: string | undefined;\n  interactionConfig: InteractionConfig;\n  interactionToBeMerged: any;\n  layerBlending: string;\n  hoverInfo: any;\n  clicked: any;\n  mousePos: any;\n  maxDefaultTooltips: number;\n  layerClasses: LayerClassesType;\n  animationConfig: AnimationConfig;\n  editor: Editor;\n  splitMaps: SplitMap[];\n  splitMapsToBeMerged: SplitMap[];\n  fileLoading: FileLoading | false;\n  fileLoadingProgress: FileLoadingProgress;\n  loaders: Loader[];\n  loadOptions: object;\n  initialState?: Partial<VisState>;\n  mergers: VisStateMergers;\n  schema: typeof KeplerGLSchema;\n  preserveLayerOrder?: number[];\n}\n\nexport type Merger = {\n  merge: <S extends VisState>(state: S, config: any, fromConfig?: boolean) => S;\n  prop: string;\n  toMergeProp?: string;\n};\nexport type VisStateMergers = Merger[];\n\n// in v0 geojson there is only sizeField\n\n// in v1 geojson\n// stroke base on -> sizeField\n// height based on -> heightField\n// radius based on -> radiusField\n// here we make our wiredst guess on which channel sizeField belongs to\nfunction geojsonSizeFieldV0ToV1(config) {\n  const defaultRaiuds = 10;\n  const defaultRadiusRange = [0, 50];\n\n  // if extruded, sizeField is most likely used for height\n  if (config.visConfig.extruded) {\n    return 'heightField';\n  }\n\n  // if show stroke enabled, sizeField is most likely used for stroke\n  if (config.visConfig.stroked) {\n    return 'sizeField';\n  }\n\n  // if radius changed, or radius Range Changed, sizeField is most likely used for radius\n  // this is the most unreliable guess, that's why we put it in the end\n  if (\n    config.visConfig.radius !== defaultRaiuds ||\n    config.visConfig.radiusRange.some((d, i) => d !== defaultRadiusRange[i])\n  ) {\n    return 'radiusField';\n  }\n\n  return 'sizeField';\n}\n\n// convert v0 to v1 layer config\nclass DimensionFieldSchemaV0 extends Schema {\n  version = VERSIONS.v0;\n  save(field) {\n    // should not be called anymore\n    return {\n      [this.key]: field !== null ? this.savePropertiesOrApplySchema(field)[this.key] : null\n    };\n  }\n\n  load(field, parents, accumulated) {\n    const [config] = parents.slice(-1);\n    let fieldName = this.key;\n    if (config.type === 'geojson' && this.key === 'sizeField' && field) {\n      fieldName = geojsonSizeFieldV0ToV1(config);\n    }\n    // fold into visualChannels to be load by VisualChannelSchemaV1\n    return {\n      visualChannels: {\n        ...(accumulated.visualChannels || {}),\n        [fieldName]: field\n      }\n    };\n  }\n}\n\nclass DimensionScaleSchemaV0 extends Schema {\n  version = VERSIONS.v0;\n  save(scale) {\n    return {[this.key]: scale};\n  }\n  load(scale, parents, accumulated) {\n    const [config] = parents.slice(-1);\n    // fold into visualChannels to be load by VisualChannelSchemaV1\n    if (this.key === 'sizeScale' && config.type === 'geojson') {\n      // sizeScale now split into radiusScale, heightScale\n      // no user customization, just use default\n      return {};\n    }\n\n    return {\n      visualChannels: {\n        ...(accumulated.visualChannels || {}),\n        [this.key]: scale\n      }\n    };\n  }\n}\n\n// used to convert v0 to v1 layer config\nclass LayerConfigSchemaV0 extends Schema {\n  version = VERSIONS.v0;\n  load(saved, parents, accumulated) {\n    // fold v0 layer property into config.key\n    return {\n      config: {\n        ...(accumulated.config || {}),\n        [this.key]: saved\n      }\n    };\n  }\n}\n\n// used to convert v0 to v1 layer columns\n// only return column value for each column\nclass LayerColumnsSchemaV0 extends Schema {\n  version = VERSIONS.v0;\n  load(saved, parents, accumulated) {\n    // fold v0 layer property into config.key, flatten columns\n    return {\n      config: {\n        ...(accumulated.config || {}),\n        columns: Object.keys(saved).reduce(\n          (accu, key) => ({\n            ...accu,\n            [key]: saved[key].value\n          }),\n          {}\n        )\n      }\n    };\n  }\n}\n\n// used to convert v0 to v1 layer config.visConfig\nclass LayerConfigToVisConfigSchemaV0 extends Schema {\n  version = VERSIONS.v0;\n  load(saved, parents, accumulated) {\n    // fold v0 layer property into config.visConfig\n    const accumulatedConfig = accumulated.config || {};\n    return {\n      config: {\n        ...accumulatedConfig,\n        visConfig: {\n          ...(accumulatedConfig.visConfig || {}),\n          [this.key]: saved\n        }\n      }\n    };\n  }\n}\n\nclass LayerVisConfigSchemaV0 extends Schema {\n  version = VERSIONS.v0;\n  key = 'visConfig';\n\n  load(visConfig, parents, accumulator) {\n    const [config] = parents.slice(-1);\n    const rename = {\n      geojson: {\n        extruded: 'enable3d',\n        elevationRange: 'heightRange'\n      }\n    };\n\n    if (config.type in rename) {\n      const propToRename = rename[config.type];\n      return {\n        config: {\n          ...(accumulator.config || {}),\n          visConfig: Object.keys(visConfig).reduce(\n            (accu, key) => ({\n              ...accu,\n              ...(propToRename[key]\n                ? {[propToRename[key]]: visConfig[key]}\n                : {[key]: visConfig[key]})\n            }),\n            {}\n          )\n        }\n      };\n    }\n\n    return {\n      config: {\n        ...(accumulator.config || {}),\n        visConfig\n      }\n    };\n  }\n}\n\nclass LayerConfigSchemaDeleteV0 extends Schema {\n  version = VERSIONS.v0;\n  load(value) {\n    return {};\n  }\n}\n\n/**\n * V0 -> V1 Changes\n * - layer is now a class\n * - config saved in a config object\n * - id, type, isAggregated is outside layer.config\n * - visualChannels is outside config, it defines available visual channel and\n *   property names for field, scale, domain and range of each visual chanel.\n * - enable3d, colorAggregation and sizeAggregation are moved into visConfig\n * - GeojsonLayer - added height, radius specific properties\n */\n\nexport const layerPropsV0 = {\n  id: null,\n  type: null,\n\n  // move into layer.config\n  dataId: new LayerConfigSchemaV0({key: 'dataId'}),\n  label: new LayerConfigSchemaV0({key: 'label'}),\n  color: new LayerConfigSchemaV0({key: 'color'}),\n  isVisible: new LayerConfigSchemaV0({key: 'isVisible'}),\n  hidden: new LayerConfigSchemaV0({key: 'hidden'}),\n\n  // convert visConfig\n  visConfig: new LayerVisConfigSchemaV0({key: 'visConfig'}),\n\n  // move into layer.config\n  // flatten\n  columns: new LayerColumnsSchemaV0(),\n\n  // save into visualChannels\n  colorField: new DimensionFieldSchemaV0({\n    properties: dimensionPropsV0,\n    key: 'colorField'\n  }),\n  colorScale: new DimensionScaleSchemaV0({\n    key: 'colorScale'\n  }),\n  sizeField: new DimensionFieldSchemaV0({\n    properties: dimensionPropsV0,\n    key: 'sizeField'\n  }),\n  sizeScale: new DimensionScaleSchemaV0({\n    key: 'sizeScale'\n  }),\n\n  // move into config.visConfig\n  enable3d: new LayerConfigToVisConfigSchemaV0({key: 'enable3d'}),\n  colorAggregation: new LayerConfigToVisConfigSchemaV0({\n    key: 'colorAggregation'\n  }),\n  sizeAggregation: new LayerConfigToVisConfigSchemaV0({key: 'sizeAggregation'}),\n\n  // delete\n  isAggregated: new LayerConfigSchemaDeleteV0()\n};\n\n/**\n * V1 Schema\n */\nclass ColumnSchemaV1 extends Schema {\n  save(columns, state) {\n    // starting from v1, only save column value\n    // fieldIdx will be calculated during merge\n    return {\n      [this.key]: Object.keys(columns).reduce(\n        (accu, ckey) => ({\n          ...accu,\n          [ckey]: columns[ckey].value\n        }),\n        {}\n      )\n    };\n  }\n\n  load(columns) {\n    return {columns};\n  }\n}\n\nclass TextLabelSchemaV1 extends Schema {\n  save(textLabel) {\n    return {\n      [this.key]: textLabel.map(tl => ({\n        ...tl,\n        field: tl.field ? pick(tl.field, ['name', 'type']) : null\n      }))\n    };\n  }\n\n  load(textLabel) {\n    return {textLabel: Array.isArray(textLabel) ? textLabel : [textLabel]};\n  }\n}\n\nconst visualChannelModificationV1 = {\n  geojson: (vc, parents, accumulator) => {\n    const [layer] = parents.slice(-1);\n    const isOld = !vc.hasOwnProperty('strokeColorField');\n    // make our best guess if this geojson layer contains point\n    const isPoint =\n      vc.radiusField || layer.config.visConfig.radius !== LAYER_VIS_CONFIGS.radius.defaultValue;\n\n    if (isOld && !isPoint && layer.config.visConfig.stroked) {\n      // if stroked is true, copy color config to stroke color config\n      return {\n        strokeColorField: vc.colorField,\n        strokeColorScale: vc.colorScale\n      };\n    }\n    return {};\n  }\n};\n/**\n * V1: save [field]: {name, type}, [scale]: '' for each channel\n */\nclass VisualChannelSchemaV1 extends Schema {\n  save(visualChannels, parents) {\n    // only save field and scale of each channel\n    const [layer] = parents.slice(-1);\n    return {\n      [this.key]: Object.keys(visualChannels).reduce(\n        //  save channel to null if didn't select any field\n        (accu, key) => ({\n          ...accu,\n          [visualChannels[key].field]: layer.config[visualChannels[key].field]\n            ? pick(layer.config[visualChannels[key].field], ['name', 'type'])\n            : null,\n          [visualChannels[key].scale]: layer.config[visualChannels[key].scale]\n        }),\n        {}\n      )\n    };\n  }\n  load(vc, parents, accumulator) {\n    // fold channels into config\n    const [layer] = parents.slice(-1);\n    const modified = visualChannelModificationV1[layer.type]\n      ? visualChannelModificationV1[layer.type](vc, parents, accumulator)\n      : {};\n\n    return {\n      ...accumulator,\n      config: {\n        ...(accumulator.config || {}),\n        ...vc,\n        ...modified\n      }\n    };\n  }\n}\nconst visConfigModificationV1 = {\n  point: (visConfig, parents, accumulated) => {\n    const modified: modifiedType = {};\n    const [layer] = parents.slice(-2, -1);\n    const isOld =\n      !visConfig.hasOwnProperty('filled') && !visConfig.strokeColor && !visConfig.strokeColorRange;\n    if (isOld) {\n      // color color & color range to stroke color\n      modified.strokeColor = layer.config.color;\n      modified.strokeColorRange = cloneDeep(visConfig.colorRange);\n      if (visConfig.outline) {\n        // point layer now supports both outline and fill\n        // for older schema where filled has not been added to point layer\n        // set it to false\n        modified.filled = false;\n      }\n    }\n\n    return modified;\n  },\n  geojson: (visConfig, parents, accumulated) => {\n    // is points?\n    const modified: modifiedType = {};\n    const [layer] = parents.slice(-2, -1);\n    const isOld =\n      layer.visualChannels &&\n      !layer.visualChannels.hasOwnProperty('strokeColorField') &&\n      !visConfig.strokeColor &&\n      !visConfig.strokeColorRange;\n    // make our best guess if this geojson layer contains point\n    const isPoint =\n      (layer.visualChannels && layer.visualChannels.radiusField) ||\n      (visConfig && visConfig.radius !== LAYER_VIS_CONFIGS.radius.defaultValue);\n\n    if (isOld) {\n      // color color & color range to stroke color\n      modified.strokeColor = layer.config.color;\n      modified.strokeColorRange = cloneDeep(visConfig.colorRange);\n      if (isPoint) {\n        // if is point, set stroke to false\n        modified.filled = true;\n        modified.stroked = false;\n      }\n    }\n\n    return modified;\n  }\n};\n\nclass VisConfigSchemaV1 extends Schema {\n  key = 'visConfig';\n\n  load(visConfig, parents, accumulated) {\n    const [layer] = parents.slice(-2, -1);\n    const modified = visConfigModificationV1[layer.type]\n      ? visConfigModificationV1[layer.type](visConfig, parents, accumulated)\n      : {};\n\n    return {\n      visConfig: {\n        ...visConfig,\n        ...modified\n      }\n    };\n  }\n}\n\nexport const layerPropsV1 = {\n  id: null,\n  type: null,\n  config: new Schema({\n    version: VERSIONS.v1,\n    key: 'config',\n    properties: {\n      dataId: null,\n      label: null,\n      color: null,\n      highlightColor: null,\n      columns: new ColumnSchemaV1({\n        version: VERSIONS.v1,\n        key: 'columns'\n      }),\n      isVisible: null,\n      visConfig: new VisConfigSchemaV1({\n        version: VERSIONS.v1\n      }),\n      hidden: null,\n      textLabel: new TextLabelSchemaV1({\n        version: VERSIONS.v1,\n        key: 'textLabel'\n      })\n    }\n  }),\n  visualChannels: new VisualChannelSchemaV1({\n    version: VERSIONS.v1,\n    key: 'visualChannels'\n  })\n};\n\nexport class LayerSchemaV0 extends Schema {\n  key = 'layers';\n\n  save(layers: Layer[], parents: [VisState]): {layers: SavedLayer[]} {\n    const [visState] = parents.slice(-1);\n\n    return {\n      [this.key as 'layers']: visState.layerOrder.reduce((saved, index) => {\n        // save layers according to their rendering order\n        const layer = layers[index];\n        if (layer.isValidToSave()) {\n          saved.push(this.savePropertiesOrApplySchema(layer).layers);\n        }\n        return saved;\n      }, [] as SavedLayer[])\n    };\n  }\n\n  load(\n    layers: SavedLayer[] | undefined\n  ): {\n    layers: ParsedLayer[] | undefined;\n  } {\n    return {\n      [this.key as 'layers']: layers\n        ? layers.map(layer => this.loadPropertiesOrApplySchema(layer, layers).layers)\n        : []\n    };\n  }\n}\n\nexport class FilterSchemaV0 extends Schema {\n  key = 'filters';\n  save(filters: Filter[]): {filters: SavedFilter[]} {\n    return {\n      filters: filters\n        .filter(isFilterValidToSave)\n        .map(filter => this.savePropertiesOrApplySchema(filter).filters)\n    };\n  }\n  load(filters: undefined | SavedFilter[]): {filters: undefined | ParsedFilter[]} {\n    return {filters};\n  }\n}\n\nconst interactionPropsV0 = ['tooltip', 'brush'];\n\nclass InteractionSchemaV0 extends Schema {\n  key = 'interactionConfig';\n\n  save(interactionConfig) {\n    return Array.isArray(this.properties)\n      ? {\n          [this.key]: this.properties.reduce(\n            (accu, key) => ({\n              ...accu,\n              ...(interactionConfig[key].enabled ? {[key]: interactionConfig[key].config} : {})\n            }),\n            {}\n          )\n        }\n      : {};\n  }\n  load(interactionConfig) {\n    // convert v0 -> v1\n    // return enabled: false if disabled,\n    return Array.isArray(this.properties)\n      ? {\n          [this.key]: this.properties.reduce(\n            (accu, key) => ({\n              ...accu,\n              ...{\n                [key]: {\n                  ...(interactionConfig[key] || {}),\n                  enabled: Boolean(interactionConfig[key])\n                }\n              }\n            }),\n            {}\n          )\n        }\n      : {};\n  }\n}\n\nconst interactionPropsV1 = [...interactionPropsV0, 'geocoder', 'coordinate'];\n\nexport class InteractionSchemaV1 extends Schema {\n  key = 'interactionConfig';\n\n  save(\n    interactionConfig: InteractionConfig\n  ):\n    | {\n        interactionConfig: SavedInteractionConfig;\n      }\n    | {} {\n    // save config even if disabled,\n    return Array.isArray(this.properties)\n      ? {\n          [this.key]: this.properties.reduce(\n            (accu, key) => ({\n              ...accu,\n              [key]: {\n                ...interactionConfig[key].config,\n                enabled: interactionConfig[key].enabled\n              }\n            }),\n            {}\n          )\n        }\n      : {};\n  }\n  load(\n    interactionConfig: SavedInteractionConfig\n  ): {\n    interactionConfig: Partial<SavedInteractionConfig>;\n  } {\n    const modifiedConfig = interactionConfig;\n    Object.keys(interactionConfig).forEach(configType => {\n      if (configType === 'tooltip') {\n        const fieldsToShow = modifiedConfig[configType].fieldsToShow;\n        if (!notNullorUndefined(fieldsToShow)) {\n          return {[this.key]: modifiedConfig};\n        }\n        Object.keys(fieldsToShow).forEach(key => {\n          // @ts-expect-error name: fieldData should be string\n          fieldsToShow[key] = fieldsToShow[key].map(fieldData => {\n            if (!fieldData.name) {\n              return {\n                name: fieldData,\n                format: null\n              };\n            }\n            return fieldData;\n          });\n        });\n      }\n      return;\n    });\n    return {[this.key as 'interactionConfig']: modifiedConfig};\n  }\n}\n\nexport const filterPropsV0 = {\n  dataId: null,\n  id: null,\n  name: null,\n  type: null,\n  value: null,\n  enlarged: null\n};\n\nexport class DimensionFieldSchema extends Schema {\n  save(field) {\n    return {\n      [this.key]: field ? this.savePropertiesOrApplySchema(field)[this.key] : null\n    };\n  }\n\n  load(field) {\n    return {[this.key]: field};\n  }\n}\n\nexport class SplitMapsSchema extends Schema {\n  convertLayerSettings(accu, [key, value]) {\n    if (typeof value === 'boolean') {\n      return {\n        ...accu,\n        [key]: value\n      };\n    } else if (value && typeof value === 'object' && value.isAvailable) {\n      return {\n        ...accu,\n        [key]: Boolean(value.isVisible)\n      };\n    }\n    return accu;\n  }\n\n  load(splitMaps) {\n    // previous splitMaps Schema {layers: {layerId: {isVisible, isAvailable}}}\n\n    if (!Array.isArray(splitMaps) || !splitMaps.length) {\n      return {splitMaps: []};\n    }\n\n    return {\n      splitMaps: splitMaps.map(settings => ({\n        ...settings,\n        layers: Object.entries(settings.layers || {}).reduce(this.convertLayerSettings, {})\n      }))\n    };\n  }\n}\n\nexport const filterPropsV1 = {\n  ...filterPropsV0,\n  plotType: null,\n  animationWindow: null,\n  yAxis: new DimensionFieldSchema({\n    version: VERSIONS.v1,\n    key: 'yAxis',\n    properties: {\n      name: null,\n      type: null\n    }\n  }),\n\n  // polygon filter properties\n  layerId: null,\n  speed: null\n};\n\nexport const propertiesV0 = {\n  filters: new FilterSchemaV0({\n    version: VERSIONS.v0,\n    properties: filterPropsV0\n  }),\n  layers: new LayerSchemaV0({\n    version: VERSIONS.v0,\n    properties: layerPropsV0\n  }),\n  interactionConfig: new InteractionSchemaV0({\n    version: VERSIONS.v0,\n    properties: interactionPropsV0\n  }),\n  layerBlending: null\n};\n\nexport const propertiesV1 = {\n  filters: new FilterSchemaV0({\n    version: VERSIONS.v1,\n    properties: filterPropsV1\n  }),\n  layers: new LayerSchemaV0({\n    version: VERSIONS.v1,\n    properties: layerPropsV1\n  }),\n  interactionConfig: new InteractionSchemaV1({\n    version: VERSIONS.v1,\n    properties: interactionPropsV1\n  }),\n  layerBlending: null,\n  splitMaps: new SplitMapsSchema({\n    key: 'splitMaps',\n    version: VERSIONS.v1\n  }),\n  animationConfig: new Schema({\n    version: VERSIONS.v1,\n    properties: {\n      currentTime: null,\n      speed: null\n    },\n    key: 'animationConfig'\n  })\n};\n\nexport class VisStateSchemaV1 extends Schema {\n  save(node: VisState, parents: any[] = [], accumulator?: any): {visState: SavedVisState} {\n    // @ts-expect-error\n    return this.savePropertiesOrApplySchema(node, parents, accumulator);\n  }\n\n  load(\n    node?: SavedVisState\n  ): {\n    visState: ParsedVisState | undefined;\n  } {\n    // @ts-expect-error\n    return this.loadPropertiesOrApplySchema(node);\n  }\n}\n\nexport const visStateSchemaV0 = new Schema({\n  version: VERSIONS.v0,\n  properties: propertiesV0,\n  key: 'visState'\n});\n\nexport const visStateSchemaV1 = new VisStateSchemaV1({\n  version: VERSIONS.v1,\n  properties: propertiesV1,\n  key: 'visState'\n});\n\nexport const visStateSchema: {\n  v0: typeof visStateSchemaV0;\n  v1: typeof visStateSchemaV1;\n} = {\n  // @ts-expect-error\n  [VERSIONS.v0]: {\n    save: toSave => visStateSchemaV0.save(toSave),\n    load: toLoad => visStateSchemaV1.load(visStateSchemaV0.load(toLoad)?.visState)\n  },\n  [VERSIONS.v1]: visStateSchemaV1\n};\n\n// test load v0\nexport default visStateSchema;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAoBAA,OAAA,cAAAA,OAAA,CAAAC,cAAA,GAAAD,OAAA,CAAAE,gBAAA,GAAAF,OAAA,CAAAG,gBAAA,GAAAH,OAAA,CAAAI,gBAAA,GAAAJ,OAAA,CAAAK,YAAA,GAAAL,OAAA,CAAAM,YAAA,GAAAN,OAAA,CAAAO,aAAA,GAAAP,OAAA,CAAAQ,eAAA,GAAAR,OAAA,CAAAS,oBAAA,GAAAT,OAAA,CAAAU,aAAA,GAAAV,OAAA,CAAAW,mBAAA,GAAAX,OAAA,CAAAY,cAAA,GAAAZ,OAAA,CAAAa,aAAA,GAAAb,OAAA,CAAAc,YAAA,GAAAd,OAAA,CAAAe,YAAA,GAAAf,OAAA,CAAAgB,gBAAA;AACA,IAAAC,QAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,eAAA,GAAAF,sBAAA,CAAAC,OAAA;AACA,IAAAE,gBAAA,GAAAH,sBAAA,CAAAC,OAAA;AACA,IAAAG,aAAA,GAAAJ,sBAAA,CAAAC,OAAA;AACA,IAAAI,uBAAA,GAAAL,sBAAA,CAAAC,OAAA;;;;;;AAuBA,IAAAK,SAAA,GAAAL,OAAA;AAEA,IAAAM,UAAA,GAAAN,OAAA;;AAkDA,IAAAO,OAAA,GAAAR,sBAAA,CAAAC,OAAA;AAGA,IAAAQ,QAAA,GAAAT,sBAAA,CAAAC,OAAA;AAEA,IAAAS,eAAA;AAEA,SAASC,QAAAC,MAAA,EAAAC,cAAT,EAAwC;EAAA,IAAAC,IAAA,GAAAC,MAAA,CAAAD,IAAA,CAAAF,MAAA;EAAA,IAAAG,MAAA,CAAAC,qBAAA;IAAA,IAAAC,OAAA,GAAAF,MAAA,CAAAC,qBAAA,CAAAJ,MAAA;IAAA,IAAAC,cAAA,EAAAI,OAAA,GAAAA,OAAA,CAAAC,MAAA,WAAAC,GAAA;MAAA,OAAAJ,MAAA,CAAAK,wBAAA,CAAAR,MAAA,EAAAO,GAAA,EAAAE,UAAA;IAAA;IAAAP,IAAA,CAAAQ,IAAA,CAAAC,KAAA,CAAAT,IAAA,EAAAG,OAAA;EAAA;EAAA,OAAAH,IAAA;AAAA;AAEtC,SAAMU,cAAAC,MAAqB,EAAI;EAAJ,KAE3B,IAAAC,CAAA,MAAAA,CAAA,GAAAC,SAAA,CAAAC,MAAA,EAAAF,CAAA;IAAA,IAAAG,MAAA,GAAAF,SAAA,CAAAD,CAAA,YAAAC,SAAA,CAAAD,CAAA;IAAA,IAAAA,CAAA;MAAAf,OAAA,CAAAI,MAAA,CAAAc,MAAA,SAAAC,OAAA,WAAAC,GAAA;QAAA,IAAAC,gBAAA,aAAAP,MAAA,EAAAM,GAAA,EAAAF,MAAA,CAAAE,GAAA;MAAA;IAAA,WAAAhB,MAAA,CAAAkB,yBAAA;MAAAlB,MAAA,CAAAmB,gBAAA,CAAAT,MAAA,EAAAV,MAAA,CAAAkB,yBAAA,CAAAJ,MAAA;IAAA;MAAAlB,OAAA,CAAAI,MAAA,CAAAc,MAAA,GAAAC,OAAA,WAAAC,GAAA;QAAAhB,MAAA,CAAAoB,cAAA,CAAAV,MAAA,EAAAM,GAAA,EAAAhB,MAAA,CAAAK,wBAAA,CAAAS,MAAA,EAAAE,GAAA;MAAA;IAAA;EAAA;EAAA,OAAAN,MAAA;AAAA;AACA,SAAIW,YAAOA,CAAPC,OAAiB,EAArB;EAA+B,IAAAC,yBAAA,GAAAC,yBAAA;EAAA,gBAAAC,qBAAA;IAAA,IAAAC,KAAA,OAAAC,gBAAA,aAAAL,OAAA;MAAAM,MAAA;IAAA,IAAAL,yBAAA;MAAA,IAAAM,SAAA,OAAAF,gBAAA,mBAAAG,WAAA;MAAAF,MAAA,GAAAG,OAAA,CAAAC,SAAA,CAAAN,KAAA,EAAAd,SAAA,EAAAiB,SAAA;IAAA;MAAAD,MAAA,GAAAF,KAAA,CAAAlB,KAAA,OAAAI,SAAA;IAAA;IAAA,WAAAqB,2BAAA,mBAAAL,MAAA;EAAA;AAAA;AAE9B,SAEDJ,0BAAA;EAAA,WAAAO,OAAA,qBAAAA,OAAA,CAAAC,SAAA;EAAA,IAAAD,OAAA,CAAAC,SAAA,CAAAE,IAAA;EAAA,WAAAC,KAAA;EAAA;IAAAC,OAAA,CAAAC,SAAA,CAAAC,OAAA,CAAAC,IAAA,CAAAR,OAAA,CAAAC,SAAA,CAAAI,OAAA;IAAA;EAAA,SAAAI,CAAA;IAAA;EAAA;AAAA;;;AACA;AACE;AACD,IAEDzD,gBAAA;AACAhB,OAAA,CAAAgB,gBAAA,GAAAA,gBAAA;;;AACA;AAEoC;AAAA;AAElC;AACD;;EAED,IAAA0D,aAAO,GAAP;EAGF,IAAAC,kBAAA;;;IACM;;;;;;;;;;;;;;;;;gBAEJ,UAAK,GAAAC,sBAAO,EAAAC,OAAA;EAEV,IAAAC,MAAA,GAAAxB,YAAA,CAAAsB,sBACG;;;IAI6B,IAAAvD,gBAAA,UACR,CAAC,MAAM,EAAduD,sBADe;IAAA,SACzBG,IADyB,GAAAlC,SAAA,CAAAC,MAAA,EAAAkC,IAAA,OAAAC,KAAA,CAAAF,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;;IAEhC;IACAC,KAAA,GAAIL,MAAO,CAAAN,IAAP,CAAA/B,KAAgB,CAAAqC,MAAhB,GAA6B,KAAK,CAAAM,MAAL,CAAaJ,IAAA;IAC5C,IAAA9B,gBAAY,iBAAA3B,uBAAZ,aAAA4D,KAAA,cAAA3D,SAAA,CAAA6D,QAAA,CAAAC,EAAA;IACD,OACDH,KAAA;;EACA,IAAA7D,aAAO,aAAAsD,sBAAA;IACL3B,GAAA;IADKsC,KAAP,WAAAC,KAAAC,KAAA;MAMD;;;EAtBkC;;IAyB/BF,KAAA,WAAAG,KAAAD,K;;;;;;;;;;;;;;;;;gBAEJ,UAAK,GAAAE,sBAAO,EAAAC,QAAA;EAEX,IAAAC,OAAA,GAAAvC,YAAA,CAAAqC,sBAAA;;cACD;IAAkC,IAAAtE,gBAAA,mBAAAsE,sBAAA;;;IAGhC;IAEEG,MAAA,GAAAD,OAAA,CAAArB,IAAA,CAAA/B,KAAA,CAAAoD,OAAA,SAAAT,MAAA,CAAAJ,IAAA;IACA,IAAA9B,gBAAA,iBAAA3B,uBAAA,aAAAuE,MAAA,cAAAtE,SAAA,CAAA6D,QAAA,CAAAC,EAAA;IACD,OAAAQ,MAAA;;EAGC,IAAAxE,aAAA,UAAc,GAAAqE,sBAAA,EACR;IAFD1C,GAAP;IAMDsC,KAAA,WAAAC,KAAAO,KAAA;;;EApBkC;;;MAwB/B,IAAAC,e;;;;;;;;;;;;;;;;;;gBAEJ,UAAK,GAAAC,mBAAgB,EAAAC,QAAa;EAEhC,IAAAC,OAAO,GAAA7C,YAAA,CAAA2C,mBAAA;EAAA,SAAPA,oBAAA;IAMD,IAAAG,MAAA;;IAIH,SAAAC,KAAA,GAAAxD,SAAA,CAAAC,MAAA,EAAAkC,IAAA,OAAAC,KAAA,CAAAoB,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;;;;;;;;;;;;;;;;;;;;;gBAGE,UAAK,GAAAC,oBAAgB,EAAAC,QAAa;EAEhC,IAAAC,OAAO,GAAAnD,YAAA,CAAAiD,oBAAA;EAGH,SAAAA,oBAAqBA,CAAA;IACnB,IAAAG,MAAA;IAHE,IAAArF,gBAAA,mBAAAkF,oBAAA;IAWT,SAAAI,KAAA,GAAA9D,SAAA,CAAAC,MAAA,EAAAkC,IAAA,OAAAC,KAAA,CAAA0B,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;;;;;IAIG,OAAAF,MAAA;;;;;;;;;;;;;;;;;;;gBAEJ,UAAK,GAAAG,8BAA6B,EAAAC,QAAA;EAEhC,IAAAC,OAAM,GAAAzD,YAAiB,CAAAuD,8BAAvB;EAEE,SAAAA,8BAAMG,CAAA;IAEJ,IAAAC,MAAA;IAHG,IAAP5F,gBAAA,mBAAAwF,8BAAA;;;IALyC;IAiBvCI,MAAA,GAAAF,OAAA,CAAAvC,IAAA,C;;;;;;;;;;;;;;;;;;;;EAIkC,IAAA0C,OAAA,GAAA5D,YACnB,CAAA6D,sBADmB;EAAA,SAC7BA,sBAD6BH,CAAA;;IAGlC,IAAA3F,gBAAS,mBAAA8F,sBAAA;IAEP,SAAAC,KAAA,GAAAvE,SAAgB,CAAAC,MAAA,EAAAkC,IAAA,OAAAC,KAAA,CAAAmC,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAFTrC,IAAA,CAAAqC,KAAA,IAAAxE,SAAA,CAAAwE,KAAA;IADI;IAOfC,MAAI,GAAAJ,OAAO,CAAP1C,IAAe,CAAA/B,KAAnB,CAAAyE,OAA2B,SAAA9B,MAAA,CAAAJ,IAAA;IACzB,IAAA9B,gBAAkB,UAAU,OAAO3B,uBAAnC,aAAA+F,MAAA,cAAA9F,SAAA,CAAA6D,QAAA,CAAAC,EAAA;IACA,IAAApC,gBAAO,iBAAA3B,uBAAA,aAAA+F,MAAA;IACL,OAAAA,MAAM;EAEJ;EACE,IAAAhG,aADS,aAAA6F,sBAAA;IAFPlE,GAAA;IADDsC,KAAP,WAAAG,KAAA6B,SAAA,EAAAC,OAAA,EAAAC,WAAA;MAcD,IAAAC,eAAA,GAAAF,OAAA,CAAAG,KAAA;;QAEDX,MAAO,GAAAY,eAAA;MAGH,IAAAC,MAAA,GAAS;QAFLC,OAAA;UADRC,QAAA;UAMDC,cAAA;;;;QAGG,IAAAC,YAAA,GAAAJ,M;;;;;;;;;;;;;;;;;;;gBAEJ,UAAK,GAAAK,yBAAO,EAAAC,QAAA;EAEX,IAAAC,OAAA,GAAA9E,YAAA,CAAA4E,yBAAA;;IAJqC,IAAAG,MAAA;IAQxC,IAAAhH,gBAAA,mBAAA6G,yBAAA;IAEA,SAAAI,KAAA,GAAAzF,SAAA,CAAAC,MAAA,EAAAkC,IAAA,OAAAC,KAAA,CAAAqD,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MACAvD,IAAA,CAAAuD,KAAA,IAAA1F,SAAA,CAAA0F,KAAA;IACA;IAEAF,MAAA,GAAAD,OAAA,CAAA5D,IAAA,CAAA/B,KAAA,CAAA2F,OAAA,SAAAhD,MAAA,CAAAJ,IAAA;IACA,IAAA9B,gBAAA,iBAAA3B,uBAAA,aAAA8G,MAAA,cAAA7G,SAAA,CAAA6D,QAAA,CAAAC,EAAA;IACA,OAAA+C,MAAA;;EAEO,EAAM,EAAA/G,aAAe,aAAA4G,yBAAA;IACxBjF,GAAE,QADsB;IAE1BsC,KAAM,WAFoBG,KAAAH,KAAA;MAI1B;IACA;EAAiC;EAAD,OALN2C,yBAAA;AAM1B,EAAAxG,OAAO,UAAI;AAAqB;AAAD;AAC/B;AAAgC;AAAD;AAC/B;AAAoC;AAAD;AACnC;AAAiC;;AAGjC,IAAAX,YAAW,GAAI;EAAwByH,EAAA,MAAK;EAANC,IAZZ;EAc1B;EACAC,MAAA,MAAAzC,mBAAA;IACAhD,GAAA,EAAO;EAEP;EACA0F,KAAA,MAAU1C,mBAAM;IACdhD,GAAA;EACA;EAFqC2F,KAnBb,MAAA3C,mBAAA;IAuB1BhD,GAAA;EACE;EADqC4F,SAvBb,MAAA5C,mBAAA;IA0B1BhD,GAAA;EACE;EACA6F,MAAG,EAAE,IAAA7C,mBAAA;IA5BmBhD,GAAA;EA8B1B;EACE;EADoCsE,SA9BZ,MAAAJ,sBAAA;IAkC1BlE,GAAA;EACA;EAA8C;EAAD;EAC7C8F,OAAA,MAAAxC,oBAAsB;EACpB;EADmDyC,UApC3B,MAAApE,sBAAA;IAuC1BqE,UAAA,EAAAjI,gBAAqB;IAAgCiC,GAAG,EAAE;EAAN,CAAnC,CAvCS;EAyC1BiG,UAAA,MAAAvD,sBAAA;IACA1C,GAAA;EA1CK;EA6CPkG,SAAA,MAAAvE,sBAAA;IACAqE,UAAA,EAAAjI,gBAAA;IACAiC,GAAA;;;;IACM;;;;;;;;;;;;cACJ,MAAAiF,yBAAqB;AACnB;AACA;AACA;AAEI;;AAOLlI,OAAA,CAAAe,YAAA,GAAAA,YAAA;;gBAED,UAAK,GAAAqI,cAAS,EAAAC,QAAA;EACJ,IAAAC,OAAA,GAAOhG,YAAP,CAAA8F,cAAA;EACT,SAAAA,eAAA;;;EAjB0B;IAoBvB,EAAA9H,aAAA,U;;;;;;;;;;;;aACJ;QACEyH,OAAA,EAAAA;MAC8B;IAE1B;EAF0B;EAAA,OAD9BK,cAAA;AAMD,EAAA1H,OAAA;;gBAED,UAAK,GAAA6H,iBAAW,EAAAC,QAAA;EACN,IAAAC,OAAA,GAAAnG,YAAiB,CAAAiG,iBAAqB;EAC/C,SAAAA,kBAAA;;;EAZ6B;EAehC,EAAM,EAAAjI,aAAA,aAA2BiI,iBAAG;IAClCtG,GAAA,EAAO,MAAE;IAA8BsC,KAAA,WAAAC,KAAAkE,SACb;MADa,WAAAxG,gBAAA,sBAAAD,GAAA,EAAAyG,SAAA,CAAAC,GAAA,WAAAC,EAAA;QAC9B,OAD8BlH,aAAA,CAAAA,aAAA,KAAAkH,EAAA;;QAE/B;;IAEN;;IAGA3G,GAAA,EAAI,MAAK;IACPsC,KAAA,WAAAG,KAAAgE,SAAA;MACA,OAAO;QACLA,SAAA,EAAAzE,KAAgB,CAAA4E,OAAK,CAAAH,SADhB,IAAAA,SAAA,IAAAA,SAAA;MAEL;IAFK;EAIR;;AACD,EAAAhI,OAAA;AAfgC,IAApCoI,2BAAA;EAkBAhC,OAAA,WAAAA,QAAAiC,EAAA,EAAAvC,OAAA,EAAAC,WAAA;IACA,IAAAuC,eAAA,GAAAxC,OAAA,CAAAG,KAAA;MACAsC,eAAA,OAAA7I,eAAA,aAAA4I,eAAA;;;;;;;;;;;;IAGI;EAD4B;AAAA;AAAA;;AAG5B;;AAGI,IAAAE,qBAAA,0BAAAC,SAAA;;EAAA,IAAAC,QAHJ,GAAA9G,YAAA,CAAA4G,qBAAA;;;WAcFE,QAAA,CAAA3H,KAAK,KAAI,EAAAI,SAAS;EAChB;EAD6B,IAAAvB,aAAA,aAAA4I,qBAAA;IAAAjH,GAAA;;MAG7B;MAIA,IAAAoH,eAAA,GAAA7C,OAAA,CAAAG,KAAA,IACK;QACH2C,gBAAM,OAAAlJ,eAAA,aAAAiJ,eACY,IAAZ;QAHRE,KAAA,GAAAD,gBAAA;;;;QAzBgC,IAAAE,c;QAmC9B,OAAA9H,aAAuB,CAAAA,aAAG,KAAA+H,IAAA,QAAAD,cAAA,WAAAtH,gBAAA,aAAAsH,cAAA,EAAAE,cAAA,CAAAzH,GAAA,EAAAwC,KAAA,EAAA8E,KAAA,CAAAvD,MAAA,CAAA0D,cAAA,CAAAzH,GAAA,EAAAwC,KAAA,QAAAkF,OAAA,aAAAJ,KAAA,CAAAvD,MAAA,CAAA0D,cAAA,CAAAzH,GAAA,EAAAwC,KAAA,kCAAAvC,gBAAA,aAAAsH,cAAA,EAAAE,cAAA,CAAAzH,GAAA,EAAA8C,KAAA,EAAAwE,KAAA,CAAAvD,MAAA,CAAA0D,cAAA,CAAAzH,GAAA,EAAA8C,KAAA,IAAAyE,cAAA;MAC9B,CAAK,EAAE;IACL;;IAD0CvH,GAAA;IAAAsC,KAAA,WAAAG,KAAAqE,EAAA,EAAAvC,OAAA,EAAAC,WAAA;MAAA;;QAGpCmD,gBACM,GAAC,IAAAxJ,eAAe,UAAc,GAAAyJ,gBAAxC,IAAiE;;MAEjE,IAAAC,QAAA,GAAAhB,2BAAA,CAAAS,KAAA,CAAA9B,IAAA,IAAAqB,2BAAA,CAAAS,KAAA,CAAA9B,IAAA,EAAAsB,EAAA,EAAAvC,OAAA,EAAAC,WAAA;MACA,OAAA/E,aAAA,CAAAA,aAA6B,CAAN,CAAa,GAAA+E,WAApC;QACAT,MAAQ,EAACtE,aAAA,CAAAA,aAAmB,CAAAA,aAAA,EAAU,GAAA+E,WAAU,CAAAT,MAAhD,SAAA+C,EAAA,GAAAe,QAAA;;IACA;EACE;EACA,OAAAZ,qBAAA;AACA,EAAAxI,OAAA;AAED,IAAAqJ,uBAAA;EACFC,KAAA,WAAAA,MAAAzD,SAAA,EAAAC,OAAA,EAAAyD,WAAA;;IAhB2B,IAAAC,gBAAA,GAAA1D,OAAA,CAAAG,KAAA;MAoB9BwD,gBAAS,IAAC,GAAA/J,eAAD,UAAqB,GAArB8J,gBAAqC;MAC5CX,KAAA,GAAAY,gBAAA;;IAD4C,IAAAC,KAAA;MAAA;;MAI5CN,QAAW,CAAAO,gBACH,KAAN,EAAA1J,QACM,CAAC,YAAA4F,SAAe,CAAA+D,UAAe;MAIvC,IAAM/D,SACH,CAAAgE,OAAM;;QAGL;QACF;QACAT,QAAS,CAAAU,MAAA,GAAT,KAAuB;MACvB;;IAEE,OAAAV,QAAA;EACA;EACAhD,OAAA,WAASA,OAAU2D,CAAAlE,SAAnB,EAAAC,OAAA,EAAAyD,WAAA;IACD;IACF,IAAAH,QAAA;IAED,IAAAY,gBAAA,GAAAlE,OAAA,CAAAG,KAAA;MACDgE,gBAAA,OAAAvK,eAAA,aAAAsK,gBAAA;MA9CHnB,KAAA,GAAAoB,gBAAA;IAiDM,IAAAP,KAAA,GAAAb,K;;;;;;;;;;;;;;;;;gBAGJ,UAAK,GAAAqB,iBAAoB,EAAAC,SAAzB,CAAsC;EAAA,IAAAC,QAAA,GAAAxI,YAAA,CAAAsI,iBAAA;;IAEpC,IAAAG,MAAM;IAKJ,IAAA1K,gBAAS,mBAAAuK,iBAAA;IAKZ,SAAAI,KAAA,GAAAnJ,SAAA,CAAAC,MAAA,EAAAkC,IAAA,OAAAC,KAAA,CAAA+G,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;;;;IAGU,IAAA/I,gBAAe,iBAAA3B,uBAAA,aAAAwK,MAAA;IACxB,OADwBA,MAAA;EAE1B;EAEE,IAAAzK,aAAS,aAASsK,iBADD;IAEjB3I,GAAG,EAAE;IACLsC,KAAA,WAAYG,KAAA6B,SAAA,EAAAC,OAAA,EAAAyD,WAAA;MACV,IAAAiB,gBADU,GAAA1E,OAAA,CAAAG,KAAA;QAEVwE,gBAFU,OAAA/K,eAAA,aAAA8K,gBAAA;QAGV3B,KAAO,GAHG4B,gBAAA;MAKV,IAAArB,QAAS,GAAIC,uBAAe,CAAAR,KAAA,CAAA9B,IAAA,IAAAsC,uBAAA,CAAAR,KAAA,CAAA9B,IAAA,EAAAlB,SAAA,EAAAC,OAAA,EAAAyD,WAAA;MAC1B;QACA1D,SAAK,EAAA7E,aAAA,CAAAA,aAAA,KAAA6E,SAAA,GAAAuD,QAAA;MAFqB,CAAnB;IAIT;EACA;EACE,OAAAc,iBAAS;AADsB,EAAAlK,OAVvB;AAcV,IAAAZ,YAAS,GAAE;EACT0H,EAAA;EACAC,IAAA,MAAG;EAF4BzB,MAAtB,MAAAtF,OAAA;IAdD0K,OAAA,EAAA5K,SAAA,CAAA6D,QAAA,CAAAgH,EAAA;IANYpJ,GAAA;IA0B1BgG,UAAA,EAAc;MACZP,MAAO,EAAE;MACTC,KAAK;MAFSC,KAAA;MA1BX0D,cAAA;;;QAgCMrJ,GAAA;;;;;;;;;;;;;;;;;;;;gBAGX,UAAK,GAAApC,aAA8D,EAAA0L,SAAA;;EAAA,SAAA1L,cAAA;IAAA,IAAA2L,MAC1D;IAEP,IAAAnL,gBAAA,mBAAAR,aACQ;IAEJ,SAAM4L,KAAK,GAAG5J,SAAO,CAAAC,MAArB,EAAAkC,IAAA,OAAAC,KAAA,CAAAwH,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;;IACA;IAECF,MAAA,GAAAG,QAAA,CAAAnI,IAAA,CAAA/B,KAAA,CAAAkK,QAAA,SAAAvH,MAAA,CAAAJ,IAAA;;IACD,OAAAwH,MAAO;EACR;;;WAIL,SAAAhH,KACEoH,MADF,EAIEpF,OAAA;MAAA,IAAAqF,OAAA;MACA,IAAAC,gBAAA,GAAAtF,OAAA,CAAAG,KAAA;QAEsBoF,gBAAS,OAAA3L,eAAA,UAAmC,GAAA0L,gBAA5C;QADUE,QADhC,GAAAD,gBAAA;;;QAvB+B,IAAAxC,KAAA,G;;;QA+BtB;;;;;;;;;;;;;;;;;gBAEX,UAAK,GAAA3J,cAA6C,EAAAqM,SAAA;;EAE9C,SAAArM,cACGA,CAAA;IACU,IAAAsM,OAAA;IAHR,IAAP7L,gBAAA,mBAAAT,cAAA;;;;IAOQsM,OAAA,GAAAC,QAAA,CAAA3I,IAAA,CAAA/B,KAAA,CAAA0K,QAAA,SAAA/H,MAAA,CAAAJ,IAAA;IAAD,IAAP9B,gBAAA,iBAAA3B,uBAAA,aAAA2L,OAAA;IACD,OAAAA,OAAA;;EAXiC,IAAA5L,aAAA,C;;;MAc9B,IAAA8L,OAAA,OAAkB;MAElB;;;;;;;;;;;;;;;;;;;gBAGJ,UAAK,GAAAC,mBAAmB,EAAAC,SAAA;EAId,IAAAC,QAAA,GAAAjK,YAAA,CAAA+J,mBACK;EAOd,SAAAA,oBAAA;;wBACD,CAAK,kBAALA,mBAAwB;IAEtB,SAAAG,MAAA,GAAA3K,SAAA,CAAAC,MAAA,EAAAkC,IAAA,OAAAC,KAAA,CAAAuI,MAAA,GAAAC,MAAA,MAAAA,MAAA,GAAAD,MAAA,EAAAC,MAAA;MACAzI,IAAA,CAAAyI,MAAO,CAAK,GAAC5K,SAAQ,CAAA4K,MAAK;IAGlB;IAAAC,OAAA,GAAAH,QAAA,CAAA/I,IAAA,CAAA/B,KAAA,CAAA8K,QAAA,SAAAnI,MAAA,CAAAJ,IAAA;IAAA,IADU9B,gBAFlB,iBAAA3B,uBAAA,aAAAmM,OAAA;IAgBD,OAAAA,OAAA;;EAnC+B,IAAApM,aAAA,C;;IAsC5BiE,KAAA,WAAAC,IAAkBmI,CAAAC,iBAAO;;QAElB,OAAAlL,a;;;;;;;;;;;;;;;;;;;gBAGX,UACE,GAAA/B,mBAKK,EAAAkN,SAAA;EAEL,IAAAC,QAAO,GAAAxK,YAAc,CAAA3C,mBAAd;EAOK,SAAAA,mBAASA,CAAA;IAJb,IAAAoN,OAAA;IAWT,IAAA1M,gBAAA,mBAAAV,mBAAA;;WACDqN,MAAA,IAAAnL,SACE,CAAAmL,MAAA;IAGA;IACAD,OAAM,GAAAD,QAAA,CAAAtJ,IAAiB,CAAA/B,KAAA,CAAAqL,QAAA,EAAvB,OAAA1I,MAAA,CAAAJ,IAAA;IACA,IAAA9B,gBAAY,WAAZ,EAA+B,IAAA3B,uBAAQ,CAAU,SAAI,GAAAwM,OAAA;IACnD,OAAAA,OAAI;EACF;EACA,IAAAzM,aAAK,aAAAX,mBAAmB;IACtBsC,GAAA;IACDsC,KAAA,WAAAC,KAAAoI,iBAAA;;MACD,OAAA3I,KAAO,CAAA4E,OAAK,MAAAZ,UAAc,CAA1B,GAAkC,IAAA/F,gBAAO,sBAAAD,GAAA,OAAAgG,UAAA,CAAAgF,MAAA,WAAAxD,IAAA,EAAAxH,GAAA;QACvC,OAAAP,aAAA,CAAAA,aAAA,KAAA+H,IAAA,WAAAvH,gBAAA,iBAAAD,GAAA,EAAAP,aAAA,CAAAA,aAAA,KAAAkL,iBAAA,CAAA3K,GAAA,EAAA+D,MAAA;UACAkH,OAAA,EAAAN,iBAAoB,CAAA3K,GAAA,EAAAiL;QAClB;MACE;IACE;EACA;IAFKjL,GAAA;IAIRsC,KAAA,WAAAG,KAAAkI,iBAAA;;MAEF,IAAAO,cARD,GAAAP,iBAAA;MASD3L,MAXD,CAAAD,IAAA,CAAA4L,iBAAA,EAAA5K,OAAA,WAAAoL,UAAA;QAYD,IAAAA,UAAA;;UAlBH,SAAAC,MAAA,CAAAC,kBAAA,EAAAC,YAAA;YAqBA,WAAArL,gBAAA,WAAS,MAAKsL,OAA6B,CAAAvL,GAAA,EAAAkL,cAA3C;UACD;;YAtDsC;;;gBAyD5B,OAAgB;kBAAAM,IAAA,EAAAC,SAAA;kBAAAC,MAAA;gBAAA;cAAA;cAMjB,OAAAD,SAAA;YANL;;;;;;;;;;;;;;EAWHD,IAAA;EAGDhG,IAAA;;;;AAGCzI,OAAA,CAAAU,aAAA,GAAAA,aAAA;;;;;IAIS,IAAAW,gB;;;;;;;;;;;aACX,IAAA6B,gBAAA,UAAqB,GAArB,SAAyCD,GAAA,EAAAwC,KAAA;IAAA;EAAA;EAAA,OAAAhF,oBAAA;;AAErCT,OAAA,CAAAS,oBAAA,GAAAA,oBAAA;AAKA,IAAAD,eAAA,0BAAAoO,SAAA;EAID,IAAAC,UAAA,aAAArO,eAAA,EAAAoO,SAAA;EACD,IAAAE,QAAO,GAAPxL,YAAA,CAAA9C,eAAA;;;WAGFsO,QAAA,CAAArM,KAAK,OAAAI,SAAW;EAAA;EACd,IAAAvB,aAAA,aAAAd,eAAA;IAEAyC,GAAA,wBAAmB;IACjBsC,KAAA,WAAOwJ,qBAAAtE,IAAA,EAAAuE,MAAA;MAAC,IAAAC,MAAA,GAAS,EAAE,EAAA7N,eAAA,aAAA4N,MAAA;QAAnB/L,GAAA,GAAAgM,MAAA;QACD1J,KAAA,GAAA0J,MAAA;MAED,WAAO1J,KAAA;QACL,OAAA7C,aAAoB,CAACA,aAAI,KAAA+H,IAAQ,WAAAvH,gBAAA,iBAAAD,GAAA,EAAAsC,KAAA;MAAA,WAAAA,KAAA,QAAAtE,QAAA,WAC5B,EAAAsE,KAAA,CAD4B,iBAAAA,KAAA,CAAA2J,WAAA;QAE/B,OAAAxM,aAAe,CAAAA,aAAQ,CAAQ,CAAC,GAAA+H,IAAT,GAAmB,EAAlC,EAAsC,IAAAvH,gBAAY,eAAlD,EAAwED,GAAxE,EAAAoB,OAAA,CAAAkB,KAAA,CAAAsD,SAAA;MAFuB;MAD5B,OAAP4B,IAAA;IAMD;;;IA7BkClF,KAAA,W;;;;MAgCxB,KAAAN,KAAA,CAAa4E,OAAA,CAAAsF,SAAA,MAAAA,SAAA,CAAArM,MACrB;QACH,OAAU;UACVqM,SAAiB;QACZ,CAAE;MACL;MAEA;QACEA,SADU,EAAAA,SAAA,CAAAxF,GAAA,WAAAyF,QAAA;UAEN,OAAE1M,aAAA,CAAAA,aAAA,KAAA0M,QAAA;YAFIxC,MAAA,EAAA3K,MAAA,CAAAoN,OAAA,CAAAD,QAAA,CAAAxC,MAAA,QAAAqB,MAAA,CAAAqB,OAAA,CAAAP,oBAAA;UAPU;QAaxB;MACA;IACA;EAfK;;;AAmBL/O,OAAA,CAAAQ,eAAa,GAAAA,eAAe;AAE1B,IAAAD,aAAY,GAAAmC,aAAA,CAAAA,aAAA,KAAAhC,aAAA;EAFc6O,QADF;EAK1BC,eAAY;EACVC,KAAA,MAAShP,oBAAS,CADM;IAExB2L,OAAA,EAAA5K,SAAY,CAAA6D,QAAA,CAAAgH,EAAA;IAPYpJ,GAAA;IAS1BgG,UAAA;MACEwF,IAAA,EAAO,IAAE;MACThG,IAAA;IAXwB;EAa1B;EAbK;;EAgBAiH,KAAM;AACX;AAEE1P,OAAA,CAAAO,aAAY,GAAAA,aAAA;AAFc,IADFD,YAAA;EAK1BqP,OAAM,EAAE,IAAI/O,cAAc;IACxBwL,OAAO,EAAE5K,SAAA,CAAA6D,QAAA,CAASC,EADM;IAExB2D,UAAU,EAAEvI;EAFY,CAAlB,CALkB;EAS1BkM,MAAA,MAAA/L,aAAuB;IACrBuL,OAAO,EAAE5K,SAAA,CAAA6D,QAAA,CAASC,EADuB;IAEzC2D,UAAU,EAAElI;EAF6B,CAAxB,CATO;EAa1B6M,iBAAe,EAbW,IAAAP,mBAAA;IAc1BjB,OAAS,EAAE5K,SAAI,CAAA6D,QAAA,CAAJC,EAAoB;IAC7B2D,UAAK,EAAA2G;EACL;EAF6BC,aAdL;AAkB1B;AACE7P,OAAA,CAAAM,YAAS,GAAAA,YADiB;AAE1B,IAAAD,YAAY;EACVsP,OAAA,MAAA/O,cADU;IAEVwL,OAAK,EAAE5K,SAAA,CAAA6D,QAAA,CAAAgH,EAAA;IAFGpD,UAFc,EAAA1I;EAM1B;EAN0BqM,MAAX,MAAA/L,aAAA;IAlBZuL,OAAA,EAAA5K,SAAA,CAAA6D,QAAA,CAAAgH,EAAA;;;mBA4BM,E;;;;;;;;;;;;iBACX;MAAwFqD,KAAnE;IAAmE;IACtFzM,GAAA;EACA;AACD;;oBAED,gBAIE,UAAA6M,SAAA;EACA,IAAAjB,UAAA,aAAAzO,gBAAA,EAAA0P,SAAA;EAED,IAAAC,QAAA,GAAAzM,YAAA,CAAAlD,gBAAA;;IAbmC,IAAAiB,gB;;;EAiBpC,IAAAC,aAAS,WAAS,EADuBlB,gBAAA;IAEzC6C,GAAA,QAAY;IACZsC,KAAK,WAAAC,KAAAwK,IAAA;MAHA,IAAAxI,OAAA,GAAA3E,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAoN,SAAA,GAAApN,SAAA;;MAMM;MACX,OAAS,KAAAqN,2BAD0C,CAAAF,IAAA,EAAAxI,OAAA,EAAAC,WAAA;IAEnD;EACA,GAAG;IAHExE,GAAA;;MAMM;MAML,OAAE,KAAAkN,2BAAM,CAAAH,IAAA;IAAA;EAAA,CADC;EAEb,OAAM5P,gBAAA;AAAM,EAAAsB,OAAA;AAAA1B,OAAA,CAAAI,gBAAI,GAAgBA,gBAAhB;AAAJ,IAAAD,gBAAA,OAAAuB,OAAA;EAJf0K,OAAA,EAAA5K,SAAA,CAAA6D,QAAA,CAAAC,EAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}