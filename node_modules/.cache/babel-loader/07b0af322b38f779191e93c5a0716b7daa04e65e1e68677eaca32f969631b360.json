{"ast":null,"code":"import _objectWithoutProperties from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"instancePickingColors\"];\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CompositeLayer } from '@deck.gl/core';\nimport { replaceInRange } from '../utils';\nimport { binaryToFeatureForAccesor } from './geojson-binary';\nimport { POINT_LAYER, LINE_LAYER, POLYGON_LAYER, getDefaultProps, forwardProps } from './sub-layer-map';\nimport { getGeojsonFeatures, separateGeojsonFeatures } from './geojson';\nimport { createLayerPropsFromFeatures, createLayerPropsFromBinary } from './geojson-layer-props';\nvar FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\nvar defaultProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, getDefaultProps(POINT_LAYER.circle)), getDefaultProps(POINT_LAYER.icon)), getDefaultProps(POINT_LAYER.text)), getDefaultProps(LINE_LAYER)), getDefaultProps(POLYGON_LAYER)), {}, {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  iconAtlas: {\n    type: 'object',\n    value: null\n  },\n  iconMapping: {\n    type: 'object',\n    value: {}\n  },\n  getIcon: {\n    type: 'accessor',\n    value: function value(f) {\n      return f.properties.icon;\n    }\n  },\n  getText: {\n    type: 'accessor',\n    value: function value(f) {\n      return f.properties.text;\n    }\n  },\n  pointType: 'circle',\n  getRadius: {\n    deprecatedFor: 'getPointRadius'\n  }\n});\nvar GeoJsonLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(GeoJsonLayer, _CompositeLayer);\n  var _super = _createSuper(GeoJsonLayer);\n  function GeoJsonLayer() {\n    _classCallCheck(this, GeoJsonLayer);\n    return _super.apply(this, arguments);\n  }\n  _createClass(GeoJsonLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        layerProps: {},\n        features: {}\n      };\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n        changeFlags = _ref.changeFlags;\n      if (!changeFlags.dataChanged) {\n        return;\n      }\n      var data = this.props.data;\n      var binary = data && 'points' in data && 'polygons' in data && 'lines' in data;\n      this.setState({\n        binary: binary\n      });\n      if (binary) {\n        this._updateStateBinary({\n          props: props,\n          changeFlags: changeFlags\n        });\n      } else {\n        this._updateStateJSON({\n          props: props,\n          changeFlags: changeFlags\n        });\n      }\n    }\n  }, {\n    key: \"_updateStateBinary\",\n    value: function _updateStateBinary(_ref2) {\n      var props = _ref2.props,\n        changeFlags = _ref2.changeFlags;\n      var layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n      this.setState({\n        layerProps: layerProps\n      });\n    }\n  }, {\n    key: \"_updateStateJSON\",\n    value: function _updateStateJSON(_ref3) {\n      var props = _ref3.props,\n        changeFlags = _ref3.changeFlags;\n      var features = getGeojsonFeatures(props.data);\n      var wrapFeature = this.getSubLayerRow.bind(this);\n      var newFeatures = {};\n      var featuresDiff = {};\n      if (Array.isArray(changeFlags.dataChanged)) {\n        var oldFeatures = this.state.features;\n        for (var key in oldFeatures) {\n          newFeatures[key] = oldFeatures[key].slice();\n          featuresDiff[key] = [];\n        }\n        var _iterator = _createForOfIteratorHelper(changeFlags.dataChanged),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var dataRange = _step.value;\n            var partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n            for (var _key in oldFeatures) {\n              featuresDiff[_key].push(replaceInRange({\n                data: newFeatures[_key],\n                getIndex: function getIndex(f) {\n                  return f.__source.index;\n                },\n                dataRange: dataRange,\n                replace: partialFeatures[_key]\n              }));\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        newFeatures = separateGeojsonFeatures(features, wrapFeature);\n      }\n      var layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n      this.setState({\n        features: newFeatures,\n        featuresDiff: featuresDiff,\n        layerProps: layerProps\n      });\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(params) {\n      var _this = this;\n      var info = _get(_getPrototypeOf(GeoJsonLayer.prototype), \"getPickingInfo\", this).call(this, params);\n      var index = info.index,\n        sourceLayer = info.sourceLayer;\n      info.featureType = FEATURE_TYPES.find(function (ft) {\n        return sourceLayer.id.startsWith(\"\".concat(_this.id, \"-\").concat(ft, \"-\"));\n      });\n      if (index >= 0 && sourceLayer.id.startsWith(\"\".concat(this.id, \"-points-text\")) && this.state.binary) {\n        info.index = this.props.data.points.globalFeatureIds.value[index];\n      }\n      return info;\n    }\n  }, {\n    key: \"_updateAutoHighlight\",\n    value: function _updateAutoHighlight(info) {\n      var pointLayerIdPrefix = \"\".concat(this.id, \"-points-\");\n      var sourceIsPoints = info.featureType === 'points';\n      var _iterator2 = _createForOfIteratorHelper(this.getSubLayers()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var layer = _step2.value;\n          if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n            layer.updateAutoHighlight(info);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"_renderPolygonLayer\",\n    value: function _renderPolygonLayer() {\n      var _this$props = this.props,\n        extruded = _this$props.extruded,\n        wireframe = _this$props.wireframe;\n      var layerProps = this.state.layerProps;\n      var id = 'polygons-fill';\n      var PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);\n      if (PolygonFillLayer) {\n        var forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n        var useLineColor = extruded && wireframe;\n        if (!useLineColor) {\n          delete forwardedProps.getLineColor;\n        }\n        forwardedProps.updateTriggers.lineColors = useLineColor;\n        return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({\n          id: id,\n          updateTriggers: forwardedProps.updateTriggers\n        }), layerProps.polygons);\n      }\n      return null;\n    }\n  }, {\n    key: \"_renderLineLayers\",\n    value: function _renderLineLayers() {\n      var _this$props2 = this.props,\n        extruded = _this$props2.extruded,\n        stroked = _this$props2.stroked;\n      var layerProps = this.state.layerProps;\n      var polygonStrokeLayerId = 'polygons-stroke';\n      var lineStringsLayerId = 'linestrings';\n      var PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n      var LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n      if (PolygonStrokeLayer || LineStringsLayer) {\n        var forwardedProps = forwardProps(this, LINE_LAYER.props);\n        return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({\n          id: polygonStrokeLayerId,\n          updateTriggers: forwardedProps.updateTriggers\n        }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({\n          id: lineStringsLayerId,\n          updateTriggers: forwardedProps.updateTriggers\n        }), layerProps.lines)];\n      }\n      return null;\n    }\n  }, {\n    key: \"_renderPointLayers\",\n    value: function _renderPointLayers() {\n      var pointType = this.props.pointType;\n      var _this$state = this.state,\n        layerProps = _this$state.layerProps,\n        binary = _this$state.binary;\n      var highlightedObjectIndex = this.props.highlightedObjectIndex;\n      if (!binary && Number.isFinite(highlightedObjectIndex)) {\n        highlightedObjectIndex = layerProps.points.data.findIndex(function (d) {\n          return d.__source.index === highlightedObjectIndex;\n        });\n      }\n      var types = new Set(pointType.split('+'));\n      var pointLayers = [];\n      var _iterator3 = _createForOfIteratorHelper(types),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var type = _step3.value;\n          var id = \"points-\".concat(type);\n          var PointLayerMapping = POINT_LAYER[type];\n          var PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points.data) && this.getSubLayerClass(id, PointLayerMapping.type);\n          if (PointsLayer) {\n            var forwardedProps = forwardProps(this, PointLayerMapping.props);\n            var pointsLayerProps = layerProps.points;\n            if (type === 'text' && binary) {\n              var _pointsLayerProps$dat = pointsLayerProps.data.attributes,\n                instancePickingColors = _pointsLayerProps$dat.instancePickingColors,\n                rest = _objectWithoutProperties(_pointsLayerProps$dat, _excluded);\n              pointsLayerProps = _objectSpread(_objectSpread({}, pointsLayerProps), {}, {\n                data: _objectSpread(_objectSpread({}, pointsLayerProps.data), {}, {\n                  attributes: rest\n                })\n              });\n            }\n            pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({\n              id: id,\n              updateTriggers: forwardedProps.updateTriggers,\n              highlightedObjectIndex: highlightedObjectIndex\n            }), pointsLayerProps));\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return pointLayers;\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var extruded = this.props.extruded;\n      var polygonFillLayer = this._renderPolygonLayer();\n      var lineLayers = this._renderLineLayers();\n      var pointLayers = this._renderPointLayers();\n      return [!extruded && polygonFillLayer, lineLayers, pointLayers, extruded && polygonFillLayer];\n    }\n  }, {\n    key: \"getSubLayerAccessor\",\n    value: function getSubLayerAccessor(accessor) {\n      var binary = this.state.binary;\n      if (!binary || typeof accessor !== 'function') {\n        return _get(_getPrototypeOf(GeoJsonLayer.prototype), \"getSubLayerAccessor\", this).call(this, accessor);\n      }\n      return function (object, info) {\n        var data = info.data,\n          index = info.index;\n        var feature = binaryToFeatureForAccesor(data, index);\n        return accessor(feature, info);\n      };\n    }\n  }]);\n  return GeoJsonLayer;\n}(CompositeLayer);\nexport { GeoJsonLayer as default };\n_defineProperty(GeoJsonLayer, \"layerName\", 'GeoJsonLayer');\n_defineProperty(GeoJsonLayer, \"defaultProps\", defaultProps);","map":{"version":3,"names":["CompositeLayer","replaceInRange","binaryToFeatureForAccesor","POINT_LAYER","LINE_LAYER","POLYGON_LAYER","getDefaultProps","forwardProps","getGeojsonFeatures","separateGeojsonFeatures","createLayerPropsFromFeatures","createLayerPropsFromBinary","FEATURE_TYPES","defaultProps","_objectSpread","circle","icon","text","stroked","filled","extruded","wireframe","iconAtlas","type","value","iconMapping","getIcon","f","properties","getText","pointType","getRadius","deprecatedFor","GeoJsonLayer","_CompositeLayer","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","initializeState","state","layerProps","features","updateState","_ref","props","changeFlags","dataChanged","data","binary","setState","_updateStateBinary","_updateStateJSON","_ref2","encodePickingColor","_ref3","wrapFeature","getSubLayerRow","bind","newFeatures","featuresDiff","Array","isArray","oldFeatures","slice","_iterator","_createForOfIteratorHelper","_step","s","n","done","dataRange","partialFeatures","push","getIndex","__source","index","replace","err","e","getPickingInfo","params","_this","info","_get","_getPrototypeOf","prototype","call","sourceLayer","featureType","find","ft","id","startsWith","concat","points","globalFeatureIds","_updateAutoHighlight","pointLayerIdPrefix","sourceIsPoints","_iterator2","getSubLayers","_step2","layer","updateAutoHighlight","_renderPolygonLayer","_this$props","PolygonFillLayer","shouldRenderSubLayer","polygons","getSubLayerClass","forwardedProps","useLineColor","getLineColor","updateTriggers","lineColors","getSubLayerProps","_renderLineLayers","_this$props2","polygonStrokeLayerId","lineStringsLayerId","PolygonStrokeLayer","polygonsOutline","LineStringsLayer","lines","_renderPointLayers","_this$state","highlightedObjectIndex","Number","isFinite","findIndex","d","types","Set","split","pointLayers","_iterator3","_step3","PointLayerMapping","PointsLayer","pointsLayerProps","_pointsLayerProps$dat","attributes","instancePickingColors","rest","_objectWithoutProperties","_excluded","renderLayers","polygonFillLayer","lineLayers","getSubLayerAccessor","accessor","object","feature","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/layers/src/geojson-layer/geojson-layer.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Accessor,\n  Color,\n  CompositeLayer,\n  CompositeLayerProps,\n  Layer,\n  PickingInfo,\n  Unit,\n  Material,\n  UpdateParameters,\n  _ConstructorOf,\n  DefaultProps\n} from '@deck.gl/core';\n\nimport type {BinaryFeatures} from '@loaders.gl/schema';\nimport type {Feature} from 'geojson';\n\nimport {replaceInRange} from '../utils';\nimport {BinaryFeatureTypes, binaryToFeatureForAccesor} from './geojson-binary';\nimport {\n  POINT_LAYER,\n  LINE_LAYER,\n  POLYGON_LAYER,\n  getDefaultProps,\n  forwardProps\n} from './sub-layer-map';\n\nimport {getGeojsonFeatures, SeparatedGeometries, separateGeojsonFeatures} from './geojson';\nimport {createLayerPropsFromFeatures, createLayerPropsFromBinary} from './geojson-layer-props';\n\n/** All properties supported by GeoJsonLayer */\nexport type GeoJsonLayerProps<DataT extends Feature = Feature> = _GeoJsonLayerProps<DataT> &\n  CompositeLayerProps<DataT>;\n\n/** Properties added by GeoJsonLayer */\nexport type _GeoJsonLayerProps<DataT extends Feature = Feature> = {\n  /**\n   * How to render Point and MultiPoint features in the data.\n   *\n   * Supported types are:\n   *  * `'circle'`\n   *  * `'icon'`\n   *  * `'text'`\n   *\n   * @default 'circle'\n   */\n  pointType?: string;\n} & _GeoJsonLayerFillProps<DataT> &\n  _GeoJsonLayerStrokeProps<DataT> &\n  _GeoJsonLayer3DProps<DataT> &\n  _GeoJsonLayerPointCircleProps<DataT> &\n  _GeojsonLayerIconPointProps<DataT> &\n  _GeojsonLayerTextPointProps<DataT>;\n\n/** GeoJsonLayer fill options. */\ntype _GeoJsonLayerFillProps<DataT> = {\n  /**\n   * Whether to draw a filled polygon (solid fill).\n   *\n   * Note that only the area between the outer polygon and any holes will be filled.\n   *\n   * @default true\n   */\n  filled?: boolean;\n\n  /**\n   * Fill collor value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getFillColor?: Accessor<DataT, Color>;\n};\n\n/** GeoJsonLayer stroke options. */\ntype _GeoJsonLayerStrokeProps<DataT> = {\n  /**\n   * Whether to draw an outline around the polygon (solid fill).\n   *\n   * Note that both the outer polygon as well the outlines of any holes will be drawn.\n   *\n   * @default true\n   */\n  stroked?: boolean;\n\n  /**\n   * Line color value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getLineColor?: Accessor<DataT, Color>;\n\n  /**\n   * Line width value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getLineWidth?: Accessor<DataT, number>;\n\n  /**\n   * The units of the line width, one of `meters`, `common`, and `pixels`.\n   *\n   * @default 'meters'\n   * @see Unit.\n   */\n  lineWidthUnits?: Unit;\n\n  /**\n   * A multiplier that is applied to all line widths\n   *\n   * @default 1\n   */\n  lineWidthScale?: number;\n\n  /**\n   * The minimum line width in pixels.\n   *\n   * @default 0\n   */\n  lineWidthMinPixels?: number;\n\n  /**\n   * The maximum line width in pixels\n   *\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  lineWidthMaxPixels?: number;\n\n  /**\n   * Type of joint. If `true`, draw round joints. Otherwise draw miter joints.\n   *\n   * @default false\n   */\n  lineJointRounded?: boolean;\n\n  /**\n   * The maximum extent of a joint in ratio to the stroke width.\n   *\n   * Only works if `lineJointRounded` is false.\n   *\n   * @default 4\n   */\n  lineMiterLimit?: number;\n\n  /**\n   * Type of line caps.\n   *\n   * If `true`, draw round caps. Otherwise draw square caps.\n   *\n   * @default false\n   */\n  lineCapRounded?: boolean;\n\n  /**\n   * If `true`, extrude the line in screen space (width always faces the camera).\n   * If `false`, the width always faces up.\n   *\n   * @default false\n   */\n  lineBillboard?: boolean;\n};\n\n/** GeoJsonLayer 3D options. */\ntype _GeoJsonLayer3DProps<DataT> = {\n  /**\n   * Extrude Polygon and MultiPolygon features along the z-axis if set to true\n   *\n   * Based on the elevations provided by the `getElevation` accessor.\n   *\n   * @default false\n   */\n  extruded?: boolean;\n\n  /**\n   * Whether to generate a line wireframe of the hexagon.\n   *\n   * @default false\n   */\n  wireframe?: boolean;\n\n  /**\n   * Elevation valur or accessor.\n   *\n   * Only used if `extruded: true`.\n   *\n   * @default 1000\n   */\n  getElevation?: Accessor<DataT, number>;\n\n  /**\n   * Elevation multiplier.\n   *\n   * The final elevation is calculated by `elevationScale * getElevation(d)`.\n   * `elevationScale` is a handy property to scale all elevation without updating the data.\n   *\n   * @default 1\n   */\n  elevationScale?: boolean;\n\n  /**\n   * Material settings for lighting effect. Applies to extruded polgons.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n};\n\n/** GeoJsonLayer Properties forwarded to `ScatterPlotLayer` if `pointType` is `'circle'` */\nexport type _GeoJsonLayerPointCircleProps<DataT> = {\n  getPointRadius?: Accessor<DataT, number>;\n  pointRadiusUnits?: Unit;\n  pointRadiusScale?: number;\n  pointRadiusMinPixels?: number;\n  pointRadiusMaxPixels?: number;\n  pointAntialiasing?: boolean;\n  pointBillboard?: boolean;\n\n  /** @deprecated use getPointRadius */\n  getRadius?: Accessor<DataT, number>;\n};\n\n/** GeoJsonLayer properties forwarded to `IconLayer` if `pointType` is `'icon'` */\ntype _GeojsonLayerIconPointProps<DataT> = {\n  iconAtlas?: any;\n  iconMapping?: any;\n  getIcon?: Accessor<DataT, any>;\n  getIconSize?: Accessor<DataT, number>;\n  getIconColor?: Accessor<DataT, Color>;\n  getIconAngle?: Accessor<DataT, number>;\n  getIconPixelOffset?: Accessor<DataT, number[]>;\n  iconSizeUnits?: Unit;\n  iconSizeScale?: number;\n  iconSizeMinPixels?: number;\n  iconSizeMaxPixels?: number;\n  iconBillboard?: boolean;\n  iconAlphaCutoff?: number;\n};\n\n/** GeoJsonLayer properties forwarded to `TextLayer` if `pointType` is `'text'` */\ntype _GeojsonLayerTextPointProps<DataT> = {\n  getText?: Accessor<DataT, any>;\n  getTextColor?: Accessor<DataT, Color>;\n  getTextAngle?: Accessor<DataT, number>;\n  getTextSize?: Accessor<DataT, number>;\n  getTextAnchor?: Accessor<DataT, string>;\n  getTextAlignmentBaseline?: Accessor<DataT, string>;\n  getTextPixelOffset?: Accessor<DataT, number[]>;\n  getTextBackgroundColor?: Accessor<DataT, Color>;\n  getTextBorderColor?: Accessor<DataT, Color>;\n  getTextBorderWidth?: Accessor<DataT, number>;\n  textSizeUnits?: Unit;\n  textSizeScale?: number;\n  textSizeMinPixels?: number;\n  textSizeMaxPixels?: number;\n  textCharacterSet?: any;\n  textFontFamily?: string;\n  textFontWeight?: number;\n  textLineHeight?: number;\n  textMaxWidth?: number;\n  textWordBreak?: string; // TODO\n  textBackground?: boolean;\n  textBackgroundPadding?: number[];\n  textOutlineColor?: Color;\n  textOutlineWidth?: number;\n  textBillboard?: boolean;\n  textFontSettings?: any;\n};\n\nconst FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\n\nconst defaultProps: DefaultProps<GeoJsonLayerProps> = {\n  ...getDefaultProps(POINT_LAYER.circle),\n  ...getDefaultProps(POINT_LAYER.icon),\n  ...getDefaultProps(POINT_LAYER.text),\n  ...getDefaultProps(LINE_LAYER),\n  ...getDefaultProps(POLYGON_LAYER),\n\n  // Overwrite sub layer defaults\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  iconAtlas: {type: 'object', value: null},\n  iconMapping: {type: 'object', value: {}},\n  getIcon: {type: 'accessor', value: f => f.properties.icon},\n  getText: {type: 'accessor', value: f => f.properties.text},\n\n  // Self props\n  pointType: 'circle',\n\n  // TODO: deprecated, remove in v9\n  getRadius: {deprecatedFor: 'getPointRadius'}\n};\n\ntype GeoJsonPickingInfo = PickingInfo & {\n  featureType?: string | null;\n  info?: any;\n};\n\n/** Render GeoJSON formatted data as polygons, lines and points (circles, icons and/or texts). */\nexport default class GeoJsonLayer<\n  DataT extends Feature = Feature,\n  ExtraProps = {}\n> extends CompositeLayer<Required<GeoJsonLayerProps<DataT>> & ExtraProps> {\n  static layerName = 'GeoJsonLayer';\n  static defaultProps = defaultProps;\n\n  initializeState(): void {\n    this.state = {\n      layerProps: {},\n      features: {}\n    };\n  }\n\n  updateState({props, changeFlags}: UpdateParameters<this>): void {\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n    const {data} = this.props;\n    const binary =\n      data && 'points' in (data as {}) && 'polygons' in (data as {}) && 'lines' in (data as {});\n\n    this.setState({binary});\n\n    if (binary) {\n      this._updateStateBinary({props, changeFlags});\n    } else {\n      this._updateStateJSON({props, changeFlags});\n    }\n  }\n\n  private _updateStateBinary({props, changeFlags}): void {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n    this.setState({layerProps});\n  }\n\n  private _updateStateJSON({props, changeFlags}): void {\n    const features: Feature[] = getGeojsonFeatures(props.data) as any;\n    const wrapFeature = this.getSubLayerRow.bind(this);\n    let newFeatures: SeparatedGeometries = {} as SeparatedGeometries;\n    const featuresDiff = {};\n\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n        for (const key in oldFeatures) {\n          featuresDiff[key].push(\n            replaceInRange({\n              data: newFeatures[key],\n              getIndex: f => f.__source.index,\n              dataRange,\n              replace: partialFeatures[key]\n            })\n          );\n        }\n      }\n    } else {\n      newFeatures = separateGeojsonFeatures(features, wrapFeature);\n    }\n\n    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n\n    this.setState({\n      features: newFeatures,\n      featuresDiff,\n      layerProps\n    });\n  }\n\n  getPickingInfo(params): GeoJsonPickingInfo {\n    const info = super.getPickingInfo(params) as GeoJsonPickingInfo;\n    const {index, sourceLayer} = info;\n    info.featureType = FEATURE_TYPES.find(ft => sourceLayer!.id.startsWith(`${this.id}-${ft}-`));\n    if (index >= 0 && sourceLayer!.id.startsWith(`${this.id}-points-text`) && this.state.binary) {\n      info.index = (this.props.data as BinaryFeatures).points!.globalFeatureIds.value[index];\n    }\n    return info;\n  }\n\n  _updateAutoHighlight(info: GeoJsonPickingInfo): void {\n    // All sub layers except the points layer use source feature index to encode the picking color\n    // The points layer uses indices from the points data array.\n    const pointLayerIdPrefix = `${this.id}-points-`;\n    const sourceIsPoints = info.featureType === 'points';\n    for (const layer of this.getSubLayers()) {\n      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n\n  private _renderPolygonLayer(): Layer | null {\n    const {extruded, wireframe} = this.props;\n    const {layerProps} = this.state;\n    const id = 'polygons-fill';\n\n    const PolygonFillLayer =\n      this.shouldRenderSubLayer(id, layerProps.polygons.data) &&\n      this.getSubLayerClass(id, POLYGON_LAYER.type);\n\n    if (PolygonFillLayer) {\n      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n      // Avoid building the lineColors attribute if wireframe is off\n      const useLineColor = extruded && wireframe;\n      if (!useLineColor) {\n        delete forwardedProps.getLineColor;\n      }\n      // using a legacy API to invalid lineColor attributes\n      forwardedProps.updateTriggers.lineColors = useLineColor;\n\n      return new PolygonFillLayer(\n        forwardedProps,\n        this.getSubLayerProps({\n          id,\n          updateTriggers: forwardedProps.updateTriggers\n        }),\n        layerProps.polygons\n      );\n    }\n    return null;\n  }\n\n  private _renderLineLayers(): (Layer | false)[] | null {\n    const {extruded, stroked} = this.props;\n    const {layerProps} = this.state;\n    const polygonStrokeLayerId = 'polygons-stroke';\n    const lineStringsLayerId = 'linestrings';\n\n    const PolygonStrokeLayer =\n      !extruded &&\n      stroked &&\n      this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) &&\n      this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n    const LineStringsLayer =\n      this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) &&\n      this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n\n    if (PolygonStrokeLayer || LineStringsLayer) {\n      const forwardedProps = forwardProps(this, LINE_LAYER.props);\n\n      return [\n        PolygonStrokeLayer &&\n          new PolygonStrokeLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: polygonStrokeLayerId,\n              updateTriggers: forwardedProps.updateTriggers\n            }),\n            layerProps.polygonsOutline\n          ),\n\n        LineStringsLayer &&\n          new LineStringsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: lineStringsLayerId,\n              updateTriggers: forwardedProps.updateTriggers\n            }),\n            layerProps.lines\n          )\n      ];\n    }\n    return null;\n  }\n\n  private _renderPointLayers(): Layer[] | null {\n    const {pointType} = this.props;\n    const {layerProps, binary} = this.state;\n    let {highlightedObjectIndex} = this.props;\n\n    if (!binary && Number.isFinite(highlightedObjectIndex)) {\n      highlightedObjectIndex = layerProps.points.data.findIndex(\n        d => d.__source.index === highlightedObjectIndex\n      );\n    }\n\n    // Avoid duplicate sub layer ids\n    const types = new Set(pointType.split('+'));\n    const pointLayers: Layer[] = [];\n    for (const type of types) {\n      const id = `points-${type}`;\n      const PointLayerMapping = POINT_LAYER[type];\n      const PointsLayer: _ConstructorOf<Layer> =\n        PointLayerMapping &&\n        this.shouldRenderSubLayer(id, layerProps.points.data) &&\n        this.getSubLayerClass(id, PointLayerMapping.type);\n      if (PointsLayer) {\n        const forwardedProps = forwardProps(this, PointLayerMapping.props);\n        let pointsLayerProps = layerProps.points;\n\n        if (type === 'text' && binary) {\n          // Picking colors are per-point but for text per-character are required\n          // getPickingInfo() maps back to the correct index\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const {instancePickingColors, ...rest} = pointsLayerProps.data.attributes;\n          pointsLayerProps = {\n            ...pointsLayerProps,\n            data: {...pointsLayerProps.data, attributes: rest}\n          };\n        }\n\n        pointLayers.push(\n          new PointsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id,\n              updateTriggers: forwardedProps.updateTriggers,\n              highlightedObjectIndex\n            }),\n            pointsLayerProps\n          )\n        );\n      }\n    }\n    return pointLayers;\n  }\n\n  renderLayers() {\n    const {extruded} = this.props;\n\n    const polygonFillLayer = this._renderPolygonLayer();\n    const lineLayers = this._renderLineLayers();\n    const pointLayers = this._renderPointLayers();\n\n    return [\n      // If not extruded: flat fill layer is drawn below outlines\n      !extruded && polygonFillLayer,\n      lineLayers,\n      pointLayers,\n      // If extruded: draw fill layer last for correct blending behavior\n      extruded && polygonFillLayer\n    ];\n  }\n\n  protected getSubLayerAccessor<In, Out>(accessor: Accessor<In, Out>): Accessor<In, Out> {\n    const {binary} = this.state;\n    if (!binary || typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n\n    return (object, info) => {\n      const {data, index} = info;\n      const feature = binaryToFeatureForAccesor(data as unknown as BinaryFeatureTypes, index);\n      // @ts-ignore (TS2349) accessor is always function\n      return accessor(feature, info);\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}