{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.maybeToDate = maybeToDate;\nexports.findPointFieldPairs = findPointFieldPairs;\nexports.sortDatasetByColumn = sortDatasetByColumn;\nexports.pinTableColumns = pinTableColumns;\nexports.copyTable = copyTable;\nexports.copyTableAndUpdate = copyTableAndUpdate;\nexports.getFieldValueAccessor = getFieldValueAccessor;\nexports[\"default\"] = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _console = require(\"global/console\");\nvar _d3Array = require(\"d3-array\");\nvar _constants = require(\"@kepler.gl/constants\");\nvar _gpuFilterUtils = require(\"./gpu-filter-utils\");\nvar _utils = require(\"@kepler.gl/utils\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n// Unique identifier of each field\nvar FID_KEY = 'name';\nfunction maybeToDate(isTime, fieldIdx, format, dc, d) {\n  if (isTime) {\n    return (0, _utils.timeToUnixMilli)(dc.valueAt(d.index, fieldIdx), format);\n  }\n  return dc.valueAt(d.index, fieldIdx);\n}\nvar KeplerTable = /*#__PURE__*/function () {\n  // fields and data\n  // table-injected metadata\n  // table-injected metadata\n  function KeplerTable(_ref) {\n    var info = _ref.info,\n      data = _ref.data,\n      color = _ref.color,\n      metadata = _ref.metadata,\n      _ref$supportedFilterT = _ref.supportedFilterTypes,\n      supportedFilterTypes = _ref$supportedFilterT === void 0 ? null : _ref$supportedFilterT,\n      _ref$disableDataOpera = _ref.disableDataOperation,\n      disableDataOperation = _ref$disableDataOpera === void 0 ? false : _ref$disableDataOpera;\n    (0, _classCallCheck2[\"default\"])(this, KeplerTable);\n    (0, _defineProperty2[\"default\"])(this, \"id\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"type\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"label\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"color\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"fields\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"dataContainer\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"allIndexes\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"filteredIndex\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"filteredIdxCPU\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"filteredIndexForDomain\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"fieldPairs\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"gpuFilter\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"filterRecord\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"filterRecordCPU\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"changedFilters\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"sortColumn\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"sortOrder\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"pinnedColumns\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"supportedFilterTypes\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"disableDataOperation\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"metadata\", void 0);\n    // TODO - what to do if validation fails? Can kepler handle exceptions?\n    // const validatedData = validateInputData(data);\n    // if (!validatedData) {\n    //   return this;\n    // }\n    // @ts-expect-error\n    var dataContainer = (0, _utils.createDataContainer)(data.rows, {\n      fields: data.fields\n    });\n    var datasetInfo = _objectSpread({\n      id: (0, _utils.generateHashId)(4),\n      label: 'new dataset',\n      type: ''\n    }, info);\n    var dataId = datasetInfo.id; // @ts-expect-error\n\n    var fields = data.fields.map(function (f, i) {\n      return _objectSpread(_objectSpread({}, f), {}, {\n        fieldIdx: i,\n        id: f.name,\n        displayName: f.displayName || f.name,\n        valueAccessor: getFieldValueAccessor(f, i, dataContainer)\n      });\n    });\n    var allIndexes = dataContainer.getPlainIndex();\n    var defaultMetadata = {\n      id: datasetInfo.id,\n      // @ts-ignore\n      format: datasetInfo.format || '',\n      label: datasetInfo.label || ''\n    };\n    this.id = datasetInfo.id;\n    this.type = datasetInfo.type;\n    this.label = datasetInfo.label;\n    this.color = color;\n    this.metadata = _objectSpread(_objectSpread({}, defaultMetadata), metadata);\n    this.dataContainer = dataContainer;\n    this.allIndexes = allIndexes;\n    this.filteredIndex = allIndexes;\n    this.filteredIndexForDomain = allIndexes;\n    this.fieldPairs = findPointFieldPairs(fields);\n    this.fields = fields;\n    this.gpuFilter = (0, _gpuFilterUtils.getGpuFilterProps)([], dataId, fields);\n    this.supportedFilterTypes = supportedFilterTypes;\n    this.disableDataOperation = disableDataOperation;\n  }\n  (0, _createClass2[\"default\"])(KeplerTable, [{\n    key: \"length\",\n    get: function get() {\n      return this.dataContainer.numRows();\n    }\n    /**\n     * Get field\n     * @param columnName\n     */\n  }, {\n    key: \"getColumnField\",\n    value: function getColumnField(columnName) {\n      var field = this.fields.find(function (fd) {\n        return fd[FID_KEY] === columnName;\n      });\n      this._assetField(columnName, field);\n      return field;\n    }\n    /**\n     * Get fieldIdx\n     * @param columnName\n     */\n  }, {\n    key: \"getColumnFieldIdx\",\n    value: function getColumnFieldIdx(columnName) {\n      var fieldIdx = this.fields.findIndex(function (fd) {\n        return fd[FID_KEY] === columnName;\n      });\n      this._assetField(columnName, Boolean(fieldIdx > -1));\n      return fieldIdx;\n    }\n    /**\n     * Get the value of a cell\n     */\n  }, {\n    key: \"getValue\",\n    value: function getValue(columnName, rowIdx) {\n      var field = this.getColumnField(columnName);\n      return field ? field.valueAccessor({\n        index: rowIdx\n      }) : null;\n    }\n    /**\n     * Updates existing field with a new object\n     * @param fieldIdx\n     * @param newField\n     */\n  }, {\n    key: \"updateColumnField\",\n    value: function updateColumnField(fieldIdx, newField) {\n      this.fields = Object.assign((0, _toConsumableArray2[\"default\"])(this.fields), (0, _defineProperty2[\"default\"])({}, fieldIdx, newField));\n    }\n    /**\n     * Update dataset color by custom color\n     * @param newColor\n     */\n  }, {\n    key: \"updateTableColor\",\n    value: function updateTableColor(newColor) {\n      this.color = newColor;\n    }\n    /**\n     * Save filterProps to field and retrieve it\n     * @param columnName\n     */\n  }, {\n    key: \"getColumnFilterProps\",\n    value: function getColumnFilterProps(columnName) {\n      var fieldIdx = this.getColumnFieldIdx(columnName);\n      if (fieldIdx < 0) {\n        return null;\n      }\n      var field = this.fields[fieldIdx];\n      if (field.hasOwnProperty('filterProps')) {\n        return field.filterProps;\n      }\n      var fieldDomain = this.getColumnFilterDomain(field);\n      if (!fieldDomain) {\n        return null;\n      }\n      var filterProps = (0, _utils.getFilterProps)(field, fieldDomain);\n      var newField = _objectSpread(_objectSpread({}, field), {}, {\n        filterProps: filterProps\n      });\n      this.updateColumnField(fieldIdx, newField);\n      return filterProps;\n    }\n    /**\n     * Apply filters to dataset, return the filtered dataset with updated `gpuFilter`, `filterRecord`, `filteredIndex`, `filteredIndexForDomain`\n     * @param filters\n     * @param layers\n     * @param opt\n     */\n  }, {\n    key: \"filterTable\",\n    value: function filterTable(filters, layers, opt) {\n      var _this = this;\n      var dataContainer = this.dataContainer,\n        dataId = this.id,\n        oldFilterRecord = this.filterRecord,\n        fields = this.fields; // if there is no filters\n\n      var filterRecord = (0, _utils.getFilterRecord)(dataId, filters, opt || {});\n      this.filterRecord = filterRecord;\n      this.gpuFilter = (0, _gpuFilterUtils.getGpuFilterProps)(filters, dataId, fields); // const newDataset = set(['filterRecord'], filterRecord, dataset);\n\n      if (!filters.length) {\n        this.filteredIndex = this.allIndexes;\n        this.filteredIndexForDomain = this.allIndexes;\n        return this;\n      }\n      this.changedFilters = (0, _utils.diffFilters)(filterRecord, oldFilterRecord); // generate 2 sets of filter result\n      // filteredIndex used to calculate layer data\n      // filteredIndexForDomain used to calculate layer Domain\n\n      var shouldCalDomain = Boolean(this.changedFilters.dynamicDomain);\n      var shouldCalIndex = Boolean(this.changedFilters.cpu);\n      var filterResult = {};\n      if (shouldCalDomain || shouldCalIndex) {\n        var dynamicDomainFilters = shouldCalDomain ? filterRecord.dynamicDomain : null;\n        var cpuFilters = shouldCalIndex ? filterRecord.cpu : null;\n        var filterFuncs = filters.reduce(function (acc, filter) {\n          var fieldIndex = (0, _gpuFilterUtils.getDatasetFieldIndexForFilter)(_this.id, filter);\n          var field = fieldIndex !== -1 ? fields[fieldIndex] : null;\n          return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, filter.id, (0, _utils.getFilterFunction)(field, _this.id, filter, layers, dataContainer)));\n        }, {});\n        filterResult = (0, _utils.filterDataByFilterTypes)({\n          dynamicDomainFilters: dynamicDomainFilters,\n          cpuFilters: cpuFilters,\n          filterFuncs: filterFuncs\n        }, dataContainer);\n      }\n      this.filteredIndex = filterResult.filteredIndex || this.filteredIndex;\n      this.filteredIndexForDomain = filterResult.filteredIndexForDomain || this.filteredIndexForDomain;\n      return this;\n    }\n    /**\n     * Apply filters to a dataset all on CPU, assign to `filteredIdxCPU`, `filterRecordCPU`\n     * @param filters\n     * @param layers\n     */\n  }, {\n    key: \"filterTableCPU\",\n    value: function filterTableCPU(filters, layers) {\n      var opt = {\n        cpuOnly: true,\n        ignoreDomain: true\n      }; // no filter\n\n      if (!filters.length) {\n        this.filteredIdxCPU = this.allIndexes;\n        this.filterRecordCPU = (0, _utils.getFilterRecord)(this.id, filters, opt);\n        return this;\n      } // no gpu filter\n\n      if (!filters.find(function (f) {\n        return f.gpu;\n      })) {\n        this.filteredIdxCPU = this.filteredIndex;\n        this.filterRecordCPU = (0, _utils.getFilterRecord)(this.id, filters, opt);\n        return this;\n      } // make a copy for cpu filtering\n\n      var copied = copyTable(this);\n      copied.filterRecord = this.filterRecordCPU;\n      copied.filteredIndex = this.filteredIdxCPU || [];\n      var filtered = copied.filterTable(filters, layers, opt);\n      this.filteredIdxCPU = filtered.filteredIndex;\n      this.filterRecordCPU = filtered.filterRecord;\n      return this;\n    }\n    /**\n     * Calculate field domain based on field type and data\n     * for Filter\n     */\n  }, {\n    key: \"getColumnFilterDomain\",\n    value: function getColumnFilterDomain(field) {\n      var dataContainer = this.dataContainer;\n      var valueAccessor = field.valueAccessor;\n      var domain;\n      switch (field.type) {\n        case _constants.ALL_FIELD_TYPES.real:\n        case _constants.ALL_FIELD_TYPES.integer:\n          // calculate domain and step\n          return (0, _utils.getNumericFieldDomain)(dataContainer, valueAccessor);\n        case _constants.ALL_FIELD_TYPES[\"boolean\"]:\n          return {\n            domain: [true, false]\n          };\n        case _constants.ALL_FIELD_TYPES.string:\n        case _constants.ALL_FIELD_TYPES.date:\n          domain = (0, _utils.getOrdinalDomain)(dataContainer, valueAccessor);\n          return {\n            domain: domain\n          };\n        case _constants.ALL_FIELD_TYPES.timestamp:\n          return (0, _utils.getTimestampFieldDomain)(dataContainer, valueAccessor);\n        default:\n          return {\n            domain: (0, _utils.getOrdinalDomain)(dataContainer, valueAccessor)\n          };\n      }\n    }\n    /**\n     *  Get the domain of this column based on scale type\n     */\n  }, {\n    key: \"getColumnLayerDomain\",\n    value: function getColumnLayerDomain(field, scaleType) {\n      var dataContainer = this.dataContainer,\n        filteredIndexForDomain = this.filteredIndexForDomain;\n      if (!_constants.SCALE_TYPES[scaleType]) {\n        _console.console.error(\"scale type \".concat(scaleType, \" not supported\"));\n        return null;\n      }\n      var valueAccessor = field.valueAccessor;\n      var indexValueAccessor = function indexValueAccessor(i) {\n        return valueAccessor({\n          index: i\n        });\n      };\n      var sortFunction = (0, _utils.getSortingFunction)(field.type);\n      switch (scaleType) {\n        case _constants.SCALE_TYPES.ordinal:\n        case _constants.SCALE_TYPES.point:\n          // do not recalculate ordinal domain based on filtered data\n          // don't need to update ordinal domain every time\n          return (0, _utils.getOrdinalDomain)(dataContainer, valueAccessor);\n        case _constants.SCALE_TYPES.quantile:\n          return (0, _utils.getQuantileDomain)(filteredIndexForDomain, indexValueAccessor, sortFunction);\n        case _constants.SCALE_TYPES.log:\n          return (0, _utils.getLogDomain)(filteredIndexForDomain, indexValueAccessor);\n        case _constants.SCALE_TYPES.quantize:\n        case _constants.SCALE_TYPES.linear:\n        case _constants.SCALE_TYPES.sqrt:\n        default:\n          return (0, _utils.getLinearDomain)(filteredIndexForDomain, indexValueAccessor);\n      }\n    }\n    /**\n     * Get a sample of rows to calculate layer boundaries\n     */\n    // getSampleData(rows)\n\n    /**\n     * Parse cell value based on column type and return a string representation\n     * Value the field value, type the field type\n     */\n    // parseFieldValue(value, type)\n    // sortDatasetByColumn()\n\n    /**\n     * Assert whether field exist\n     * @param fieldName\n     * @param condition\n     */\n  }, {\n    key: \"_assetField\",\n    value: function _assetField(fieldName, condition) {\n      if (!condition) {\n        _console.console.error(\"\".concat(fieldName, \" doesnt exist in dataset \").concat(this.id));\n      }\n    }\n  }]);\n  return KeplerTable;\n}();\n\n// HELPER FUNCTIONS (MAINLY EXPORTED FOR TEST...)\n// have to double excape\nvar specialCharacterSet = \"[#_&@\\\\.\\\\-\\\\ ]\";\nfunction foundMatchingFields(re, suffixPair, allNames, fieldName) {\n  var partnerIdx = allNames.findIndex(function (d) {\n    return d === fieldName.replace(re, function (match) {\n      return match.replace(suffixPair[0], suffixPair[1]);\n    });\n  });\n  var altIdx = -1;\n  if (partnerIdx > -1) {\n    // if found partner, go on and look for altitude\n    _constants.ALTITUDE_FIELDS.some(function (alt) {\n      altIdx = allNames.findIndex(function (d) {\n        return d === fieldName.replace(re, function (match) {\n          return match.replace(suffixPair[0], alt);\n        });\n      });\n      return altIdx > -1;\n    });\n  }\n  return {\n    partnerIdx: partnerIdx,\n    altIdx: altIdx\n  };\n}\n/**\n * Find point fields pairs from fields\n *\n * @param fields\n * @returns found point fields\n */\n\nfunction findPointFieldPairs(fields) {\n  var allNames = fields.map(function (f) {\n    return f.name.toLowerCase();\n  }); // get list of all fields with matching suffixes\n\n  var acc = [];\n  return allNames.reduce(function (carry, fieldName, idx) {\n    // This search for pairs will early exit if found.\n    var _iterator = _createForOfIteratorHelper(_constants.TRIP_POINT_FIELDS),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var suffixPair = _step.value;\n        // match first suffix\n        // (^|[#_&@\\.\\-\\ ])lat([#_&@\\.\\-\\ ]|$)\n        var re = new RegExp(\"(^|\".concat(specialCharacterSet, \")\").concat(suffixPair[0], \"(\").concat(specialCharacterSet, \"|$)\"));\n        if (re.test(fieldName)) {\n          var _foundMatchingFields = foundMatchingFields(re, suffixPair, allNames, fieldName),\n            partnerIdx = _foundMatchingFields.partnerIdx,\n            altIdx = _foundMatchingFields.altIdx;\n          if (partnerIdx > -1) {\n            var trimName = fieldName.replace(re, '').trim();\n            carry.push({\n              defaultName: trimName || 'point',\n              pair: _objectSpread({\n                lat: {\n                  fieldIdx: idx,\n                  value: fields[idx].name\n                },\n                lng: {\n                  fieldIdx: partnerIdx,\n                  value: fields[partnerIdx].name\n                }\n              }, altIdx > -1 ? {\n                alt: {\n                  fieldIdx: altIdx,\n                  value: fields[altIdx].name\n                }\n              } : {}),\n              suffix: suffixPair\n            });\n            return carry;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return carry;\n  }, acc);\n}\n/**\n *\n * @param dataset\n * @param column\n * @param mode\n * @type\n */\n\nfunction sortDatasetByColumn(dataset, column, mode) {\n  var allIndexes = dataset.allIndexes,\n    fields = dataset.fields,\n    dataContainer = dataset.dataContainer;\n  var fieldIndex = fields.findIndex(function (f) {\n    return f.name === column;\n  });\n  if (fieldIndex < 0) {\n    return dataset;\n  }\n  var sortBy = _constants.SORT_ORDER[mode || ''] || _constants.SORT_ORDER.ASCENDING;\n  if (sortBy === _constants.SORT_ORDER.UNSORT) {\n    dataset.sortColumn = {};\n    dataset.sortOrder = null;\n    return dataset;\n  }\n  var sortFunction = sortBy === _constants.SORT_ORDER.ASCENDING ? _d3Array.ascending : _d3Array.descending;\n  var sortOrder = allIndexes.slice().sort(function (a, b) {\n    return sortFunction(dataContainer.valueAt(a, fieldIndex), dataContainer.valueAt(b, fieldIndex));\n  });\n  dataset.sortColumn = (0, _defineProperty2[\"default\"])({}, column, sortBy);\n  dataset.sortOrder = sortOrder;\n  return dataset;\n}\nfunction pinTableColumns(dataset, column) {\n  var field = dataset.getColumnField(column);\n  if (!field) {\n    return dataset;\n  }\n  var pinnedColumns;\n  if (Array.isArray(dataset.pinnedColumns) && dataset.pinnedColumns.includes(field.name)) {\n    // unpin it\n    pinnedColumns = dataset.pinnedColumns.filter(function (co) {\n      return co !== field.name;\n    });\n  } else {\n    pinnedColumns = (dataset.pinnedColumns || []).concat(field.name);\n  } // @ts-ignore\n\n  return copyTableAndUpdate(dataset, {\n    pinnedColumns: pinnedColumns\n  });\n}\nfunction copyTable(original) {\n  return Object.assign(Object.create(Object.getPrototypeOf(original)), original);\n}\n/**\n * @type\n * @returns\n */\n\nfunction copyTableAndUpdate(original) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.entries(options).reduce(function (acc, entry) {\n    acc[entry[0]] = entry[1];\n    return acc;\n  }, copyTable(original));\n}\nfunction getFieldValueAccessor(f, i, dc) {\n  return maybeToDate.bind(null,\n  // is time\n  f.type === _constants.ALL_FIELD_TYPES.timestamp, i, f.format || '', dc);\n}\nvar _default = KeplerTable;\nexports[\"default\"] = _default;","map":{"version":3,"names":["Object","defineProperty","exports","findPointFieldPairs","pinTableColumns","copyTableAndUpdate","_console","require","_constants","_gpuFilterUtils","_utils","_unsupportedIterableToArray","o","minLen","_arrayLikeToArray","n","prototype","toString","call","slice","constructor","name","Array","from","test","arr","len","length","i","arr2","ownKeys","info","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","key","_defineProperty2","getOwnPropertyDescriptors","defineProperties","FID_KEY","maybeToDate","isTime","fieldIdx","format","dc","d","timeToUnixMilli","valueAt","index","KeplerTable","_ref","data","color","metadata","_ref$supportedFilterT","supportedFilterTypes","_ref$disableDataOpera","disableDataOperation","_classCallCheck2","dataContainer","createDataContainer","rows","fields","datasetInfo","id","generateHashId","label","type","dataId","map","f","displayName","valueAccessor","getFieldValueAccessor","allIndexes","getPlainIndex","defaultMetadata","fieldPairs","gpuFilter","getGpuFilterProps","_createClass2","get","numRows","field","find","fd","_assetField","columnName","value","getColumnFieldIdx","findIndex","Boolean","getValue","rowIdx","updateColumnField","newField","assign","_toConsumableArray2","updateTableColor","newColor","hasOwnProperty","filterProps","fieldDomain","getColumnFilterDomain","filterTable","filters","layers","opt","filterRecord","getFilterRecord","filteredIndex","filteredIndexForDomain","changedFilters","diffFilters","oldFilterRecord","shouldCalDomain","dynamicDomain","shouldCalIndex","cpu","filterResult","dynamicDomainFilters","cpuFilters","filterFuncs","reduce","acc","filterDataByFilterTypes","cpuOnly","ignoreDomain","filteredIdxCPU","filterRecordCPU","copied","copyTable","filtered","domain","ALL_FIELD_TYPES","real","integer","getNumericFieldDomain","getOrdinalDomain","timestamp","getColumnLayerDomain","scaleType","SCALE_TYPES","console","error","concat","sortFunction","getSortingFunction","ordinal","point","quantile","getQuantileDomain","indexValueAccessor","log","quantize","linear","sqrt","condition","fieldName","specialCharacterSet","foundMatchingFields","re","suffixPair","allNames","partnerIdx","replace","match","altIdx","ALTITUDE_FIELDS","some","alt","carry","idx","_iterator","_createForOfIteratorHelper","TRIP_POINT_FIELDS","_step","s","done","RegExp","_foundMatchingFields","trimName","trim","defaultName","pair","lat","lng","suffix","err","e","sortDatasetByColumn","dataset","column","mode","fieldIndex","sortBy","SORT_ORDER","ASCENDING","UNSORT","sortOrder","_d3Array","ascending","descending","sort","a","b","sortColumn","getColumnField","pinnedColumns","isArray","includes","original"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/table/src/kepler-table.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {console as Console} from 'global/console';\nimport {ascending, descending} from 'd3-array';\n\nimport {\n  TRIP_POINT_FIELDS,\n  SORT_ORDER,\n  ALL_FIELD_TYPES,\n  ALTITUDE_FIELDS,\n  SCALE_TYPES\n} from '@kepler.gl/constants';\nimport {\n  RGBColor,\n  Field,\n  FieldPair,\n  FieldDomain,\n  Filter,\n  ProtoDataset,\n  FilterRecord,\n  FilterDatasetOpt\n} from '@kepler.gl/types';\n\nimport {getGpuFilterProps, getDatasetFieldIndexForFilter} from './gpu-filter-utils';\n\nimport {Layer} from '@kepler.gl/layers';\nimport {\n  generateHashId,\n  getSortingFunction,\n  timeToUnixMilli,\n  createDataContainer,\n  diffFilters,\n  filterDataByFilterTypes,\n  FilterResult,\n  getFilterFunction,\n  getFilterProps,\n  getFilterRecord,\n  getNumericFieldDomain,\n  getTimestampFieldDomain,\n  getLinearDomain,\n  getLogDomain,\n  getOrdinalDomain,\n  getQuantileDomain,\n  DataContainerInterface\n} from '@kepler.gl/utils';\n\nexport type GpuFilter = {\n  filterRange: number[][];\n  filterValueUpdateTriggers: any;\n  filterValueAccessor: (\n    dc: DataContainerInterface\n  ) => (\n    getIndex?: (any) => number,\n    getData?: (dc_: DataContainerInterface, d: any, fieldIndex: number) => any\n  ) => (d: any) => number;\n};\n\n// Unique identifier of each field\nconst FID_KEY = 'name';\n\nexport function maybeToDate(\n  isTime: boolean,\n  fieldIdx: number,\n  format: string,\n  dc: DataContainerInterface,\n  d: {index: number}\n) {\n  if (isTime) {\n    return timeToUnixMilli(dc.valueAt(d.index, fieldIdx), format);\n  }\n\n  return dc.valueAt(d.index, fieldIdx);\n}\n\nclass KeplerTable {\n  readonly id: string;\n\n  type?: string;\n  label: string;\n  color: RGBColor;\n\n  // fields and data\n  fields: Field[];\n\n  dataContainer: DataContainerInterface;\n\n  allIndexes: number[];\n  filteredIndex: number[];\n  filteredIdxCPU?: number[];\n  filteredIndexForDomain: number[];\n  fieldPairs: FieldPair[];\n  gpuFilter: GpuFilter;\n  filterRecord?: FilterRecord;\n  filterRecordCPU?: FilterRecord;\n  changedFilters?: any;\n\n  // table-injected metadata\n  sortColumn?: {\n    // column name: sorted idx\n    [key: string]: string; // ASCENDING | DESCENDING | UNSORT\n  };\n  sortOrder?: number[] | null;\n\n  pinnedColumns?: string[];\n  supportedFilterTypes?: string[] | null;\n  disableDataOperation?: boolean;\n\n  // table-injected metadata\n  metadata: object;\n\n  constructor({\n    info,\n    data,\n    color,\n    metadata,\n    supportedFilterTypes = null,\n    disableDataOperation = false\n  }: {\n    info?: ProtoDataset['info'];\n    data: ProtoDataset['data'];\n    color: RGBColor;\n    metadata?: ProtoDataset['metadata'];\n    supportedFilterTypes?: ProtoDataset['supportedFilterTypes'];\n    disableDataOperation?: ProtoDataset['disableDataOperation'];\n  }) {\n    // TODO - what to do if validation fails? Can kepler handle exceptions?\n    // const validatedData = validateInputData(data);\n    // if (!validatedData) {\n    //   return this;\n    // }\n\n    // @ts-expect-error\n    const dataContainer = createDataContainer(data.rows, {fields: data.fields});\n\n    const datasetInfo = {\n      id: generateHashId(4),\n      label: 'new dataset',\n      type: '',\n      ...info\n    };\n    const dataId = datasetInfo.id;\n    // @ts-expect-error\n    const fields: Field[] = data.fields.map((f, i) => ({\n      ...f,\n      fieldIdx: i,\n      id: f.name,\n      displayName: f.displayName || f.name,\n      valueAccessor: getFieldValueAccessor(f, i, dataContainer)\n    }));\n\n    const allIndexes = dataContainer.getPlainIndex();\n    const defaultMetadata = {\n      id: datasetInfo.id,\n      // @ts-ignore\n      format: datasetInfo.format || '',\n      label: datasetInfo.label || ''\n    };\n\n    this.id = datasetInfo.id;\n    this.type = datasetInfo.type;\n    this.label = datasetInfo.label;\n    this.color = color;\n    this.metadata = {\n      ...defaultMetadata,\n      ...metadata\n    };\n\n    this.dataContainer = dataContainer;\n    this.allIndexes = allIndexes;\n    this.filteredIndex = allIndexes;\n    this.filteredIndexForDomain = allIndexes;\n    this.fieldPairs = findPointFieldPairs(fields);\n    this.fields = fields;\n    this.gpuFilter = getGpuFilterProps([], dataId, fields);\n    this.supportedFilterTypes = supportedFilterTypes;\n    this.disableDataOperation = disableDataOperation;\n  }\n\n  get length() {\n    return this.dataContainer.numRows();\n  }\n\n  /**\n   * Get field\n   * @param columnName\n   */\n  getColumnField(columnName: string): Field | undefined {\n    const field = this.fields.find(fd => fd[FID_KEY] === columnName);\n    this._assetField(columnName, field);\n    return field;\n  }\n\n  /**\n   * Get fieldIdx\n   * @param columnName\n   */\n  getColumnFieldIdx(columnName: string): number {\n    const fieldIdx = this.fields.findIndex(fd => fd[FID_KEY] === columnName);\n    this._assetField(columnName, Boolean(fieldIdx > -1));\n    return fieldIdx;\n  }\n\n  /**\n   * Get the value of a cell\n   */\n  getValue(columnName: string, rowIdx: number): any {\n    const field = this.getColumnField(columnName);\n    return field ? field.valueAccessor({index: rowIdx}) : null;\n  }\n\n  /**\n   * Updates existing field with a new object\n   * @param fieldIdx\n   * @param newField\n   */\n  updateColumnField(fieldIdx: number, newField: Field): void {\n    this.fields = Object.assign([...this.fields], {[fieldIdx]: newField});\n  }\n\n  /**\n   * Update dataset color by custom color\n   * @param newColor\n   */\n  updateTableColor(newColor: RGBColor): void {\n    this.color = newColor;\n  }\n\n  /**\n   * Save filterProps to field and retrieve it\n   * @param columnName\n   */\n  getColumnFilterProps(columnName: string): Field['filterProps'] | null | undefined {\n    const fieldIdx = this.getColumnFieldIdx(columnName);\n    if (fieldIdx < 0) {\n      return null;\n    }\n    const field = this.fields[fieldIdx];\n    if (field.hasOwnProperty('filterProps')) {\n      return field.filterProps;\n    }\n\n    const fieldDomain = this.getColumnFilterDomain(field);\n    if (!fieldDomain) {\n      return null;\n    }\n\n    const filterProps = getFilterProps(field, fieldDomain);\n    const newField = {\n      ...field,\n      filterProps\n    };\n\n    this.updateColumnField(fieldIdx, newField);\n\n    return filterProps;\n  }\n\n  /**\n   * Apply filters to dataset, return the filtered dataset with updated `gpuFilter`, `filterRecord`, `filteredIndex`, `filteredIndexForDomain`\n   * @param filters\n   * @param layers\n   * @param opt\n   */\n  filterTable(filters: Filter[], layers: Layer[], opt?: FilterDatasetOpt): KeplerTable {\n    const {dataContainer, id: dataId, filterRecord: oldFilterRecord, fields} = this;\n\n    // if there is no filters\n    const filterRecord = getFilterRecord(dataId, filters, opt || {});\n\n    this.filterRecord = filterRecord;\n    this.gpuFilter = getGpuFilterProps(filters, dataId, fields);\n\n    // const newDataset = set(['filterRecord'], filterRecord, dataset);\n\n    if (!filters.length) {\n      this.filteredIndex = this.allIndexes;\n      this.filteredIndexForDomain = this.allIndexes;\n      return this;\n    }\n\n    this.changedFilters = diffFilters(filterRecord, oldFilterRecord);\n\n    // generate 2 sets of filter result\n    // filteredIndex used to calculate layer data\n    // filteredIndexForDomain used to calculate layer Domain\n    const shouldCalDomain = Boolean(this.changedFilters.dynamicDomain);\n    const shouldCalIndex = Boolean(this.changedFilters.cpu);\n\n    let filterResult: FilterResult = {};\n    if (shouldCalDomain || shouldCalIndex) {\n      const dynamicDomainFilters = shouldCalDomain ? filterRecord.dynamicDomain : null;\n      const cpuFilters = shouldCalIndex ? filterRecord.cpu : null;\n\n      const filterFuncs = filters.reduce((acc, filter) => {\n        const fieldIndex = getDatasetFieldIndexForFilter(this.id, filter);\n        const field = fieldIndex !== -1 ? fields[fieldIndex] : null;\n\n        return {\n          ...acc,\n          [filter.id]: getFilterFunction(field, this.id, filter, layers, dataContainer)\n        };\n      }, {});\n\n      filterResult = filterDataByFilterTypes(\n        {dynamicDomainFilters, cpuFilters, filterFuncs},\n        dataContainer\n      );\n    }\n\n    this.filteredIndex = filterResult.filteredIndex || this.filteredIndex;\n    this.filteredIndexForDomain =\n      filterResult.filteredIndexForDomain || this.filteredIndexForDomain;\n\n    return this;\n  }\n\n  /**\n   * Apply filters to a dataset all on CPU, assign to `filteredIdxCPU`, `filterRecordCPU`\n   * @param filters\n   * @param layers\n   */\n  filterTableCPU(filters: Filter[], layers: Layer[]): KeplerTable {\n    const opt = {\n      cpuOnly: true,\n      ignoreDomain: true\n    };\n\n    // no filter\n    if (!filters.length) {\n      this.filteredIdxCPU = this.allIndexes;\n      this.filterRecordCPU = getFilterRecord(this.id, filters, opt);\n      return this;\n    }\n\n    // no gpu filter\n    if (!filters.find(f => f.gpu)) {\n      this.filteredIdxCPU = this.filteredIndex;\n      this.filterRecordCPU = getFilterRecord(this.id, filters, opt);\n      return this;\n    }\n\n    // make a copy for cpu filtering\n    const copied = copyTable(this);\n\n    copied.filterRecord = this.filterRecordCPU;\n    copied.filteredIndex = this.filteredIdxCPU || [];\n\n    const filtered = copied.filterTable(filters, layers, opt);\n\n    this.filteredIdxCPU = filtered.filteredIndex;\n    this.filterRecordCPU = filtered.filterRecord;\n\n    return this;\n  }\n\n  /**\n   * Calculate field domain based on field type and data\n   * for Filter\n   */\n  getColumnFilterDomain(field: Field): FieldDomain {\n    const {dataContainer} = this;\n    const {valueAccessor} = field;\n\n    let domain;\n\n    switch (field.type) {\n      case ALL_FIELD_TYPES.real:\n      case ALL_FIELD_TYPES.integer:\n        // calculate domain and step\n        return getNumericFieldDomain(dataContainer, valueAccessor);\n\n      case ALL_FIELD_TYPES.boolean:\n        return {domain: [true, false]};\n\n      case ALL_FIELD_TYPES.string:\n      case ALL_FIELD_TYPES.date:\n        domain = getOrdinalDomain(dataContainer, valueAccessor);\n        return {domain};\n\n      case ALL_FIELD_TYPES.timestamp:\n        return getTimestampFieldDomain(dataContainer, valueAccessor);\n\n      default:\n        return {domain: getOrdinalDomain(dataContainer, valueAccessor)};\n    }\n  }\n\n  /**\n   *  Get the domain of this column based on scale type\n   */\n  getColumnLayerDomain(\n    field: Field,\n    scaleType: string\n  ): number[] | string[] | [number, number] | null {\n    const {dataContainer, filteredIndexForDomain} = this;\n\n    if (!SCALE_TYPES[scaleType]) {\n      Console.error(`scale type ${scaleType} not supported`);\n      return null;\n    }\n\n    const {valueAccessor} = field;\n    const indexValueAccessor = i => valueAccessor({index: i});\n    const sortFunction = getSortingFunction(field.type);\n\n    switch (scaleType) {\n      case SCALE_TYPES.ordinal:\n      case SCALE_TYPES.point:\n        // do not recalculate ordinal domain based on filtered data\n        // don't need to update ordinal domain every time\n        return getOrdinalDomain(dataContainer, valueAccessor);\n\n      case SCALE_TYPES.quantile:\n        return getQuantileDomain(filteredIndexForDomain, indexValueAccessor, sortFunction);\n\n      case SCALE_TYPES.log:\n        return getLogDomain(filteredIndexForDomain, indexValueAccessor);\n\n      case SCALE_TYPES.quantize:\n      case SCALE_TYPES.linear:\n      case SCALE_TYPES.sqrt:\n      default:\n        return getLinearDomain(filteredIndexForDomain, indexValueAccessor);\n    }\n  }\n\n  /**\n   * Get a sample of rows to calculate layer boundaries\n   */\n  // getSampleData(rows)\n\n  /**\n   * Parse cell value based on column type and return a string representation\n   * Value the field value, type the field type\n   */\n  // parseFieldValue(value, type)\n\n  // sortDatasetByColumn()\n\n  /**\n   * Assert whether field exist\n   * @param fieldName\n   * @param condition\n   */\n  _assetField(fieldName: string, condition: any): void {\n    if (!condition) {\n      Console.error(`${fieldName} doesnt exist in dataset ${this.id}`);\n    }\n  }\n}\n\nexport type Datasets = {\n  [key: string]: KeplerTable;\n};\n\n// HELPER FUNCTIONS (MAINLY EXPORTED FOR TEST...)\n// have to double excape\nconst specialCharacterSet = `[#_&@\\\\.\\\\-\\\\ ]`;\n\nfunction foundMatchingFields(re, suffixPair, allNames, fieldName) {\n  const partnerIdx = allNames.findIndex(\n    d => d === fieldName.replace(re, match => match.replace(suffixPair[0], suffixPair[1]))\n  );\n  let altIdx = -1;\n  if (partnerIdx > -1) {\n    // if found partner, go on and look for altitude\n    ALTITUDE_FIELDS.some(alt => {\n      altIdx = allNames.findIndex(\n        d => d === fieldName.replace(re, match => match.replace(suffixPair[0], alt))\n      );\n      return altIdx > -1;\n    });\n  }\n  return {partnerIdx, altIdx};\n}\n/**\n * Find point fields pairs from fields\n *\n * @param fields\n * @returns found point fields\n */\nexport function findPointFieldPairs(fields: Field[]): FieldPair[] {\n  const allNames = fields.map(f => f.name.toLowerCase());\n\n  // get list of all fields with matching suffixes\n  const acc: FieldPair[] = [];\n  return allNames.reduce((carry, fieldName, idx) => {\n    // This search for pairs will early exit if found.\n    for (const suffixPair of TRIP_POINT_FIELDS) {\n      // match first suffix\n      // (^|[#_&@\\.\\-\\ ])lat([#_&@\\.\\-\\ ]|$)\n      const re = new RegExp(`(^|${specialCharacterSet})${suffixPair[0]}(${specialCharacterSet}|$)`);\n\n      if (re.test(fieldName)) {\n        const {partnerIdx, altIdx} = foundMatchingFields(re, suffixPair, allNames, fieldName);\n\n        if (partnerIdx > -1) {\n          const trimName = fieldName.replace(re, '').trim();\n\n          carry.push({\n            defaultName: trimName || 'point',\n            pair: {\n              lat: {\n                fieldIdx: idx,\n                value: fields[idx].name\n              },\n              lng: {\n                fieldIdx: partnerIdx,\n                value: fields[partnerIdx].name\n              },\n              ...(altIdx > -1\n                ? {\n                    alt: {\n                      fieldIdx: altIdx,\n                      value: fields[altIdx].name\n                    }\n                  }\n                : {})\n            },\n            suffix: suffixPair\n          });\n          return carry;\n        }\n      }\n    }\n    return carry;\n  }, acc);\n}\n\n/**\n *\n * @param dataset\n * @param column\n * @param mode\n * @type\n */\nexport function sortDatasetByColumn(\n  dataset: KeplerTable,\n  column: string,\n  mode?: string\n): KeplerTable {\n  const {allIndexes, fields, dataContainer} = dataset;\n  const fieldIndex = fields.findIndex(f => f.name === column);\n  if (fieldIndex < 0) {\n    return dataset;\n  }\n\n  const sortBy = SORT_ORDER[mode || ''] || SORT_ORDER.ASCENDING;\n\n  if (sortBy === SORT_ORDER.UNSORT) {\n    dataset.sortColumn = {};\n    dataset.sortOrder = null;\n\n    return dataset;\n  }\n\n  const sortFunction = sortBy === SORT_ORDER.ASCENDING ? ascending : descending;\n  const sortOrder = allIndexes\n    .slice()\n    .sort((a, b) =>\n      sortFunction(dataContainer.valueAt(a, fieldIndex), dataContainer.valueAt(b, fieldIndex))\n    );\n\n  dataset.sortColumn = {\n    [column]: sortBy\n  };\n  dataset.sortOrder = sortOrder;\n\n  return dataset;\n}\n\nexport function pinTableColumns(dataset: KeplerTable, column: string): KeplerTable {\n  const field = dataset.getColumnField(column);\n  if (!field) {\n    return dataset;\n  }\n\n  let pinnedColumns;\n  if (Array.isArray(dataset.pinnedColumns) && dataset.pinnedColumns.includes(field.name)) {\n    // unpin it\n    pinnedColumns = dataset.pinnedColumns.filter(co => co !== field.name);\n  } else {\n    pinnedColumns = (dataset.pinnedColumns || []).concat(field.name);\n  }\n\n  // @ts-ignore\n  return copyTableAndUpdate(dataset, {pinnedColumns});\n}\n\nexport function copyTable(original: KeplerTable): KeplerTable {\n  return Object.assign(Object.create(Object.getPrototypeOf(original)), original);\n}\n\n/**\n * @type\n * @returns\n */\nexport function copyTableAndUpdate(\n  original: KeplerTable,\n  options: Partial<KeplerTable> = {}\n): KeplerTable {\n  return Object.entries(options).reduce((acc, entry) => {\n    acc[entry[0]] = entry[1];\n    return acc;\n  }, copyTable(original));\n}\n\nexport function getFieldValueAccessor<\n  F extends {\n    type?: Field['type'];\n    format?: Field['format'];\n  }\n>(f: F, i: number, dc: DataContainerInterface) {\n  return maybeToDate.bind(\n    null,\n    // is time\n    f.type === ALL_FIELD_TYPES.timestamp,\n    i,\n    f.format || '',\n    dc\n  );\n}\n\nexport default KeplerTable;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}