{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as Polygon from './polygon';\nimport { Tesselator } from '@deck.gl/core';\nimport { cutPolygonByGrid, cutPolygonByMercatorBounds } from '@math.gl/polygon';\nvar PolygonTesselator = /*#__PURE__*/function (_Tesselator) {\n  _inherits(PolygonTesselator, _Tesselator);\n  var _super = _createSuper(PolygonTesselator);\n  function PolygonTesselator(opts) {\n    _classCallCheck(this, PolygonTesselator);\n    var fp64 = opts.fp64,\n      _opts$IndexType = opts.IndexType,\n      IndexType = _opts$IndexType === void 0 ? Uint32Array : _opts$IndexType;\n    return _super.call(this, _objectSpread(_objectSpread({}, opts), {}, {\n      attributes: {\n        positions: {\n          size: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        vertexValid: {\n          type: Uint8ClampedArray,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    }));\n  }\n  _createClass(PolygonTesselator, [{\n    key: \"get\",\n    value: function get(attributeName) {\n      var attributes = this.attributes;\n      if (attributeName === 'indices') {\n        return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n      }\n      return attributes[attributeName];\n    }\n  }, {\n    key: \"updateGeometry\",\n    value: function updateGeometry(opts) {\n      _get(_getPrototypeOf(PolygonTesselator.prototype), \"updateGeometry\", this).call(this, opts);\n      var externalIndices = this.buffers.indices;\n      if (externalIndices) {\n        this.vertexCount = (externalIndices.value || externalIndices).length;\n      } else if (this.data && !this.getGeometry) {\n        throw new Error('missing indices buffer');\n      }\n    }\n  }, {\n    key: \"normalizeGeometry\",\n    value: function normalizeGeometry(polygon) {\n      if (this.normalize) {\n        var normalizedPolygon = Polygon.normalize(polygon, this.positionSize);\n        if (this.opts.resolution) {\n          return cutPolygonByGrid(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {\n            size: this.positionSize,\n            gridResolution: this.opts.resolution,\n            edgeTypes: true\n          });\n        }\n        if (this.opts.wrapLongitude) {\n          return cutPolygonByMercatorBounds(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {\n            size: this.positionSize,\n            maxLatitude: 86,\n            edgeTypes: true\n          });\n        }\n        return normalizedPolygon;\n      }\n      return polygon;\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(polygon) {\n      if (isCut(polygon)) {\n        var size = 0;\n        var _iterator = _createForOfIteratorHelper(polygon),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var subPolygon = _step.value;\n            size += this.getGeometrySize(subPolygon);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        return size;\n      }\n      return Polygon.getPositions(polygon).length / this.positionSize;\n    }\n  }, {\n    key: \"getGeometryFromBuffer\",\n    value: function getGeometryFromBuffer(buffer) {\n      if (this.normalize || !this.buffers.indices) {\n        return _get(_getPrototypeOf(PolygonTesselator.prototype), \"getGeometryFromBuffer\", this).call(this, buffer);\n      }\n      return null;\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(polygon, context) {\n      if (polygon && isCut(polygon)) {\n        var _iterator2 = _createForOfIteratorHelper(polygon),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var subPolygon = _step2.value;\n            var geometrySize = this.getGeometrySize(subPolygon);\n            context.geometrySize = geometrySize;\n            this.updateGeometryAttributes(subPolygon, context);\n            context.vertexStart += geometrySize;\n            context.indexStart = this.indexStarts[context.geometryIndex + 1];\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } else {\n        this._updateIndices(polygon, context);\n        this._updatePositions(polygon, context);\n        this._updateVertexValid(polygon, context);\n      }\n    }\n  }, {\n    key: \"_updateIndices\",\n    value: function _updateIndices(polygon, _ref) {\n      var geometryIndex = _ref.geometryIndex,\n        offset = _ref.vertexStart,\n        indexStart = _ref.indexStart;\n      var attributes = this.attributes,\n        indexStarts = this.indexStarts,\n        typedArrayManager = this.typedArrayManager;\n      var target = attributes.indices;\n      if (!target || !polygon) {\n        return;\n      }\n      var i = indexStart;\n      var indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n      target = typedArrayManager.allocate(target, indexStart + indices.length, {\n        copy: true\n      });\n      for (var j = 0; j < indices.length; j++) {\n        target[i++] = indices[j] + offset;\n      }\n      indexStarts[geometryIndex + 1] = indexStart + indices.length;\n      attributes.indices = target;\n    }\n  }, {\n    key: \"_updatePositions\",\n    value: function _updatePositions(polygon, _ref2) {\n      var vertexStart = _ref2.vertexStart,\n        geometrySize = _ref2.geometrySize;\n      var positions = this.attributes.positions,\n        positionSize = this.positionSize;\n      if (!positions || !polygon) {\n        return;\n      }\n      var polygonPositions = Polygon.getPositions(polygon);\n      for (var i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n        var x = polygonPositions[j * positionSize];\n        var y = polygonPositions[j * positionSize + 1];\n        var z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n        positions[i * 3] = x;\n        positions[i * 3 + 1] = y;\n        positions[i * 3 + 2] = z;\n      }\n    }\n  }, {\n    key: \"_updateVertexValid\",\n    value: function _updateVertexValid(polygon, _ref3) {\n      var vertexStart = _ref3.vertexStart,\n        geometrySize = _ref3.geometrySize;\n      var positionSize = this.positionSize;\n      var vertexValid = this.attributes.vertexValid;\n      var holeIndices = polygon && Polygon.getHoleIndices(polygon);\n      if (polygon && polygon.edgeTypes) {\n        vertexValid.set(polygon.edgeTypes, vertexStart);\n      } else {\n        vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n      }\n      if (holeIndices) {\n        for (var j = 0; j < holeIndices.length; j++) {\n          vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n        }\n      }\n      vertexValid[vertexStart + geometrySize - 1] = 0;\n    }\n  }]);\n  return PolygonTesselator;\n}(Tesselator);\nexport { PolygonTesselator as default };\nfunction isCut(polygon) {\n  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);\n}","map":{"version":3,"names":["Polygon","Tesselator","cutPolygonByGrid","cutPolygonByMercatorBounds","PolygonTesselator","_Tesselator","_inherits","_super","_createSuper","opts","_classCallCheck","fp64","_opts$IndexType","IndexType","Uint32Array","call","_objectSpread","attributes","positions","size","type","Float64Array","Float32Array","vertexValid","Uint8ClampedArray","indices","_createClass","key","value","get","attributeName","subarray","vertexCount","updateGeometry","_get","_getPrototypeOf","prototype","externalIndices","buffers","length","data","getGeometry","Error","normalizeGeometry","polygon","normalize","normalizedPolygon","positionSize","resolution","getPositions","getHoleIndices","gridResolution","edgeTypes","wrapLongitude","maxLatitude","getGeometrySize","isCut","_iterator","_createForOfIteratorHelper","_step","s","n","done","subPolygon","err","e","f","getGeometryFromBuffer","buffer","updateGeometryAttributes","context","_iterator2","_step2","geometrySize","vertexStart","indexStart","indexStarts","geometryIndex","_updateIndices","_updatePositions","_updateVertexValid","_ref","offset","typedArrayManager","target","i","getSurfaceIndices","preproject","allocate","copy","j","_ref2","polygonPositions","x","y","z","_ref3","holeIndices","set","fill","default","Array","isArray","Number","isFinite"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/layers/src/solid-polygon-layer/polygon-tesselator.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {Tesselator} from '@deck.gl/core';\nimport {cutPolygonByGrid, cutPolygonByMercatorBounds} from '@math.gl/polygon';\n\nimport type {\n  PolygonGeometry,\n  NormalizedPolygonGeometry,\n  FlatComplexPolygonGeometry\n} from './polygon';\nimport type {TypedArray} from '@math.gl/core';\n\ntype GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\ntype CutPolygon = FlatComplexPolygonGeometry & {\n  edgeTypes: number[];\n};\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator<\n  PolygonGeometry,\n  NormalizedPolygonGeometry | CutPolygon[],\n  {\n    fp64?: boolean;\n    IndexType?: Uint32ArrayConstructor | Uint16ArrayConstructor;\n    resolution?: number;\n    wrapLongitude?: boolean;\n    preproject?: (xy: number[]) => number[];\n  }\n> {\n  constructor(opts) {\n    const {fp64, IndexType = Uint32Array} = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {size: 3, type: fp64 ? Float64Array : Float32Array},\n        vertexValid: {type: Uint8ClampedArray, size: 1},\n        indices: {type: IndexType, size: 1}\n      }\n    });\n  }\n\n  /** Get attribute by name */\n  get(attributeName: string): TypedArray | null {\n    const {attributes} = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  /** Override base Tesselator method */\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      // @ts-ignore (2339) value is not defined on TypedArray (fall through)\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    } else if (this.data && !this.getGeometry) {\n      throw new Error('missing indices buffer');\n    }\n  }\n\n  /** Implement base Tesselator interface */\n  protected normalizeGeometry(polygon: PolygonGeometry): NormalizedPolygonGeometry | CutPolygon[] {\n    if (this.normalize) {\n      const normalizedPolygon = Polygon.normalize(polygon, this.positionSize);\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(\n          Polygon.getPositions(normalizedPolygon),\n          Polygon.getHoleIndices(normalizedPolygon),\n          {\n            size: this.positionSize,\n            gridResolution: this.opts.resolution,\n            edgeTypes: true\n          }\n        ) as CutPolygon[];\n      }\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(\n          Polygon.getPositions(normalizedPolygon),\n          Polygon.getHoleIndices(normalizedPolygon),\n          {\n            size: this.positionSize,\n            maxLatitude: 86,\n            edgeTypes: true\n          }\n        ) as CutPolygon[];\n      }\n      return normalizedPolygon;\n    }\n    // normalize is explicitly set to false, assume that user passed in already normalized polygons\n    return polygon as NormalizedPolygonGeometry;\n  }\n\n  /** Implement base Tesselator interface */\n  protected getGeometrySize(polygon: NormalizedPolygonGeometry | CutPolygon[]): number {\n    if (isCut(polygon)) {\n      let size = 0;\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n      return size;\n    }\n    return Polygon.getPositions(polygon).length / this.positionSize;\n  }\n\n  /** Override base Tesselator method */\n  protected getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization/tesselation\n    return null;\n  }\n\n  /** Implement base Tesselator interface */\n  protected updateGeometryAttributes(\n    polygon: NormalizedPolygonGeometry | CutPolygon[] | null,\n    context: GeometryUpdateContext\n  ) {\n    if (polygon && isCut(polygon)) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n      this._updatePositions(polygon, context);\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  // Flatten the indices array\n  private _updateIndices(\n    polygon: NormalizedPolygonGeometry | null,\n    {geometryIndex, vertexStart: offset, indexStart}: GeometryUpdateContext\n  ) {\n    const {attributes, indexStarts, typedArrayManager} = this;\n\n    let target = attributes.indices;\n    if (!target || !polygon) {\n      return;\n    }\n    let i = indexStart;\n\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n\n    // make sure the buffer is large enough\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  // Flatten out all the vertices of all the sub subPolygons\n  private _updatePositions(\n    polygon: NormalizedPolygonGeometry | null,\n    {vertexStart, geometrySize}: GeometryUpdateContext\n  ) {\n    const {\n      attributes: {positions},\n      positionSize\n    } = this;\n    if (!positions || !polygon) {\n      return;\n    }\n    const polygonPositions = Polygon.getPositions(polygon);\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  private _updateVertexValid(\n    polygon: NormalizedPolygonGeometry | null,\n    {vertexStart, geometrySize}: GeometryUpdateContext\n  ) {\n    const {positionSize} = this;\n    const vertexValid = this.attributes.vertexValid as TypedArray;\n    const holeIndices = polygon && Polygon.getHoleIndices(polygon);\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    if (polygon && (polygon as CutPolygon).edgeTypes) {\n      vertexValid.set((polygon as CutPolygon).edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\n\nfunction isCut(polygon: NormalizedPolygonGeometry | CutPolygon[]): polygon is CutPolygon[] {\n  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}