{"ast":null,"code":"import _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Vector3, equals as _equals, assert } from '@math.gl/core';\nvar scratchPosition = new Vector3();\nvar scratchNormal = new Vector3();\nvar Plane = /*#__PURE__*/function () {\n  function Plane() {\n    var normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 1];\n    var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    _classCallCheck(this, Plane);\n    _defineProperty(this, \"normal\", void 0);\n    _defineProperty(this, \"distance\", void 0);\n    this.normal = new Vector3();\n    this.distance = -0;\n    this.fromNormalDistance(normal, distance);\n  }\n  _createClass(Plane, [{\n    key: \"fromNormalDistance\",\n    value: function fromNormalDistance(normal, distance) {\n      assert(Number.isFinite(distance));\n      this.normal.from(normal).normalize();\n      this.distance = distance;\n      return this;\n    }\n  }, {\n    key: \"fromPointNormal\",\n    value: function fromPointNormal(point, normal) {\n      point = scratchPosition.from(point);\n      this.normal.from(normal).normalize();\n      var distance = -this.normal.dot(point);\n      this.distance = distance;\n      return this;\n    }\n  }, {\n    key: \"fromCoefficients\",\n    value: function fromCoefficients(a, b, c, d) {\n      this.normal.set(a, b, c);\n      assert(_equals(this.normal.len(), 1));\n      this.distance = d;\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Plane(this.normal, this.distance);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return _equals(this.distance, right.distance) && _equals(this.normal, right.normal);\n    }\n  }, {\n    key: \"getPointDistance\",\n    value: function getPointDistance(point) {\n      return this.normal.dot(point) + this.distance;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(matrix4) {\n      var normal = scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();\n      var point = this.normal.scale(-this.distance).transform(matrix4);\n      return this.fromPointNormal(point, normal);\n    }\n  }, {\n    key: \"projectPointOntoPlane\",\n    value: function projectPointOntoPlane(point) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      point = scratchPosition.from(point);\n      var pointDistance = this.getPointDistance(point);\n      var scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);\n      return point.subtract(scaledNormal).to(result);\n    }\n  }]);\n  return Plane;\n}();\nexport { Plane as default };","map":{"version":3,"names":["Vector3","equals","assert","scratchPosition","scratchNormal","Plane","normal","arguments","length","undefined","distance","_classCallCheck","_defineProperty","fromNormalDistance","_createClass","key","value","Number","isFinite","from","normalize","fromPointNormal","point","dot","fromCoefficients","a","b","c","d","set","len","clone","right","getPointDistance","transform","matrix4","copy","transformAsVector","scale","projectPointOntoPlane","result","pointDistance","scaledNormal","subtract","to","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@math.gl/culling/src/lib/plane.ts"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, equals, assert, NumericArray} from '@math.gl/core';\n\nconst scratchPosition = new Vector3();\nconst scratchNormal = new Vector3();\n\n// A plane in Hessian Normal Form\nexport default class Plane {\n  readonly normal: Vector3;\n  distance: number;\n\n  constructor(normal: Readonly<NumericArray> = [0, 0, 1], distance: number = 0) {\n    this.normal = new Vector3();\n    this.distance = -0;\n    this.fromNormalDistance(normal, distance);\n  }\n\n  /** Creates a plane from a normal and a distance from the origin. */\n  fromNormalDistance(normal: Readonly<NumericArray>, distance: number): this {\n    assert(Number.isFinite(distance));\n    this.normal.from(normal).normalize();\n    this.distance = distance;\n    return this;\n  }\n\n  /** Creates a plane from a normal and a point on the plane. */\n  fromPointNormal(point: Readonly<NumericArray>, normal: Readonly<NumericArray>): this {\n    point = scratchPosition.from(point);\n    this.normal.from(normal).normalize();\n    const distance = -this.normal.dot(point);\n    this.distance = distance;\n    return this;\n  }\n\n  /** Creates a plane from the general equation */\n  fromCoefficients(a: number, b: number, c: number, d: number): this {\n    this.normal.set(a, b, c);\n    assert(equals(this.normal.len(), 1));\n    this.distance = d;\n    return this;\n  }\n\n  /** Duplicates a Plane instance. */\n  clone(): Plane {\n    return new Plane(this.normal, this.distance);\n  }\n\n  /** Compares the provided Planes by normal and distance */\n  equals(right: Plane): boolean {\n    return equals(this.distance, right.distance) && equals(this.normal, right.normal);\n  }\n\n  /** Computes the signed shortest distance of a point to a plane.\n   * The sign of the distance determines which side of the plane the point is on.\n   */\n  getPointDistance(point: Readonly<NumericArray>): number {\n    return this.normal.dot(point) + this.distance;\n  }\n\n  /** Transforms the plane by the given transformation matrix. */\n  transform(matrix4: Readonly<NumericArray>): this {\n    const normal = scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();\n    const point = this.normal.scale(-this.distance).transform(matrix4);\n    return this.fromPointNormal(point, normal);\n  }\n\n  /** Projects a point onto the plane. */\n  projectPointOntoPlane(point: Readonly<NumericArray>, result: Vector3): Vector3;\n  projectPointOntoPlane(\n    point: Readonly<NumericArray>,\n    result?: readonly number[]\n  ): readonly number[];\n\n  projectPointOntoPlane(point, result = [0, 0, 0]) {\n    point = scratchPosition.from(point);\n    // projectedPoint = point - (normal.point + scale) * normal\n    const pointDistance = this.getPointDistance(point);\n    const scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);\n\n    return point.subtract(scaledNormal).to(result);\n  }\n}\n"],"mappings":";;;AAIA,SAAQA,OAAR,EAAiBC,MAAjB,IAAiBA,OAAjB,EAAyBC,MAAzB,QAAoD,eAApD;AAEA,IAAMC,eAAe,GAAG,IAAIH,OAAJ,EAAxB;AACA,IAAMI,aAAa,GAAG,IAAIJ,OAAJ,EAAtB;AAAA,IAGqBK,KAAN;EAIb,SAAAA,MAAA,EAA8E;IAAA,IAAlEC,MAA8B,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAlC;IAAA,IAA6CG,QAAgB,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAhE;IAAAI,eAAA,OAAAN,KAAA;IAAmEO,eAAA;IAAAA,eAAA;IAC5E,KAAKN,MAAL,GAAc,IAAIN,OAAJ,EAAd;IACA,KAAKU,QAAL,GAAgB,CAAC,CAAjB;IACA,KAAKG,kBAAL,CAAwBP,MAAxB,EAAgCI,QAAhC;EACD;EAAAI,YAAA,CAAAT,KAAA;IAAAU,GAAA;IAAAC,KAAA,EAGD,SAAAH,mBAAmBP,MAAD,EAAiCI,QAAjC,EAAyD;MACzER,MAAM,CAACe,MAAM,CAACC,QAAP,CAAgBR,QAAhB,CAAD,CAAN;MACA,KAAKJ,MAAL,CAAYa,IAAZ,CAAiBb,MAAjB,EAAyBc,SAAzB;MACA,KAAKV,QAAL,GAAgBA,QAAhB;MACA,OAAO,IAAP;IACD;EAAA;IAAAK,GAAA;IAAAC,KAAA,EAGD,SAAAK,gBAAgBC,KAAD,EAAgChB,MAAhC,EAAsE;MACnFgB,KAAK,GAAGnB,eAAe,CAACgB,IAAhB,CAAqBG,KAArB,CAAR;MACA,KAAKhB,MAAL,CAAYa,IAAZ,CAAiBb,MAAjB,EAAyBc,SAAzB;MACA,IAAMV,QAAQ,GAAG,CAAC,KAAKJ,MAAL,CAAYiB,GAAZ,CAAgBD,KAAhB,CAAlB;MACA,KAAKZ,QAAL,GAAgBA,QAAhB;MACA,OAAO,IAAP;IACD;EAAA;IAAAK,GAAA;IAAAC,KAAA,EAGD,SAAAQ,iBAAiBC,CAAD,EAAYC,CAAZ,EAAuBC,CAAvB,EAAkCC,CAAlC,EAAmD;MACjE,KAAKtB,MAAL,CAAYuB,GAAZ,CAAgBJ,CAAhB,EAAmBC,CAAnB,EAAsBC,CAAtB;MACAzB,MAAM,CAACD,OAAM,CAAC,KAAKK,MAAL,CAAYwB,GAAZ,EAAD,EAAoB,CAApB,CAAP,CAAN;MACA,KAAKpB,QAAL,GAAgBkB,CAAhB;MACA,OAAO,IAAP;IACD;EAAA;IAAAb,GAAA;IAAAC,KAAA,EAGD,SAAAe,MAAA,EAAe;MACb,OAAO,IAAI1B,KAAJ,CAAU,KAAKC,MAAf,EAAuB,KAAKI,QAA5B,CAAP;IACD;EAAA;IAAAK,GAAA;IAAAC,KAAA,EAGD,SAAAf,OAAO+B,KAAD,EAAwB;MAC5B,OAAO/B,OAAM,CAAC,KAAKS,QAAN,EAAgBsB,KAAK,CAACtB,QAAtB,CAAN,IAAyCT,OAAM,CAAC,KAAKK,MAAN,EAAc0B,KAAK,CAAC1B,MAApB,CAAtD;IACD;EAAA;IAAAS,GAAA;IAAAC,KAAA,EAKD,SAAAiB,iBAAiBX,KAAD,EAAwC;MACtD,OAAO,KAAKhB,MAAL,CAAYiB,GAAZ,CAAgBD,KAAhB,IAAyB,KAAKZ,QAArC;IACD;EAAA;IAAAK,GAAA;IAAAC,KAAA,EAGD,SAAAkB,UAAUC,OAAD,EAAwC;MAC/C,IAAM7B,MAAM,GAAGF,aAAa,CAACgC,IAAd,CAAmB,KAAK9B,MAAxB,EAAgC+B,iBAAhC,CAAkDF,OAAlD,EAA2Df,SAA3D,EAAf;MACA,IAAME,KAAK,GAAG,KAAKhB,MAAL,CAAYgC,KAAZ,CAAkB,CAAC,KAAK5B,QAAxB,EAAkCwB,SAAlC,CAA4CC,OAA5C,CAAd;MACA,OAAO,KAAKd,eAAL,CAAqBC,KAArB,EAA4BhB,MAA5B,CAAP;IACD;EAAA;IAAAS,GAAA;IAAAC,KAAA,EASD,SAAAuB,sBAAsBjB,KAAD,EAA4B;MAAA,IAApBkB,MAAM,GAAAjC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAjB;MACnBe,KAAK,GAAGnB,eAAe,CAACgB,IAAhB,CAAqBG,KAArB,CAAR;MAEA,IAAMmB,aAAa,GAAG,KAAKR,gBAAL,CAAsBX,KAAtB,CAAtB;MACA,IAAMoB,YAAY,GAAGtC,aAAa,CAACgC,IAAd,CAAmB,KAAK9B,MAAxB,EAAgCgC,KAAhC,CAAsCG,aAAtC,CAArB;MAEA,OAAOnB,KAAK,CAACqB,QAAN,CAAeD,YAAf,EAA6BE,EAA7B,CAAgCJ,MAAhC,CAAP;IACD;EAAA;EAAA,OAAAnC,KAAA;AAAA;AAAA,SAzEkBA,KAAN,IAAAwC,OAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}