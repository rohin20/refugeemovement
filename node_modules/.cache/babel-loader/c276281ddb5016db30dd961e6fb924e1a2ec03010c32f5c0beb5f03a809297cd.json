{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.aggregateRequiredColumns = exports.getFilterDataFunc = exports.getValueAggrFunc = exports.pointPosResolver = exports.pointPosAccessor = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.memoize\"));\nvar _baseLayer = _interopRequireDefault(require(\"./base-layer\"));\nvar _utils = require(\"@kepler.gl/utils\");\nvar _constants = require(\"@kepler.gl/constants\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar pointPosAccessor = function pointPosAccessor(_ref) {\n  var lat = _ref.lat,\n    lng = _ref.lng;\n  return function (dc) {\n    return function (d) {\n      return [dc.valueAt(d.index, lng.fieldIdx), dc.valueAt(d.index, lat.fieldIdx)];\n    };\n  };\n};\nexports.pointPosAccessor = pointPosAccessor;\nvar pointPosResolver = function pointPosResolver(_ref2) {\n  var lat = _ref2.lat,\n    lng = _ref2.lng;\n  return \"\".concat(lat.fieldIdx, \"-\").concat(lng.fieldIdx);\n};\nexports.pointPosResolver = pointPosResolver;\nvar getValueAggrFunc = function getValueAggrFunc(getPointData) {\n  return function (field, aggregation) {\n    return function (points) {\n      return field ? (0, _utils.aggregate)(points.map(function (p) {\n        return field.valueAccessor(getPointData(p));\n      }), aggregation) : points.length;\n    };\n  };\n};\nexports.getValueAggrFunc = getValueAggrFunc;\nvar getFilterDataFunc = function getFilterDataFunc(filterRange, getFilterValue) {\n  return function (pt) {\n    return getFilterValue(pt).every(function (val, i) {\n      return val >= filterRange[i][0] && val <= filterRange[i][1];\n    });\n  };\n};\nexports.getFilterDataFunc = getFilterDataFunc;\nvar getLayerColorRange = function getLayerColorRange(colorRange) {\n  return colorRange.colors.map(_utils.hexToRgb);\n};\nvar aggregateRequiredColumns = ['lat', 'lng'];\nexports.aggregateRequiredColumns = aggregateRequiredColumns;\nvar AggregationLayer = /*#__PURE__*/function (_Layer) {\n  (0, _inherits2[\"default\"])(AggregationLayer, _Layer);\n  var _super = _createSuper(AggregationLayer);\n  function AggregationLayer(props) {\n    var _this;\n    (0, _classCallCheck2[\"default\"])(this, AggregationLayer);\n    _this = _super.call(this, props);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"getColorRange\", void 0);\n    _this.getPositionAccessor = function (dataContainer) {\n      return pointPosAccessor(_this.config.columns)(dataContainer);\n    };\n    _this.getColorRange = (0, _lodash[\"default\"])(getLayerColorRange); // Access data of a point from aggregated bins, depends on how BinSorter works\n    // Deck.gl's BinSorter puts data in point.source\n\n    _this.getPointData = function (pt) {\n      return pt.source;\n    };\n    _this.gpuFilterGetIndex = function (pt) {\n      return _this.getPointData(pt).index;\n    };\n    _this.gpuFilterGetData = function (dataContainer, data, fieldIndex) {\n      return dataContainer.valueAt(data.index, fieldIndex);\n    };\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(AggregationLayer, [{\n    key: \"isAggregated\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"requiredLayerColumns\",\n    get: function get() {\n      return aggregateRequiredColumns;\n    }\n  }, {\n    key: \"columnPairs\",\n    get: function get() {\n      return this.defaultPointColumnPairs;\n    }\n  }, {\n    key: \"noneLayerDataAffectingProps\",\n    get: function get() {\n      return [].concat((0, _toConsumableArray2[\"default\"])((0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(AggregationLayer.prototype), \"noneLayerDataAffectingProps\", this)), ['enable3d', 'colorRange', 'colorDomain', 'sizeRange', 'sizeScale', 'sizeDomain', 'percentile', 'coverage', 'elevationPercentile', 'elevationScale', 'enableElevationZoomFactor']);\n    }\n  }, {\n    key: \"visualChannels\",\n    get: function get() {\n      return {\n        color: {\n          aggregation: 'colorAggregation',\n          channelScaleType: _constants.CHANNEL_SCALES.colorAggr,\n          defaultMeasure: 'property.pointCount',\n          domain: 'colorDomain',\n          field: 'colorField',\n          key: 'color',\n          property: 'color',\n          range: 'colorRange',\n          scale: 'colorScale'\n        },\n        size: {\n          aggregation: 'sizeAggregation',\n          channelScaleType: _constants.CHANNEL_SCALES.sizeAggr,\n          condition: function condition(config) {\n            return config.visConfig.enable3d;\n          },\n          defaultMeasure: 'property.pointCount',\n          domain: 'sizeDomain',\n          field: 'sizeField',\n          key: 'size',\n          property: 'height',\n          range: 'sizeRange',\n          scale: 'sizeScale'\n        }\n      };\n    }\n    /**\n     * Get the description of a visualChannel config\n     * @param key\n     * @returns\n     */\n  }, {\n    key: \"getVisualChannelDescription\",\n    value: function getVisualChannelDescription(key) {\n      var _this$visConfigSettin;\n      var channel = this.visualChannels[key];\n      if (!channel) return {\n        label: '',\n        measure: undefined\n      }; // e.g. label: Color, measure: Average of ETA\n\n      var range = channel.range,\n        field = channel.field,\n        defaultMeasure = channel.defaultMeasure,\n        aggregation = channel.aggregation;\n      var fieldConfig = this.config[field];\n      var label = (_this$visConfigSettin = this.visConfigSettings[range]) === null || _this$visConfigSettin === void 0 ? void 0 : _this$visConfigSettin.label;\n      return {\n        label: typeof label === 'function' ? label(this.config) : label || '',\n        measure: fieldConfig && aggregation ? \"\".concat(this.config.visConfig[aggregation], \" of \").concat(fieldConfig.displayName || fieldConfig.name) : defaultMeasure\n      };\n    }\n  }, {\n    key: \"getHoverData\",\n    value: function getHoverData(object) {\n      // return aggregated object\n      return object;\n    }\n    /**\n     * Aggregation layer handles visual channel aggregation inside deck.gl layer\n     */\n  }, {\n    key: \"updateLayerVisualChannel\",\n    value: function updateLayerVisualChannel(_ref3, channel) {\n      var dataContainer = _ref3.dataContainer;\n      this.validateVisualChannel(channel);\n    }\n    /**\n     * Validate aggregation type on top of basic layer visual channel validation\n     * @param channel\n     */\n  }, {\n    key: \"validateVisualChannel\",\n    value: function validateVisualChannel(channel) {\n      // field type decides aggregation type decides scale type\n      this.validateFieldType(channel);\n      this.validateAggregationType(channel);\n      this.validateScale(channel);\n    }\n    /**\n     * Validate aggregation type based on selected field\n     */\n  }, {\n    key: \"validateAggregationType\",\n    value: function validateAggregationType(channel) {\n      var visualChannel = this.visualChannels[channel];\n      var field = visualChannel.field,\n        aggregation = visualChannel.aggregation;\n      var aggregationOptions = this.getAggregationOptions(channel);\n      if (!aggregation) {\n        return;\n      }\n      if (!aggregationOptions.length) {\n        // if field cannot be aggregated, set field to null\n        this.updateLayerConfig((0, _defineProperty2[\"default\"])({}, field, null));\n      } else if (!aggregationOptions.includes(this.config.visConfig[aggregation])) {\n        // current aggregation type is not supported by this field\n        // set aggregation to the first supported option\n        this.updateLayerVisConfig((0, _defineProperty2[\"default\"])({}, aggregation, aggregationOptions[0]));\n      }\n    }\n  }, {\n    key: \"getAggregationOptions\",\n    value: function getAggregationOptions(channel) {\n      var visualChannel = this.visualChannels[channel];\n      var field = visualChannel.field,\n        channelScaleType = visualChannel.channelScaleType;\n      return Object.keys(this.config[field] ? _constants.FIELD_OPTS[this.config[field].type].scale[channelScaleType] : _constants.DEFAULT_AGGREGATION[channelScaleType]);\n    }\n    /**\n     * Get scale options based on current field and aggregation type\n     * @param channel\n     * @returns\n     */\n  }, {\n    key: \"getScaleOptions\",\n    value: function getScaleOptions(channel) {\n      var visualChannel = this.visualChannels[channel];\n      var field = visualChannel.field,\n        aggregation = visualChannel.aggregation,\n        channelScaleType = visualChannel.channelScaleType;\n      var aggregationType = aggregation ? this.config.visConfig[aggregation] : null;\n      if (!aggregationType) {\n        return [];\n      }\n      return this.config[field] ?\n      // scale options based on aggregation\n      _constants.FIELD_OPTS[this.config[field].type].scale[channelScaleType][aggregationType] :\n      // default scale options for point count\n      _constants.DEFAULT_AGGREGATION[channelScaleType][aggregationType];\n    }\n    /**\n     * Aggregation layer handles visual channel aggregation inside deck.gl layer\n     */\n  }, {\n    key: \"updateLayerDomain\",\n    value: function updateLayerDomain(datasets, newFilter) {\n      return this;\n    }\n  }, {\n    key: \"updateLayerMeta\",\n    value: function updateLayerMeta(dataContainer, getPosition) {\n      // get bounds from points\n      var bounds = this.getPointsBounds(dataContainer, getPosition);\n      this.updateMeta({\n        bounds: bounds\n      });\n    }\n  }, {\n    key: \"calculateDataAttribute\",\n    value: function calculateDataAttribute(_ref4, getPosition) {\n      var dataContainer = _ref4.dataContainer,\n        filteredIndex = _ref4.filteredIndex;\n      var data = [];\n      for (var i = 0; i < filteredIndex.length; i++) {\n        var index = filteredIndex[i];\n        var pos = getPosition({\n          index: index\n        }); // if doesn't have point lat or lng, do not add the point\n        // deck.gl can't handle position = null\n\n        if (pos.every(Number.isFinite)) {\n          data.push({\n            index: index\n          });\n        }\n      }\n      return data;\n    }\n  }, {\n    key: \"formatLayerData\",\n    value: function formatLayerData(datasets, oldLayerData) {\n      if (this.config.dataId === null) {\n        return {};\n      }\n      var _datasets$this$config = datasets[this.config.dataId],\n        gpuFilter = _datasets$this$config.gpuFilter,\n        dataContainer = _datasets$this$config.dataContainer;\n      var getPosition = this.getPositionAccessor(dataContainer);\n      var aggregatePoints = getValueAggrFunc(this.getPointData);\n      var getColorValue = aggregatePoints(this.config.colorField, this.config.visConfig.colorAggregation);\n      var getElevationValue = aggregatePoints(this.config.sizeField, this.config.visConfig.sizeAggregation);\n      var hasFilter = Object.values(gpuFilter.filterRange).some(function (arr) {\n        return arr.some(function (v) {\n          return v !== 0;\n        });\n      });\n      var getFilterValue = gpuFilter.filterValueAccessor(dataContainer)(this.gpuFilterGetIndex, this.gpuFilterGetData);\n      var filterData = hasFilter ? getFilterDataFunc(gpuFilter.filterRange, getFilterValue) : undefined;\n      var _this$updateData = this.updateData(datasets, oldLayerData),\n        data = _this$updateData.data;\n      return _objectSpread(_objectSpread({\n        data: data,\n        getPosition: getPosition,\n        _filterData: filterData\n      }, getColorValue ? {\n        getColorValue: getColorValue\n      } : {}), getElevationValue ? {\n        getElevationValue: getElevationValue\n      } : {});\n    }\n  }, {\n    key: \"getDefaultDeckLayerProps\",\n    value: function getDefaultDeckLayerProps(opts) {\n      var baseProp = (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(AggregationLayer.prototype), \"getDefaultDeckLayerProps\", this).call(this, opts);\n      return _objectSpread(_objectSpread({}, baseProp), {}, {\n        highlightColor: _constants.HIGHLIGH_COLOR_3D,\n        // gpu data filtering is not supported in aggregation layer\n        extensions: [],\n        autoHighlight: this.config.visConfig.enable3d\n      });\n    }\n  }, {\n    key: \"getDefaultAggregationLayerProp\",\n    value: function getDefaultAggregationLayerProp(opts) {\n      var gpuFilter = opts.gpuFilter,\n        mapState = opts.mapState,\n        _opts$layerCallbacks = opts.layerCallbacks,\n        layerCallbacks = _opts$layerCallbacks === void 0 ? {} : _opts$layerCallbacks;\n      var visConfig = this.config.visConfig;\n      var eleZoomFactor = this.getElevationZoomFactor(mapState);\n      var updateTriggers = {\n        getColorValue: {\n          colorField: this.config.colorField,\n          colorAggregation: this.config.visConfig.colorAggregation\n        },\n        getElevationValue: {\n          sizeField: this.config.sizeField,\n          sizeAggregation: this.config.visConfig.sizeAggregation\n        },\n        _filterData: _objectSpread({\n          filterRange: gpuFilter.filterRange\n        }, gpuFilter.filterValueUpdateTriggers)\n      };\n      return _objectSpread(_objectSpread({}, this.getDefaultDeckLayerProps(opts)), {}, {\n        coverage: visConfig.coverage,\n        // color\n        colorRange: this.getColorRange(visConfig.colorRange),\n        colorScaleType: this.config.colorScale,\n        upperPercentile: visConfig.percentile[1],\n        lowerPercentile: visConfig.percentile[0],\n        colorAggregation: visConfig.colorAggregation,\n        // elevation\n        extruded: visConfig.enable3d,\n        elevationScale: visConfig.elevationScale * eleZoomFactor,\n        elevationScaleType: this.config.sizeScale,\n        elevationRange: visConfig.sizeRange,\n        elevationLowerPercentile: visConfig.elevationPercentile[0],\n        elevationUpperPercentile: visConfig.elevationPercentile[1],\n        // updateTriggers\n        updateTriggers: updateTriggers,\n        // callbacks\n        onSetColorDomain: layerCallbacks.onSetLayerDomain\n      });\n    }\n  }]);\n  return AggregationLayer;\n}(_baseLayer[\"default\"]);\nexports[\"default\"] = AggregationLayer;","map":{"version":3,"names":["exports","aggregateRequiredColumns","getFilterDataFunc","getValueAggrFunc","pointPosResolver","pointPosAccessor","_toConsumableArray2","_interopRequireDefault","require","_classCallCheck2","_createClass2","_getPrototypeOf2","_defineProperty2","_lodash","_baseLayer","_utils","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","_possibleConstructorReturn2","_ref","lat","lng","dc","d","valueAt","index","fieldIdx","_ref2","concat","points","field","aggregate","map","p","valueAccessor","getPointData","getFilterValue","pt","every","val","filterRange","getLayerColorRange","colorRange","colors","hexToRgb","AggregationLayer","_Layer","_inherits2","_super","props","_this","call","getPositionAccessor","dataContainer","getColorRange","gpuFilterGetIndex","gpuFilterGetData","data","fieldIndex","get","defaultPointColumnPairs","_get2","prototype","color","aggregation","channelScaleType","_constants","CHANNEL_SCALES","colorAggr","defaultMeasure","domain","property","range","scale","size","config","visConfig","enable3d","channel","visualChannels","label","measure","undefined","fieldConfig","_this$visConfigSettin","visConfigSettings","displayName","name","value","validateVisualChannel","validateFieldType","validateAggregationType","validateScale","visualChannel","aggregationOptions","getAggregationOptions","updateLayerVisConfig","aggregationType","FIELD_OPTS","type","updateLayerDomain","filteredIndex","datasets","newFilter","bounds","getPointsBounds","getPosition","updateMeta","calculateDataAttribute","_ref4","pos","Number","isFinite","formatLayerData","oldLayerData","dataId","_datasets$this$config","gpuFilter","aggregatePoints","getColorValue","colorField","colorAggregation","getElevationValue","sizeField","sizeAggregation","hasFilter","values","some","arr","filterValueAccessor","filterData","_this$updateData","updateData","getDefaultDeckLayerProps","opts","baseProp","highlightColor","HIGHLIGH_COLOR_3D","extensions","autoHighlight","getDefaultAggregationLayerProp","mapState","_opts$layerCallbacks","layerCallbacks","eleZoomFactor","getElevationZoomFactor","updateTriggers","_filterData","filterValueUpdateTriggers"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/layers/src/aggregation-layer.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport memoize from 'lodash.memoize';\nimport Layer, {\n  LayerBaseConfig,\n  LayerColorConfig,\n  LayerColumn,\n  LayerSizeConfig,\n  VisualChannelDescription,\n  VisualChannels\n} from './base-layer';\nimport {hexToRgb, aggregate} from '@kepler.gl/utils';\nimport {\n  HIGHLIGH_COLOR_3D,\n  CHANNEL_SCALES,\n  FIELD_OPTS,\n  DEFAULT_AGGREGATION,\n  ColorRange\n} from '@kepler.gl/constants';\nimport {Merge} from '@kepler.gl/types';\nimport {KeplerTable, Datasets} from '@kepler.gl/table';\n\ntype AggregationLayerColumns = {\n  lat: LayerColumn;\n  lng: LayerColumn;\n};\n\nexport type AggregationLayerData = {\n  index: number;\n};\n\nexport const pointPosAccessor = ({lat, lng}: AggregationLayerColumns) => dc => d => [\n  dc.valueAt(d.index, lng.fieldIdx),\n  dc.valueAt(d.index, lat.fieldIdx)\n];\n\nexport const pointPosResolver = ({lat, lng}: AggregationLayerColumns) =>\n  `${lat.fieldIdx}-${lng.fieldIdx}`;\n\nexport const getValueAggrFunc = getPointData => (field, aggregation) => points =>\n  field\n    ? aggregate(\n        points.map(p => field.valueAccessor(getPointData(p))),\n        aggregation\n      )\n    : points.length;\n\nexport const getFilterDataFunc = (filterRange, getFilterValue) => pt =>\n  getFilterValue(pt).every((val, i) => val >= filterRange[i][0] && val <= filterRange[i][1]);\n\nconst getLayerColorRange = (colorRange: ColorRange) => colorRange.colors.map(hexToRgb);\n\nexport const aggregateRequiredColumns: ['lat', 'lng'] = ['lat', 'lng'];\n\nexport type AggregationLayerVisualChannelConfig = LayerColorConfig & LayerSizeConfig;\nexport type AggregationLayerConfig = Merge<LayerBaseConfig, {columns: AggregationLayerColumns}> &\n  AggregationLayerVisualChannelConfig;\nexport default class AggregationLayer extends Layer {\n  getColorRange: any;\n  declare config: AggregationLayerConfig;\n  declare getPointData: (any) => any;\n  declare gpuFilterGetIndex: (any) => number;\n  declare gpuFilterGetData: (dataContainer, data, fieldIndex) => any;\n\n  constructor(\n    props?: {\n      id?: string;\n    } & Partial<LayerBaseConfig>\n  ) {\n    super(props);\n\n    this.getPositionAccessor = dataContainer =>\n      pointPosAccessor(this.config.columns)(dataContainer);\n    this.getColorRange = memoize(getLayerColorRange);\n\n    // Access data of a point from aggregated bins, depends on how BinSorter works\n    // Deck.gl's BinSorter puts data in point.source\n    this.getPointData = pt => pt.source;\n\n    this.gpuFilterGetIndex = pt => this.getPointData(pt).index;\n    this.gpuFilterGetData = (dataContainer, data, fieldIndex) =>\n      dataContainer.valueAt(data.index, fieldIndex);\n  }\n\n  get isAggregated(): true {\n    return true;\n  }\n\n  get requiredLayerColumns() {\n    return aggregateRequiredColumns;\n  }\n\n  get columnPairs() {\n    return this.defaultPointColumnPairs;\n  }\n\n  get noneLayerDataAffectingProps() {\n    return [\n      ...super.noneLayerDataAffectingProps,\n      'enable3d',\n      'colorRange',\n      'colorDomain',\n      'sizeRange',\n      'sizeScale',\n      'sizeDomain',\n      'percentile',\n      'coverage',\n      'elevationPercentile',\n      'elevationScale',\n      'enableElevationZoomFactor'\n    ];\n  }\n\n  get visualChannels(): VisualChannels {\n    return {\n      color: {\n        aggregation: 'colorAggregation',\n        channelScaleType: CHANNEL_SCALES.colorAggr,\n        defaultMeasure: 'property.pointCount',\n        domain: 'colorDomain',\n        field: 'colorField',\n        key: 'color',\n        property: 'color',\n        range: 'colorRange',\n        scale: 'colorScale'\n      },\n      size: {\n        aggregation: 'sizeAggregation',\n        channelScaleType: CHANNEL_SCALES.sizeAggr,\n        condition: config => config.visConfig.enable3d,\n        defaultMeasure: 'property.pointCount',\n        domain: 'sizeDomain',\n        field: 'sizeField',\n        key: 'size',\n        property: 'height',\n        range: 'sizeRange',\n        scale: 'sizeScale'\n      }\n    };\n  }\n\n  /**\n   * Get the description of a visualChannel config\n   * @param key\n   * @returns\n   */\n  getVisualChannelDescription(key: string): VisualChannelDescription {\n    const channel = this.visualChannels[key];\n    if (!channel) return {label: '', measure: undefined};\n    // e.g. label: Color, measure: Average of ETA\n    const {range, field, defaultMeasure, aggregation} = channel;\n    const fieldConfig = this.config[field];\n    const label = this.visConfigSettings[range]?.label;\n\n    return {\n      label: typeof label === 'function' ? label(this.config) : label || '',\n      measure:\n        fieldConfig && aggregation\n          ? `${this.config.visConfig[aggregation]} of ${fieldConfig.displayName ||\n              fieldConfig.name}`\n          : defaultMeasure\n    };\n  }\n\n  getHoverData(object) {\n    // return aggregated object\n    return object;\n  }\n\n  /**\n   * Aggregation layer handles visual channel aggregation inside deck.gl layer\n   */\n  updateLayerVisualChannel({dataContainer}, channel) {\n    this.validateVisualChannel(channel);\n  }\n\n  /**\n   * Validate aggregation type on top of basic layer visual channel validation\n   * @param channel\n   */\n  validateVisualChannel(channel) {\n    // field type decides aggregation type decides scale type\n    this.validateFieldType(channel);\n    this.validateAggregationType(channel);\n    this.validateScale(channel);\n  }\n\n  /**\n   * Validate aggregation type based on selected field\n   */\n  validateAggregationType(channel) {\n    const visualChannel = this.visualChannels[channel];\n    const {field, aggregation} = visualChannel;\n    const aggregationOptions = this.getAggregationOptions(channel);\n\n    if (!aggregation) {\n      return;\n    }\n\n    if (!aggregationOptions.length) {\n      // if field cannot be aggregated, set field to null\n      this.updateLayerConfig({[field]: null});\n    } else if (!aggregationOptions.includes(this.config.visConfig[aggregation])) {\n      // current aggregation type is not supported by this field\n      // set aggregation to the first supported option\n      this.updateLayerVisConfig({[aggregation]: aggregationOptions[0]});\n    }\n  }\n\n  getAggregationOptions(channel) {\n    const visualChannel = this.visualChannels[channel];\n    const {field, channelScaleType} = visualChannel;\n\n    return Object.keys(\n      this.config[field]\n        ? FIELD_OPTS[this.config[field].type].scale[channelScaleType]\n        : DEFAULT_AGGREGATION[channelScaleType]\n    );\n  }\n\n  /**\n   * Get scale options based on current field and aggregation type\n   * @param channel\n   * @returns\n   */\n  getScaleOptions(channel: string): string[] {\n    const visualChannel = this.visualChannels[channel];\n    const {field, aggregation, channelScaleType} = visualChannel;\n    const aggregationType = aggregation ? this.config.visConfig[aggregation] : null;\n\n    if (!aggregationType) {\n      return [];\n    }\n\n    return this.config[field]\n      ? // scale options based on aggregation\n        FIELD_OPTS[this.config[field].type].scale[channelScaleType][aggregationType]\n      : // default scale options for point count\n        DEFAULT_AGGREGATION[channelScaleType][aggregationType];\n  }\n\n  /**\n   * Aggregation layer handles visual channel aggregation inside deck.gl layer\n   */\n  updateLayerDomain(datasets, newFilter): AggregationLayer {\n    return this;\n  }\n\n  updateLayerMeta(dataContainer, getPosition) {\n    // get bounds from points\n    const bounds = this.getPointsBounds(dataContainer, getPosition);\n\n    this.updateMeta({bounds});\n  }\n\n  calculateDataAttribute({dataContainer, filteredIndex}: KeplerTable, getPosition) {\n    const data: AggregationLayerData[] = [];\n\n    for (let i = 0; i < filteredIndex.length; i++) {\n      const index = filteredIndex[i];\n      const pos = getPosition({index});\n\n      // if doesn't have point lat or lng, do not add the point\n      // deck.gl can't handle position = null\n      if (pos.every(Number.isFinite)) {\n        data.push({\n          index\n        });\n      }\n    }\n\n    return data;\n  }\n\n  formatLayerData(datasets: Datasets, oldLayerData) {\n    if (this.config.dataId === null) {\n      return {};\n    }\n    const {gpuFilter, dataContainer} = datasets[this.config.dataId];\n    const getPosition = this.getPositionAccessor(dataContainer);\n\n    const aggregatePoints = getValueAggrFunc(this.getPointData);\n    const getColorValue = aggregatePoints(\n      this.config.colorField,\n      this.config.visConfig.colorAggregation\n    );\n\n    const getElevationValue = aggregatePoints(\n      this.config.sizeField,\n      this.config.visConfig.sizeAggregation\n    );\n    const hasFilter = Object.values(gpuFilter.filterRange).some((arr: any) =>\n      arr.some(v => v !== 0)\n    );\n\n    const getFilterValue = gpuFilter.filterValueAccessor(dataContainer)(\n      this.gpuFilterGetIndex,\n      this.gpuFilterGetData\n    );\n    const filterData = hasFilter\n      ? getFilterDataFunc(gpuFilter.filterRange, getFilterValue)\n      : undefined;\n\n    const {data} = this.updateData(datasets, oldLayerData);\n\n    return {\n      data,\n      getPosition,\n      _filterData: filterData,\n      // @ts-expect-error\n      ...(getColorValue ? {getColorValue} : {}),\n      // @ts-expect-error\n      ...(getElevationValue ? {getElevationValue} : {})\n    };\n  }\n\n  getDefaultDeckLayerProps(opts): any {\n    const baseProp = super.getDefaultDeckLayerProps(opts);\n    return {\n      ...baseProp,\n      highlightColor: HIGHLIGH_COLOR_3D,\n      // gpu data filtering is not supported in aggregation layer\n      extensions: [],\n      autoHighlight: this.config.visConfig.enable3d\n    };\n  }\n\n  getDefaultAggregationLayerProp(opts) {\n    const {gpuFilter, mapState, layerCallbacks = {}} = opts;\n    const {visConfig} = this.config;\n    const eleZoomFactor = this.getElevationZoomFactor(mapState);\n\n    const updateTriggers = {\n      getColorValue: {\n        colorField: this.config.colorField,\n        colorAggregation: this.config.visConfig.colorAggregation\n      },\n      getElevationValue: {\n        sizeField: this.config.sizeField,\n        sizeAggregation: this.config.visConfig.sizeAggregation\n      },\n      _filterData: {\n        filterRange: gpuFilter.filterRange,\n        ...gpuFilter.filterValueUpdateTriggers\n      }\n    };\n\n    return {\n      ...this.getDefaultDeckLayerProps(opts),\n      coverage: visConfig.coverage,\n\n      // color\n      colorRange: this.getColorRange(visConfig.colorRange),\n      colorScaleType: this.config.colorScale,\n      upperPercentile: visConfig.percentile[1],\n      lowerPercentile: visConfig.percentile[0],\n      colorAggregation: visConfig.colorAggregation,\n\n      // elevation\n      extruded: visConfig.enable3d,\n      elevationScale: visConfig.elevationScale * eleZoomFactor,\n      elevationScaleType: this.config.sizeScale,\n      elevationRange: visConfig.sizeRange,\n      elevationLowerPercentile: visConfig.elevationPercentile[0],\n      elevationUpperPercentile: visConfig.elevationPercentile[1],\n\n      // updateTriggers\n      updateTriggers,\n\n      // callbacks\n      onSetColorDomain: layerCallbacks.onSetLayerDomain\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}