{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.visStateSchema = exports.visStateSchemaV1 = exports.visStateSchemaV0 = exports.propertiesV1 = exports.propertiesV0 = exports.filterPropsV1 = exports.SplitMapsSchema = exports.DimensionFieldSchema = exports.filterPropsV0 = exports.InteractionSchemaV1 = exports.FilterSchemaV0 = exports.LayerSchemaV0 = exports.layerPropsV1 = exports.layerPropsV0 = exports.dimensionPropsV0 = void 0;\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.pick\"));\nvar _versions = require(\"./versions\");\nvar _filterUtils = require(\"../utils/filter-utils\");\nvar _layerFactory = require(\"../layers/layer-factory\");\nvar _schema = _interopRequireDefault(require(\"./schema\"));\nvar _lodash2 = _interopRequireDefault(require(\"lodash.clonedeep\"));\nvar _dataUtils = require(\"../utils/data-utils\");\nvar _visStateSchema;\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * V0 Schema\n */\nvar dimensionPropsV0 = ['name', 'type']; // in v0 geojson there is only sizeField\n// in v1 geojson\n// stroke base on -> sizeField\n// height based on -> heightField\n// radius based on -> radiusField\n// here we make our wiredst guess on which channel sizeField belongs to\n\nexports.dimensionPropsV0 = dimensionPropsV0;\nfunction geojsonSizeFieldV0ToV1(config) {\n  var defaultRaiuds = 10;\n  var defaultRadiusRange = [0, 50]; // if extruded, sizeField is most likely used for height\n\n  if (config.visConfig.extruded) {\n    return 'heightField';\n  } // if show stroke enabled, sizeField is most likely used for stroke\n\n  if (config.visConfig.stroked) {\n    return 'sizeField';\n  } // if radius changed, or radius Range Changed, sizeField is most likely used for radius\n  // this is the most unreliable guess, that's why we put it in the end\n\n  if (config.visConfig.radius !== defaultRaiuds || config.visConfig.radiusRange.some(function (d, i) {\n    return d !== defaultRadiusRange[i];\n  })) {\n    return 'radiusField';\n  }\n  return 'sizeField';\n} // convert v0 to v1 layer config\n\nvar DimensionFieldSchemaV0 = /*#__PURE__*/function (_Schema) {\n  (0, _inherits2[\"default\"])(DimensionFieldSchemaV0, _Schema);\n  var _super = _createSuper(DimensionFieldSchemaV0);\n  function DimensionFieldSchemaV0() {\n    var _this;\n    (0, _classCallCheck2[\"default\"])(this, DimensionFieldSchemaV0);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"version\", _versions.VERSIONS.v0);\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(DimensionFieldSchemaV0, [{\n    key: \"save\",\n    value: function save(field) {\n      // should not be called anymore\n      return (0, _defineProperty2[\"default\"])({}, this.key, field !== null ? this.savePropertiesOrApplySchema(field)[this.key] : null);\n    }\n  }, {\n    key: \"load\",\n    value: function load(field, parents, accumulated) {\n      var _parents$slice = parents.slice(-1),\n        _parents$slice2 = (0, _slicedToArray2[\"default\"])(_parents$slice, 1),\n        config = _parents$slice2[0];\n      var fieldName = this.key;\n      if (config.type === 'geojson' && this.key === 'sizeField' && field) {\n        fieldName = geojsonSizeFieldV0ToV1(config);\n      } // fold into visualChannels to be load by VisualChannelSchemaV1\n\n      return {\n        visualChannels: _objectSpread(_objectSpread({}, accumulated.visualChannels || {}), {}, (0, _defineProperty2[\"default\"])({}, fieldName, field))\n      };\n    }\n  }]);\n  return DimensionFieldSchemaV0;\n}(_schema[\"default\"]);\nvar DimensionScaleSchemaV0 = /*#__PURE__*/function (_Schema2) {\n  (0, _inherits2[\"default\"])(DimensionScaleSchemaV0, _Schema2);\n  var _super2 = _createSuper(DimensionScaleSchemaV0);\n  function DimensionScaleSchemaV0() {\n    var _this2;\n    (0, _classCallCheck2[\"default\"])(this, DimensionScaleSchemaV0);\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    _this2 = _super2.call.apply(_super2, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this2), \"version\", _versions.VERSIONS.v0);\n    return _this2;\n  }\n  (0, _createClass2[\"default\"])(DimensionScaleSchemaV0, [{\n    key: \"save\",\n    value: function save(scale) {\n      return (0, _defineProperty2[\"default\"])({}, this.key, scale);\n    }\n  }, {\n    key: \"load\",\n    value: function load(scale, parents, accumulated) {\n      var _parents$slice3 = parents.slice(-1),\n        _parents$slice4 = (0, _slicedToArray2[\"default\"])(_parents$slice3, 1),\n        config = _parents$slice4[0]; // fold into visualChannels to be load by VisualChannelSchemaV1\n\n      if (this.key === 'sizeScale' && config.type === 'geojson') {\n        // sizeScale now split into radiusScale, heightScale\n        // no user customization, just use default\n        return {};\n      }\n      return {\n        visualChannels: _objectSpread(_objectSpread({}, accumulated.visualChannels || {}), {}, (0, _defineProperty2[\"default\"])({}, this.key, scale))\n      };\n    }\n  }]);\n  return DimensionScaleSchemaV0;\n}(_schema[\"default\"]); // used to convert v0 to v1 layer config\n\nvar LayerConfigSchemaV0 = /*#__PURE__*/function (_Schema3) {\n  (0, _inherits2[\"default\"])(LayerConfigSchemaV0, _Schema3);\n  var _super3 = _createSuper(LayerConfigSchemaV0);\n  function LayerConfigSchemaV0() {\n    var _this3;\n    (0, _classCallCheck2[\"default\"])(this, LayerConfigSchemaV0);\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    _this3 = _super3.call.apply(_super3, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this3), \"version\", _versions.VERSIONS.v0);\n    return _this3;\n  }\n  (0, _createClass2[\"default\"])(LayerConfigSchemaV0, [{\n    key: \"load\",\n    value: function load(saved, parents, accumulated) {\n      // fold v0 layer property into config.key\n      return {\n        config: _objectSpread(_objectSpread({}, accumulated.config || {}), {}, (0, _defineProperty2[\"default\"])({}, this.key, saved))\n      };\n    }\n  }]);\n  return LayerConfigSchemaV0;\n}(_schema[\"default\"]); // used to convert v0 to v1 layer columns\n// only return column value for each column\n\nvar LayerColumnsSchemaV0 = /*#__PURE__*/function (_Schema4) {\n  (0, _inherits2[\"default\"])(LayerColumnsSchemaV0, _Schema4);\n  var _super4 = _createSuper(LayerColumnsSchemaV0);\n  function LayerColumnsSchemaV0() {\n    var _this4;\n    (0, _classCallCheck2[\"default\"])(this, LayerColumnsSchemaV0);\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    _this4 = _super4.call.apply(_super4, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this4), \"version\", _versions.VERSIONS.v0);\n    return _this4;\n  }\n  (0, _createClass2[\"default\"])(LayerColumnsSchemaV0, [{\n    key: \"load\",\n    value: function load(saved, parents, accumulated) {\n      // fold v0 layer property into config.key, flatten columns\n      return {\n        config: _objectSpread(_objectSpread({}, accumulated.config || {}), {}, {\n          columns: Object.keys(saved).reduce(function (accu, key) {\n            return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, saved[key].value));\n          }, {})\n        })\n      };\n    }\n  }]);\n  return LayerColumnsSchemaV0;\n}(_schema[\"default\"]); // used to convert v0 to v1 layer config.visConfig\n\nvar LayerConfigToVisConfigSchemaV0 = /*#__PURE__*/function (_Schema5) {\n  (0, _inherits2[\"default\"])(LayerConfigToVisConfigSchemaV0, _Schema5);\n  var _super5 = _createSuper(LayerConfigToVisConfigSchemaV0);\n  function LayerConfigToVisConfigSchemaV0() {\n    var _this5;\n    (0, _classCallCheck2[\"default\"])(this, LayerConfigToVisConfigSchemaV0);\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    _this5 = _super5.call.apply(_super5, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this5), \"version\", _versions.VERSIONS.v0);\n    return _this5;\n  }\n  (0, _createClass2[\"default\"])(LayerConfigToVisConfigSchemaV0, [{\n    key: \"load\",\n    value: function load(saved, parents, accumulated) {\n      // fold v0 layer property into config.visConfig\n      var accumulatedConfig = accumulated.config || {};\n      return {\n        config: _objectSpread(_objectSpread({}, accumulatedConfig), {}, {\n          visConfig: _objectSpread(_objectSpread({}, accumulatedConfig.visConfig || {}), {}, (0, _defineProperty2[\"default\"])({}, this.key, saved))\n        })\n      };\n    }\n  }]);\n  return LayerConfigToVisConfigSchemaV0;\n}(_schema[\"default\"]);\nvar LayerVisConfigSchemaV0 = /*#__PURE__*/function (_Schema6) {\n  (0, _inherits2[\"default\"])(LayerVisConfigSchemaV0, _Schema6);\n  var _super6 = _createSuper(LayerVisConfigSchemaV0);\n  function LayerVisConfigSchemaV0() {\n    var _this6;\n    (0, _classCallCheck2[\"default\"])(this, LayerVisConfigSchemaV0);\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n    _this6 = _super6.call.apply(_super6, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this6), \"version\", _versions.VERSIONS.v0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this6), \"key\", 'visConfig');\n    return _this6;\n  }\n  (0, _createClass2[\"default\"])(LayerVisConfigSchemaV0, [{\n    key: \"load\",\n    value: function load(visConfig, parents, accumulator) {\n      var _parents$slice5 = parents.slice(-1),\n        _parents$slice6 = (0, _slicedToArray2[\"default\"])(_parents$slice5, 1),\n        config = _parents$slice6[0];\n      var rename = {\n        geojson: {\n          extruded: 'enable3d',\n          elevationRange: 'heightRange'\n        }\n      };\n      if (config.type in rename) {\n        var propToRename = rename[config.type];\n        return {\n          config: _objectSpread(_objectSpread({}, accumulator.config || {}), {}, {\n            visConfig: Object.keys(visConfig).reduce(function (accu, key) {\n              return _objectSpread(_objectSpread({}, accu), propToRename[key] ? (0, _defineProperty2[\"default\"])({}, propToRename[key], visConfig[key]) : (0, _defineProperty2[\"default\"])({}, key, visConfig[key]));\n            }, {})\n          })\n        };\n      }\n      return {\n        config: _objectSpread(_objectSpread({}, accumulator.config || {}), {}, {\n          visConfig: visConfig\n        })\n      };\n    }\n  }]);\n  return LayerVisConfigSchemaV0;\n}(_schema[\"default\"]);\nvar LayerConfigSchemaDeleteV0 = /*#__PURE__*/function (_Schema7) {\n  (0, _inherits2[\"default\"])(LayerConfigSchemaDeleteV0, _Schema7);\n  var _super7 = _createSuper(LayerConfigSchemaDeleteV0);\n  function LayerConfigSchemaDeleteV0() {\n    var _this7;\n    (0, _classCallCheck2[\"default\"])(this, LayerConfigSchemaDeleteV0);\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    _this7 = _super7.call.apply(_super7, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this7), \"version\", _versions.VERSIONS.v0);\n    return _this7;\n  }\n  (0, _createClass2[\"default\"])(LayerConfigSchemaDeleteV0, [{\n    key: \"load\",\n    value: function load(value) {\n      return {};\n    }\n  }]);\n  return LayerConfigSchemaDeleteV0;\n}(_schema[\"default\"]);\n/**\n * V0 -> V1 Changes\n * - layer is now a class\n * - config saved in a config object\n * - id, type, isAggregated is outside layer.config\n * - visualChannels is outside config, it defines available visual channel and\n *   property names for field, scale, domain and range of each visual chanel.\n * - enable3d, colorAggregation and sizeAggregation are moved into visConfig\n * - GeojsonLayer - added height, radius specific properties\n */\n\nvar layerPropsV0 = {\n  id: null,\n  type: null,\n  // move into layer.config\n  dataId: new LayerConfigSchemaV0({\n    key: 'dataId'\n  }),\n  label: new LayerConfigSchemaV0({\n    key: 'label'\n  }),\n  color: new LayerConfigSchemaV0({\n    key: 'color'\n  }),\n  isVisible: new LayerConfigSchemaV0({\n    key: 'isVisible'\n  }),\n  hidden: new LayerConfigSchemaV0({\n    key: 'hidden'\n  }),\n  // convert visConfig\n  visConfig: new LayerVisConfigSchemaV0({\n    key: 'visConfig'\n  }),\n  // move into layer.config\n  // flatten\n  columns: new LayerColumnsSchemaV0(),\n  // save into visualChannels\n  colorField: new DimensionFieldSchemaV0({\n    properties: dimensionPropsV0,\n    key: 'colorField'\n  }),\n  colorScale: new DimensionScaleSchemaV0({\n    key: 'colorScale'\n  }),\n  sizeField: new DimensionFieldSchemaV0({\n    properties: dimensionPropsV0,\n    key: 'sizeField'\n  }),\n  sizeScale: new DimensionScaleSchemaV0({\n    key: 'sizeScale'\n  }),\n  // move into config.visConfig\n  enable3d: new LayerConfigToVisConfigSchemaV0({\n    key: 'enable3d'\n  }),\n  colorAggregation: new LayerConfigToVisConfigSchemaV0({\n    key: 'colorAggregation'\n  }),\n  sizeAggregation: new LayerConfigToVisConfigSchemaV0({\n    key: 'sizeAggregation'\n  }),\n  // delete\n  isAggregated: new LayerConfigSchemaDeleteV0()\n};\n/**\n * V1 Schema\n */\n\nexports.layerPropsV0 = layerPropsV0;\nvar ColumnSchemaV1 = /*#__PURE__*/function (_Schema8) {\n  (0, _inherits2[\"default\"])(ColumnSchemaV1, _Schema8);\n  var _super8 = _createSuper(ColumnSchemaV1);\n  function ColumnSchemaV1() {\n    (0, _classCallCheck2[\"default\"])(this, ColumnSchemaV1);\n    return _super8.apply(this, arguments);\n  }\n  (0, _createClass2[\"default\"])(ColumnSchemaV1, [{\n    key: \"save\",\n    value: function save(columns, state) {\n      // starting from v1, only save column value\n      // fieldIdx will be calculated during merge\n      return (0, _defineProperty2[\"default\"])({}, this.key, Object.keys(columns).reduce(function (accu, ckey) {\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, ckey, columns[ckey].value));\n      }, {}));\n    }\n  }, {\n    key: \"load\",\n    value: function load(columns) {\n      return {\n        columns: columns\n      };\n    }\n  }]);\n  return ColumnSchemaV1;\n}(_schema[\"default\"]);\nvar TextLabelSchemaV1 = /*#__PURE__*/function (_Schema9) {\n  (0, _inherits2[\"default\"])(TextLabelSchemaV1, _Schema9);\n  var _super9 = _createSuper(TextLabelSchemaV1);\n  function TextLabelSchemaV1() {\n    (0, _classCallCheck2[\"default\"])(this, TextLabelSchemaV1);\n    return _super9.apply(this, arguments);\n  }\n  (0, _createClass2[\"default\"])(TextLabelSchemaV1, [{\n    key: \"save\",\n    value: function save(textLabel) {\n      return (0, _defineProperty2[\"default\"])({}, this.key, textLabel.map(function (tl) {\n        return _objectSpread(_objectSpread({}, tl), {}, {\n          field: tl.field ? (0, _lodash[\"default\"])(tl.field, ['name', 'type']) : null\n        });\n      }));\n    }\n  }, {\n    key: \"load\",\n    value: function load(textLabel) {\n      return {\n        textLabel: Array.isArray(textLabel) ? textLabel : [textLabel]\n      };\n    }\n  }]);\n  return TextLabelSchemaV1;\n}(_schema[\"default\"]);\nvar visualChannelModificationV1 = {\n  geojson: function geojson(vc, parents, accumulator) {\n    var _parents$slice7 = parents.slice(-1),\n      _parents$slice8 = (0, _slicedToArray2[\"default\"])(_parents$slice7, 1),\n      layer = _parents$slice8[0];\n    var isOld = !vc.hasOwnProperty('strokeColorField'); // make our best guess if this geojson layer contains point\n\n    var isPoint = vc.radiusField || layer.config.visConfig.radius !== _layerFactory.LAYER_VIS_CONFIGS.radius.defaultValue;\n    if (isOld && !isPoint && layer.config.visConfig.stroked) {\n      // if stroked is true, copy color config to stroke color config\n      return {\n        strokeColorField: vc.colorField,\n        strokeColorScale: vc.colorScale\n      };\n    }\n    return {};\n  }\n};\n/**\n * V1: save [field]: {name, type}, [scale]: '' for each channel\n */\n\nvar VisualChannelSchemaV1 = /*#__PURE__*/function (_Schema10) {\n  (0, _inherits2[\"default\"])(VisualChannelSchemaV1, _Schema10);\n  var _super10 = _createSuper(VisualChannelSchemaV1);\n  function VisualChannelSchemaV1() {\n    (0, _classCallCheck2[\"default\"])(this, VisualChannelSchemaV1);\n    return _super10.apply(this, arguments);\n  }\n  (0, _createClass2[\"default\"])(VisualChannelSchemaV1, [{\n    key: \"save\",\n    value: function save(visualChannels, parents) {\n      // only save field and scale of each channel\n      var _parents$slice9 = parents.slice(-1),\n        _parents$slice10 = (0, _slicedToArray2[\"default\"])(_parents$slice9, 1),\n        layer = _parents$slice10[0];\n      return (0, _defineProperty2[\"default\"])({}, this.key, Object.keys(visualChannels).reduce(\n      //  save channel to null if didn't select any field\n      function (accu, key) {\n        var _objectSpread8;\n        return _objectSpread(_objectSpread({}, accu), {}, (_objectSpread8 = {}, (0, _defineProperty2[\"default\"])(_objectSpread8, visualChannels[key].field, layer.config[visualChannels[key].field] ? (0, _lodash[\"default\"])(layer.config[visualChannels[key].field], ['name', 'type']) : null), (0, _defineProperty2[\"default\"])(_objectSpread8, visualChannels[key].scale, layer.config[visualChannels[key].scale]), _objectSpread8));\n      }, {}));\n    }\n  }, {\n    key: \"load\",\n    value: function load(vc, parents, accumulator) {\n      // fold channels into config\n      var _parents$slice11 = parents.slice(-1),\n        _parents$slice12 = (0, _slicedToArray2[\"default\"])(_parents$slice11, 1),\n        layer = _parents$slice12[0];\n      var modified = visualChannelModificationV1[layer.type] ? visualChannelModificationV1[layer.type](vc, parents, accumulator) : {};\n      return _objectSpread(_objectSpread({}, accumulator), {}, {\n        config: _objectSpread(_objectSpread(_objectSpread({}, accumulator.config || {}), vc), modified)\n      });\n    }\n  }]);\n  return VisualChannelSchemaV1;\n}(_schema[\"default\"]);\nvar visConfigModificationV1 = {\n  point: function point(visConfig, parents, accumulated) {\n    var modified = {};\n    var _parents$slice13 = parents.slice(-2, -1),\n      _parents$slice14 = (0, _slicedToArray2[\"default\"])(_parents$slice13, 1),\n      layer = _parents$slice14[0];\n    var isOld = !visConfig.hasOwnProperty('filled') && !visConfig.strokeColor && !visConfig.strokeColorRange;\n    if (isOld) {\n      // color color & color range to stroke color\n      modified.strokeColor = layer.config.color;\n      modified.strokeColorRange = (0, _lodash2[\"default\"])(visConfig.colorRange);\n      if (visConfig.outline) {\n        // point layer now supports both outline and fill\n        // for older schema where filled has not been added to point layer\n        // set it to false\n        modified.filled = false;\n      }\n    }\n    return modified;\n  },\n  geojson: function geojson(visConfig, parents, accumulated) {\n    // is points?\n    var modified = {};\n    var _parents$slice15 = parents.slice(-2, -1),\n      _parents$slice16 = (0, _slicedToArray2[\"default\"])(_parents$slice15, 1),\n      layer = _parents$slice16[0];\n    var isOld = layer.visualChannels && !layer.visualChannels.hasOwnProperty('strokeColorField') && !visConfig.strokeColor && !visConfig.strokeColorRange; // make our best guess if this geojson layer contains point\n\n    var isPoint = layer.visualChannels && layer.visualChannels.radiusField || visConfig && visConfig.radius !== _layerFactory.LAYER_VIS_CONFIGS.radius.defaultValue;\n    if (isOld) {\n      // color color & color range to stroke color\n      modified.strokeColor = layer.config.color;\n      modified.strokeColorRange = (0, _lodash2[\"default\"])(visConfig.colorRange);\n      if (isPoint) {\n        // if is point, set stroke to false\n        modified.filled = true;\n        modified.stroked = false;\n      }\n    }\n    return modified;\n  }\n};\nvar VisConfigSchemaV1 = /*#__PURE__*/function (_Schema11) {\n  (0, _inherits2[\"default\"])(VisConfigSchemaV1, _Schema11);\n  var _super11 = _createSuper(VisConfigSchemaV1);\n  function VisConfigSchemaV1() {\n    var _this8;\n    (0, _classCallCheck2[\"default\"])(this, VisConfigSchemaV1);\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    _this8 = _super11.call.apply(_super11, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this8), \"key\", 'visConfig');\n    return _this8;\n  }\n  (0, _createClass2[\"default\"])(VisConfigSchemaV1, [{\n    key: \"load\",\n    value: function load(visConfig, parents, accumulated) {\n      var _parents$slice17 = parents.slice(-2, -1),\n        _parents$slice18 = (0, _slicedToArray2[\"default\"])(_parents$slice17, 1),\n        layer = _parents$slice18[0];\n      var modified = visConfigModificationV1[layer.type] ? visConfigModificationV1[layer.type](visConfig, parents, accumulated) : {};\n      return {\n        visConfig: _objectSpread(_objectSpread({}, visConfig), modified)\n      };\n    }\n  }]);\n  return VisConfigSchemaV1;\n}(_schema[\"default\"]);\nvar layerPropsV1 = {\n  id: null,\n  type: null,\n  config: new _schema[\"default\"]({\n    version: _versions.VERSIONS.v1,\n    key: 'config',\n    properties: {\n      dataId: null,\n      label: null,\n      color: null,\n      highlightColor: null,\n      columns: new ColumnSchemaV1({\n        version: _versions.VERSIONS.v1,\n        key: 'columns'\n      }),\n      isVisible: null,\n      visConfig: new VisConfigSchemaV1({\n        version: _versions.VERSIONS.v1\n      }),\n      hidden: null,\n      textLabel: new TextLabelSchemaV1({\n        version: _versions.VERSIONS.v1,\n        key: 'textLabel'\n      })\n    }\n  }),\n  visualChannels: new VisualChannelSchemaV1({\n    version: _versions.VERSIONS.v1,\n    key: 'visualChannels'\n  })\n};\nexports.layerPropsV1 = layerPropsV1;\nvar LayerSchemaV0 = /*#__PURE__*/function (_Schema12) {\n  (0, _inherits2[\"default\"])(LayerSchemaV0, _Schema12);\n  var _super12 = _createSuper(LayerSchemaV0);\n  function LayerSchemaV0() {\n    var _this9;\n    (0, _classCallCheck2[\"default\"])(this, LayerSchemaV0);\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n    _this9 = _super12.call.apply(_super12, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this9), \"key\", 'layers');\n    return _this9;\n  }\n  (0, _createClass2[\"default\"])(LayerSchemaV0, [{\n    key: \"save\",\n    value: function save(layers, parents) {\n      var _this10 = this;\n      var _parents$slice19 = parents.slice(-1),\n        _parents$slice20 = (0, _slicedToArray2[\"default\"])(_parents$slice19, 1),\n        visState = _parents$slice20[0];\n      return (0, _defineProperty2[\"default\"])({}, this.key, visState.layerOrder.reduce(function (saved, index) {\n        // save layers according to their rendering order\n        var layer = layers[index];\n        if (layer.isValidToSave()) {\n          saved.push(_this10.savePropertiesOrApplySchema(layer).layers);\n        }\n        return saved;\n      }, []));\n    }\n  }, {\n    key: \"load\",\n    value: function load(layers) {\n      var _this11 = this;\n      return (0, _defineProperty2[\"default\"])({}, this.key, layers.map(function (layer) {\n        return _this11.loadPropertiesOrApplySchema(layer, layers).layers;\n      }));\n    }\n  }]);\n  return LayerSchemaV0;\n}(_schema[\"default\"]);\nexports.LayerSchemaV0 = LayerSchemaV0;\nvar FilterSchemaV0 = /*#__PURE__*/function (_Schema13) {\n  (0, _inherits2[\"default\"])(FilterSchemaV0, _Schema13);\n  var _super13 = _createSuper(FilterSchemaV0);\n  function FilterSchemaV0() {\n    var _this12;\n    (0, _classCallCheck2[\"default\"])(this, FilterSchemaV0);\n    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      args[_key10] = arguments[_key10];\n    }\n    _this12 = _super13.call.apply(_super13, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this12), \"key\", 'filters');\n    return _this12;\n  }\n  (0, _createClass2[\"default\"])(FilterSchemaV0, [{\n    key: \"save\",\n    value: function save(filters) {\n      var _this13 = this;\n      return {\n        filters: filters.filter(_filterUtils.isValidFilterValue).map(function (filter) {\n          return _this13.savePropertiesOrApplySchema(filter).filters;\n        })\n      };\n    }\n  }, {\n    key: \"load\",\n    value: function load(filters) {\n      return {\n        filters: filters\n      };\n    }\n  }]);\n  return FilterSchemaV0;\n}(_schema[\"default\"]);\nexports.FilterSchemaV0 = FilterSchemaV0;\nvar interactionPropsV0 = ['tooltip', 'brush'];\nvar InteractionSchemaV0 = /*#__PURE__*/function (_Schema14) {\n  (0, _inherits2[\"default\"])(InteractionSchemaV0, _Schema14);\n  var _super14 = _createSuper(InteractionSchemaV0);\n  function InteractionSchemaV0() {\n    var _this14;\n    (0, _classCallCheck2[\"default\"])(this, InteractionSchemaV0);\n    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      args[_key11] = arguments[_key11];\n    }\n    _this14 = _super14.call.apply(_super14, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this14), \"key\", 'interactionConfig');\n    return _this14;\n  }\n  (0, _createClass2[\"default\"])(InteractionSchemaV0, [{\n    key: \"save\",\n    value: function save(interactionConfig) {\n      return Array.isArray(this.properties) ? (0, _defineProperty2[\"default\"])({}, this.key, this.properties.reduce(function (accu, key) {\n        return _objectSpread(_objectSpread({}, accu), interactionConfig[key].enabled ? (0, _defineProperty2[\"default\"])({}, key, interactionConfig[key].config) : {});\n      }, {})) : {};\n    }\n  }, {\n    key: \"load\",\n    value: function load(interactionConfig) {\n      // convert v0 -> v1\n      // return enabled: false if disabled,\n      return Array.isArray(this.properties) ? (0, _defineProperty2[\"default\"])({}, this.key, this.properties.reduce(function (accu, key) {\n        return _objectSpread(_objectSpread({}, accu), (0, _defineProperty2[\"default\"])({}, key, _objectSpread(_objectSpread({}, interactionConfig[key] || {}), {}, {\n          enabled: Boolean(interactionConfig[key])\n        })));\n      }, {})) : {};\n    }\n  }]);\n  return InteractionSchemaV0;\n}(_schema[\"default\"]);\nvar interactionPropsV1 = [].concat(interactionPropsV0, ['geocoder', 'coordinate']);\nvar InteractionSchemaV1 = /*#__PURE__*/function (_Schema15) {\n  (0, _inherits2[\"default\"])(InteractionSchemaV1, _Schema15);\n  var _super15 = _createSuper(InteractionSchemaV1);\n  function InteractionSchemaV1() {\n    var _this15;\n    (0, _classCallCheck2[\"default\"])(this, InteractionSchemaV1);\n    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n      args[_key12] = arguments[_key12];\n    }\n    _this15 = _super15.call.apply(_super15, [this].concat(args));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this15), \"key\", 'interactionConfig');\n    return _this15;\n  }\n  (0, _createClass2[\"default\"])(InteractionSchemaV1, [{\n    key: \"save\",\n    value: function save(interactionConfig) {\n      // save config even if disabled,\n      return Array.isArray(this.properties) ? (0, _defineProperty2[\"default\"])({}, this.key, this.properties.reduce(function (accu, key) {\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, _objectSpread(_objectSpread({}, interactionConfig[key].config), {}, {\n          enabled: interactionConfig[key].enabled\n        })));\n      }, {})) : {};\n    }\n  }, {\n    key: \"load\",\n    value: function load(interactionConfig) {\n      var _this16 = this;\n      var modifiedConfig = interactionConfig;\n      Object.keys(interactionConfig).forEach(function (configType) {\n        if (configType === 'tooltip') {\n          var fieldsToShow = modifiedConfig[configType].fieldsToShow;\n          if (!(0, _dataUtils.notNullorUndefined)(fieldsToShow)) {\n            return (0, _defineProperty2[\"default\"])({}, _this16.key, modifiedConfig);\n          }\n          Object.keys(fieldsToShow).forEach(function (key) {\n            fieldsToShow[key] = fieldsToShow[key].map(function (fieldData) {\n              if (!fieldData.name) {\n                return {\n                  name: fieldData,\n                  format: null\n                };\n              }\n              return fieldData;\n            });\n          });\n        }\n        return;\n      });\n      return (0, _defineProperty2[\"default\"])({}, this.key, modifiedConfig);\n    }\n  }]);\n  return InteractionSchemaV1;\n}(_schema[\"default\"]);\nexports.InteractionSchemaV1 = InteractionSchemaV1;\nvar filterPropsV0 = {\n  dataId: null,\n  id: null,\n  name: null,\n  type: null,\n  value: null,\n  enlarged: null\n};\nexports.filterPropsV0 = filterPropsV0;\nvar DimensionFieldSchema = /*#__PURE__*/function (_Schema16) {\n  (0, _inherits2[\"default\"])(DimensionFieldSchema, _Schema16);\n  var _super16 = _createSuper(DimensionFieldSchema);\n  function DimensionFieldSchema() {\n    (0, _classCallCheck2[\"default\"])(this, DimensionFieldSchema);\n    return _super16.apply(this, arguments);\n  }\n  (0, _createClass2[\"default\"])(DimensionFieldSchema, [{\n    key: \"save\",\n    value: function save(field) {\n      return (0, _defineProperty2[\"default\"])({}, this.key, field ? this.savePropertiesOrApplySchema(field)[this.key] : null);\n    }\n  }, {\n    key: \"load\",\n    value: function load(field) {\n      return (0, _defineProperty2[\"default\"])({}, this.key, field);\n    }\n  }]);\n  return DimensionFieldSchema;\n}(_schema[\"default\"]);\nexports.DimensionFieldSchema = DimensionFieldSchema;\nvar SplitMapsSchema = /*#__PURE__*/function (_Schema17) {\n  (0, _inherits2[\"default\"])(SplitMapsSchema, _Schema17);\n  var _super17 = _createSuper(SplitMapsSchema);\n  function SplitMapsSchema() {\n    (0, _classCallCheck2[\"default\"])(this, SplitMapsSchema);\n    return _super17.apply(this, arguments);\n  }\n  (0, _createClass2[\"default\"])(SplitMapsSchema, [{\n    key: \"convertLayerSettings\",\n    value: function convertLayerSettings(accu, _ref18) {\n      var _ref19 = (0, _slicedToArray2[\"default\"])(_ref18, 2),\n        key = _ref19[0],\n        value = _ref19[1];\n      if (typeof value === 'boolean') {\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, value));\n      } else if (value && (0, _typeof2[\"default\"])(value) === 'object' && value.isAvailable) {\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, Boolean(value.isVisible)));\n      }\n      return accu;\n    }\n  }, {\n    key: \"load\",\n    value: function load(splitMaps) {\n      var _this17 = this;\n\n      // previous splitMaps Schema {layers: {layerId: {isVisible, isAvailable}}}\n      if (!Array.isArray(splitMaps) || !splitMaps.length) {\n        return {\n          splitMaps: []\n        };\n      }\n      return {\n        splitMaps: splitMaps.map(function (settings) {\n          return _objectSpread(_objectSpread({}, settings), {}, {\n            layers: Object.entries(settings.layers || {}).reduce(_this17.convertLayerSettings, {})\n          });\n        })\n      };\n    }\n  }]);\n  return SplitMapsSchema;\n}(_schema[\"default\"]);\nexports.SplitMapsSchema = SplitMapsSchema;\nvar filterPropsV1 = _objectSpread(_objectSpread({}, filterPropsV0), {}, {\n  plotType: null,\n  animationWindow: null,\n  yAxis: new DimensionFieldSchema({\n    version: _versions.VERSIONS.v1,\n    key: 'yAxis',\n    properties: {\n      name: null,\n      type: null\n    }\n  }),\n  // polygon filter properties\n  layerId: null,\n  speed: null\n});\nexports.filterPropsV1 = filterPropsV1;\nvar propertiesV0 = {\n  filters: new FilterSchemaV0({\n    version: _versions.VERSIONS.v0,\n    properties: filterPropsV0\n  }),\n  layers: new LayerSchemaV0({\n    version: _versions.VERSIONS.v0,\n    properties: layerPropsV0\n  }),\n  interactionConfig: new InteractionSchemaV0({\n    version: _versions.VERSIONS.v0,\n    properties: interactionPropsV0\n  }),\n  layerBlending: null\n};\nexports.propertiesV0 = propertiesV0;\nvar propertiesV1 = {\n  filters: new FilterSchemaV0({\n    version: _versions.VERSIONS.v1,\n    properties: filterPropsV1\n  }),\n  layers: new LayerSchemaV0({\n    version: _versions.VERSIONS.v1,\n    properties: layerPropsV1\n  }),\n  interactionConfig: new InteractionSchemaV1({\n    version: _versions.VERSIONS.v1,\n    properties: interactionPropsV1\n  }),\n  layerBlending: null,\n  splitMaps: new SplitMapsSchema({\n    key: 'splitMaps',\n    version: _versions.VERSIONS.v1\n  }),\n  animationConfig: new _schema[\"default\"]({\n    version: _versions.VERSIONS.v1,\n    properties: {\n      currentTime: null,\n      speed: null\n    },\n    key: 'animationConfig'\n  })\n};\nexports.propertiesV1 = propertiesV1;\nvar visStateSchemaV0 = new _schema[\"default\"]({\n  version: _versions.VERSIONS.v0,\n  properties: propertiesV0,\n  key: 'visState'\n});\nexports.visStateSchemaV0 = visStateSchemaV0;\nvar visStateSchemaV1 = new _schema[\"default\"]({\n  version: _versions.VERSIONS.v1,\n  properties: propertiesV1,\n  key: 'visState'\n});\nexports.visStateSchemaV1 = visStateSchemaV1;\nvar visStateSchema = (_visStateSchema = {}, (0, _defineProperty2[\"default\"])(_visStateSchema, _versions.VERSIONS.v0, {\n  save: function save(toSave) {\n    return visStateSchemaV0.save(toSave);\n  },\n  load: function load(toLoad) {\n    return visStateSchemaV1.load(visStateSchemaV0.load(toLoad).visState);\n  }\n}), (0, _defineProperty2[\"default\"])(_visStateSchema, _versions.VERSIONS.v1, visStateSchemaV1), _visStateSchema); // test load v0\n\nexports.visStateSchema = visStateSchema;\nvar _default = visStateSchema;\nexports[\"default\"] = _default;","map":{"version":3,"names":["_lodash","_interopRequireDefault","require","_versions","_filterUtils","_layerFactory","_schema","_lodash2","_dataUtils","dimensionPropsV0","geojsonSizeFieldV0ToV1","config","defaultRaiuds","defaultRadiusRange","visConfig","extruded","stroked","radius","radiusRange","some","d","i","DimensionFieldSchemaV0","VERSIONS","v0","save","field","_defineProperty2","key","savePropertiesOrApplySchema","load","parents","accumulated","_parents$slice","slice","_parents$slice2","_slicedToArray2","fieldName","type","visualChannels","_objectSpread","DimensionScaleSchemaV0","scale","_parents$slice3","_parents$slice4","LayerConfigSchemaV0","saved","LayerColumnsSchemaV0","columns","Object","keys","reduce","accu","value","LayerConfigToVisConfigSchemaV0","accumulatedConfig","LayerVisConfigSchemaV0","accumulator","_parents$slice5","_parents$slice6","rename","geojson","elevationRange","propToRename","LayerConfigSchemaDeleteV0","layerPropsV0","id","dataId","label","color","isVisible","hidden","colorField","properties","colorScale","sizeField","sizeScale","enable3d","colorAggregation","sizeAggregation","isAggregated","ColumnSchemaV1","state","ckey","TextLabelSchemaV1","textLabel","map","tl","Array","isArray","visualChannelModificationV1","vc","_parents$slice7","_parents$slice8","layer","isOld","hasOwnProperty","isPoint","radiusField","LAYER_VIS_CONFIGS","defaultValue","strokeColorField","strokeColorScale","VisualChannelSchemaV1","_parents$slice9","_parents$slice10","_objectSpread8","_parents$slice11","_parents$slice12","modified","visConfigModificationV1","point","_parents$slice13","_parents$slice14","strokeColor","strokeColorRange","colorRange","outline","filled","_parents$slice15","_parents$slice16","VisConfigSchemaV1","_parents$slice17","_parents$slice18","layerPropsV1","version","v1","highlightColor","LayerSchemaV0","layers","_this10","_parents$slice19","_parents$slice20","visState","layerOrder","index","isValidToSave","push","_this11","loadPropertiesOrApplySchema","FilterSchemaV0","filters","_this13","filter","isValidFilterValue","interactionPropsV0","InteractionSchemaV0","interactionConfig","enabled","Boolean","interactionPropsV1","concat","InteractionSchemaV1","_this16","modifiedConfig","forEach","configType","fieldsToShow","notNullorUndefined","fieldData","name","format","filterPropsV0","enlarged","DimensionFieldSchema","SplitMapsSchema","convertLayerSettings","_ref18","_ref19","_typeof2","isAvailable","splitMaps","_this17","length","settings","entries","filterPropsV1","plotType","animationWindow","yAxis","layerId","speed","propertiesV0","layerBlending","propertiesV1","animationConfig","currentTime","visStateSchemaV0","visStateSchemaV1","visStateSchema","_visStateSchema","toSave","toLoad"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/kepler.gl/src/schemas/vis-state-schema.js"],"sourcesContent":["// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport pick from 'lodash.pick';\nimport {VERSIONS} from './versions';\nimport {isValidFilterValue} from 'utils/filter-utils';\nimport {LAYER_VIS_CONFIGS} from 'layers/layer-factory';\nimport Schema from './schema';\nimport cloneDeep from 'lodash.clonedeep';\nimport {notNullorUndefined} from 'utils/data-utils';\n\n/**\n * V0 Schema\n */\n\nexport const dimensionPropsV0 = ['name', 'type'];\n\n// in v0 geojson there is only sizeField\n\n// in v1 geojson\n// stroke base on -> sizeField\n// height based on -> heightField\n// radius based on -> radiusField\n// here we make our wiredst guess on which channel sizeField belongs to\nfunction geojsonSizeFieldV0ToV1(config) {\n  const defaultRaiuds = 10;\n  const defaultRadiusRange = [0, 50];\n\n  // if extruded, sizeField is most likely used for height\n  if (config.visConfig.extruded) {\n    return 'heightField';\n  }\n\n  // if show stroke enabled, sizeField is most likely used for stroke\n  if (config.visConfig.stroked) {\n    return 'sizeField';\n  }\n\n  // if radius changed, or radius Range Changed, sizeField is most likely used for radius\n  // this is the most unreliable guess, that's why we put it in the end\n  if (\n    config.visConfig.radius !== defaultRaiuds ||\n    config.visConfig.radiusRange.some((d, i) => d !== defaultRadiusRange[i])\n  ) {\n    return 'radiusField';\n  }\n\n  return 'sizeField';\n}\n\n// convert v0 to v1 layer config\nclass DimensionFieldSchemaV0 extends Schema {\n  version = VERSIONS.v0;\n  save(field) {\n    // should not be called anymore\n    return {\n      [this.key]: field !== null ? this.savePropertiesOrApplySchema(field)[this.key] : null\n    };\n  }\n\n  load(field, parents, accumulated) {\n    const [config] = parents.slice(-1);\n    let fieldName = this.key;\n    if (config.type === 'geojson' && this.key === 'sizeField' && field) {\n      fieldName = geojsonSizeFieldV0ToV1(config);\n    }\n    // fold into visualChannels to be load by VisualChannelSchemaV1\n    return {\n      visualChannels: {\n        ...(accumulated.visualChannels || {}),\n        [fieldName]: field\n      }\n    };\n  }\n}\n\nclass DimensionScaleSchemaV0 extends Schema {\n  version = VERSIONS.v0;\n  save(scale) {\n    return {[this.key]: scale};\n  }\n  load(scale, parents, accumulated) {\n    const [config] = parents.slice(-1);\n    // fold into visualChannels to be load by VisualChannelSchemaV1\n    if (this.key === 'sizeScale' && config.type === 'geojson') {\n      // sizeScale now split into radiusScale, heightScale\n      // no user customization, just use default\n      return {};\n    }\n\n    return {\n      visualChannels: {\n        ...(accumulated.visualChannels || {}),\n        [this.key]: scale\n      }\n    };\n  }\n}\n\n// used to convert v0 to v1 layer config\nclass LayerConfigSchemaV0 extends Schema {\n  version = VERSIONS.v0;\n  load(saved, parents, accumulated) {\n    // fold v0 layer property into config.key\n    return {\n      config: {\n        ...(accumulated.config || {}),\n        [this.key]: saved\n      }\n    };\n  }\n}\n\n// used to convert v0 to v1 layer columns\n// only return column value for each column\nclass LayerColumnsSchemaV0 extends Schema {\n  version = VERSIONS.v0;\n  load(saved, parents, accumulated) {\n    // fold v0 layer property into config.key, flatten columns\n    return {\n      config: {\n        ...(accumulated.config || {}),\n        columns: Object.keys(saved).reduce(\n          (accu, key) => ({\n            ...accu,\n            [key]: saved[key].value\n          }),\n          {}\n        )\n      }\n    };\n  }\n}\n\n// used to convert v0 to v1 layer config.visConfig\nclass LayerConfigToVisConfigSchemaV0 extends Schema {\n  version = VERSIONS.v0;\n  load(saved, parents, accumulated) {\n    // fold v0 layer property into config.visConfig\n    const accumulatedConfig = accumulated.config || {};\n    return {\n      config: {\n        ...accumulatedConfig,\n        visConfig: {\n          ...(accumulatedConfig.visConfig || {}),\n          [this.key]: saved\n        }\n      }\n    };\n  }\n}\n\nclass LayerVisConfigSchemaV0 extends Schema {\n  version = VERSIONS.v0;\n  key = 'visConfig';\n\n  load(visConfig, parents, accumulator) {\n    const [config] = parents.slice(-1);\n    const rename = {\n      geojson: {\n        extruded: 'enable3d',\n        elevationRange: 'heightRange'\n      }\n    };\n\n    if (config.type in rename) {\n      const propToRename = rename[config.type];\n      return {\n        config: {\n          ...(accumulator.config || {}),\n          visConfig: Object.keys(visConfig).reduce(\n            (accu, key) => ({\n              ...accu,\n              ...(propToRename[key]\n                ? {[propToRename[key]]: visConfig[key]}\n                : {[key]: visConfig[key]})\n            }),\n            {}\n          )\n        }\n      };\n    }\n\n    return {\n      config: {\n        ...(accumulator.config || {}),\n        visConfig\n      }\n    };\n  }\n}\n\nclass LayerConfigSchemaDeleteV0 extends Schema {\n  version = VERSIONS.v0;\n  load(value) {\n    return {};\n  }\n}\n\n/**\n * V0 -> V1 Changes\n * - layer is now a class\n * - config saved in a config object\n * - id, type, isAggregated is outside layer.config\n * - visualChannels is outside config, it defines available visual channel and\n *   property names for field, scale, domain and range of each visual chanel.\n * - enable3d, colorAggregation and sizeAggregation are moved into visConfig\n * - GeojsonLayer - added height, radius specific properties\n */\n\nexport const layerPropsV0 = {\n  id: null,\n  type: null,\n\n  // move into layer.config\n  dataId: new LayerConfigSchemaV0({key: 'dataId'}),\n  label: new LayerConfigSchemaV0({key: 'label'}),\n  color: new LayerConfigSchemaV0({key: 'color'}),\n  isVisible: new LayerConfigSchemaV0({key: 'isVisible'}),\n  hidden: new LayerConfigSchemaV0({key: 'hidden'}),\n\n  // convert visConfig\n  visConfig: new LayerVisConfigSchemaV0({key: 'visConfig'}),\n\n  // move into layer.config\n  // flatten\n  columns: new LayerColumnsSchemaV0(),\n\n  // save into visualChannels\n  colorField: new DimensionFieldSchemaV0({\n    properties: dimensionPropsV0,\n    key: 'colorField'\n  }),\n  colorScale: new DimensionScaleSchemaV0({\n    key: 'colorScale'\n  }),\n  sizeField: new DimensionFieldSchemaV0({\n    properties: dimensionPropsV0,\n    key: 'sizeField'\n  }),\n  sizeScale: new DimensionScaleSchemaV0({\n    key: 'sizeScale'\n  }),\n\n  // move into config.visConfig\n  enable3d: new LayerConfigToVisConfigSchemaV0({key: 'enable3d'}),\n  colorAggregation: new LayerConfigToVisConfigSchemaV0({\n    key: 'colorAggregation'\n  }),\n  sizeAggregation: new LayerConfigToVisConfigSchemaV0({key: 'sizeAggregation'}),\n\n  // delete\n  isAggregated: new LayerConfigSchemaDeleteV0()\n};\n\n/**\n * V1 Schema\n */\nclass ColumnSchemaV1 extends Schema {\n  save(columns, state) {\n    // starting from v1, only save column value\n    // fieldIdx will be calculated during merge\n    return {\n      [this.key]: Object.keys(columns).reduce(\n        (accu, ckey) => ({\n          ...accu,\n          [ckey]: columns[ckey].value\n        }),\n        {}\n      )\n    };\n  }\n\n  load(columns) {\n    return {columns};\n  }\n}\n\nclass TextLabelSchemaV1 extends Schema {\n  save(textLabel) {\n    return {\n      [this.key]: textLabel.map(tl => ({\n        ...tl,\n        field: tl.field ? pick(tl.field, ['name', 'type']) : null\n      }))\n    };\n  }\n\n  load(textLabel) {\n    return {textLabel: Array.isArray(textLabel) ? textLabel : [textLabel]};\n  }\n}\n\nconst visualChannelModificationV1 = {\n  geojson: (vc, parents, accumulator) => {\n    const [layer] = parents.slice(-1);\n    const isOld = !vc.hasOwnProperty('strokeColorField');\n    // make our best guess if this geojson layer contains point\n    const isPoint =\n      vc.radiusField || layer.config.visConfig.radius !== LAYER_VIS_CONFIGS.radius.defaultValue;\n\n    if (isOld && !isPoint && layer.config.visConfig.stroked) {\n      // if stroked is true, copy color config to stroke color config\n      return {\n        strokeColorField: vc.colorField,\n        strokeColorScale: vc.colorScale\n      };\n    }\n    return {};\n  }\n};\n/**\n * V1: save [field]: {name, type}, [scale]: '' for each channel\n */\nclass VisualChannelSchemaV1 extends Schema {\n  save(visualChannels, parents) {\n    // only save field and scale of each channel\n    const [layer] = parents.slice(-1);\n    return {\n      [this.key]: Object.keys(visualChannels).reduce(\n        //  save channel to null if didn't select any field\n        (accu, key) => ({\n          ...accu,\n          [visualChannels[key].field]: layer.config[visualChannels[key].field]\n            ? pick(layer.config[visualChannels[key].field], ['name', 'type'])\n            : null,\n          [visualChannels[key].scale]: layer.config[visualChannels[key].scale]\n        }),\n        {}\n      )\n    };\n  }\n  load(vc, parents, accumulator) {\n    // fold channels into config\n    const [layer] = parents.slice(-1);\n    const modified = visualChannelModificationV1[layer.type]\n      ? visualChannelModificationV1[layer.type](vc, parents, accumulator)\n      : {};\n\n    return {\n      ...accumulator,\n      config: {\n        ...(accumulator.config || {}),\n        ...vc,\n        ...modified\n      }\n    };\n  }\n}\nconst visConfigModificationV1 = {\n  point: (visConfig, parents, accumulated) => {\n    const modified = {};\n    const [layer] = parents.slice(-2, -1);\n    const isOld =\n      !visConfig.hasOwnProperty('filled') && !visConfig.strokeColor && !visConfig.strokeColorRange;\n    if (isOld) {\n      // color color & color range to stroke color\n      modified.strokeColor = layer.config.color;\n      modified.strokeColorRange = cloneDeep(visConfig.colorRange);\n      if (visConfig.outline) {\n        // point layer now supports both outline and fill\n        // for older schema where filled has not been added to point layer\n        // set it to false\n        modified.filled = false;\n      }\n    }\n\n    return modified;\n  },\n  geojson: (visConfig, parents, accumulated) => {\n    // is points?\n    const modified = {};\n    const [layer] = parents.slice(-2, -1);\n    const isOld =\n      layer.visualChannels &&\n      !layer.visualChannels.hasOwnProperty('strokeColorField') &&\n      !visConfig.strokeColor &&\n      !visConfig.strokeColorRange;\n    // make our best guess if this geojson layer contains point\n    const isPoint =\n      (layer.visualChannels && layer.visualChannels.radiusField) ||\n      (visConfig && visConfig.radius !== LAYER_VIS_CONFIGS.radius.defaultValue);\n\n    if (isOld) {\n      // color color & color range to stroke color\n      modified.strokeColor = layer.config.color;\n      modified.strokeColorRange = cloneDeep(visConfig.colorRange);\n      if (isPoint) {\n        // if is point, set stroke to false\n        modified.filled = true;\n        modified.stroked = false;\n      }\n    }\n\n    return modified;\n  }\n};\n\nclass VisConfigSchemaV1 extends Schema {\n  key = 'visConfig';\n\n  load(visConfig, parents, accumulated) {\n    const [layer] = parents.slice(-2, -1);\n    const modified = visConfigModificationV1[layer.type]\n      ? visConfigModificationV1[layer.type](visConfig, parents, accumulated)\n      : {};\n\n    return {\n      visConfig: {\n        ...visConfig,\n        ...modified\n      }\n    };\n  }\n}\n\nexport const layerPropsV1 = {\n  id: null,\n  type: null,\n  config: new Schema({\n    version: VERSIONS.v1,\n    key: 'config',\n    properties: {\n      dataId: null,\n      label: null,\n      color: null,\n      highlightColor: null,\n      columns: new ColumnSchemaV1({\n        version: VERSIONS.v1,\n        key: 'columns'\n      }),\n      isVisible: null,\n      visConfig: new VisConfigSchemaV1({\n        version: VERSIONS.v1\n      }),\n      hidden: null,\n      textLabel: new TextLabelSchemaV1({\n        version: VERSIONS.v1,\n        key: 'textLabel'\n      })\n    }\n  }),\n  visualChannels: new VisualChannelSchemaV1({\n    version: VERSIONS.v1,\n    key: 'visualChannels'\n  })\n};\n\nexport class LayerSchemaV0 extends Schema {\n  key = 'layers';\n\n  save(layers, parents) {\n    const [visState] = parents.slice(-1);\n\n    return {\n      [this.key]: visState.layerOrder.reduce((saved, index) => {\n        // save layers according to their rendering order\n        const layer = layers[index];\n        if (layer.isValidToSave()) {\n          saved.push(this.savePropertiesOrApplySchema(layer).layers);\n        }\n        return saved;\n      }, [])\n    };\n  }\n\n  load(layers) {\n    return {\n      [this.key]: layers.map(layer => this.loadPropertiesOrApplySchema(layer, layers).layers)\n    };\n  }\n}\n\nexport class FilterSchemaV0 extends Schema {\n  key = 'filters';\n  save(filters) {\n    return {\n      filters: filters\n        .filter(isValidFilterValue)\n        .map(filter => this.savePropertiesOrApplySchema(filter).filters)\n    };\n  }\n  load(filters) {\n    return {filters};\n  }\n}\n\nconst interactionPropsV0 = ['tooltip', 'brush'];\n\nclass InteractionSchemaV0 extends Schema {\n  key = 'interactionConfig';\n\n  save(interactionConfig) {\n    return Array.isArray(this.properties)\n      ? {\n          [this.key]: this.properties.reduce(\n            (accu, key) => ({\n              ...accu,\n              ...(interactionConfig[key].enabled ? {[key]: interactionConfig[key].config} : {})\n            }),\n            {}\n          )\n        }\n      : {};\n  }\n  load(interactionConfig) {\n    // convert v0 -> v1\n    // return enabled: false if disabled,\n    return Array.isArray(this.properties)\n      ? {\n          [this.key]: this.properties.reduce(\n            (accu, key) => ({\n              ...accu,\n              ...{\n                [key]: {\n                  ...(interactionConfig[key] || {}),\n                  enabled: Boolean(interactionConfig[key])\n                }\n              }\n            }),\n            {}\n          )\n        }\n      : {};\n  }\n}\n\nconst interactionPropsV1 = [...interactionPropsV0, 'geocoder', 'coordinate'];\n\nexport class InteractionSchemaV1 extends Schema {\n  key = 'interactionConfig';\n\n  save(interactionConfig) {\n    // save config even if disabled,\n    return Array.isArray(this.properties)\n      ? {\n          [this.key]: this.properties.reduce(\n            (accu, key) => ({\n              ...accu,\n              [key]: {\n                ...interactionConfig[key].config,\n                enabled: interactionConfig[key].enabled\n              }\n            }),\n            {}\n          )\n        }\n      : {};\n  }\n  load(interactionConfig) {\n    const modifiedConfig = interactionConfig;\n    Object.keys(interactionConfig).forEach(configType => {\n      if (configType === 'tooltip') {\n        const fieldsToShow = modifiedConfig[configType].fieldsToShow;\n        if (!notNullorUndefined(fieldsToShow)) {\n          return {[this.key]: modifiedConfig};\n        }\n        Object.keys(fieldsToShow).forEach(key => {\n          fieldsToShow[key] = fieldsToShow[key].map(fieldData => {\n            if (!fieldData.name) {\n              return {\n                name: fieldData,\n                format: null\n              };\n            }\n            return fieldData;\n          });\n        });\n      }\n      return;\n    });\n    return {[this.key]: modifiedConfig};\n  }\n}\n\nexport const filterPropsV0 = {\n  dataId: null,\n  id: null,\n  name: null,\n  type: null,\n  value: null,\n  enlarged: null\n};\n\nexport class DimensionFieldSchema extends Schema {\n  save(field) {\n    return {\n      [this.key]: field ? this.savePropertiesOrApplySchema(field)[this.key] : null\n    };\n  }\n\n  load(field) {\n    return {[this.key]: field};\n  }\n}\n\nexport class SplitMapsSchema extends Schema {\n  convertLayerSettings(accu, [key, value]) {\n    if (typeof value === 'boolean') {\n      return {\n        ...accu,\n        [key]: value\n      };\n    } else if (value && typeof value === 'object' && value.isAvailable) {\n      return {\n        ...accu,\n        [key]: Boolean(value.isVisible)\n      };\n    }\n    return accu;\n  }\n\n  load(splitMaps) {\n    // previous splitMaps Schema {layers: {layerId: {isVisible, isAvailable}}}\n\n    if (!Array.isArray(splitMaps) || !splitMaps.length) {\n      return {splitMaps: []};\n    }\n\n    return {\n      splitMaps: splitMaps.map(settings => ({\n        ...settings,\n        layers: Object.entries(settings.layers || {}).reduce(this.convertLayerSettings, {})\n      }))\n    };\n  }\n}\n\nexport const filterPropsV1 = {\n  ...filterPropsV0,\n  plotType: null,\n  animationWindow: null,\n  yAxis: new DimensionFieldSchema({\n    version: VERSIONS.v1,\n    key: 'yAxis',\n    properties: {\n      name: null,\n      type: null\n    }\n  }),\n\n  // polygon filter properties\n  layerId: null,\n  speed: null\n};\n\nexport const propertiesV0 = {\n  filters: new FilterSchemaV0({\n    version: VERSIONS.v0,\n    properties: filterPropsV0\n  }),\n  layers: new LayerSchemaV0({\n    version: VERSIONS.v0,\n    properties: layerPropsV0\n  }),\n  interactionConfig: new InteractionSchemaV0({\n    version: VERSIONS.v0,\n    properties: interactionPropsV0\n  }),\n  layerBlending: null\n};\n\nexport const propertiesV1 = {\n  filters: new FilterSchemaV0({\n    version: VERSIONS.v1,\n    properties: filterPropsV1\n  }),\n  layers: new LayerSchemaV0({\n    version: VERSIONS.v1,\n    properties: layerPropsV1\n  }),\n  interactionConfig: new InteractionSchemaV1({\n    version: VERSIONS.v1,\n    properties: interactionPropsV1\n  }),\n  layerBlending: null,\n  splitMaps: new SplitMapsSchema({\n    key: 'splitMaps',\n    version: VERSIONS.v1\n  }),\n  animationConfig: new Schema({\n    version: VERSIONS.v1,\n    properties: {\n      currentTime: null,\n      speed: null\n    },\n    key: 'animationConfig'\n  })\n};\n\nexport const visStateSchemaV0 = new Schema({\n  version: VERSIONS.v0,\n  properties: propertiesV0,\n  key: 'visState'\n});\n\nexport const visStateSchemaV1 = new Schema({\n  version: VERSIONS.v1,\n  properties: propertiesV1,\n  key: 'visState'\n});\n\nexport const visStateSchema = {\n  [VERSIONS.v0]: {\n    save: toSave => visStateSchemaV0.save(toSave),\n    load: toLoad => visStateSchemaV1.load(visStateSchemaV0.load(toLoad).visState)\n  },\n  [VERSIONS.v1]: visStateSchemaV1\n};\n\n// test load v0\nexport default visStateSchema;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}