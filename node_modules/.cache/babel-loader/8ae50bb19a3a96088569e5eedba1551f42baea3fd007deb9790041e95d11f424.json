{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.pointVisConfigs = exports.pointOptionalColumns = exports.pointRequiredColumns = exports.pointPosAccessor = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _extensions = require(\"@deck.gl/extensions\");\nvar _layers = require(\"@deck.gl/layers\");\nvar _baseLayer = _interopRequireDefault(require(\"../base-layer\"));\nvar _utils = require(\"@kepler.gl/utils\");\nvar _pointLayerIcon = _interopRequireDefault(require(\"./point-layer-icon\"));\nvar _constants = require(\"@kepler.gl/constants\");\nvar _layerTextLabel = require(\"../layer-text-label\");\nvar _layerUtils = require(\"../layer-utils\");\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar pointPosAccessor = function pointPosAccessor(_ref) {\n  var lat = _ref.lat,\n    lng = _ref.lng,\n    altitude = _ref.altitude;\n  return function (dc) {\n    return function (d) {\n      return [dc.valueAt(d.index, lng.fieldIdx), dc.valueAt(d.index, lat.fieldIdx), altitude && altitude.fieldIdx > -1 ? dc.valueAt(d.index, altitude.fieldIdx) : 0];\n    };\n  };\n};\nexports.pointPosAccessor = pointPosAccessor;\nvar pointRequiredColumns = ['lat', 'lng'];\nexports.pointRequiredColumns = pointRequiredColumns;\nvar pointOptionalColumns = ['altitude'];\nexports.pointOptionalColumns = pointOptionalColumns;\nvar brushingExtension = new _extensions.BrushingExtension();\nvar pointVisConfigs = {\n  radius: 'radius',\n  fixedRadius: 'fixedRadius',\n  opacity: 'opacity',\n  outline: 'outline',\n  thickness: 'thickness',\n  strokeColor: 'strokeColor',\n  colorRange: 'colorRange',\n  strokeColorRange: 'strokeColorRange',\n  radiusRange: 'radiusRange',\n  filled: _objectSpread(_objectSpread({}, _constants.LAYER_VIS_CONFIGS.filled), {}, {\n    type: 'boolean',\n    label: 'layer.fillColor',\n    defaultValue: true,\n    property: 'filled'\n  })\n};\nexports.pointVisConfigs = pointVisConfigs;\nvar PointLayer = /*#__PURE__*/function (_Layer) {\n  (0, _inherits2[\"default\"])(PointLayer, _Layer);\n  var _super = _createSuper(PointLayer);\n  function PointLayer(props) {\n    var _this;\n    (0, _classCallCheck2[\"default\"])(this, PointLayer);\n    _this = _super.call(this, props);\n    _this.registerVisConfig(pointVisConfigs);\n    _this.getPositionAccessor = function (dataContainer) {\n      return pointPosAccessor(_this.config.columns)(dataContainer);\n    };\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(PointLayer, [{\n    key: \"type\",\n    get: function get() {\n      return 'point';\n    }\n  }, {\n    key: \"isAggregated\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"layerIcon\",\n    get: function get() {\n      return _pointLayerIcon[\"default\"];\n    }\n  }, {\n    key: \"requiredLayerColumns\",\n    get: function get() {\n      return pointRequiredColumns;\n    }\n  }, {\n    key: \"optionalColumns\",\n    get: function get() {\n      return pointOptionalColumns;\n    }\n  }, {\n    key: \"columnPairs\",\n    get: function get() {\n      return this.defaultPointColumnPairs;\n    }\n  }, {\n    key: \"noneLayerDataAffectingProps\",\n    get: function get() {\n      return [].concat((0, _toConsumableArray2[\"default\"])((0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(PointLayer.prototype), \"noneLayerDataAffectingProps\", this)), ['radius']);\n    }\n  }, {\n    key: \"visualChannels\",\n    get: function get() {\n      return {\n        color: _objectSpread(_objectSpread({}, (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(PointLayer.prototype), \"visualChannels\", this).color), {}, {\n          accessor: 'getFillColor',\n          condition: function condition(config) {\n            return config.visConfig.filled;\n          },\n          defaultValue: function defaultValue(config) {\n            return config.color;\n          }\n        }),\n        strokeColor: {\n          property: 'strokeColor',\n          key: 'strokeColor',\n          field: 'strokeColorField',\n          scale: 'strokeColorScale',\n          domain: 'strokeColorDomain',\n          range: 'strokeColorRange',\n          channelScaleType: _constants.CHANNEL_SCALES.color,\n          accessor: 'getLineColor',\n          condition: function condition(config) {\n            return config.visConfig.outline;\n          },\n          defaultValue: function defaultValue(config) {\n            return config.visConfig.strokeColor || config.color;\n          }\n        },\n        size: _objectSpread(_objectSpread({}, (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(PointLayer.prototype), \"visualChannels\", this).size), {}, {\n          property: 'radius',\n          range: 'radiusRange',\n          fixed: 'fixedRadius',\n          channelScaleType: 'radius',\n          accessor: 'getRadius',\n          defaultValue: 1\n        })\n      };\n    }\n  }, {\n    key: \"setInitialLayerConfig\",\n    value: function setInitialLayerConfig(dataset) {\n      if (!dataset.dataContainer.numRows()) {\n        return this;\n      }\n      var defaultColorField = (0, _utils.findDefaultColorField)(dataset);\n      if (defaultColorField) {\n        this.updateLayerConfig({\n          // @ts-expect-error Remove this after updateLayerConfig converted into generic function\n          colorField: defaultColorField\n        });\n        this.updateLayerVisualChannel(dataset, 'color');\n      }\n      return this;\n    }\n  }, {\n    key: \"getDefaultLayerConfig\",\n    value: function getDefaultLayerConfig() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return _objectSpread(_objectSpread({}, (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(PointLayer.prototype), \"getDefaultLayerConfig\", this).call(this, props)), {}, {\n        // add stroke color visual channel\n        strokeColorField: null,\n        strokeColorDomain: [0, 1],\n        strokeColorScale: 'quantile'\n      });\n    }\n  }, {\n    key: \"calculateDataAttribute\",\n    value: function calculateDataAttribute(_ref2, getPosition) {\n      var filteredIndex = _ref2.filteredIndex;\n      var data = [];\n      for (var i = 0; i < filteredIndex.length; i++) {\n        var index = filteredIndex[i];\n        var pos = getPosition({\n          index: index\n        }); // if doesn't have point lat or lng, do not add the point\n        // deck.gl can't handle position = null\n\n        if (pos.every(Number.isFinite)) {\n          data.push({\n            position: pos,\n            index: index\n          });\n        }\n      }\n      return data;\n    }\n  }, {\n    key: \"formatLayerData\",\n    value: function formatLayerData(datasets, oldLayerData) {\n      if (this.config.dataId === null) {\n        return {};\n      }\n      var textLabel = this.config.textLabel;\n      var _datasets$this$config = datasets[this.config.dataId],\n        gpuFilter = _datasets$this$config.gpuFilter,\n        dataContainer = _datasets$this$config.dataContainer;\n      var _this$updateData = this.updateData(datasets, oldLayerData),\n        data = _this$updateData.data,\n        triggerChanged = _this$updateData.triggerChanged;\n      var getPosition = this.getPositionAccessor(dataContainer); // get all distinct characters in the text labels\n\n      var textLabels = (0, _layerTextLabel.formatTextLabelData)({\n        textLabel: textLabel,\n        triggerChanged: triggerChanged,\n        oldLayerData: oldLayerData,\n        data: data,\n        dataContainer: dataContainer\n      });\n      var accessors = this.getAttributeAccessors({\n        dataContainer: dataContainer\n      });\n      return _objectSpread({\n        data: data,\n        getPosition: getPosition,\n        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(),\n        textLabels: textLabels\n      }, accessors);\n    }\n    /* eslint-enable complexity */\n  }, {\n    key: \"updateLayerMeta\",\n    value: function updateLayerMeta(dataContainer) {\n      var getPosition = this.getPositionAccessor(dataContainer);\n      var bounds = this.getPointsBounds(dataContainer, getPosition);\n      this.updateMeta({\n        bounds: bounds\n      });\n    }\n  }, {\n    key: \"renderLayer\",\n    value: function renderLayer(opts) {\n      var _this$config$columns$;\n      var data = opts.data,\n        gpuFilter = opts.gpuFilter,\n        objectHovered = opts.objectHovered,\n        mapState = opts.mapState,\n        interactionConfig = opts.interactionConfig; // if no field size is defined we need to pass fixed radius = false\n\n      var fixedRadius = this.config.visConfig.fixedRadius && Boolean(this.config.sizeField);\n      var radiusScale = this.getRadiusScaleByZoom(mapState, fixedRadius);\n      var layerProps = _objectSpread({\n        stroked: this.config.visConfig.outline,\n        filled: this.config.visConfig.filled,\n        lineWidthScale: this.config.visConfig.thickness,\n        radiusScale: radiusScale\n      }, this.config.visConfig.fixedRadius ? {} : {\n        radiusMaxPixels: 500\n      });\n      var updateTriggers = _objectSpread({\n        getPosition: this.config.columns,\n        getFilterValue: gpuFilter.filterValueUpdateTriggers\n      }, this.getVisualChannelUpdateTriggers());\n      var defaultLayerProps = this.getDefaultDeckLayerProps(opts);\n      var brushingProps = this.getBrushingExtensionProps(interactionConfig);\n      var getPixelOffset = (0, _layerTextLabel.getTextOffsetByRadius)(radiusScale, data.getRadius, mapState);\n      var extensions = [].concat((0, _toConsumableArray2[\"default\"])(defaultLayerProps.extensions), [brushingExtension]);\n      var sharedProps = _objectSpread({\n        getFilterValue: data.getFilterValue,\n        extensions: extensions,\n        filterRange: defaultLayerProps.filterRange,\n        visible: defaultLayerProps.visible\n      }, brushingProps);\n      var hoveredObject = this.hasHoveredObject(objectHovered);\n      return [new _layers.ScatterplotLayer(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaultLayerProps), brushingProps), layerProps), data), {}, {\n        parameters: {\n          // circles will be flat on the map when the altitude column is not used\n          depthTest: ((_this$config$columns$ = this.config.columns.altitude) === null || _this$config$columns$ === void 0 ? void 0 : _this$config$columns$.fieldIdx) > -1\n        },\n        lineWidthUnits: 'pixels',\n        updateTriggers: updateTriggers,\n        extensions: extensions\n      }))].concat((0, _toConsumableArray2[\"default\"])(hoveredObject ? [new _layers.ScatterplotLayer(_objectSpread(_objectSpread(_objectSpread({}, this.getDefaultHoverLayerProps()), layerProps), {}, {\n        data: [hoveredObject],\n        getLineColor: this.config.highlightColor,\n        getFillColor: this.config.highlightColor,\n        getRadius: data.getRadius,\n        getPosition: data.getPosition\n      }))] : []), (0, _toConsumableArray2[\"default\"])(this.renderTextLabelLayer({\n        getPosition: data.getPosition,\n        sharedProps: sharedProps,\n        getPixelOffset: getPixelOffset,\n        updateTriggers: updateTriggers\n      }, opts)));\n    }\n  }], [{\n    key: \"findDefaultLayerProps\",\n    value: function findDefaultLayerProps(_ref3) {\n      var _ref3$fieldPairs = _ref3.fieldPairs,\n        fieldPairs = _ref3$fieldPairs === void 0 ? [] : _ref3$fieldPairs;\n      var props = []; // Make layer for each pair\n\n      fieldPairs.forEach(function (pair) {\n        var latField = pair.pair.lat;\n        var prop = {\n          label: pair.defaultName || 'Point'\n        }; // default layer color for begintrip and dropoff point\n\n        if (latField.value in _constants.DEFAULT_LAYER_COLOR) {\n          prop.color = (0, _utils.hexToRgb)(_constants.DEFAULT_LAYER_COLOR[latField.value]);\n        } // set the first layer to be visible\n\n        if (props.length === 0) {\n          prop.isVisible = true;\n        }\n        prop.columns = (0, _layerUtils.assignPointPairToLayerColumn)(pair, true);\n        props.push(prop);\n      });\n      return {\n        props: props\n      };\n    }\n  }]);\n  return PointLayer;\n}(_baseLayer[\"default\"]);\nexports[\"default\"] = PointLayer;","map":{"version":3,"names":["value","exports","pointVisConfigs","pointOptionalColumns","pointRequiredColumns","pointPosAccessor","_toConsumableArray2","_interopRequireDefault","require","_classCallCheck2","_createClass2","_get2","_inherits2","_possibleConstructorReturn2","_baseLayer","_utils","_pointLayerIcon","_constants","_layerTextLabel","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","_getPrototypeOf2","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","prototype","valueOf","call","e","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","_objectSpread","target","i","length","source","forEach","key","_defineProperty2","getOwnPropertyDescriptors","defineProperties","defineProperty","_ref","lat","lng","altitude","dc","d","valueAt","index","fieldIdx","brushingExtension","outline","thickness","colorRange","strokeColorRange","filled","LAYER_VIS_CONFIGS","label","defaultValue","property","_super","PointLayer","_this","props","getPositionAccessor","dataContainer","config","columns","get","defaultPointColumnPairs","concat","condition","color","accessor","visConfig","strokeColor","field","scale","domain","size","range","fixed","channelScaleType","setInitialLayerConfig","dataset","numRows","defaultColorField","findDefaultColorField","updateLayerVisualChannel","getDefaultLayerConfig","strokeColorField","strokeColorDomain","strokeColorScale","calculateDataAttribute","_ref2","getPosition","filteredIndex","pos","every","Number","isFinite","position","data","formatLayerData","datasets","oldLayerData","dataId","textLabel","_datasets$this$config","gpuFilter","_this$updateData","updateData","triggerChanged","accessors","getAttributeAccessors","getFilterValue","filterValueAccessor","textLabels","bounds","getPointsBounds","updateMeta","_this$config$columns$","opts","mapState","interactionConfig","fixedRadius","sizeField","layerProps","stroked","lineWidthScale","radiusScale","radiusMaxPixels","updateTriggers","filterValueUpdateTriggers","getVisualChannelUpdateTriggers","defaultLayerProps","getDefaultDeckLayerProps","brushingProps","getBrushingExtensionProps","getPixelOffset","getTextOffsetByRadius","getRadius","extensions","sharedProps","filterRange","visible","hoveredObject","hasHoveredObject","objectHovered","_layers","ScatterplotLayer","lineWidthUnits","getDefaultHoverLayerProps","getLineColor","highlightColor","getFillColor","renderTextLabelLayer","findDefaultLayerProps","_ref3","_ref3$fieldPairs","fieldPairs","pair","latField"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/layers/src/point-layer/point-layer.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {BrushingExtension} from '@deck.gl/extensions';\nimport {ScatterplotLayer} from '@deck.gl/layers';\n\nimport Layer, {\n  LayerBaseConfig,\n  LayerColorConfig,\n  LayerColumn,\n  LayerSizeConfig,\n  LayerStrokeColorConfig\n} from '../base-layer';\nimport {hexToRgb, findDefaultColorField} from '@kepler.gl/utils';\nimport {default as KeplerTable} from '@kepler.gl/table';\nimport PointLayerIcon from './point-layer-icon';\nimport {\n  LAYER_VIS_CONFIGS,\n  DEFAULT_LAYER_COLOR,\n  CHANNEL_SCALES,\n  ColorRange\n} from '@kepler.gl/constants';\n\nimport {getTextOffsetByRadius, formatTextLabelData} from '../layer-text-label';\nimport {assignPointPairToLayerColumn} from '../layer-utils';\nimport {\n  Merge,\n  RGBColor,\n  VisConfigBoolean,\n  VisConfigColorRange,\n  VisConfigColorSelect,\n  VisConfigNumber,\n  VisConfigRange\n} from '@kepler.gl/types';\n\nexport type PointLayerVisConfigSettings = {\n  radius: VisConfigNumber;\n  fixedRadius: VisConfigBoolean;\n  opacity: VisConfigNumber;\n  outline: VisConfigBoolean;\n  thickness: VisConfigNumber;\n  strokeColor: VisConfigColorSelect;\n  colorRange: VisConfigColorRange;\n  strokeColorRange: VisConfigColorRange;\n  radiusRange: VisConfigRange;\n  filled: VisConfigBoolean;\n};\n\nexport type PointLayerColumnsConfig = {\n  lat: LayerColumn;\n  lng: LayerColumn;\n  altitude?: LayerColumn;\n};\n\nexport type PointLayerVisConfig = {\n  radius: number;\n  fixedRadius: boolean;\n  opacity: number;\n  outline: boolean;\n  thickness: number;\n  strokeColor: RGBColor;\n  colorRange: ColorRange;\n  strokeColorRange: ColorRange;\n  radiusRange: [number, number];\n  filled: boolean;\n};\nexport type PointLayerVisualChannelConfig = LayerColorConfig &\n  LayerSizeConfig &\n  LayerStrokeColorConfig;\nexport type PointLayerConfig = Merge<\n  LayerBaseConfig,\n  {columns: PointLayerColumnsConfig; visConfig: PointLayerVisConfig}\n> &\n  PointLayerVisualChannelConfig;\n\nexport type PointLayerData = {\n  position: number[];\n  index: number;\n};\n\nexport const pointPosAccessor = ({lat, lng, altitude}: PointLayerColumnsConfig) => dc => d => [\n  dc.valueAt(d.index, lng.fieldIdx),\n  dc.valueAt(d.index, lat.fieldIdx),\n  altitude && altitude.fieldIdx > -1 ? dc.valueAt(d.index, altitude.fieldIdx) : 0\n];\n\nexport const pointRequiredColumns: ['lat', 'lng'] = ['lat', 'lng'];\nexport const pointOptionalColumns: ['altitude'] = ['altitude'];\n\nconst brushingExtension = new BrushingExtension();\n\nexport const pointVisConfigs: {\n  radius: 'radius';\n  fixedRadius: 'fixedRadius';\n  opacity: 'opacity';\n  outline: 'outline';\n  thickness: 'thickness';\n  strokeColor: 'strokeColor';\n  colorRange: 'colorRange';\n  strokeColorRange: 'strokeColorRange';\n  radiusRange: 'radiusRange';\n  filled: VisConfigBoolean;\n} = {\n  radius: 'radius',\n  fixedRadius: 'fixedRadius',\n  opacity: 'opacity',\n  outline: 'outline',\n  thickness: 'thickness',\n  strokeColor: 'strokeColor',\n  colorRange: 'colorRange',\n  strokeColorRange: 'strokeColorRange',\n  radiusRange: 'radiusRange',\n  filled: {\n    ...LAYER_VIS_CONFIGS.filled,\n    type: 'boolean',\n    label: 'layer.fillColor',\n    defaultValue: true,\n    property: 'filled'\n  }\n};\n\nexport default class PointLayer extends Layer {\n  declare config: PointLayerConfig;\n  declare visConfigSettings: PointLayerVisConfigSettings;\n  constructor(props) {\n    super(props);\n\n    this.registerVisConfig(pointVisConfigs);\n    this.getPositionAccessor = dataContainer =>\n      pointPosAccessor(this.config.columns)(dataContainer);\n  }\n\n  get type(): 'point' {\n    return 'point';\n  }\n\n  get isAggregated(): false {\n    return false;\n  }\n\n  get layerIcon() {\n    return PointLayerIcon;\n  }\n  get requiredLayerColumns() {\n    return pointRequiredColumns;\n  }\n\n  get optionalColumns() {\n    return pointOptionalColumns;\n  }\n\n  get columnPairs() {\n    return this.defaultPointColumnPairs;\n  }\n\n  get noneLayerDataAffectingProps() {\n    return [...super.noneLayerDataAffectingProps, 'radius'];\n  }\n\n  get visualChannels() {\n    return {\n      color: {\n        ...super.visualChannels.color,\n        accessor: 'getFillColor',\n        condition: config => config.visConfig.filled,\n        defaultValue: config => config.color\n      },\n      strokeColor: {\n        property: 'strokeColor',\n        key: 'strokeColor',\n        field: 'strokeColorField',\n        scale: 'strokeColorScale',\n        domain: 'strokeColorDomain',\n        range: 'strokeColorRange',\n        channelScaleType: CHANNEL_SCALES.color,\n        accessor: 'getLineColor',\n        condition: config => config.visConfig.outline,\n        defaultValue: config => config.visConfig.strokeColor || config.color\n      },\n      size: {\n        ...super.visualChannels.size,\n        property: 'radius',\n        range: 'radiusRange',\n        fixed: 'fixedRadius',\n        channelScaleType: 'radius',\n        accessor: 'getRadius',\n        defaultValue: 1\n      }\n    };\n  }\n\n  setInitialLayerConfig(dataset) {\n    if (!dataset.dataContainer.numRows()) {\n      return this;\n    }\n    const defaultColorField = findDefaultColorField(dataset);\n\n    if (defaultColorField) {\n      this.updateLayerConfig({\n        // @ts-expect-error Remove this after updateLayerConfig converted into generic function\n        colorField: defaultColorField\n      });\n      this.updateLayerVisualChannel(dataset, 'color');\n    }\n\n    return this;\n  }\n\n  static findDefaultLayerProps({fieldPairs = []}: KeplerTable) {\n    const props: {\n      label: string;\n      color?: RGBColor;\n      isVisible?: boolean;\n      columns?: PointLayerColumnsConfig;\n    }[] = [];\n\n    // Make layer for each pair\n    fieldPairs.forEach(pair => {\n      const latField = pair.pair.lat;\n\n      const prop: {\n        label: string;\n        color?: RGBColor;\n        isVisible?: boolean;\n        columns?: PointLayerColumnsConfig;\n      } = {\n        label: pair.defaultName || 'Point'\n      };\n\n      // default layer color for begintrip and dropoff point\n      if (latField.value in DEFAULT_LAYER_COLOR) {\n        prop.color = hexToRgb(DEFAULT_LAYER_COLOR[latField.value]);\n      }\n\n      // set the first layer to be visible\n      if (props.length === 0) {\n        prop.isVisible = true;\n      }\n      prop.columns = assignPointPairToLayerColumn(pair, true);\n\n      props.push(prop);\n    });\n\n    return {props};\n  }\n\n  getDefaultLayerConfig(props = {}) {\n    return {\n      ...super.getDefaultLayerConfig(props),\n\n      // add stroke color visual channel\n      strokeColorField: null,\n      strokeColorDomain: [0, 1],\n      strokeColorScale: 'quantile'\n    };\n  }\n\n  calculateDataAttribute({filteredIndex}: KeplerTable, getPosition) {\n    const data: PointLayerData[] = [];\n\n    for (let i = 0; i < filteredIndex.length; i++) {\n      const index = filteredIndex[i];\n      const pos = getPosition({index});\n\n      // if doesn't have point lat or lng, do not add the point\n      // deck.gl can't handle position = null\n      if (pos.every(Number.isFinite)) {\n        data.push({\n          position: pos,\n          index\n        });\n      }\n    }\n    return data;\n  }\n\n  formatLayerData(datasets, oldLayerData) {\n    if (this.config.dataId === null) {\n      return {};\n    }\n    const {textLabel} = this.config;\n    const {gpuFilter, dataContainer} = datasets[this.config.dataId];\n    const {data, triggerChanged} = this.updateData(datasets, oldLayerData);\n    const getPosition = this.getPositionAccessor(dataContainer);\n\n    // get all distinct characters in the text labels\n    const textLabels = formatTextLabelData({\n      textLabel,\n      triggerChanged,\n      oldLayerData,\n      data,\n      dataContainer\n    });\n\n    const accessors = this.getAttributeAccessors({dataContainer});\n\n    return {\n      data,\n      getPosition,\n      getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(),\n      textLabels,\n      ...accessors\n    };\n  }\n  /* eslint-enable complexity */\n\n  updateLayerMeta(dataContainer) {\n    const getPosition = this.getPositionAccessor(dataContainer);\n    const bounds = this.getPointsBounds(dataContainer, getPosition);\n    this.updateMeta({bounds});\n  }\n\n  renderLayer(opts) {\n    const {data, gpuFilter, objectHovered, mapState, interactionConfig} = opts;\n\n    // if no field size is defined we need to pass fixed radius = false\n    const fixedRadius = this.config.visConfig.fixedRadius && Boolean(this.config.sizeField);\n    const radiusScale = this.getRadiusScaleByZoom(mapState, fixedRadius);\n\n    const layerProps = {\n      stroked: this.config.visConfig.outline,\n      filled: this.config.visConfig.filled,\n      lineWidthScale: this.config.visConfig.thickness,\n      radiusScale,\n      ...(this.config.visConfig.fixedRadius ? {} : {radiusMaxPixels: 500})\n    };\n\n    const updateTriggers = {\n      getPosition: this.config.columns,\n      getFilterValue: gpuFilter.filterValueUpdateTriggers,\n      ...this.getVisualChannelUpdateTriggers()\n    };\n\n    const defaultLayerProps = this.getDefaultDeckLayerProps(opts);\n    const brushingProps = this.getBrushingExtensionProps(interactionConfig);\n    const getPixelOffset = getTextOffsetByRadius(radiusScale, data.getRadius, mapState);\n    const extensions = [...defaultLayerProps.extensions, brushingExtension];\n\n    const sharedProps = {\n      getFilterValue: data.getFilterValue,\n      extensions,\n      filterRange: defaultLayerProps.filterRange,\n      visible: defaultLayerProps.visible,\n      ...brushingProps\n    };\n    const hoveredObject = this.hasHoveredObject(objectHovered);\n\n    return [\n      new ScatterplotLayer({\n        ...defaultLayerProps,\n        ...brushingProps,\n        ...layerProps,\n        ...data,\n        parameters: {\n          // circles will be flat on the map when the altitude column is not used\n          depthTest: (this.config.columns.altitude?.fieldIdx as number) > -1\n        },\n        lineWidthUnits: 'pixels',\n        updateTriggers,\n        extensions\n      }),\n      // hover layer\n      ...(hoveredObject\n        ? [\n            new ScatterplotLayer({\n              ...this.getDefaultHoverLayerProps(),\n              ...layerProps,\n              data: [hoveredObject],\n              getLineColor: this.config.highlightColor,\n              getFillColor: this.config.highlightColor,\n              getRadius: data.getRadius,\n              getPosition: data.getPosition\n            })\n          ]\n        : []),\n      // text label layer\n      ...this.renderTextLabelLayer(\n        {\n          getPosition: data.getPosition,\n          sharedProps,\n          getPixelOffset,\n          updateTriggers\n        },\n        opts\n      )\n    ];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}