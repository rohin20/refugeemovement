{"ast":null,"code":"import _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _SHADER_TYPE;\nimport { VERTEX_SHADER, FRAGMENT_SHADER } from './constants';\nimport { resolveModules } from './resolve-modules';\nimport { getPlatformShaderDefines, getVersionDefines } from './platform-defines';\nimport injectShader, { DECLARATION_INJECT_MARKER } from './inject-shader';\nimport transpileShader from './transpile-shader';\nimport { assert } from '../utils';\nvar INJECT_SHADER_DECLARATIONS = \"\\n\\n\".concat(DECLARATION_INJECT_MARKER, \"\\n\\n\");\nvar SHADER_TYPE = (_SHADER_TYPE = {}, _defineProperty(_SHADER_TYPE, VERTEX_SHADER, 'vertex'), _defineProperty(_SHADER_TYPE, FRAGMENT_SHADER, 'fragment'), _SHADER_TYPE);\nvar FRAGMENT_SHADER_PROLOGUE = \"precision highp float;\\n\\n\";\nexport function assembleShaders(gl, opts) {\n  var vs = opts.vs,\n    fs = opts.fs;\n  var modules = resolveModules(opts.modules || []);\n  return {\n    gl: gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {\n      source: vs,\n      type: VERTEX_SHADER,\n      modules: modules\n    })),\n    fs: assembleShader(gl, Object.assign({}, opts, {\n      source: fs,\n      type: FRAGMENT_SHADER,\n      modules: modules\n    })),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\nfunction assembleShader(gl, _ref) {\n  var id = _ref.id,\n    source = _ref.source,\n    type = _ref.type,\n    modules = _ref.modules,\n    _ref$defines = _ref.defines,\n    defines = _ref$defines === void 0 ? {} : _ref$defines,\n    _ref$hookFunctions = _ref.hookFunctions,\n    hookFunctions = _ref$hookFunctions === void 0 ? [] : _ref$hookFunctions,\n    _ref$inject = _ref.inject,\n    inject = _ref$inject === void 0 ? {} : _ref$inject,\n    _ref$transpileToGLSL = _ref.transpileToGLSL100,\n    transpileToGLSL100 = _ref$transpileToGLSL === void 0 ? false : _ref$transpileToGLSL,\n    _ref$prologue = _ref.prologue,\n    prologue = _ref$prologue === void 0 ? true : _ref$prologue,\n    log = _ref.log;\n  assert(typeof source === 'string', 'shader source must be a string');\n  var isVertex = type === VERTEX_SHADER;\n  var sourceLines = source.split('\\n');\n  var glslVersion = 100;\n  var versionLine = '';\n  var coreSource = source;\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300;\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } else {\n    versionLine = \"#version \".concat(glslVersion);\n  }\n  var allDefines = {};\n  modules.forEach(function (module) {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n  var assembledSource = prologue ? \"\".concat(versionLine, \"\\n\").concat(getShaderName({\n    id: id,\n    source: source,\n    type: type\n  }), \"\\n\").concat(getShaderType({\n    type: type\n  }), \"\\n\").concat(getPlatformShaderDefines(gl), \"\\n\").concat(getVersionDefines(gl, glslVersion, !isVertex), \"\\n\").concat(getApplicationDefines(allDefines), \"\\n\").concat(isVertex ? '' : FRAGMENT_SHADER_PROLOGUE, \"\\n\") : \"\".concat(versionLine, \"\\n\");\n  var hookFunctionMap = normalizeHookFunctions(hookFunctions);\n  var hookInjections = {};\n  var declInjections = {};\n  var mainInjections = {};\n  for (var key in inject) {\n    var injection = typeof inject[key] === 'string' ? {\n      injection: inject[key],\n      order: 0\n    } : inject[key];\n    var match = key.match(/^(v|f)s:(#)?([\\w-]+)$/);\n    if (match) {\n      var hash = match[2];\n      var name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      mainInjections[key] = [injection];\n    }\n  }\n  var _iterator = _createForOfIteratorHelper(modules),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var module = _step.value;\n      if (log) {\n        module.checkDeprecations(coreSource, log);\n      }\n      var moduleSource = module.getModuleSource(type, glslVersion);\n      assembledSource += moduleSource;\n      var injections = module.injections[type];\n      for (var _key in injections) {\n        var _match = _key.match(/^(v|f)s:#([\\w-]+)$/);\n        if (_match) {\n          var _name = _match[2];\n          var injectionType = _name === 'decl' ? declInjections : mainInjections;\n          injectionType[_key] = injectionType[_key] || [];\n          injectionType[_key].push(injections[_key]);\n        } else {\n          hookInjections[_key] = hookInjections[_key] || [];\n          hookInjections[_key].push(injections[_key]);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n  assembledSource = injectShader(assembledSource, type, declInjections);\n  assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);\n  assembledSource += coreSource;\n  assembledSource = injectShader(assembledSource, type, mainInjections);\n  assembledSource = transpileShader(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);\n  return assembledSource;\n}\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    var uniforms = {};\n    var _iterator2 = _createForOfIteratorHelper(modules),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var module = _step2.value;\n        var moduleUniforms = module.getUniforms(opts, uniforms);\n        Object.assign(uniforms, moduleUniforms);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return uniforms;\n  };\n}\nfunction getShaderType(_ref2) {\n  var type = _ref2.type;\n  return \"\\n#define SHADER_TYPE_\".concat(SHADER_TYPE[type].toUpperCase(), \"\\n\");\n}\nfunction getShaderName(_ref3) {\n  var id = _ref3.id,\n    source = _ref3.source,\n    type = _ref3.type;\n  var injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName ? \"\\n#define SHADER_NAME \".concat(id, \"_\").concat(SHADER_TYPE[type], \"\\n\\n\") : '';\n}\nfunction getApplicationDefines() {\n  var defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var count = 0;\n  var sourceText = '';\n  for (var define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n    var value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += \"#define \".concat(define.toUpperCase(), \" \").concat(defines[define], \"\\n\");\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\nfunction getHookFunctions(hookFunctions, hookInjections) {\n  var result = '';\n  for (var hookName in hookFunctions) {\n    var hookFunction = hookFunctions[hookName];\n    result += \"void \".concat(hookFunction.signature, \" {\\n\");\n    if (hookFunction.header) {\n      result += \"  \".concat(hookFunction.header);\n    }\n    if (hookInjections[hookName]) {\n      var injections = hookInjections[hookName];\n      injections.sort(function (a, b) {\n        return a.order - b.order;\n      });\n      var _iterator3 = _createForOfIteratorHelper(injections),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var injection = _step3.value;\n          result += \"  \".concat(injection.injection, \"\\n\");\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    if (hookFunction.footer) {\n      result += \"  \".concat(hookFunction.footer);\n    }\n    result += '}\\n';\n  }\n  return result;\n}\nfunction normalizeHookFunctions(hookFunctions) {\n  var result = {\n    vs: {},\n    fs: {}\n  };\n  hookFunctions.forEach(function (hook) {\n    var opts;\n    if (typeof hook !== 'string') {\n      opts = hook;\n      hook = opts.hook;\n    } else {\n      opts = {};\n    }\n    hook = hook.trim();\n    var _hook$split = hook.split(':'),\n      _hook$split2 = _slicedToArray(_hook$split, 2),\n      stage = _hook$split2[0],\n      signature = _hook$split2[1];\n    var name = hook.replace(/\\(.+/, '');\n    result[stage][name] = Object.assign(opts, {\n      signature: signature\n    });\n  });\n  return result;\n}","map":{"version":3,"names":["VERTEX_SHADER","FRAGMENT_SHADER","resolveModules","getPlatformShaderDefines","getVersionDefines","injectShader","DECLARATION_INJECT_MARKER","transpileShader","assert","INJECT_SHADER_DECLARATIONS","concat","SHADER_TYPE","_SHADER_TYPE","_defineProperty","FRAGMENT_SHADER_PROLOGUE","assembleShaders","gl","opts","vs","fs","modules","assembleShader","Object","assign","source","type","getUniforms","assembleGetUniforms","_ref","id","_ref$defines","defines","_ref$hookFunctions","hookFunctions","_ref$inject","inject","_ref$transpileToGLSL","transpileToGLSL100","_ref$prologue","prologue","log","isVertex","sourceLines","split","glslVersion","versionLine","coreSource","indexOf","slice","join","allDefines","forEach","module","getDefines","assembledSource","getShaderName","getShaderType","getApplicationDefines","hookFunctionMap","normalizeHookFunctions","hookInjections","declInjections","mainInjections","key","injection","order","match","hash","name","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","checkDeprecations","moduleSource","getModuleSource","injections","injectionType","push","err","e","f","getHookFunctions","uniforms","_iterator2","_step2","moduleUniforms","_ref2","toUpperCase","_ref3","injectShaderName","arguments","length","undefined","count","sourceText","define","Number","isFinite","result","hookName","hookFunction","signature","header","sort","a","b","_iterator3","_step3","footer","hook","trim","_hook$split","_hook$split2","_slicedToArray","stage","replace"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@luma.gl/shadertools/src/lib/assemble-shaders.js"],"sourcesContent":["import {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {resolveModules} from './resolve-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport injectShader, {DECLARATION_INJECT_MARKER} from './inject-shader';\nimport transpileShader from './transpile-shader';\nimport {assert} from '../utils';\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n\\n`;\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\nprecision highp float;\n\n`;\n\n// Inject a list of modules\nexport function assembleShaders(gl, opts) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(\n  gl,\n  {\n    id,\n    source,\n    type,\n    modules,\n    defines = {},\n    hookFunctions = [],\n    inject = {},\n    transpileToGLSL100 = false,\n    prologue = true,\n    log\n  }\n) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const isVertex = type === VERTEX_SHADER;\n\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300; // TODO - regexp that matches actual version number\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } else {\n    versionLine = `#version ${glslVersion}`;\n  }\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = prologue\n    ? `\\\n${versionLine}\n${getShaderName({id, source, type})}\n${getShaderType({type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl, glslVersion, !isVertex)}\n${getApplicationDefines(allDefines)}\n${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n`\n    : `${versionLine}\n`;\n\n  const hookFunctionMap = normalizeHookFunctions(hookFunctions);\n\n  // Add source of dependent modules in resolved order\n  const hookInjections = {};\n  const declInjections = {};\n  const mainInjections = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    const match = key.match(/^(v|f)s:(#)?([\\w-]+)$/);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    if (log) {\n      module.checkDeprecations(coreSource, log);\n    }\n    const moduleSource = module.getModuleSource(type, glslVersion);\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n\n    const injections = module.injections[type];\n    for (const key in injections) {\n      const match = key.match(/^(v|f)s:#([\\w-]+)$/);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource = injectShader(assembledSource, type, declInjections);\n\n  assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, type, mainInjections);\n\n  assembledSource = transpileShader(\n    assembledSource,\n    transpileToGLSL100 ? 100 : glslVersion,\n    isVertex\n  );\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\nfunction getShaderType({type}) {\n  return `\n#define SHADER_TYPE_${SHADER_TYPE[type].toUpperCase()}\n`;\n}\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n`\n    : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\nfunction getHookFunctions(hookFunctions, hookInjections) {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n\nfunction normalizeHookFunctions(hookFunctions) {\n  const result = {\n    vs: {},\n    fs: {}\n  };\n\n  hookFunctions.forEach(hook => {\n    let opts;\n    if (typeof hook !== 'string') {\n      opts = hook;\n      hook = opts.hook;\n    } else {\n      opts = {};\n    }\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    result[stage][name] = Object.assign(opts, {signature});\n  });\n\n  return result;\n}\n"],"mappings":";;;;AAAA,SAAQA,aAAR,EAAuBC,eAAvB,QAA6C,aAA7C;AACA,SAAQC,cAAR,QAA6B,mBAA7B;AACA,SAAQC,wBAAR,EAAkCC,iBAAlC,QAA0D,oBAA1D;AACA,OAAOC,YAAP,IAAsBC,yBAAtB,QAAsD,iBAAtD;AACA,OAAOC,eAAP,MAA4B,oBAA5B;AACA,SAAQC,MAAR,QAAqB,UAArB;AAEA,IAAMC,0BAA0B,UAAAC,MAAA,CAAUJ,yBAAV,SAAhC;AAEA,IAAMK,WAAW,IAAAC,YAAA,OAAAC,eAAA,CAAAD,YAAA,EACdZ,aAAD,EAAiB,QADC,GAAAa,eAAA,CAAAD,YAAA,EAEjBX,eAAD,EAAmB,aAAAW,YAAA,CAFrB;AAOA,IAAME,wBAAwB,+BAA9B;AAMA,OAAO,SAASC,eAATA,CAAyBC,EAAzB,EAA6BC,IAA7B,EAAmC;EACxC,IAAOC,EAAD,GAAWD,IAAjB,CAAOC,EAAD;IAAKC,EAAA,GAAMF,IAAjB,CAAWE,EAAA;EACX,IAAMC,OAAO,GAAGlB,cAAc,CAACe,IAAI,CAACG,OAAL,IAAgB,EAAjB,CAA9B;EACA,OAAO;IACLJ,EADK,EACLA,EADK;IAELE,EAAE,EAAEG,cAAc,CAACL,EAAD,EAAKM,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBN,IAAlB,EAAwB;MAACO,MAAM,EAAEN,EAAT;MAAaO,IAAI,EAAEzB,aAAnB;MAAkCoB,OAAA,EAAAA;IAAlC,CAAxB,CAAL,CAFb;IAGLD,EAAE,EAAEE,cAAc,CAACL,EAAD,EAAKM,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBN,IAAlB,EAAwB;MAACO,MAAM,EAAEL,EAAT;MAAaM,IAAI,EAAExB,eAAnB;MAAoCmB,OAAA,EAAAA;IAApC,CAAxB,CAAL,CAHb;IAILM,WAAW,EAAEC,mBAAmB,CAACP,OAAD;EAJ3B,CAAP;AAMD;AAID,SAASC,cAATA,CACEL,EADF,EAAAY,IAAA,EAcE;EAAA,IAXEC,EADF,GAYAD,IAAA,CAXEC,EADF;IAEEL,MAFF,GAYAI,IAAA,CAVEJ,MAFF;IAGEC,IAHF,GAYAG,IAAA,CATEH,IAHF;IAIEL,OAJF,GAYAQ,IAAA,CARER,OAJF;IAAAU,YAAA,GAYAF,IAAA,CAPEG,OAAO;IAAPA,OAAO,GAAAD,YAAA,cAAG,EALZ,GAAAA,YAAA;IAAAE,kBAAA,GAYAJ,IAAA,CANEK,aAAa;IAAbA,aAAa,GAAAD,kBAAA,cAAG,EANlB,GAAAA,kBAAA;IAAAE,WAAA,GAYAN,IAAA,CALEO,MAAM;IAANA,MAAM,GAAAD,WAAA,cAAG,EAPX,GAAAA,WAAA;IAAAE,oBAAA,GAYAR,IAAA,CAJES,kBAAkB;IAAlBA,kBAAkB,GAAAD,oBAAA,cAAG,KARvB,GAAAA,oBAAA;IAAAE,aAAA,GAYAV,IAAA,CAHEW,QAAQ;IAARA,QAAQ,GAAAD,aAAA,cAAG,IATb,GAAAA,aAAA;IAUEE,GAAA,GAEFZ,IAAA,CAFEY,GAAA;EAGFhC,MAAM,CAAC,OAAOgB,MAAP,KAAkB,QAAnB,EAA6B,gCAA7B,CAAN;EAEA,IAAMiB,QAAQ,GAAGhB,IAAI,KAAKzB,aAA1B;EAEA,IAAM0C,WAAW,GAAGlB,MAAM,CAACmB,KAAP,CAAa,IAAb,CAApB;EACA,IAAIC,WAAW,GAAG,GAAlB;EACA,IAAIC,WAAW,GAAG,EAAlB;EACA,IAAIC,UAAU,GAAGtB,MAAjB;EAGA,IAAIkB,WAAW,CAAC,CAAD,CAAX,CAAeK,OAAf,CAAuB,WAAvB,MAAwC,CAA5C,EAA+C;IAC7CH,WAAW,GAAG,GAAd;IACAC,WAAW,GAAGH,WAAW,CAAC,CAAD,CAAzB;IACAI,UAAU,GAAGJ,WAAW,CAACM,KAAZ,CAAkB,CAAlB,EAAqBC,IAArB,CAA0B,IAA1B,CAAb;EACD,CAJD,MAIO;IACLJ,WAAW,eAAAnC,MAAA,CAAekC,WAAf,CAAX;EACD;EAGD,IAAMM,UAAU,GAAG,EAAnB;EACA9B,OAAO,CAAC+B,OAAR,CAAgB,UAAAC,MAAM,EAAI;IACxB9B,MAAM,CAACC,MAAP,CAAc2B,UAAd,EAA0BE,MAAM,CAACC,UAAP,EAA1B;EACD,CAFD;EAGA/B,MAAM,CAACC,MAAP,CAAc2B,UAAd,EAA0BnB,OAA1B;EAKA,IAAIuB,eAAe,GAAGf,QAAQ,MAAA7B,MAAA,CAE9BmC,WAF8B,QAAAnC,MAAA,CAG9B6C,aAAa,CAAC;IAAC1B,EAAD,EAACA,EAAD;IAAKL,MAAL,EAAKA,MAAL;IAAaC,IAAA,EAAAA;EAAb,CAAD,CAHiB,QAAAf,MAAA,CAI9B8C,aAAa,CAAC;IAAC/B,IAAA,EAAAA;EAAD,CAAD,CAJiB,QAAAf,MAAA,CAK9BP,wBAAwB,CAACa,EAAD,CALM,QAAAN,MAAA,CAM9BN,iBAAiB,CAACY,EAAD,EAAK4B,WAAL,EAAkB,CAACH,QAAnB,CANa,QAAA/B,MAAA,CAO9B+C,qBAAqB,CAACP,UAAD,CAPS,QAAAxC,MAAA,CAQ9B+B,QAAQ,GAAG,EAAH,GAAQ3B,wBARc,aAAAJ,MAAA,CAUvBmC,WAVuB,OAA9B;EAaA,IAAMa,eAAe,GAAGC,sBAAsB,CAAC1B,aAAD,CAA9C;EAGA,IAAM2B,cAAc,GAAG,EAAvB;EACA,IAAMC,cAAc,GAAG,EAAvB;EACA,IAAMC,cAAc,GAAG,EAAvB;EAEA,KAAK,IAAMC,GAAX,IAAkB5B,MAAlB,EAA0B;IACxB,IAAM6B,SAAS,GACb,OAAO7B,MAAM,CAAC4B,GAAD,CAAb,KAAuB,QAAvB,GAAkC;MAACC,SAAS,EAAE7B,MAAM,CAAC4B,GAAD,CAAlB;MAAyBE,KAAK,EAAE;IAAhC,CAAlC,GAAuE9B,MAAM,CAAC4B,GAAD,CAD/E;IAEA,IAAMG,KAAK,GAAGH,GAAG,CAACG,KAAJ,CAAU,uBAAV,CAAd;IACA,IAAIA,KAAJ,EAAW;MACT,IAAMC,IAAI,GAAGD,KAAK,CAAC,CAAD,CAAlB;MACA,IAAME,IAAI,GAAGF,KAAK,CAAC,CAAD,CAAlB;MACA,IAAIC,IAAJ,EAAU;QACR,IAAIC,IAAI,KAAK,MAAb,EAAqB;UACnBP,cAAc,CAACE,GAAD,CAAd,GAAsB,CAACC,SAAD,CAAtB;QACD,CAFD,MAEO;UACLF,cAAc,CAACC,GAAD,CAAd,GAAsB,CAACC,SAAD,CAAtB;QACD;MACF,CAND,MAMO;QACLJ,cAAc,CAACG,GAAD,CAAd,GAAsB,CAACC,SAAD,CAAtB;MACD;IACF,CAZD,MAYO;MAELF,cAAc,CAACC,GAAD,CAAd,GAAsB,CAACC,SAAD,CAAtB;IACD;EACF;EAAA,IAAAK,SAAA,GAAAC,0BAAA,CAEoBlD,OAArB;IAAAmD,KAAA;EAAA;IAAA,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA8B;MAAA,IAAnBtB,MAAX,GAAAmB,KAAA,CAAAI,KAAA;MACE,IAAInC,GAAJ,EAAS;QACPY,MAAM,CAACwB,iBAAP,CAAyB9B,UAAzB,EAAqCN,GAArC;MACD;MACD,IAAMqC,YAAY,GAAGzB,MAAM,CAAC0B,eAAP,CAAuBrD,IAAvB,EAA6BmB,WAA7B,CAArB;MAEAU,eAAe,IAAIuB,YAAnB;MAEA,IAAME,UAAU,GAAG3B,MAAM,CAAC2B,UAAP,CAAkBtD,IAAlB,CAAnB;MACA,KAAK,IAAMsC,IAAX,IAAkBgB,UAAlB,EAA8B;QAC5B,IAAMb,MAAK,GAAGH,IAAG,CAACG,KAAJ,CAAU,oBAAV,CAAd;QACA,IAAIA,MAAJ,EAAW;UACT,IAAME,KAAI,GAAGF,MAAK,CAAC,CAAD,CAAlB;UACA,IAAMc,aAAa,GAAGZ,KAAI,KAAK,MAAT,GAAkBP,cAAlB,GAAmCC,cAAzD;UACAkB,aAAa,CAACjB,IAAD,CAAb,GAAqBiB,aAAa,CAACjB,IAAD,CAAb,IAAsB,EAA3C;UACAiB,aAAa,CAACjB,IAAD,CAAb,CAAmBkB,IAAnB,CAAwBF,UAAU,CAAChB,IAAD,CAAlC;QACD,CALD,MAKO;UACLH,cAAc,CAACG,IAAD,CAAd,GAAsBH,cAAc,CAACG,IAAD,CAAd,IAAuB,EAA7C;UACAH,cAAc,CAACG,IAAD,CAAd,CAAoBkB,IAApB,CAAyBF,UAAU,CAAChB,IAAD,CAAnC;QACD;MACF;IACF;EAAA,SAAAmB,GAAA;IAAAb,SAAA,CAAAc,CAAA,CAAAD,GAAA;EAAA;IAAAb,SAAA,CAAAe,CAAA;EAAA;EAGD9B,eAAe,IAAI7C,0BAAnB;EAEA6C,eAAe,GAAGjD,YAAY,CAACiD,eAAD,EAAkB7B,IAAlB,EAAwBoC,cAAxB,CAA9B;EAEAP,eAAe,IAAI+B,gBAAgB,CAAC3B,eAAe,CAACjC,IAAD,CAAhB,EAAwBmC,cAAxB,CAAnC;EAGAN,eAAe,IAAIR,UAAnB;EAGAQ,eAAe,GAAGjD,YAAY,CAACiD,eAAD,EAAkB7B,IAAlB,EAAwBqC,cAAxB,CAA9B;EAEAR,eAAe,GAAG/C,eAAe,CAC/B+C,eAD+B,EAE/BjB,kBAAkB,GAAG,GAAH,GAASO,WAFI,EAG/BH,QAH+B,CAAjC;EAMA,OAAOa,eAAP;AACD;AAMD,SAAS3B,mBAATA,CAA6BP,OAA7B,EAAsC;EACpC,OAAO,SAASM,WAATA,CAAqBT,IAArB,EAA2B;IAChC,IAAMqE,QAAQ,GAAG,EAAjB;IAAA,IAAAC,UAAA,GAAAjB,0BAAA,CACqBlD,OAArB;MAAAoE,MAAA;IAAA;MAAA,KAAAD,UAAA,CAAAf,CAAA,MAAAgB,MAAA,GAAAD,UAAA,CAAAd,CAAA,IAAAC,IAAA,GAA8B;QAAA,IAAnBtB,MAAX,GAAAoC,MAAA,CAAAb,KAAA;QAGE,IAAMc,cAAc,GAAGrC,MAAM,CAAC1B,WAAP,CAAmBT,IAAnB,EAAyBqE,QAAzB,CAAvB;QACAhE,MAAM,CAACC,MAAP,CAAc+D,QAAd,EAAwBG,cAAxB;MACD;IAAA,SAAAP,GAAA;MAAAK,UAAA,CAAAJ,CAAA,CAAAD,GAAA;IAAA;MAAAK,UAAA,CAAAH,CAAA;IAAA;IACD,OAAOE,QAAP;EACD,CATD;AAUD;AAED,SAAS9B,aAATA,CAAAkC,KAAA,EAA+B;EAAA,IAAPjE,IAAA,GAAOiE,KAAA,CAAPjE,IAAA;EACtB,gCAAAf,MAAA,CACoBC,WAAW,CAACc,IAAD,CAAX,CAAkBkE,WAAlB,EADpB;AAGD;AAKD,SAASpC,aAATA,CAAAqC,KAAA,EAA2C;EAAA,IAAnB/D,EAAD,GAAoB+D,KAAA,CAAnB/D,EAAD;IAAKL,MAAL,GAAoBoE,KAAA,CAAfpE,MAAL;IAAaC,IAAA,GAAOmE,KAAA,CAAPnE,IAAA;EAClC,IAAMoE,gBAAgB,GAAGhE,EAAE,IAAI,OAAOA,EAAP,KAAc,QAApB,IAAgCL,MAAM,CAACuB,OAAP,CAAe,aAAf,MAAkC,CAAC,CAA5F;EACA,OAAO8C,gBAAgB,4BAAAnF,MAAA,CAEHmB,EAFG,OAAAnB,MAAA,CAEGC,WAAW,CAACc,IAAD,CAFd,YAKnB,EALJ;AAMD;AAGD,SAASgC,qBAATA,CAAA,EAA6C;EAAA,IAAd1B,OAAc,GAAA+D,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAJ,EAAI;EAC3C,IAAIG,KAAK,GAAG,CAAZ;EACA,IAAIC,UAAU,GAAG,EAAjB;EACA,KAAK,IAAMC,MAAX,IAAqBpE,OAArB,EAA8B;IAC5B,IAAIkE,KAAK,KAAK,CAAd,EAAiB;MACfC,UAAU,IAAI,4BAAd;IACD;IACDD,KAAK;IAEL,IAAMtB,KAAK,GAAG5C,OAAO,CAACoE,MAAD,CAArB;IACA,IAAIxB,KAAK,IAAIyB,MAAM,CAACC,QAAP,CAAgB1B,KAAhB,CAAb,EAAqC;MACnCuB,UAAU,eAAAxF,MAAA,CAAeyF,MAAM,CAACR,WAAP,EAAf,OAAAjF,MAAA,CAAuCqB,OAAO,CAACoE,MAAD,CAA9C,OAAV;IACD;EACF;EACD,IAAIF,KAAK,KAAK,CAAd,EAAiB;IACfC,UAAU,IAAI,IAAd;EACD;EACD,OAAOA,UAAP;AACD;AAED,SAASb,gBAATA,CAA0BpD,aAA1B,EAAyC2B,cAAzC,EAAyD;EACvD,IAAI0C,MAAM,GAAG,EAAb;EACA,KAAK,IAAMC,QAAX,IAAuBtE,aAAvB,EAAsC;IACpC,IAAMuE,YAAY,GAAGvE,aAAa,CAACsE,QAAD,CAAlC;IACAD,MAAM,YAAA5F,MAAA,CAAY8F,YAAY,CAACC,SAAzB,SAAN;IACA,IAAID,YAAY,CAACE,MAAjB,EAAyB;MACvBJ,MAAM,SAAA5F,MAAA,CAAS8F,YAAY,CAACE,MAAtB,CAAN;IACD;IACD,IAAI9C,cAAc,CAAC2C,QAAD,CAAlB,EAA8B;MAC5B,IAAMxB,UAAU,GAAGnB,cAAc,CAAC2C,QAAD,CAAjC;MACAxB,UAAU,CAAC4B,IAAX,CAAgB,UAACC,CAAD,EAAIC,CAAJ;QAAA,OAAUD,CAAC,CAAC3C,KAAF,GAAU4C,CAAC,CAAC5C,KAAtC;MAAA;MAAA,IAAA6C,UAAA,GAAAxC,0BAAA,CACwBS,UAAxB;QAAAgC,MAAA;MAAA;QAAA,KAAAD,UAAA,CAAAtC,CAAA,MAAAuC,MAAA,GAAAD,UAAA,CAAArC,CAAA,IAAAC,IAAA,GAAoC;UAAA,IAAzBV,SAAX,GAAA+C,MAAA,CAAApC,KAAA;UACE2B,MAAM,SAAA5F,MAAA,CAASsD,SAAS,CAACA,SAAnB,OAAN;QACD;MAAA,SAAAkB,GAAA;QAAA4B,UAAA,CAAA3B,CAAA,CAAAD,GAAA;MAAA;QAAA4B,UAAA,CAAA1B,CAAA;MAAA;IACF;IACD,IAAIoB,YAAY,CAACQ,MAAjB,EAAyB;MACvBV,MAAM,SAAA5F,MAAA,CAAS8F,YAAY,CAACQ,MAAtB,CAAN;IACD;IACDV,MAAM,IAAI,KAAV;EACD;EAED,OAAOA,MAAP;AACD;AAED,SAAS3C,sBAATA,CAAgC1B,aAAhC,EAA+C;EAC7C,IAAMqE,MAAM,GAAG;IACbpF,EAAE,EAAE,EADS;IAEbC,EAAE,EAAE;EAFS,CAAf;EAKAc,aAAa,CAACkB,OAAd,CAAsB,UAAA8D,IAAI,EAAI;IAC5B,IAAIhG,IAAJ;IACA,IAAI,OAAOgG,IAAP,KAAgB,QAApB,EAA8B;MAC5BhG,IAAI,GAAGgG,IAAP;MACAA,IAAI,GAAGhG,IAAI,CAACgG,IAAZ;IACD,CAHD,MAGO;MACLhG,IAAI,GAAG,EAAP;IACD;IACDgG,IAAI,GAAGA,IAAI,CAACC,IAAL,EAAP;IACA,IAAAC,WAAA,GAA2BF,IAAI,CAACtE,KAAL,CAAW,GAAX,CAA3B;MAAAyE,YAAA,GAAAC,cAAA,CAAAF,WAAA;MAAOG,KAAD,GAAAF,YAAA;MAAQX,SAAR,GAAAW,YAAA;IACN,IAAMhD,IAAI,GAAG6C,IAAI,CAACM,OAAL,CAAa,MAAb,EAAqB,EAArB,CAAb;IACAjB,MAAM,CAACgB,KAAD,CAAN,CAAclD,IAAd,IAAsB9C,MAAM,CAACC,MAAP,CAAcN,IAAd,EAAoB;MAACwF,SAAA,EAAAA;IAAD,CAApB,CAAtB;EACD,CAZD;EAcA,OAAOH,MAAP;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}