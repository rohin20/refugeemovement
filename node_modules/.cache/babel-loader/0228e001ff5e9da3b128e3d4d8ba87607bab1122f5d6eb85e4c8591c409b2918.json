{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateStateWithLayerAndData = updateStateWithLayerAndData;\nexports.updateStateOnLayerVisibilityChange = updateStateOnLayerVisibilityChange;\nexports.layerConfigChangeUpdater = layerConfigChangeUpdater;\nexports.layerTextLabelChangeUpdater = layerTextLabelChangeUpdater;\nexports.layerDataIdChangeUpdater = layerDataIdChangeUpdater;\nexports.layerTypeChangeUpdater = layerTypeChangeUpdater;\nexports.layerVisualChannelChangeUpdater = layerVisualChannelChangeUpdater;\nexports.layerVisConfigChangeUpdater = layerVisConfigChangeUpdater;\nexports.setFilterAnimationTimeUpdater = setFilterAnimationTimeUpdater;\nexports.setFilterAnimationWindowUpdater = setFilterAnimationWindowUpdater;\nexports.setFilterUpdater = setFilterUpdater;\nexports.interactionConfigChangeUpdater = interactionConfigChangeUpdater;\nexports.renameDatasetUpdater = renameDatasetUpdater;\nexports.closeSpecificMapAtIndex = closeSpecificMapAtIndex;\nexports.loadFileStepSuccessUpdater = loadFileStepSuccessUpdater;\nexports.loadNextFileUpdater = loadNextFileUpdater;\nexports.makeLoadFileTask = makeLoadFileTask;\nexports.processFileContentUpdater = processFileContentUpdater;\nexports.parseProgress = parseProgress;\nexports.addDefaultLayers = addDefaultLayers;\nexports.addDefaultTooltips = addDefaultTooltips;\nexports.initialFileLoadingProgress = initialFileLoadingProgress;\nexports.updateFileLoadingProgressUpdater = updateFileLoadingProgressUpdater;\nexports.updateAllLayerDomainData = updateAllLayerDomainData;\nexports.updateAnimationDomain = updateAnimationDomain;\nexports.setFeaturesUpdater = setFeaturesUpdater;\nexports.deleteFeatureUpdater = deleteFeatureUpdater;\nexports.setPolygonFilterLayerUpdater = setPolygonFilterLayerUpdater;\nexports.sortTableColumnUpdater = sortTableColumnUpdater;\nexports.pinTableColumnUpdater = pinTableColumnUpdater;\nexports.copyTableColumnUpdater = copyTableColumnUpdater;\nexports.toggleEditorVisibilityUpdater = toggleEditorVisibilityUpdater;\nexports.setFilterAnimationTimeConfigUpdater = setFilterAnimationTimeConfigUpdater;\nexports.setLayerAnimationTimeConfigUpdater = setLayerAnimationTimeConfigUpdater;\nexports.setSelectedFeatureUpdater = exports.setEditorModeUpdater = exports.setMapInfoUpdater = exports.applyCPUFilterUpdater = exports.loadFilesErrUpdater = exports.nextFileBatchUpdater = exports.loadFilesUpdater = exports.updateVisDataUpdater = exports.toggleLayerForMapUpdater = exports.toggleSplitMapUpdater = exports.mouseMoveUpdater = exports.mapClickUpdater = exports.layerClickUpdater = exports.layerHoverUpdater = exports.receiveMapConfigUpdater = exports.resetMapConfigUpdater = exports.updateTableColorUpdater = exports.showDatasetTableUpdater = exports.updateLayerBlendingUpdater = exports.removeDatasetUpdater = exports.reorderLayerUpdater = exports.duplicateLayerUpdater = exports.removeLayerUpdater = exports.addLayerUpdater = exports.removeFilterUpdater = exports.toggleFilterFeatureUpdater = exports.enlargeFilterUpdater = exports.updateLayerAnimationSpeedUpdater = exports.setLayerAnimationTimeUpdater = exports.updateFilterAnimationSpeedUpdater = exports.toggleLayerAnimationControlUpdater = exports.toggleLayerAnimationUpdater = exports.toggleFilterAnimationUpdater = exports.layerColorUIChangeUpdater = exports.addFilterUpdater = exports.setFilterPlotUpdater = exports.INITIAL_VIS_STATE = exports.DEFAULT_EDITOR = exports.DEFAULT_ANIMATION_CONFIG = exports.defaultInteractionConfig = void 0;\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _window = require(\"global/window\");\nvar _tasks = require(\"react-palm/tasks\");\nvar _lodash = _interopRequireDefault(require(\"lodash.clonedeep\"));\nvar _lodash2 = _interopRequireDefault(require(\"lodash.uniq\"));\nvar _lodash3 = _interopRequireDefault(require(\"lodash.get\"));\nvar _lodash4 = _interopRequireDefault(require(\"lodash.xor\"));\nvar _copyToClipboard = _interopRequireDefault(require(\"copy-to-clipboard\"));\nvar _tasks2 = require(\"@kepler.gl/tasks\");\nvar _actions = require(\"@kepler.gl/actions\");\nvar _utils = require(\"@kepler.gl/utils\");\nvar _visStateMerger = require(\"./vis-state-merger\");\nvar _layers = require(\"@kepler.gl/layers\");\nvar _constants = require(\"@kepler.gl/constants\");\nvar _composerHelpers = require(\"./composer-helpers\");\nvar _schemas = _interopRequireDefault(require(\"@kepler.gl/schemas\"));\nvar _layerUtils = require(\"./layer-utils\");\nvar _table = require(\"@kepler.gl/table\");\nvar _interactionUtils = require(\"./interaction-utils\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n// react-palm\n// disable capture exception for react-palm call to withTask\n(0, _tasks.disableStackCapturing)();\n/**\n * Updaters for `visState` reducer. Can be used in your root reducer to directly modify kepler.gl's state.\n * Read more about [Using updaters](../advanced-usage/using-updaters.md)\n *\n * @public\n * @example\n *\n * import keplerGlReducer, {visStateUpdaters} from 'kepler.gl/reducers';\n * // Root Reducer\n * const reducers = combineReducers({\n *  keplerGl: keplerGlReducer,\n *  app: appReducer\n * });\n *\n * const composedReducer = (state, action) => {\n *  switch (action.type) {\n *    case 'CLICK_BUTTON':\n *      return {\n *        ...state,\n *        keplerGl: {\n *          ...state.keplerGl,\n *          foo: {\n *             ...state.keplerGl.foo,\n *             visState: visStateUpdaters.enlargeFilterUpdater(\n *               state.keplerGl.foo.visState,\n *               {idx: 0}\n *             )\n *          }\n *        }\n *      };\n *  }\n *  return reducers(state, action);\n * };\n *\n * export default composedReducer;\n */\n\n/* eslint-disable no-unused-vars */\n// @ts-ignore\n\nvar visStateUpdaters = null;\n/* eslint-enable no-unused-vars */\n\nvar defaultInteractionConfig = {\n  tooltip: {\n    id: 'tooltip',\n    label: 'interactions.tooltip',\n    enabled: true,\n    config: {\n      fieldsToShow: {},\n      compareMode: false,\n      compareType: _constants.COMPARE_TYPES.ABSOLUTE\n    }\n  },\n  geocoder: {\n    id: 'geocoder',\n    label: 'interactions.geocoder',\n    enabled: false,\n    position: null\n  },\n  brush: {\n    id: 'brush',\n    label: 'interactions.brush',\n    enabled: false,\n    config: {\n      // size is in km\n      size: 0.5\n    }\n  },\n  coordinate: {\n    id: 'coordinate',\n    label: 'interactions.coordinate',\n    enabled: false,\n    position: null\n  }\n};\nexports.defaultInteractionConfig = defaultInteractionConfig;\nvar DEFAULT_ANIMATION_CONFIG = {\n  domain: null,\n  currentTime: null,\n  speed: 1,\n  isAnimating: false,\n  timeFormat: null,\n  timezone: null,\n  defaultTimeFormat: null\n};\nexports.DEFAULT_ANIMATION_CONFIG = DEFAULT_ANIMATION_CONFIG;\nvar DEFAULT_EDITOR = {\n  mode: _constants.EDITOR_MODES.DRAW_POLYGON,\n  features: [],\n  selectedFeature: null,\n  visible: true\n};\n/**\n * Default initial `visState`\n * @memberof visStateUpdaters\n * @constant\n * @public\n */\n\nexports.DEFAULT_EDITOR = DEFAULT_EDITOR;\nvar INITIAL_VIS_STATE = {\n  // map info\n  mapInfo: {\n    title: '',\n    description: ''\n  },\n  // layers\n  layers: [],\n  layerData: [],\n  layerToBeMerged: [],\n  layerOrder: [],\n  // filters\n  filters: [],\n  filterToBeMerged: [],\n  // a collection of multiple dataset\n  datasets: {},\n  editingDataset: undefined,\n  interactionConfig: defaultInteractionConfig,\n  interactionToBeMerged: undefined,\n  layerBlending: 'normal',\n  hoverInfo: undefined,\n  clicked: undefined,\n  mousePos: {},\n  maxDefaultTooltips: _constants.MAX_DEFAULT_TOOLTIPS,\n  // this is used when user split maps\n  splitMaps: [// this will contain a list of objects to\n    // describe the state of layer availability and visibility for each map\n    // [\n    //   {\n    //      layers: {layer_id: true | false}\n    //   }\n    // ]\n  ],\n  splitMapsToBeMerged: [],\n  // defaults layer classes\n  layerClasses: _layers.LayerClasses,\n  // default animation\n  // time in unix timestamp (milliseconds) (the number of seconds since the Unix Epoch)\n  animationConfig: DEFAULT_ANIMATION_CONFIG,\n  editor: DEFAULT_EDITOR,\n  fileLoading: false,\n  fileLoadingProgress: {},\n  loaders: [],\n  loadOptions: {},\n  // visStateMergers\n  mergers: _visStateMerger.VIS_STATE_MERGERS,\n  // kepler schemas\n  schema: _schemas[\"default\"]\n};\n/**\n * Update state with updated layer and layerData\n *\n */\n\nexports.INITIAL_VIS_STATE = INITIAL_VIS_STATE;\nfunction updateStateWithLayerAndData(state, _ref) {\n  var layerData = _ref.layerData,\n    layer = _ref.layer,\n    idx = _ref.idx;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    layers: state.layers.map(function (lyr, i) {\n      return i === idx ? layer : lyr;\n    }),\n    layerData: layerData ? state.layerData.map(function (d, i) {\n      return i === idx ? layerData : d;\n    }) : state.layerData\n  });\n}\nfunction updateStateOnLayerVisibilityChange(state, layer) {\n  var newState = state;\n  if (state.splitMaps.length) {\n    newState = _objectSpread(_objectSpread({}, state), {}, {\n      splitMaps: layer.config.isVisible ? (0, _utils.addNewLayersToSplitMap)(state.splitMaps, layer) : (0, _utils.removeLayerFromSplitMaps)(state.splitMaps, layer)\n    });\n  }\n  if (layer.config.animation.enabled) {\n    newState = updateAnimationDomain(state);\n  }\n  return newState;\n}\n/**\n * Update layer base config: dataId, label, column, isVisible\n * @memberof visStateUpdaters\n * @returns nextState\n */\n\nfunction layerConfigChangeUpdater(state, action) {\n  var oldLayer = action.oldLayer;\n  var idx = state.layers.findIndex(function (l) {\n    return l.id === oldLayer.id;\n  });\n  var props = Object.keys(action.newConfig);\n  if (typeof action.newConfig.dataId === 'string') {\n    var _action$newConfig = action.newConfig,\n      dataId = _action$newConfig.dataId,\n      restConfig = (0, _objectWithoutProperties2[\"default\"])(_action$newConfig, [\"dataId\"]);\n    var stateWithDataId = layerDataIdChangeUpdater(state, {\n      oldLayer: oldLayer,\n      newConfig: {\n        dataId: dataId\n      }\n    });\n    var nextLayer = stateWithDataId.layers.find(function (l) {\n      return l.id === oldLayer.id;\n    });\n    return nextLayer && Object.keys(restConfig).length ? layerConfigChangeUpdater(stateWithDataId, {\n      oldLayer: nextLayer,\n      newConfig: restConfig\n    }) : stateWithDataId;\n  }\n  var newLayer = oldLayer.updateLayerConfig(action.newConfig);\n  var layerData; // let newLayer;\n\n  if (newLayer.shouldCalculateLayerData(props)) {\n    var oldLayerData = state.layerData[idx];\n    var updateLayerDataResult = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData);\n    layerData = updateLayerDataResult.layerData;\n    newLayer = updateLayerDataResult.layer;\n  }\n  var newState = state;\n  if ('isVisible' in action.newConfig) {\n    newState = updateStateOnLayerVisibilityChange(state, newLayer);\n  }\n  return updateStateWithLayerAndData(newState, {\n    layer: newLayer,\n    layerData: layerData,\n    idx: idx\n  });\n}\nfunction addOrRemoveTextLabels(newFields, textLabel) {\n  var newTextLabel = textLabel.slice();\n  var currentFields = textLabel.map(function (tl) {\n    return tl.field && tl.field.name;\n  }).filter(function (d) {\n    return d;\n  });\n  var addFields = newFields.filter(function (f) {\n    return !currentFields.includes(f.name);\n  });\n  var deleteFields = currentFields.filter(function (f) {\n    return !newFields.find(function (fd) {\n      return fd.name === f;\n    });\n  }); // delete\n\n  newTextLabel = newTextLabel.filter(function (tl) {\n    return tl.field && !deleteFields.includes(tl.field.name);\n  });\n  newTextLabel = !newTextLabel.length ? [_constants.DEFAULT_TEXT_LABEL] : newTextLabel; // add\n\n  newTextLabel = [].concat((0, _toConsumableArray2[\"default\"])(newTextLabel.filter(function (tl) {\n    return tl.field;\n  })), (0, _toConsumableArray2[\"default\"])(addFields.map(function (af) {\n    return _objectSpread(_objectSpread({}, _constants.DEFAULT_TEXT_LABEL), {}, {\n      field: af\n    });\n  })));\n  return newTextLabel;\n}\nfunction updateTextLabelPropAndValue(idx, prop, value, textLabel) {\n  if (!textLabel[idx].hasOwnProperty(prop)) {\n    return textLabel;\n  }\n  var newTextLabel = textLabel.slice();\n  if (prop && (value || textLabel.length === 1)) {\n    newTextLabel = textLabel.map(function (tl, i) {\n      return i === idx ? _objectSpread(_objectSpread({}, tl), {}, (0, _defineProperty2[\"default\"])({}, prop, value)) : tl;\n    });\n  } else if (prop === 'field' && value === null && textLabel.length > 1) {\n    // remove label when field value is set to null\n    newTextLabel.splice(idx, 1);\n  }\n  return newTextLabel;\n}\n/**\n * Update layer base config: dataId, label, column, isVisible\n * @memberof visStateUpdaters\n * @returns nextState\n */\n\nfunction layerTextLabelChangeUpdater(state, action) {\n  var oldLayer = action.oldLayer,\n    idx = action.idx,\n    prop = action.prop,\n    value = action.value;\n  var textLabel = oldLayer.config.textLabel;\n  var newTextLabel = textLabel.slice();\n  if (!textLabel[idx] && idx === textLabel.length) {\n    // if idx is set to length, add empty text label\n    newTextLabel = [].concat((0, _toConsumableArray2[\"default\"])(textLabel), [_constants.DEFAULT_TEXT_LABEL]);\n  }\n  if (idx === 'all' && prop === 'fields') {\n    newTextLabel = addOrRemoveTextLabels(value, textLabel);\n  } else {\n    newTextLabel = updateTextLabelPropAndValue(idx, prop, value, newTextLabel);\n  } // update text label prop and value\n\n  return layerConfigChangeUpdater(state, {\n    oldLayer: oldLayer,\n    newConfig: {\n      textLabel: newTextLabel\n    }\n  });\n}\nfunction validateExistingLayerWithData(dataset, layerClasses, layer) {\n  var loadedLayer = (0, _visStateMerger.serializeLayer)(layer);\n  return (0, _visStateMerger.validateLayerWithData)(dataset, loadedLayer, layerClasses, {\n    allowEmptyColumn: true\n  });\n}\n/**\n * Update layer config dataId\n * @memberof visStateUpdaters\n * @returns nextState\n */\n\nfunction layerDataIdChangeUpdater(state, action) {\n  var oldLayer = action.oldLayer,\n    newConfig = action.newConfig;\n  var dataId = newConfig.dataId;\n  if (!oldLayer || !state.datasets[dataId]) {\n    return state;\n  }\n  var idx = state.layers.findIndex(function (l) {\n    return l.id === oldLayer.id;\n  });\n  var newLayer = oldLayer.updateLayerConfig({\n    dataId: dataId\n  }); // this may happen when a layer is new (type: null and no columns) but it's not ready to be saved\n\n  if (newLayer.isValidToSave()) {\n    var validated = validateExistingLayerWithData(state.datasets[dataId], state.layerClasses, newLayer); // if cant validate it with data create a new one\n\n    if (!validated) {\n      // @ts-expect-error TODO: checking oldLayer.type !== null\n      newLayer = new state.layerClasses[oldLayer.type]({\n        dataId: dataId,\n        id: oldLayer.id\n      });\n    } else {\n      newLayer = validated;\n    }\n  }\n  newLayer = newLayer.updateLayerConfig({\n    isVisible: oldLayer.config.isVisible,\n    isConfigActive: true\n  });\n  newLayer.updateLayerDomain(state.datasets);\n  var _calculateLayerData = (0, _layerUtils.calculateLayerData)(newLayer, state, undefined),\n    layerData = _calculateLayerData.layerData,\n    layer = _calculateLayerData.layer;\n  return updateStateWithLayerAndData(state, {\n    layerData: layerData,\n    layer: layer,\n    idx: idx\n  });\n}\nfunction setInitialLayerConfig(layer, datasets, layerClasses) {\n  var newLayer = layer;\n  if (!Object.keys(datasets).length) {\n    // no data is loaded\n    return layer;\n  }\n  if (!layer.config.dataId) {\n    // set layer dataId\n    newLayer = layer.updateLayerConfig({\n      dataId: Object.keys(datasets)[0]\n    });\n  }\n  var dataset = datasets[newLayer.config.dataId];\n  if (!dataset) {\n    return layer;\n  } // find defaut layer props\n\n  var result = typeof layerClasses[newLayer.type].findDefaultLayerProps === 'function' ? layerClasses[newLayer.type].findDefaultLayerProps(dataset, []) : {\n    props: []\n  }; // an array of possible props, use 1st one\n\n  var props = Array.isArray(result) ? result : result.props || [];\n  if (props.length) {\n    newLayer = new layerClasses[layer.type](_objectSpread(_objectSpread({}, props[0]), {}, {\n      label: newLayer.config.label,\n      dataId: newLayer.config.dataId,\n      isVisible: true,\n      isConfigActive: newLayer.config.isConfigActive\n    }));\n    return typeof newLayer.setInitialLayerConfig === 'function' ? newLayer.setInitialLayerConfig(dataset) : newLayer;\n  }\n  return newLayer;\n}\n/**\n * Update layer type. Previews layer config will be copied if applicable.\n * @memberof visStateUpdaters\n * @public\n */\n\nfunction layerTypeChangeUpdater(state, action) {\n  var oldLayer = action.oldLayer,\n    newType = action.newType;\n  if (!oldLayer) {\n    return state;\n  }\n  var oldId = oldLayer.id;\n  var idx = state.layers.findIndex(function (l) {\n    return l.id === oldId;\n  });\n  if (!state.layerClasses[newType]) {\n    _window.console.error(\"\".concat(newType, \" is not a valid layer type\"));\n    return state;\n  }\n  var newLayer = new state.layerClasses[newType]({\n    // keep old layer lable and isConfigActive\n    label: oldLayer.config.label,\n    isConfigActive: oldLayer.config.isConfigActive\n  });\n  if (!oldLayer.type) {\n    // if setting layer type on an empty layer\n    newLayer = setInitialLayerConfig(newLayer, state.datasets, state.layerClasses);\n  } else {\n    // get a mint layer, with new id and type\n    // because deck.gl uses id to match between new and old layer.\n    // If type has changed but id is the same, it will break\n    newLayer.assignConfigToLayer(oldLayer.config, oldLayer.visConfigSettings);\n    newLayer.updateLayerDomain(state.datasets);\n  }\n  var clicked = state.clicked,\n    hoverInfo = state.hoverInfo;\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    clicked: oldLayer.isLayerHovered(clicked) ? undefined : clicked,\n    hoverInfo: oldLayer.isLayerHovered(hoverInfo) ? undefined : hoverInfo\n  });\n  var _calculateLayerData2 = (0, _layerUtils.calculateLayerData)(newLayer, newState),\n    layerData = _calculateLayerData2.layerData,\n    layer = _calculateLayerData2.layer;\n  newState = updateStateWithLayerAndData(newState, {\n    layerData: layerData,\n    layer: layer,\n    idx: idx\n  });\n  if (layer.config.animation.enabled || oldLayer.config.animation.enabled) {\n    newState = updateAnimationDomain(newState);\n  } // update splitMap layer id\n\n  if (state.splitMaps.length) {\n    newState = _objectSpread(_objectSpread({}, newState), {}, {\n      splitMaps: newState.splitMaps.map(function (settings) {\n        var _settings$layers = settings.layers,\n          oldLayerMap = _settings$layers[oldId],\n          otherLayers = (0, _objectWithoutProperties2[\"default\"])(_settings$layers, [oldId].map(_toPropertyKey));\n        return oldId in settings.layers ? _objectSpread(_objectSpread({}, settings), {}, {\n          layers: _objectSpread(_objectSpread({}, otherLayers), {}, (0, _defineProperty2[\"default\"])({}, layer.id, oldLayerMap))\n        }) : settings;\n      })\n    });\n  }\n  return newState;\n}\n/**\n * Update layer visual channel\n * @memberof visStateUpdaters\n * @returns {Object} nextState\n * @public\n */\n\nfunction layerVisualChannelChangeUpdater(state, action) {\n  var oldLayer = action.oldLayer,\n    newConfig = action.newConfig,\n    channel = action.channel;\n  if (!oldLayer.config.dataId) {\n    return state;\n  }\n  var dataset = state.datasets[oldLayer.config.dataId];\n  var idx = state.layers.findIndex(function (l) {\n    return l.id === oldLayer.id;\n  });\n  var newLayer = oldLayer.updateLayerConfig(newConfig);\n  newLayer.updateLayerVisualChannel(dataset, channel);\n  var oldLayerData = state.layerData[idx];\n  var _calculateLayerData3 = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData),\n    layerData = _calculateLayerData3.layerData,\n    layer = _calculateLayerData3.layer;\n  return updateStateWithLayerAndData(state, {\n    layerData: layerData,\n    layer: layer,\n    idx: idx\n  });\n}\n/**\n * Update layer `visConfig`\n * @memberof visStateUpdaters\n * @public\n */\n\nfunction layerVisConfigChangeUpdater(state, action) {\n  var oldLayer = action.oldLayer;\n  var idx = state.layers.findIndex(function (l) {\n    return l.id === oldLayer.id;\n  });\n  var props = Object.keys(action.newVisConfig);\n  var newVisConfig = _objectSpread(_objectSpread({}, oldLayer.config.visConfig), action.newVisConfig);\n  var newLayer = oldLayer.updateLayerConfig({\n    visConfig: newVisConfig\n  });\n  if (newLayer.shouldCalculateLayerData(props)) {\n    var oldLayerData = state.layerData[idx];\n    var _calculateLayerData4 = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData),\n      layerData = _calculateLayerData4.layerData,\n      layer = _calculateLayerData4.layer;\n    return updateStateWithLayerAndData(state, {\n      layerData: layerData,\n      layer: layer,\n      idx: idx\n    });\n  }\n  return updateStateWithLayerAndData(state, {\n    layer: newLayer,\n    idx: idx\n  });\n}\n/**\n * Update filter property\n * @memberof visStateUpdaters\n * @public\n */\n\nfunction setFilterAnimationTimeUpdater(state, action) {\n  return setFilterUpdater(state, action);\n}\n/**\n * Update filter animation window\n * @memberof visStateUpdaters\n * @public\n */\n\nfunction setFilterAnimationWindowUpdater(state, _ref2) {\n  var id = _ref2.id,\n    animationWindow = _ref2.animationWindow;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    filters: state.filters.map(function (f) {\n      return f.id === id ? _objectSpread(_objectSpread({}, f), {}, {\n        animationWindow: animationWindow\n      }) : f;\n    })\n  });\n}\n/**\n * Update filter property\n * @memberof visStateUpdaters\n * @public\n */\n\nfunction setFilterUpdater(state, action) {\n  var idx = action.idx,\n    prop = action.prop,\n    value = action.value,\n    _action$valueIndex = action.valueIndex,\n    valueIndex = _action$valueIndex === void 0 ? 0 : _action$valueIndex;\n  var oldFilter = state.filters[idx];\n  if (!oldFilter) {\n    _window.console.error(\"filters.\".concat(idx, \" is undefined\"));\n    return state;\n  }\n  var newFilter = (0, _utils.set)([prop], value, oldFilter);\n  var newState = state;\n  var _newFilter = newFilter,\n    dataId = _newFilter.dataId; // Ensuring backward compatibility\n\n  var datasetIds = (0, _utils.toArray)(dataId);\n  switch (prop) {\n    // TODO: Next PR for UI if we update dataId, we need to consider two cases:\n    // 1. dataId is empty: create a default filter\n    // 2. Add a new dataset id\n    case _utils.FILTER_UPDATER_PROPS.dataId:\n      // if trying to update filter dataId. create an empty new filter\n      newFilter = (0, _utils.updateFilterDataId)(dataId);\n      break;\n    case _utils.FILTER_UPDATER_PROPS.name:\n      // we are supporting the current functionality\n      // TODO: Next PR for UI filter name will only update filter name but it won't have side effects\n      // we are gonna use pair of datasets and fieldIdx to update the filter\n      var datasetId = newFilter.dataId[valueIndex];\n      var _applyFilterFieldName = (0, _utils.applyFilterFieldName)(newFilter, state.datasets[datasetId], value, valueIndex, {\n          mergeDomain: false\n        }),\n        updatedFilter = _applyFilterFieldName.filter,\n        newDataset = _applyFilterFieldName.dataset;\n      if (!updatedFilter) {\n        return state;\n      }\n      newFilter = updatedFilter;\n      if (newFilter.gpu) {\n        newFilter = (0, _table.setFilterGpuMode)(newFilter, state.filters);\n        newFilter = (0, _table.assignGpuChannel)(newFilter, state.filters);\n      }\n      newState = (0, _utils.set)(['datasets', datasetId], newDataset, state); // only filter the current dataset\n\n      break;\n    case _utils.FILTER_UPDATER_PROPS.layerId:\n      // We need to update only datasetId/s if we have added/removed layers\n      // - check for layerId changes (XOR works because of string values)\n      // if no differences between layerIds, don't do any filtering\n      // @ts-ignore\n      var layerIdDifference = (0, _lodash4[\"default\"])(newFilter.layerId, oldFilter.layerId);\n      var layerDataIds = (0, _lodash2[\"default\"])(layerIdDifference.map(function (lid) {\n        return (0, _lodash3[\"default\"])(state.layers.find(function (l) {\n          return l.id === lid;\n        }), ['config', 'dataId']);\n      }).filter(function (d) {\n        return d;\n      })); // only filter datasetsIds\n\n      datasetIds = layerDataIds; // Update newFilter dataIds\n\n      var newDataIds = (0, _lodash2[\"default\"])(newFilter.layerId.map(function (lid) {\n        return (0, _lodash3[\"default\"])(state.layers.find(function (l) {\n          return l.id === lid;\n        }), ['config', 'dataId']);\n      }).filter(function (d) {\n        return d;\n      }));\n      newFilter = _objectSpread(_objectSpread({}, newFilter), {}, {\n        dataId: newDataIds\n      });\n      break;\n    default:\n      break;\n  }\n  var enlargedFilter = state.filters.find(function (f) {\n    return f.enlarged;\n  });\n  if (enlargedFilter && enlargedFilter.id !== newFilter.id) {\n    // there should be only one enlarged filter\n    newFilter.enlarged = false;\n  } // save new filters to newState\n\n  newState = (0, _utils.set)(['filters', idx], newFilter, newState); // if we are currently setting a prop that only requires to filter the current\n  // dataset we will pass only the current dataset to applyFiltersToDatasets and\n  // updateAllLayerDomainData otherwise we pass the all list of datasets as defined in dataId\n\n  var datasetIdsToFilter = _utils.LIMITED_FILTER_EFFECT_PROPS[prop] ? [datasetIds[valueIndex]] : datasetIds; // filter data\n\n  var filteredDatasets = (0, _utils.applyFiltersToDatasets)(datasetIdsToFilter, newState.datasets, newState.filters, newState.layers);\n  newState = (0, _utils.set)(['datasets'], filteredDatasets, newState); // dataId is an array\n  // pass only the dataset we need to update\n\n  newState = updateAllLayerDomainData(newState, datasetIdsToFilter, newFilter);\n  return newState;\n}\n/**\n * Set the property of a filter plot\n * @memberof visStateUpdaters\n * @public\n */\n\nvar setFilterPlotUpdater = function setFilterPlotUpdater(state, _ref3) {\n  var idx = _ref3.idx,\n    newProp = _ref3.newProp,\n    _ref3$valueIndex = _ref3.valueIndex,\n    valueIndex = _ref3$valueIndex === void 0 ? 0 : _ref3$valueIndex;\n  var newFilter = _objectSpread(_objectSpread({}, state.filters[idx]), newProp);\n  var prop = Object.keys(newProp)[0];\n  if (prop === 'yAxis') {\n    var plotType = (0, _utils.getDefaultFilterPlotType)(newFilter); // TODO: plot is not supported in multi dataset filter for now\n\n    if (plotType) {\n      newFilter = _objectSpread(_objectSpread(_objectSpread({}, newFilter), (0, _utils.getFilterPlot)(_objectSpread(_objectSpread({}, newFilter), {}, {\n        plotType: plotType\n      }), state.datasets[newFilter.dataId[valueIndex]])), {}, {\n        plotType: plotType\n      });\n    }\n  }\n  return _objectSpread(_objectSpread({}, state), {}, {\n    filters: state.filters.map(function (f, i) {\n      return i === idx ? newFilter : f;\n    })\n  });\n};\n/**\n * Add a new filter\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.setFilterPlotUpdater = setFilterPlotUpdater;\nvar addFilterUpdater = function addFilterUpdater(state, action) {\n  return !action.dataId ? state : _objectSpread(_objectSpread({}, state), {}, {\n    filters: [].concat((0, _toConsumableArray2[\"default\"])(state.filters), [(0, _utils.getDefaultFilter)(action.dataId)])\n  });\n};\n/**\n * Set layer color palette ui state\n * @memberof visStateUpdaters\n */\n\nexports.addFilterUpdater = addFilterUpdater;\nvar layerColorUIChangeUpdater = function layerColorUIChangeUpdater(state, _ref4) {\n  var oldLayer = _ref4.oldLayer,\n    prop = _ref4.prop,\n    newConfig = _ref4.newConfig;\n  var oldVixConfig = oldLayer.config.visConfig[prop];\n  var newLayer = oldLayer.updateLayerColorUI(prop, newConfig);\n  var newVisConfig = newLayer.config.visConfig[prop];\n  if (oldVixConfig !== newVisConfig) {\n    return layerVisConfigChangeUpdater(state, {\n      oldLayer: oldLayer,\n      newVisConfig: (0, _defineProperty2[\"default\"])({}, prop, newVisConfig)\n    });\n  }\n  return _objectSpread(_objectSpread({}, state), {}, {\n    layers: state.layers.map(function (l) {\n      return l.id === oldLayer.id ? newLayer : l;\n    })\n  });\n};\n/**\n * Start and end filter animation\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.layerColorUIChangeUpdater = layerColorUIChangeUpdater;\nvar toggleFilterAnimationUpdater = function toggleFilterAnimationUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    filters: state.filters.map(function (f, i) {\n      return i === action.idx ? _objectSpread(_objectSpread({}, f), {}, {\n        isAnimating: !f.isAnimating\n      }) : f;\n    })\n  });\n};\n/**\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.toggleFilterAnimationUpdater = toggleFilterAnimationUpdater;\nvar toggleLayerAnimationUpdater = function toggleLayerAnimationUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {\n      isAnimating: !state.animationConfig.isAnimating\n    })\n  });\n};\n/**\n * Hide and show layer animation control\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.toggleLayerAnimationUpdater = toggleLayerAnimationUpdater;\nvar toggleLayerAnimationControlUpdater = function toggleLayerAnimationControlUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {\n      hideControl: !state.animationConfig.hideControl\n    })\n  });\n};\n/**\n * Change filter animation speed\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.toggleLayerAnimationControlUpdater = toggleLayerAnimationControlUpdater;\nvar updateFilterAnimationSpeedUpdater = function updateFilterAnimationSpeedUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    filters: state.filters.map(function (f, i) {\n      return i === action.idx ? _objectSpread(_objectSpread({}, f), {}, {\n        speed: action.speed\n      }) : f;\n    })\n  });\n};\n/**\n * Reset animation config current time to a specified value\n * @memberof visStateUpdaters\n * @public\n *\n */\n\nexports.updateFilterAnimationSpeedUpdater = updateFilterAnimationSpeedUpdater;\nvar setLayerAnimationTimeUpdater = function setLayerAnimationTimeUpdater(state, _ref5) {\n  var value = _ref5.value;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {\n      currentTime: value\n    })\n  });\n};\n/**\n * Update animation speed with the vertical speed slider\n * @memberof visStateUpdaters\n * @public\n *\n */\n\nexports.setLayerAnimationTimeUpdater = setLayerAnimationTimeUpdater;\nvar updateLayerAnimationSpeedUpdater = function updateLayerAnimationSpeedUpdater(state, _ref6) {\n  var speed = _ref6.speed;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {\n      speed: speed\n    })\n  });\n};\n/**\n * Show larger time filter at bottom for time playback (apply to time filter only)\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.updateLayerAnimationSpeedUpdater = updateLayerAnimationSpeedUpdater;\nvar enlargeFilterUpdater = function enlargeFilterUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    filters: state.filters.map(function (f, i) {\n      return i === action.idx ? _objectSpread(_objectSpread({}, f), {}, {\n        enlarged: !f.enlarged\n      }) : f;\n    })\n  });\n};\n/**\n * Toggles filter feature visibility\n * @memberof visStateUpdaters\n */\n\nexports.enlargeFilterUpdater = enlargeFilterUpdater;\nvar toggleFilterFeatureUpdater = function toggleFilterFeatureUpdater(state, action) {\n  var filter = state.filters[action.idx];\n  var isVisible = (0, _lodash3[\"default\"])(filter, ['value', 'properties', 'isVisible']);\n  var newFilter = _objectSpread(_objectSpread({}, filter), {}, {\n    value: (0, _utils.featureToFilterValue)(filter.value, filter.id, {\n      isVisible: !isVisible\n    })\n  });\n  return _objectSpread(_objectSpread({}, state), {}, {\n    filters: Object.assign((0, _toConsumableArray2[\"default\"])(state.filters), (0, _defineProperty2[\"default\"])({}, action.idx, newFilter))\n  });\n};\n/**\n * Remove a filter\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.toggleFilterFeatureUpdater = toggleFilterFeatureUpdater;\nvar removeFilterUpdater = function removeFilterUpdater(state, action) {\n  var idx = action.idx;\n  var _state$filters$idx = state.filters[idx],\n    dataId = _state$filters$idx.dataId,\n    id = _state$filters$idx.id;\n  var newFilters = [].concat((0, _toConsumableArray2[\"default\"])(state.filters.slice(0, idx)), (0, _toConsumableArray2[\"default\"])(state.filters.slice(idx + 1, state.filters.length)));\n  var filteredDatasets = (0, _utils.applyFiltersToDatasets)(dataId, state.datasets, newFilters, state.layers);\n  var newEditor = (0, _utils.getFilterIdInFeature)(state.editor.selectedFeature) === id ? _objectSpread(_objectSpread({}, state.editor), {}, {\n    selectedFeature: null\n  }) : state.editor;\n  var newState = (0, _utils.set)(['filters'], newFilters, state);\n  newState = (0, _utils.set)(['datasets'], filteredDatasets, newState);\n  newState = (0, _utils.set)(['editor'], newEditor, newState);\n  return updateAllLayerDomainData(newState, dataId, undefined);\n};\n/**\n * Add a new layer\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.removeFilterUpdater = removeFilterUpdater;\nvar addLayerUpdater = function addLayerUpdater(state, action) {\n  var newLayer;\n  var newLayerData;\n  if (action.config) {\n    newLayer = (0, _visStateMerger.createLayerFromConfig)(state, action.config);\n    if (!newLayer) {\n      _window.console.warn('Failed to create layer from config, it usually means the config is not be in correct format', action.config);\n      return state;\n    }\n    var result = (0, _layerUtils.calculateLayerData)(newLayer, state);\n    newLayer = result.layer;\n    newLayerData = result.layerData;\n  } else {\n    var _action$datasetId;\n\n    // create an empty layer with a specific dataset or a default one\n    var defaultDataset = (_action$datasetId = action.datasetId) !== null && _action$datasetId !== void 0 ? _action$datasetId : Object.keys(state.datasets)[0];\n    newLayer = new _layers.Layer({\n      isVisible: true,\n      isConfigActive: true,\n      dataId: defaultDataset\n    });\n    newLayerData = {};\n  }\n  return _objectSpread(_objectSpread({}, state), {}, {\n    layers: [].concat((0, _toConsumableArray2[\"default\"])(state.layers), [newLayer]),\n    layerData: [].concat((0, _toConsumableArray2[\"default\"])(state.layerData), [newLayerData]),\n    layerOrder: [].concat((0, _toConsumableArray2[\"default\"])(state.layerOrder), [state.layerOrder.length]),\n    splitMaps: (0, _utils.addNewLayersToSplitMap)(state.splitMaps, newLayer)\n  });\n};\n/**\n * remove layer\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.addLayerUpdater = addLayerUpdater;\nvar removeLayerUpdater = function removeLayerUpdater(state, _ref7) {\n  var idx = _ref7.idx;\n  var layers = state.layers,\n    layerData = state.layerData,\n    clicked = state.clicked,\n    hoverInfo = state.hoverInfo;\n  var layerToRemove = state.layers[idx];\n  var newMaps = (0, _utils.removeLayerFromSplitMaps)(state.splitMaps, layerToRemove);\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    layers: [].concat((0, _toConsumableArray2[\"default\"])(layers.slice(0, idx)), (0, _toConsumableArray2[\"default\"])(layers.slice(idx + 1, layers.length))),\n    layerData: [].concat((0, _toConsumableArray2[\"default\"])(layerData.slice(0, idx)), (0, _toConsumableArray2[\"default\"])(layerData.slice(idx + 1, layerData.length))),\n    layerOrder: state.layerOrder.filter(function (i) {\n      return i !== idx;\n    }).map(function (pid) {\n      return pid > idx ? pid - 1 : pid;\n    }),\n    clicked: layerToRemove.isLayerHovered(clicked) ? undefined : clicked,\n    hoverInfo: layerToRemove.isLayerHovered(hoverInfo) ? undefined : hoverInfo,\n    splitMaps: newMaps // TODO: update filters, create helper to remove layer form filter (remove layerid and dataid) if mapped\n  });\n\n  return updateAnimationDomain(newState);\n};\n/**\n * duplicate layer\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.removeLayerUpdater = removeLayerUpdater;\nvar duplicateLayerUpdater = function duplicateLayerUpdater(state, _ref8) {\n  var idx = _ref8.idx;\n  var layers = state.layers;\n  var original = state.layers[idx];\n  var originalLayerOrderIdx = state.layerOrder.findIndex(function (i) {\n    return i === idx;\n  });\n  if (!original) {\n    _window.console.warn(\"layer.\".concat(idx, \" is undefined\"));\n    return state;\n  }\n  var newLabel = \"Copy of \".concat(original.config.label);\n  var postfix = 0; // eslint-disable-next-line no-loop-func\n\n  while (layers.find(function (l) {\n    return l.config.label === newLabel;\n  })) {\n    newLabel = \"Copy of \".concat(original.config.label, \" \").concat(++postfix);\n  } // collect layer config from original\n\n  var loadedLayer = (0, _visStateMerger.serializeLayer)(original); // assign new id and label to copied layer\n\n  if (!(loadedLayer !== null && loadedLayer !== void 0 && loadedLayer.config)) {\n    return state;\n  }\n  loadedLayer.config.label = newLabel;\n  loadedLayer.id = (0, _utils.generateHashId)(_layers.LAYER_ID_LENGTH); // add layer to state\n\n  var nextState = addLayerUpdater(state, {\n    config: loadedLayer\n  }); // new added layer are at the end, move it to be on top of original layer\n\n  var newLayerOrderIdx = nextState.layerOrder.length - 1;\n  var newLayerOrder = (0, _utils.arrayInsert)(nextState.layerOrder.slice(0, newLayerOrderIdx), originalLayerOrderIdx, newLayerOrderIdx);\n  nextState = _objectSpread(_objectSpread({}, nextState), {}, {\n    layerOrder: newLayerOrder\n  });\n  return updateAnimationDomain(nextState);\n};\n/**\n * Reorder layer\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.duplicateLayerUpdater = duplicateLayerUpdater;\nvar reorderLayerUpdater = function reorderLayerUpdater(state, _ref9) {\n  var order = _ref9.order;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    layerOrder: order\n  });\n};\n/**\n * Remove a dataset and all layers, filters, tooltip configs that based on it\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.reorderLayerUpdater = reorderLayerUpdater;\nvar removeDatasetUpdater = function removeDatasetUpdater(state, action) {\n  // extract dataset key\n  var datasetKey = action.dataId;\n  var datasets = state.datasets; // check if dataset is present\n\n  if (!datasets[datasetKey]) {\n    return state;\n  }\n  /* eslint-disable no-unused-vars */\n\n  var layers = state.layers,\n    _state$datasets = state.datasets,\n    dataset = _state$datasets[datasetKey],\n    newDatasets = (0, _objectWithoutProperties2[\"default\"])(_state$datasets, [datasetKey].map(_toPropertyKey));\n  /* eslint-enable no-unused-vars */\n\n  var indexes = layers.reduce(function (listOfIndexes, layer, index) {\n    if (layer.config.dataId === datasetKey) {\n      // @ts-ignore\n      listOfIndexes.push(index);\n    }\n    return listOfIndexes;\n  }, []); // remove layers and datasets\n\n  var _indexes$reduce = indexes.reduce(function (_ref10, idx) {\n      var currentState = _ref10.newState,\n        indexCounter = _ref10.indexCounter;\n      var currentIndex = idx - indexCounter;\n      currentState = removeLayerUpdater(currentState, {\n        idx: currentIndex\n      });\n      indexCounter++;\n      return {\n        newState: currentState,\n        indexCounter: indexCounter\n      };\n    }, {\n      newState: _objectSpread(_objectSpread({}, state), {}, {\n        datasets: newDatasets\n      }),\n      indexCounter: 0\n    }),\n    newState = _indexes$reduce.newState; // remove filters\n\n  var filters = state.filters.filter(function (filter) {\n    return !filter.dataId.includes(datasetKey);\n  }); // update interactionConfig\n\n  var interactionConfig = state.interactionConfig;\n  var _interactionConfig = interactionConfig,\n    tooltip = _interactionConfig.tooltip;\n  if (tooltip) {\n    var config = tooltip.config;\n    /* eslint-disable no-unused-vars */\n\n    var _config$fieldsToShow = config.fieldsToShow,\n      fields = _config$fieldsToShow[datasetKey],\n      fieldsToShow = (0, _objectWithoutProperties2[\"default\"])(_config$fieldsToShow, [datasetKey].map(_toPropertyKey));\n    /* eslint-enable no-unused-vars */\n\n    interactionConfig = _objectSpread(_objectSpread({}, interactionConfig), {}, {\n      tooltip: _objectSpread(_objectSpread({}, tooltip), {}, {\n        config: _objectSpread(_objectSpread({}, config), {}, {\n          fieldsToShow: fieldsToShow\n        })\n      })\n    });\n  }\n  return _objectSpread(_objectSpread({}, newState), {}, {\n    filters: filters,\n    interactionConfig: interactionConfig\n  });\n};\n/**\n * update layer blending mode\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.removeDatasetUpdater = removeDatasetUpdater;\nvar updateLayerBlendingUpdater = function updateLayerBlendingUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    layerBlending: action.mode\n  });\n};\n/**\n * Display dataset table in a modal\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.updateLayerBlendingUpdater = updateLayerBlendingUpdater;\nvar showDatasetTableUpdater = function showDatasetTableUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    editingDataset: action.dataId\n  });\n};\n/**\n * Add custom color for datasets and layers\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.showDatasetTableUpdater = showDatasetTableUpdater;\nvar updateTableColorUpdater = function updateTableColorUpdater(state, action) {\n  var dataId = action.dataId,\n    newColor = action.newColor;\n  var datasets = state.datasets;\n  if ((0, _utils.isRgbColor)(newColor)) {\n    var existing = datasets[dataId];\n    existing.updateTableColor(newColor);\n    return _objectSpread(_objectSpread({}, state), {}, {\n      datasets: _objectSpread(_objectSpread({}, state.datasets), {}, (0, _defineProperty2[\"default\"])({}, dataId, (0, _table.copyTableAndUpdate)(existing, {})))\n    });\n  }\n  return state;\n};\n/**\n * reset visState to initial State\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.updateTableColorUpdater = updateTableColorUpdater;\nvar resetMapConfigUpdater = function resetMapConfigUpdater(state) {\n  return _objectSpread(_objectSpread(_objectSpread({}, INITIAL_VIS_STATE), state.initialState), {}, {\n    initialState: state.initialState\n  });\n};\n/**\n * Propagate `visState` reducer with a new configuration. Current config will be override.\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.resetMapConfigUpdater = resetMapConfigUpdater;\nvar receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref11) {\n  var _ref11$payload = _ref11.payload,\n    _ref11$payload$config = _ref11$payload.config,\n    config = _ref11$payload$config === void 0 ? {\n      version: ''\n    } : _ref11$payload$config,\n    _ref11$payload$option = _ref11$payload.options,\n    options = _ref11$payload$option === void 0 ? {} : _ref11$payload$option;\n  if (!config.visState) {\n    return state;\n  }\n  var keepExistingConfig = options.keepExistingConfig; // reset config if keepExistingConfig is falsy\n\n  var mergedState = !keepExistingConfig ? resetMapConfigUpdater(state) : state;\n  var _iterator = _createForOfIteratorHelper(state.mergers),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var merger = _step.value;\n      if ((0, _visStateMerger.isValidMerger)(merger) && config.visState[merger.prop]) {\n        mergedState = merger.merge(mergedState, config.visState[merger.prop], true);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return mergedState;\n};\n/**\n * Trigger layer hover event with hovered object\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.receiveMapConfigUpdater = receiveMapConfigUpdater;\nvar layerHoverUpdater = function layerHoverUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    hoverInfo: _objectSpread({}, action.info)\n  });\n};\n/* eslint-enable max-statements */\n\n/**\n * Update `interactionConfig`\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.layerHoverUpdater = layerHoverUpdater;\nfunction interactionConfigChangeUpdater(state, action) {\n  var config = action.config;\n  var interactionConfig = _objectSpread(_objectSpread({}, state.interactionConfig), (0, _defineProperty2[\"default\"])({}, config.id, config)); // Don't enable tooltip and brush at the same time\n  // but coordinates can be shown at all time\n\n  var contradict = ['brush', 'tooltip'];\n  if (contradict.includes(config.id) && config.enabled && !state.interactionConfig[config.id].enabled) {\n    // only enable one interaction at a time\n    contradict.forEach(function (k) {\n      if (k !== config.id) {\n        interactionConfig[k] = _objectSpread(_objectSpread({}, interactionConfig[k]), {}, {\n          enabled: false\n        });\n      }\n    });\n  }\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    interactionConfig: interactionConfig\n  });\n  if (config.id === 'geocoder' && !config.enabled) {\n    return removeDatasetUpdater(newState, {\n      dataId: 'geocoder_dataset'\n    });\n  }\n  return newState;\n}\n/**\n * Trigger layer click event with clicked object\n * @memberof visStateUpdaters\n * @public\n */\n\nvar layerClickUpdater = function layerClickUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    mousePos: state.interactionConfig.coordinate.enabled ? _objectSpread(_objectSpread({}, state.mousePos), {}, {\n      pinned: state.mousePos.pinned ? null : (0, _lodash[\"default\"])(state.mousePos)\n    }) : state.mousePos,\n    clicked: action.info && action.info.picked ? action.info : null\n  });\n};\n/**\n * Trigger map click event, unselect clicked object\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.layerClickUpdater = layerClickUpdater;\nvar mapClickUpdater = function mapClickUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    clicked: null\n  });\n};\n/**\n * Trigger map move event\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.mapClickUpdater = mapClickUpdater;\nvar mouseMoveUpdater = function mouseMoveUpdater(state, _ref12) {\n  var evt = _ref12.evt;\n  if (Object.values(state.interactionConfig).some(function (config) {\n    return config.enabled;\n  })) {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      mousePos: _objectSpread(_objectSpread(_objectSpread({}, state.mousePos), Array.isArray(evt.point) ? {\n        mousePosition: (0, _toConsumableArray2[\"default\"])(evt.point)\n      } : {}), Array.isArray(evt.lngLat) ? {\n        coordinate: (0, _toConsumableArray2[\"default\"])(evt.lngLat)\n      } : {})\n    });\n  }\n  return state;\n};\n/**\n * Toggle visibility of a layer for a split map\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.mouseMoveUpdater = mouseMoveUpdater;\nvar toggleSplitMapUpdater = function toggleSplitMapUpdater(state, action) {\n  return state.splitMaps && state.splitMaps.length === 0 ? _objectSpread(_objectSpread({}, state), {}, {\n    // maybe we should use an array to store state for a single map as well\n    // if current maps length is equal to 0 it means that we are about to split the view\n    splitMaps: (0, _utils.computeSplitMapLayers)(state.layers)\n  }) : closeSpecificMapAtIndex(state, action);\n};\n/**\n * Toggle visibility of a layer in a split map\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.toggleSplitMapUpdater = toggleSplitMapUpdater;\nvar toggleLayerForMapUpdater = function toggleLayerForMapUpdater(state, _ref13) {\n  var mapIndex = _ref13.mapIndex,\n    layerId = _ref13.layerId;\n  var splitMaps = state.splitMaps;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    splitMaps: splitMaps.map(function (sm, i) {\n      return i === mapIndex ? _objectSpread(_objectSpread({}, splitMaps[i]), {}, {\n        layers: _objectSpread(_objectSpread({}, splitMaps[i].layers), {}, (0, _defineProperty2[\"default\"])({}, layerId, !splitMaps[i].layers[layerId]))\n      }) : sm;\n    })\n  });\n};\n/**\n * Add new dataset to `visState`, with option to load a map config along with the datasets\n * @memberof visStateUpdaters\n * @public\n */\n\n/* eslint-disable max-statements */\n// eslint-disable-next-line complexity\n\nexports.toggleLayerForMapUpdater = toggleLayerForMapUpdater;\nvar updateVisDataUpdater = function updateVisDataUpdater(state, action) {\n  // datasets can be a single data entries or an array of multiple data entries\n  var config = action.config,\n    options = action.options;\n  var datasets = (0, _utils.toArray)(action.datasets);\n  var newDataEntries = datasets.reduce(function (accu) {\n    var _ref14 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref14$info = _ref14.info,\n      info = _ref14$info === void 0 ? {} : _ref14$info,\n      rest = (0, _objectWithoutProperties2[\"default\"])(_ref14, [\"info\"]);\n    return _objectSpread(_objectSpread({}, accu), (0, _table.createNewDataEntry)(_objectSpread({\n      info: info\n    }, rest), state.datasets) || {});\n  }, {});\n  var dataEmpty = Object.keys(newDataEntries).length < 1; // apply config if passed from action\n\n  var previousState = config ? receiveMapConfigUpdater(state, {\n    payload: {\n      config: config,\n      options: options\n    }\n  }) : state;\n  var mergedState = _objectSpread(_objectSpread({}, previousState), {}, {\n    datasets: _objectSpread(_objectSpread({}, previousState.datasets), newDataEntries)\n  }); // merge state with config to be merged\n\n  var _iterator2 = _createForOfIteratorHelper(mergedState.mergers),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var merger = _step2.value;\n      if ((0, _visStateMerger.isValidMerger)(merger) && merger.toMergeProp && mergedState[merger.toMergeProp]) {\n        var toMerge = mergedState[merger.toMergeProp];\n        mergedState[merger.toMergeProp] = INITIAL_VIS_STATE[merger.toMergeProp];\n        mergedState = merger.merge(mergedState, toMerge);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var newLayers = !dataEmpty ? mergedState.layers.filter(function (l) {\n    return l.config.dataId && l.config.dataId in newDataEntries;\n  }) : [];\n  if (!newLayers.length && (options || {}).autoCreateLayers !== false) {\n    // no layer merged, find defaults\n    var result = addDefaultLayers(mergedState, newDataEntries);\n    mergedState = result.state;\n    newLayers = result.newLayers;\n  }\n  if (mergedState.splitMaps.length) {\n    // if map is split, add new layers to splitMaps\n    newLayers = mergedState.layers.filter(function (l) {\n      return l.config.dataId && l.config.dataId in newDataEntries;\n    });\n    mergedState = _objectSpread(_objectSpread({}, mergedState), {}, {\n      splitMaps: (0, _utils.addNewLayersToSplitMap)(mergedState.splitMaps, newLayers)\n    });\n  } // if no tooltips merged add default tooltips\n\n  Object.keys(newDataEntries).forEach(function (dataId) {\n    var tooltipFields = mergedState.interactionConfig.tooltip.config.fieldsToShow[dataId];\n    if (!Array.isArray(tooltipFields) || !tooltipFields.length) {\n      mergedState = addDefaultTooltips(mergedState, newDataEntries[dataId]);\n    }\n  });\n  var updatedState = updateAllLayerDomainData(mergedState, dataEmpty ? Object.keys(mergedState.datasets) : Object.keys(newDataEntries), undefined); // register layer animation domain,\n  // need to be called after layer data is calculated\n\n  updatedState = updateAnimationDomain(updatedState);\n  return updatedState;\n};\n/* eslint-enable max-statements */\n\n/**\n * Rename an existing dataset in `visState`\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.updateVisDataUpdater = updateVisDataUpdater;\nfunction renameDatasetUpdater(state, action) {\n  var dataId = action.dataId,\n    label = action.label;\n  var datasets = state.datasets;\n  var existing = datasets[dataId];\n  if (existing) {\n    var newDataset = (0, _table.copyTableAndUpdate)(existing, {\n      label: label\n    });\n    return _objectSpread(_objectSpread({}, state), {}, {\n      datasets: _objectSpread(_objectSpread({}, datasets), {}, (0, _defineProperty2[\"default\"])({}, dataId, newDataset))\n    });\n  } // No-op if the dataset doesn't exist\n\n  return state;\n}\n/**\n * When a user clicks on the specific map closing icon\n * the application will close the selected map\n * and will merge the remaining one with the global state\n * TODO: i think in the future this action should be called merge map layers with global settings\n * @param {Object} state `visState`\n * @param {Object} action action\n * @returns {Object} nextState\n */\n\nfunction closeSpecificMapAtIndex(state, action) {\n  var _state$splitMaps$inde;\n\n  // retrieve layers meta data from the remaining map that we need to keep\n  var indexToRetrieve = 1 - action.payload;\n  var mapLayers = (_state$splitMaps$inde = state.splitMaps[indexToRetrieve]) === null || _state$splitMaps$inde === void 0 ? void 0 : _state$splitMaps$inde.layers;\n  var layers = state.layers; // update layer visibility\n\n  var newLayers = layers.map(function (layer) {\n    return mapLayers && !mapLayers[layer.id] && layer.config.isVisible ? layer.updateLayerConfig({\n      // if layer.id is not in mapLayers, it should be inVisible\n      isVisible: false\n    }) : layer;\n  }); // delete map\n\n  return _objectSpread(_objectSpread({}, state), {}, {\n    layers: newLayers,\n    splitMaps: []\n  });\n}\n/**\n * Trigger file loading dispatch `addDataToMap` if succeed, or `loadFilesErr` if failed\n * @memberof visStateUpdaters\n * @public\n */\n\nvar loadFilesUpdater = function loadFilesUpdater(state, action) {\n  var files = action.files,\n    _action$onFinish = action.onFinish,\n    onFinish = _action$onFinish === void 0 ? _actions.loadFilesSuccess : _action$onFinish;\n  if (!files.length) {\n    return state;\n  }\n  var fileLoadingProgress = Array.from(files).reduce(function (accu, f, i) {\n    return (0, _composerHelpers.merge_)(initialFileLoadingProgress(f, i))(accu);\n  }, {});\n  var fileLoading = {\n    fileCache: [],\n    filesToLoad: files,\n    onFinish: onFinish\n  };\n  var nextState = (0, _composerHelpers.merge_)({\n    fileLoadingProgress: fileLoadingProgress,\n    fileLoading: fileLoading\n  })(state);\n  return loadNextFileUpdater(nextState);\n};\n/**\n * Sucessfully loaded one file, move on to the next one\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.loadFilesUpdater = loadFilesUpdater;\nfunction loadFileStepSuccessUpdater(state, action) {\n  if (!state.fileLoading) {\n    return state;\n  }\n  var fileName = action.fileName,\n    fileCache = action.fileCache;\n  var _state$fileLoading = state.fileLoading,\n    filesToLoad = _state$fileLoading.filesToLoad,\n    onFinish = _state$fileLoading.onFinish;\n  var stateWithProgress = updateFileLoadingProgressUpdater(state, {\n    fileName: fileName,\n    progress: {\n      percent: 1,\n      message: 'Done'\n    }\n  }); // save processed file to fileCache\n\n  var stateWithCache = (0, _composerHelpers.pick_)('fileLoading')((0, _composerHelpers.merge_)({\n    fileCache: fileCache\n  }))(stateWithProgress);\n  return (0, _tasks.withTask)(stateWithCache, (0, _tasks2.DELAY_TASK)(200).map(filesToLoad.length ? _actions.loadNextFile : function () {\n    return onFinish(fileCache);\n  }));\n} // withTask<T>(state: T, task: any): T\n\n/**\n *\n * @memberof visStateUpdaters\n * @public\n */\n\nfunction loadNextFileUpdater(state) {\n  if (!state.fileLoading) {\n    return state;\n  }\n  var filesToLoad = state.fileLoading.filesToLoad;\n  var _filesToLoad = (0, _toArray2[\"default\"])(filesToLoad),\n    file = _filesToLoad[0],\n    remainingFilesToLoad = _filesToLoad.slice(1); // save filesToLoad to state\n\n  var nextState = (0, _composerHelpers.pick_)('fileLoading')((0, _composerHelpers.merge_)({\n    filesToLoad: remainingFilesToLoad\n  }))(state);\n  var stateWithProgress = updateFileLoadingProgressUpdater(nextState, {\n    fileName: file.name,\n    progress: {\n      percent: 0,\n      message: 'loading...'\n    }\n  });\n  var loaders = state.loaders,\n    loadOptions = state.loadOptions;\n  return (0, _tasks.withTask)(stateWithProgress, makeLoadFileTask(file, nextState.fileLoading && nextState.fileLoading.fileCache, loaders, loadOptions));\n}\nfunction makeLoadFileTask(file, fileCache) {\n  var loaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var loadOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return (0, _tasks2.LOAD_FILE_TASK)({\n    file: file,\n    fileCache: fileCache,\n    loaders: loaders,\n    loadOptions: loadOptions\n  }).bimap(\n  // prettier ignore\n  // success\n  function (gen) {\n    return (0, _actions.nextFileBatch)({\n      gen: gen,\n      fileName: file.name,\n      onFinish: function onFinish(result) {\n        return (0, _actions.processFileContent)({\n          content: result,\n          fileCache: fileCache\n        });\n      }\n    });\n  },\n  // error\n  function (err) {\n    return (0, _actions.loadFilesErr)(file.name, err);\n  });\n}\n/**\n *\n * @memberof visStateUpdaters\n * @public\n */\n\nfunction processFileContentUpdater(state, action) {\n  var _action$payload = action.payload,\n    content = _action$payload.content,\n    fileCache = _action$payload.fileCache;\n  var stateWithProgress = updateFileLoadingProgressUpdater(state, {\n    fileName: content.fileName,\n    progress: {\n      percent: 1,\n      message: 'processing...'\n    }\n  });\n  return (0, _tasks.withTask)(stateWithProgress, (0, _tasks2.PROCESS_FILE_DATA)({\n    content: content,\n    fileCache: fileCache\n  }).bimap(function (result) {\n    return (0, _actions.loadFileStepSuccess)({\n      fileName: content.fileName,\n      fileCache: result\n    });\n  }, function (err) {\n    return (0, _actions.loadFilesErr)(content.fileName, err);\n  }));\n}\nfunction parseProgress() {\n  var prevProgress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var progress = arguments.length > 1 ? arguments[1] : undefined;\n\n  // This happens when receiving query metadata or other cases we don't\n  // have an update for the user.\n  if (!progress || !progress.percent) {\n    return {};\n  }\n  return {\n    percent: progress.percent\n  };\n}\n/**\n * gets called with payload = AsyncGenerator<???>\n * @memberof visStateUpdaters\n * @public\n */\n\nvar nextFileBatchUpdater = function nextFileBatchUpdater(state, _ref15) {\n  var _ref15$payload = _ref15.payload,\n    gen = _ref15$payload.gen,\n    fileName = _ref15$payload.fileName,\n    progress = _ref15$payload.progress,\n    accumulated = _ref15$payload.accumulated,\n    onFinish = _ref15$payload.onFinish;\n  var stateWithProgress = updateFileLoadingProgressUpdater(state, {\n    fileName: fileName,\n    progress: parseProgress(state.fileLoadingProgress[fileName], progress)\n  });\n  return (0, _tasks.withTask)(stateWithProgress, (0, _tasks2.UNWRAP_TASK)(gen.next()).bimap(function (_ref16) {\n    var value = _ref16.value,\n      done = _ref16.done;\n    return done ? onFinish(accumulated) : (0, _actions.nextFileBatch)({\n      gen: gen,\n      fileName: fileName,\n      progress: value.progress,\n      accumulated: value,\n      onFinish: onFinish\n    });\n  }, function (err) {\n    return (0, _actions.loadFilesErr)(fileName, err);\n  }));\n};\n/**\n * Trigger loading file error\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.nextFileBatchUpdater = nextFileBatchUpdater;\nvar loadFilesErrUpdater = function loadFilesErrUpdater(state, _ref17) {\n  var error = _ref17.error,\n    fileName = _ref17.fileName;\n\n  // update ui with error message\n  _window.console.warn(error);\n  if (!state.fileLoading) {\n    return state;\n  }\n  var _state$fileLoading2 = state.fileLoading,\n    filesToLoad = _state$fileLoading2.filesToLoad,\n    onFinish = _state$fileLoading2.onFinish,\n    fileCache = _state$fileLoading2.fileCache;\n  var nextState = updateFileLoadingProgressUpdater(state, {\n    fileName: fileName,\n    progress: {\n      error: error\n    }\n  }); // kick off next file or finish\n\n  return (0, _tasks.withTask)(nextState, (0, _tasks2.DELAY_TASK)(200).map(filesToLoad.length ? _actions.loadNextFile : function () {\n    return onFinish(fileCache);\n  }));\n};\n/**\n * When select dataset for export, apply cpu filter to selected dataset\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.loadFilesErrUpdater = loadFilesErrUpdater;\nvar applyCPUFilterUpdater = function applyCPUFilterUpdater(state, _ref18) {\n  var dataId = _ref18.dataId;\n  // apply cpuFilter\n  var dataIds = (0, _utils.toArray)(dataId);\n  return dataIds.reduce(function (accu, id) {\n    return (0, _utils.filterDatasetCPU)(accu, id);\n  }, state);\n};\n/**\n * User input to update the info of the map\n * @memberof visStateUpdaters\n * @public\n */\n\nexports.applyCPUFilterUpdater = applyCPUFilterUpdater;\nvar setMapInfoUpdater = function setMapInfoUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    mapInfo: _objectSpread(_objectSpread({}, state.mapInfo), action.info)\n  });\n};\n/**\n * Helper function to update All layer domain and layer data of state\n */\n\nexports.setMapInfoUpdater = setMapInfoUpdater;\nfunction addDefaultLayers(state, datasets) {\n  var empty = [];\n  var defaultLayers = Object.values(datasets).reduce(function (accu, dataset) {\n    var foundLayers = (0, _layerUtils.findDefaultLayer)(dataset, state.layerClasses);\n    return foundLayers && foundLayers.length ? accu.concat(foundLayers) : accu;\n  }, empty);\n  return {\n    state: _objectSpread(_objectSpread({}, state), {}, {\n      layers: [].concat((0, _toConsumableArray2[\"default\"])(state.layers), (0, _toConsumableArray2[\"default\"])(defaultLayers)),\n      layerOrder: [].concat((0, _toConsumableArray2[\"default\"])(defaultLayers.map(function (_, i) {\n        return state.layers.length + i;\n      })), (0, _toConsumableArray2[\"default\"])(state.layerOrder))\n    }),\n    newLayers: defaultLayers\n  };\n}\n/**\n * helper function to find default tooltips\n * @param {Object} state\n * @param {Object} dataset\n * @returns {Object} nextState\n */\n\nfunction addDefaultTooltips(state, dataset) {\n  var tooltipFields = (0, _interactionUtils.findFieldsToShow)(_objectSpread(_objectSpread({}, dataset), {}, {\n    maxDefaultTooltips: state.maxDefaultTooltips\n  }));\n  var merged = _objectSpread(_objectSpread({}, state.interactionConfig.tooltip.config.fieldsToShow), tooltipFields);\n  return (0, _utils.set)(['interactionConfig', 'tooltip', 'config', 'fieldsToShow'], merged, state);\n}\nfunction initialFileLoadingProgress(file, index) {\n  var fileName = file.name || \"Untitled File \".concat(index);\n  return (0, _defineProperty2[\"default\"])({}, fileName, {\n    // percent of current file\n    percent: 0,\n    message: '',\n    fileName: fileName,\n    error: null\n  });\n}\nfunction updateFileLoadingProgressUpdater(state, _ref20) {\n  var fileName = _ref20.fileName,\n    progress = _ref20.progress;\n  // @ts-expect-error\n  return (0, _composerHelpers.pick_)('fileLoadingProgress')((0, _composerHelpers.pick_)(fileName)((0, _composerHelpers.merge_)(progress)))(state);\n}\n/**\n * Helper function to update layer domains for an array of datasets\n */\n\nfunction updateAllLayerDomainData(state, dataId, updatedFilter) {\n  var dataIds = typeof dataId === 'string' ? [dataId] : dataId;\n  var newLayers = [];\n  var newLayerData = [];\n  state.layers.forEach(function (oldLayer, i) {\n    if (oldLayer.config.dataId && dataIds.includes(oldLayer.config.dataId)) {\n      // No need to recalculate layer domain if filter has fixed domain\n      var newLayer = updatedFilter && updatedFilter.fixedDomain ? oldLayer : oldLayer.updateLayerDomain(state.datasets, updatedFilter);\n      var _calculateLayerData5 = (0, _layerUtils.calculateLayerData)(newLayer, state, state.layerData[i]),\n        layerData = _calculateLayerData5.layerData,\n        layer = _calculateLayerData5.layer;\n      newLayers.push(layer);\n      newLayerData.push(layerData);\n    } else {\n      newLayers.push(oldLayer);\n      newLayerData.push(state.layerData[i]);\n    }\n  });\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    layers: newLayers,\n    layerData: newLayerData\n  });\n  return newState;\n}\nfunction updateAnimationDomain(state) {\n  // merge all animatable layer domain and update global config\n  var animatableLayers = state.layers.filter(function (l) {\n    return l.config.isVisible && l.config.animation && l.config.animation.enabled &&\n    // @ts-expect-error trip-layer-only\n    Array.isArray(l.animationDomain);\n  });\n  if (!animatableLayers.length) {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {\n        domain: null,\n        defaultTimeFormat: null\n      })\n    });\n  }\n  var mergedDomain = animatableLayers.reduce(function (accu, layer) {\n    return [\n    // @ts-expect-error trip-layer-only\n    Math.min(accu[0], layer.animationDomain[0]),\n    // @ts-expect-error trip-layer-only\n    Math.max(accu[1], layer.animationDomain[1])];\n  }, [Number(Infinity), -Infinity]);\n  var defaultTimeFormat = (0, _utils.getTimeWidgetTitleFormatter)(mergedDomain);\n  return _objectSpread(_objectSpread({}, state), {}, {\n    animationConfig: _objectSpread(_objectSpread({}, state.animationConfig), {}, {\n      currentTime: (0, _utils.isInRange)(state.animationConfig.currentTime, mergedDomain) ? state.animationConfig.currentTime : mergedDomain[0],\n      domain: mergedDomain,\n      defaultTimeFormat: defaultTimeFormat\n    })\n  });\n}\n/**\n * Update the status of the editor\n * @memberof visStateUpdaters\n */\n\nvar setEditorModeUpdater = function setEditorModeUpdater(state, _ref21) {\n  var mode = _ref21.mode;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    editor: _objectSpread(_objectSpread({}, state.editor), {}, {\n      mode: mode,\n      selectedFeature: null\n    })\n  });\n}; // const featureToFilterValue = (feature) => ({...feature, id: feature.id});\n\n/**\n * Update editor features\n * @memberof visStateUpdaters\n */\n\nexports.setEditorModeUpdater = setEditorModeUpdater;\nfunction setFeaturesUpdater(state, _ref22) {\n  var _ref22$features = _ref22.features,\n    features = _ref22$features === void 0 ? [] : _ref22$features;\n  var lastFeature = features.length && features[features.length - 1];\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    editor: _objectSpread(_objectSpread({}, state.editor), {}, {\n      // only save none filter features to editor\n      features: features.filter(function (f) {\n        return !(0, _utils.getFilterIdInFeature)(f);\n      }),\n      mode: lastFeature && lastFeature.properties.isClosed ? _constants.EDITOR_MODES.EDIT : state.editor.mode\n    })\n  }); // Retrieve existing feature\n\n  var selectedFeature = state.editor.selectedFeature; // If no feature is selected we can simply return since no operations\n\n  if (!selectedFeature) {\n    return newState;\n  } // TODO: check if the feature has changed\n\n  var feature = features.find(function (f) {\n    return f.id === selectedFeature.id;\n  }); // if feature is part of a filter\n\n  var filterId = feature && (0, _utils.getFilterIdInFeature)(feature);\n  if (filterId && feature) {\n    var featureValue = (0, _utils.featureToFilterValue)(feature, filterId);\n    var filterIdx = state.filters.findIndex(function (fil) {\n      return fil.id === filterId;\n    }); // @ts-ignore\n\n    return setFilterUpdater(newState, {\n      idx: filterIdx,\n      prop: 'value',\n      value: featureValue\n    });\n  }\n  return newState;\n}\n/**\n * Set the current selected feature\n * @memberof uiStateUpdaters\n */\n\nvar setSelectedFeatureUpdater = function setSelectedFeatureUpdater(state, _ref23) {\n  var feature = _ref23.feature;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    editor: _objectSpread(_objectSpread({}, state.editor), {}, {\n      selectedFeature: feature\n    })\n  });\n};\n/**\n * Delete existing feature from filters\n * @memberof visStateUpdaters\n */\n\nexports.setSelectedFeatureUpdater = setSelectedFeatureUpdater;\nfunction deleteFeatureUpdater(state, _ref24) {\n  var feature = _ref24.feature;\n  if (!feature) {\n    return state;\n  }\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    editor: _objectSpread(_objectSpread({}, state.editor), {}, {\n      selectedFeature: null\n    })\n  });\n  if ((0, _utils.getFilterIdInFeature)(feature)) {\n    var filterIdx = newState.filters.findIndex(function (f) {\n      return f.id === (0, _utils.getFilterIdInFeature)(feature);\n    });\n    return filterIdx > -1 ? removeFilterUpdater(newState, {\n      idx: filterIdx\n    }) : newState;\n  } // modify editor object\n\n  var newEditor = _objectSpread(_objectSpread({}, state.editor), {}, {\n    features: state.editor.features.filter(function (f) {\n      return f.id !== feature.id;\n    }),\n    selectedFeature: null\n  });\n  return _objectSpread(_objectSpread({}, state), {}, {\n    editor: newEditor\n  });\n}\n/**\n * Toggle feature as layer filter\n * @memberof visStateUpdaters\n */\n\nfunction setPolygonFilterLayerUpdater(state, payload) {\n  var layer = payload.layer,\n    feature = payload.feature;\n  var filterId = (0, _utils.getFilterIdInFeature)(feature); // let newFilter = null;\n\n  var filterIdx;\n  var newLayerId = [layer.id];\n  var newState = state; // If polygon filter already exists, we need to find out if the current layer is already included\n\n  if (filterId) {\n    filterIdx = state.filters.findIndex(function (f) {\n      return f.id === filterId;\n    });\n    if (!state.filters[filterIdx]) {\n      // what if filter doesn't exist?... not possible.\n      // because features in the editor is passed in from filters and editors.\n      // but we will move this feature back to editor just in case\n      var noneFilterFeature = _objectSpread(_objectSpread({}, feature), {}, {\n        properties: _objectSpread(_objectSpread({}, feature.properties), {}, {\n          filterId: null\n        })\n      });\n      return _objectSpread(_objectSpread({}, state), {}, {\n        editor: _objectSpread(_objectSpread({}, state.editor), {}, {\n          features: [].concat((0, _toConsumableArray2[\"default\"])(state.editor.features), [noneFilterFeature]),\n          selectedFeature: noneFilterFeature\n        })\n      });\n    }\n    var filter = state.filters[filterIdx];\n    var _filter$layerId = filter.layerId,\n      layerId = _filter$layerId === void 0 ? [] : _filter$layerId;\n    var isLayerIncluded = layerId.includes(layer.id);\n    newLayerId = isLayerIncluded ?\n    // if layer is included, remove it\n    layerId.filter(function (l) {\n      return l !== layer.id;\n    }) : [].concat((0, _toConsumableArray2[\"default\"])(layerId), [layer.id]);\n  } else {\n    // if we haven't create the polygon filter, create it\n    var newFilter = (0, _utils.generatePolygonFilter)([], feature);\n    filterIdx = state.filters.length; // add feature, remove feature from eidtor\n\n    newState = _objectSpread(_objectSpread({}, state), {}, {\n      filters: [].concat((0, _toConsumableArray2[\"default\"])(state.filters), [newFilter]),\n      editor: _objectSpread(_objectSpread({}, state.editor), {}, {\n        features: state.editor.features.filter(function (f) {\n          return f.id !== feature.id;\n        }),\n        selectedFeature: newFilter.value\n      })\n    });\n  }\n  return setFilterUpdater(newState, {\n    idx: filterIdx,\n    prop: 'layerId',\n    value: newLayerId\n  });\n}\n/**\n * @memberof visStateUpdaters\n * @public\n */\n\nfunction sortTableColumnUpdater(state, _ref25) {\n  var dataId = _ref25.dataId,\n    column = _ref25.column,\n    mode = _ref25.mode;\n  var dataset = state.datasets[dataId];\n  if (!dataset) {\n    return state;\n  }\n  var sortMode = mode;\n  if (!sortMode) {\n    var currentMode = (0, _lodash3[\"default\"])(dataset, ['sortColumn', column]); // @ts-ignore - should be fixable in a TS file\n\n    sortMode = currentMode ? Object.keys(_constants.SORT_ORDER).find(function (m) {\n      return m !== currentMode;\n    }) : _constants.SORT_ORDER.ASCENDING;\n  }\n  var sorted = (0, _table.sortDatasetByColumn)(dataset, column, sortMode);\n  return (0, _utils.set)(['datasets', dataId], sorted, state);\n}\n/**\n * @memberof visStateUpdaters\n * @public\n */\n\nfunction pinTableColumnUpdater(state, _ref26) {\n  var dataId = _ref26.dataId,\n    column = _ref26.column;\n  var dataset = state.datasets[dataId];\n  if (!dataset) {\n    return state;\n  }\n  var newDataset = (0, _table.pinTableColumns)(dataset, column);\n  return (0, _utils.set)(['datasets', dataId], newDataset, state);\n}\n/**\n * Copy column content as strings\n * @memberof visStateUpdaters\n * @public\n */\n\nfunction copyTableColumnUpdater(state, _ref27) {\n  var dataId = _ref27.dataId,\n    column = _ref27.column;\n  var dataset = state.datasets[dataId];\n  if (!dataset) {\n    return state;\n  }\n  var fieldIdx = dataset.fields.findIndex(function (f) {\n    return f.name === column;\n  });\n  if (fieldIdx < 0) {\n    return state;\n  }\n  var type = dataset.fields[fieldIdx].type;\n  var text = dataset.dataContainer.map(function (row) {\n    return (0, _utils.parseFieldValue)(row.valueAt(fieldIdx), type);\n  }, true).join('\\n');\n  (0, _copyToClipboard[\"default\"])(text);\n  return state;\n}\n/**\n * Update editor\n */\n\nfunction toggleEditorVisibilityUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    editor: _objectSpread(_objectSpread({}, state.editor), {}, {\n      visible: !state.editor.visible\n    })\n  });\n}\nfunction setFilterAnimationTimeConfigUpdater(state, _ref28) {\n  var idx = _ref28.idx,\n    config = _ref28.config;\n  var oldFilter = state.filters[idx];\n  if (!oldFilter) {\n    _window.console.error(\"filters.\".concat(idx, \" is undefined\"));\n    return state;\n  }\n  if (oldFilter.type !== _constants.FILTER_TYPES.timeRange) {\n    _window.console.error(\"setFilterAnimationTimeConfig can only be called to update a time filter. check filter.type === 'timeRange'\");\n    return state;\n  }\n  var updates = checkTimeConfigArgs(config);\n  return (0, _composerHelpers.pick_)('filters')((0, _composerHelpers.swap_)((0, _composerHelpers.merge_)(updates)(oldFilter)))(state);\n}\nfunction checkTimeConfigArgs(config) {\n  var allowed = ['timeFormat', 'timezone'];\n  return Object.keys(config).reduce(function (accu, prop) {\n    if (!allowed.includes(prop)) {\n      _window.console.error(\"setLayerAnimationTimeConfig takes timeFormat and/or timezone as options, found \".concat(prop));\n      return accu;\n    } // here we are NOT checking if timezone or timeFormat input is valid\n\n    accu[prop] = config[prop];\n    return accu;\n  }, {});\n}\n/**\n * Update editor\n */\n\nfunction setLayerAnimationTimeConfigUpdater(state, _ref29) {\n  var config = _ref29.config;\n  if (!config) {\n    return state;\n  }\n  var updates = checkTimeConfigArgs(config);\n  return (0, _composerHelpers.pick_)('animationConfig')((0, _composerHelpers.merge_)(updates))(state);\n}","map":{"version":3,"names":["exports","updateAnimationDomain","deleteFeatureUpdater","sortTableColumnUpdater","copyTableColumnUpdater","setFilterAnimationTimeConfigUpdater","setSelectedFeatureUpdater","setEditorModeUpdater","setMapInfoUpdater","applyCPUFilterUpdater","loadFilesErrUpdater","nextFileBatchUpdater","loadFilesUpdater","updateVisDataUpdater","toggleLayerForMapUpdater","toggleSplitMapUpdater","mouseMoveUpdater","mapClickUpdater","layerClickUpdater","layerHoverUpdater","receiveMapConfigUpdater","resetMapConfigUpdater","updateTableColorUpdater","showDatasetTableUpdater","updateLayerBlendingUpdater","removeDatasetUpdater","reorderLayerUpdater","duplicateLayerUpdater","removeLayerUpdater","addLayerUpdater","removeFilterUpdater","toggleFilterFeatureUpdater","enlargeFilterUpdater","updateLayerAnimationSpeedUpdater","setLayerAnimationTimeUpdater","updateFilterAnimationSpeedUpdater","toggleLayerAnimationControlUpdater","toggleLayerAnimationUpdater","toggleFilterAnimationUpdater","layerColorUIChangeUpdater","addFilterUpdater","setFilterPlotUpdater","INITIAL_VIS_STATE","DEFAULT_EDITOR","DEFAULT_ANIMATION_CONFIG","defaultInteractionConfig","_toArray2","_interopRequireDefault","require","_toConsumableArray2","_objectWithoutProperties2","_defineProperty2","_window","_tasks","_lodash","_lodash2","_lodash3","_lodash4","_copyToClipboard","_tasks2","_layerUtils","_table","_interactionUtils","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","_toPropertyKey","arg","key","_toPrimitive","_typeof","String","input","hint","prim","toPrimitive","undefined","res","Number","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","disableStackCapturing","visStateUpdaters","tooltip","id","label","enabled","config","fieldsToShow","compareMode","compareType","_constants","COMPARE_TYPES","ABSOLUTE","geocoder","position","brush","coordinate","domain","isAnimating","timeFormat","timezone","defaultTimeFormat","mode","EDITOR_MODES","DRAW_POLYGON","features","selectedFeature","visible","mapInfo","title","description","layers","layerData","layerToBeMerged","layerOrder","filters","filterToBeMerged","datasets","editingDataset","interactionConfig","interactionToBeMerged","layerBlending","hoverInfo","clicked","mousePos","maxDefaultTooltips","MAX_DEFAULT_TOOLTIPS","splitMaps","animationConfig","editor","fileLoading","fileLoadingProgress","loaders","loadOptions","mergers","_visStateMerger","VIS_STATE_MERGERS","schema","_schemas","updateStateWithLayerAndData","state","_ref","idx","map","lyr","d","newState","layer","isVisible","_utils","addNewLayersToSplitMap","removeLayerFromSplitMaps","animation","layerConfigChangeUpdater","action","oldLayer","findIndex","l","newConfig","dataId","_action$newConfig","restConfig","stateWithDataId","layerDataIdChangeUpdater","nextLayer","newLayer","updateLayerConfig","shouldCalculateLayerData","props","oldLayerData","updateLayerDataResult","calculateLayerData","updateStateOnLayerVisibilityChange","newTextLabel","textLabel","currentFields","tl","field","addFields","newFields","includes","find","fd","DEFAULT_TEXT_LABEL","concat","af","updateTextLabelPropAndValue","prop","hasOwnProperty","splice","layerTextLabelChangeUpdater","addOrRemoveTextLabels","validateExistingLayerWithData","dataset","layerClasses","validateLayerWithData","loadedLayer","allowEmptyColumn","isValidToSave","validated","type","isConfigActive","_calculateLayerData","result","findDefaultLayerProps","setInitialLayerConfig","layerTypeChangeUpdater","newType","oldId","console","error","assignConfigToLayer","visConfigSettings","isLayerHovered","_calculateLayerData2","_settings$layers","settings","oldLayerMap","otherLayers","channel","updateLayerVisualChannel","_calculateLayerData3","layerVisConfigChangeUpdater","newVisConfig","visConfig","_calculateLayerData4","setFilterAnimationTimeUpdater","setFilterUpdater","setFilterAnimationWindowUpdater","_ref2","animationWindow","_action$valueIndex","valueIndex","oldFilter","newFilter","set","_newFilter","datasetIds","toArray","FILTER_UPDATER_PROPS","mergeDomain","updatedFilter","_applyFilterFieldName","newDataset","gpu","setFilterGpuMode","datasetId","layerId","layerIdDifference","layerDataIds","lid","newDataIds","enlargedFilter","enlarged","datasetIdsToFilter","LIMITED_FILTER_EFFECT_PROPS","filteredDatasets","applyFiltersToDatasets","updateAllLayerDomainData","_ref3","newProp","_ref3$valueIndex","plotType","getDefaultFilterPlotType","getDefaultFilter","_ref4","oldVixConfig","updateLayerColorUI","hideControl","speed","_ref5","currentTime","_ref6","featureToFilterValue","assign","_state$filters$idx","newFilters","newEditor","newLayerData","createLayerFromConfig","_action$datasetId","defaultDataset","_ref7","layerToRemove","newMaps","pid","original","_ref8","originalLayerOrderIdx","newLabel","postfix","serializeLayer","nextState","newLayerOrderIdx","newLayerOrder","arrayInsert","_ref9","order","_state$datasets","datasetKey","newDatasets","indexes","reduce","listOfIndexes","index","currentState","_ref10","indexCounter","currentIndex","_indexes$reduce","_interactionConfig","_config$fieldsToShow","fields","isRgbColor","newColor","existing","updateTableColor","copyTableAndUpdate","initialState","_ref11","_ref11$payload","payload","_ref11$payload$config","version","_ref11$payload$option","options","visState","mergedState","keepExistingConfig","_iterator","_step","merger","merge","interactionConfigChangeUpdater","contradict","k","pinned","info","picked","_ref12","evt","point","mousePosition","lngLat","computeSplitMapLayers","closeSpecificMapAtIndex","sm","mapIndex","newDataEntries","accu","_ref14","rest","previousState","_iterator2","_step2","isValidMerger","toMergeProp","toMerge","addDefaultLayers","newLayers","addDefaultTooltips","updatedState","dataEmpty","renameDatasetUpdater","_state$splitMaps$inde","indexToRetrieve","mapLayers","files","_action$onFinish","onFinish","_actions","loadFilesSuccess","fileCache","filesToLoad","_composerHelpers","merge_","loadNextFileUpdater","loadFileStepSuccessUpdater","stateWithProgress","_state$fileLoading","updateFileLoadingProgressUpdater","percent","message","stateWithCache","pick_","withTask","DELAY_TASK","loadNextFile","_filesToLoad","file","remainingFilesToLoad","fileName","progress","makeLoadFileTask","LOAD_FILE_TASK","bimap","gen","processFileContent","content","loadFilesErr","processFileContentUpdater","_action$payload","PROCESS_FILE_DATA","loadFileStepSuccess","prevProgress","_ref15","_ref15$payload","accumulated","parseProgress","nextFileBatch","_ref17","warn","_ref18","dataIds","empty","foundLayers","defaultLayers","_","tooltipFields","findFieldsToShow","merged","_ref20","fixedDomain","updateLayerDomain","_calculateLayerData5","animatableLayers","animationDomain","mergedDomain","Math","min","max","Infinity","getTimeWidgetTitleFormatter","isInRange","_ref21","setFeaturesUpdater","_ref22","lastFeature","getFilterIdInFeature","properties","isClosed","EDIT","feature","filterId","featureValue","filterIdx","fil","_ref23","_ref24","setPolygonFilterLayerUpdater","newLayerId","noneFilterFeature","_filter$layerId","isLayerIncluded","generatePolygonFilter","sorted","_ref25","column","sortMode","currentMode","SORT_ORDER","m","sortDatasetByColumn","pinTableColumnUpdater","_ref26","pinTableColumns","_ref27","fieldIdx","text","dataContainer","row","parseFieldValue","valueAt","join","toggleEditorVisibilityUpdater","Console","_ref28","FILTER_TYPES","timeRange","updates","checkTimeConfigArgs","allowed"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/reducers/src/vis-state-updaters.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {console as Console} from 'global/window';\nimport {disableStackCapturing, withTask} from 'react-palm/tasks';\nimport cloneDeep from 'lodash.clonedeep';\nimport uniq from 'lodash.uniq';\nimport get from 'lodash.get';\nimport xor from 'lodash.xor';\nimport copy from 'copy-to-clipboard';\n// Tasks\nimport {LOAD_FILE_TASK, UNWRAP_TASK, PROCESS_FILE_DATA, DELAY_TASK} from '@kepler.gl/tasks';\n// Actions\nimport {\n  loadFilesErr,\n  loadFilesSuccess,\n  loadFileStepSuccess,\n  loadNextFile,\n  nextFileBatch,\n  ReceiveMapConfigPayload,\n  VisStateActions,\n  MapStateActions,\n  processFileContent,\n  ActionTypes\n} from '@kepler.gl/actions';\n\n// Utils\nimport {\n  set,\n  toArray,\n  arrayInsert,\n  generateHashId,\n  addNewLayersToSplitMap,\n  computeSplitMapLayers,\n  removeLayerFromSplitMaps,\n  isRgbColor,\n  parseFieldValue,\n  applyFilterFieldName,\n  applyFiltersToDatasets,\n  featureToFilterValue,\n  filterDatasetCPU,\n  FILTER_UPDATER_PROPS,\n  generatePolygonFilter,\n  getDefaultFilter,\n  getFilterIdInFeature,\n  getTimeWidgetTitleFormatter,\n  isInRange,\n  LIMITED_FILTER_EFFECT_PROPS,\n  updateFilterDataId,\n  getFilterPlot,\n  getDefaultFilterPlotType\n} from '@kepler.gl/utils';\n\nimport {\n  isValidMerger,\n  VIS_STATE_MERGERS,\n  validateLayerWithData,\n  createLayerFromConfig,\n  serializeLayer\n} from './vis-state-merger';\n\nimport {Layer, LayerClasses, LAYER_ID_LENGTH} from '@kepler.gl/layers';\nimport {\n  EDITOR_MODES,\n  SORT_ORDER,\n  FILTER_TYPES,\n  MAX_DEFAULT_TOOLTIPS,\n  DEFAULT_TEXT_LABEL,\n  COMPARE_TYPES\n} from '@kepler.gl/constants';\nimport {pick_, merge_, swap_} from './composer-helpers';\n\nimport KeplerGLSchema, {VisState} from '@kepler.gl/schemas';\n\nimport {Filter, InteractionConfig, AnimationConfig, Editor} from '@kepler.gl/types';\nimport {Loader} from '@loaders.gl/loader-utils';\n\nimport {calculateLayerData, findDefaultLayer} from './layer-utils';\nimport {\n  copyTableAndUpdate,\n  Datasets,\n  pinTableColumns,\n  sortDatasetByColumn,\n  assignGpuChannel,\n  setFilterGpuMode,\n  createNewDataEntry\n} from '@kepler.gl/table';\nimport {findFieldsToShow} from './interaction-utils';\n\n// react-palm\n// disable capture exception for react-palm call to withTask\ndisableStackCapturing();\n\n/**\n * Updaters for `visState` reducer. Can be used in your root reducer to directly modify kepler.gl's state.\n * Read more about [Using updaters](../advanced-usage/using-updaters.md)\n *\n * @public\n * @example\n *\n * import keplerGlReducer, {visStateUpdaters} from 'kepler.gl/reducers';\n * // Root Reducer\n * const reducers = combineReducers({\n *  keplerGl: keplerGlReducer,\n *  app: appReducer\n * });\n *\n * const composedReducer = (state, action) => {\n *  switch (action.type) {\n *    case 'CLICK_BUTTON':\n *      return {\n *        ...state,\n *        keplerGl: {\n *          ...state.keplerGl,\n *          foo: {\n *             ...state.keplerGl.foo,\n *             visState: visStateUpdaters.enlargeFilterUpdater(\n *               state.keplerGl.foo.visState,\n *               {idx: 0}\n *             )\n *          }\n *        }\n *      };\n *  }\n *  return reducers(state, action);\n * };\n *\n * export default composedReducer;\n */\n/* eslint-disable no-unused-vars */\n// @ts-ignore\nconst visStateUpdaters = null;\n/* eslint-enable no-unused-vars */\n\nexport const defaultInteractionConfig: InteractionConfig = {\n  tooltip: {\n    id: 'tooltip',\n    label: 'interactions.tooltip',\n    enabled: true,\n    config: {\n      fieldsToShow: {},\n      compareMode: false,\n      compareType: COMPARE_TYPES.ABSOLUTE\n    }\n  },\n  geocoder: {\n    id: 'geocoder',\n    label: 'interactions.geocoder',\n    enabled: false,\n    position: null\n  },\n  brush: {\n    id: 'brush',\n    label: 'interactions.brush',\n    enabled: false,\n    config: {\n      // size is in km\n      size: 0.5\n    }\n  },\n  coordinate: {\n    id: 'coordinate',\n    label: 'interactions.coordinate',\n    enabled: false,\n    position: null\n  }\n};\n\nexport const DEFAULT_ANIMATION_CONFIG: AnimationConfig = {\n  domain: null,\n  currentTime: null,\n  speed: 1,\n  isAnimating: false,\n  timeFormat: null,\n  timezone: null,\n  defaultTimeFormat: null\n};\n\nexport const DEFAULT_EDITOR: Editor = {\n  mode: EDITOR_MODES.DRAW_POLYGON,\n  features: [],\n  selectedFeature: null,\n  visible: true\n};\n\n/**\n * Default initial `visState`\n * @memberof visStateUpdaters\n * @constant\n * @public\n */\nexport const INITIAL_VIS_STATE: VisState = {\n  // map info\n  mapInfo: {\n    title: '',\n    description: ''\n  },\n  // layers\n  layers: [],\n  layerData: [],\n  layerToBeMerged: [],\n  layerOrder: [],\n\n  // filters\n  filters: [],\n  filterToBeMerged: [],\n\n  // a collection of multiple dataset\n  datasets: {},\n  editingDataset: undefined,\n\n  interactionConfig: defaultInteractionConfig,\n  interactionToBeMerged: undefined,\n\n  layerBlending: 'normal',\n  hoverInfo: undefined,\n  clicked: undefined,\n  mousePos: {},\n  maxDefaultTooltips: MAX_DEFAULT_TOOLTIPS,\n\n  // this is used when user split maps\n  splitMaps: [\n    // this will contain a list of objects to\n    // describe the state of layer availability and visibility for each map\n    // [\n    //   {\n    //      layers: {layer_id: true | false}\n    //   }\n    // ]\n  ],\n  splitMapsToBeMerged: [],\n\n  // defaults layer classes\n  layerClasses: LayerClasses,\n\n  // default animation\n  // time in unix timestamp (milliseconds) (the number of seconds since the Unix Epoch)\n  animationConfig: DEFAULT_ANIMATION_CONFIG,\n\n  editor: DEFAULT_EDITOR,\n\n  fileLoading: false,\n  fileLoadingProgress: {},\n\n  loaders: [],\n  loadOptions: {},\n\n  // visStateMergers\n  mergers: VIS_STATE_MERGERS,\n\n  // kepler schemas\n  schema: KeplerGLSchema\n};\n\n/**\n * Update state with updated layer and layerData\n *\n */\nexport function updateStateWithLayerAndData(\n  state: VisState,\n  {layerData, layer, idx}: {layerData?: any; layer: Layer; idx: number}\n): VisState {\n  return {\n    ...state,\n    layers: state.layers.map((lyr, i) => (i === idx ? layer : lyr)),\n    layerData: layerData\n      ? state.layerData.map((d, i) => (i === idx ? layerData : d))\n      : state.layerData\n  };\n}\n\nexport function updateStateOnLayerVisibilityChange<S extends VisState>(state: S, layer: Layer): S {\n  let newState = state;\n  if (state.splitMaps.length) {\n    newState = {\n      ...state,\n      splitMaps: layer.config.isVisible\n        ? addNewLayersToSplitMap(state.splitMaps, layer)\n        : removeLayerFromSplitMaps(state.splitMaps, layer)\n    };\n  }\n\n  if (layer.config.animation.enabled) {\n    newState = updateAnimationDomain(state);\n  }\n\n  return newState;\n}\n\n/**\n * Update layer base config: dataId, label, column, isVisible\n * @memberof visStateUpdaters\n * @returns nextState\n */\nexport function layerConfigChangeUpdater(\n  state: VisState,\n  action: VisStateActions.LayerConfigChangeUpdaterAction\n): VisState {\n  const {oldLayer} = action;\n  const idx = state.layers.findIndex(l => l.id === oldLayer.id);\n  const props = Object.keys(action.newConfig);\n  if (typeof action.newConfig.dataId === 'string') {\n    const {dataId, ...restConfig} = action.newConfig;\n    const stateWithDataId = layerDataIdChangeUpdater(state, {\n      oldLayer,\n      newConfig: {dataId}\n    });\n    const nextLayer = stateWithDataId.layers.find(l => l.id === oldLayer.id);\n    return nextLayer && Object.keys(restConfig).length\n      ? layerConfigChangeUpdater(stateWithDataId, {oldLayer: nextLayer, newConfig: restConfig})\n      : stateWithDataId;\n  }\n\n  let newLayer = oldLayer.updateLayerConfig(action.newConfig);\n\n  let layerData;\n\n  // let newLayer;\n  if (newLayer.shouldCalculateLayerData(props)) {\n    const oldLayerData = state.layerData[idx];\n    const updateLayerDataResult = calculateLayerData(newLayer, state, oldLayerData);\n\n    layerData = updateLayerDataResult.layerData;\n    newLayer = updateLayerDataResult.layer;\n  }\n\n  let newState = state;\n  if ('isVisible' in action.newConfig) {\n    newState = updateStateOnLayerVisibilityChange(state, newLayer);\n  }\n\n  return updateStateWithLayerAndData(newState, {\n    layer: newLayer,\n    layerData,\n    idx\n  });\n}\n\nfunction addOrRemoveTextLabels(newFields, textLabel) {\n  let newTextLabel = textLabel.slice();\n\n  const currentFields = textLabel.map(tl => tl.field && tl.field.name).filter(d => d);\n\n  const addFields = newFields.filter(f => !currentFields.includes(f.name));\n  const deleteFields = currentFields.filter(f => !newFields.find(fd => fd.name === f));\n\n  // delete\n  newTextLabel = newTextLabel.filter(tl => tl.field && !deleteFields.includes(tl.field.name));\n  newTextLabel = !newTextLabel.length ? [DEFAULT_TEXT_LABEL] : newTextLabel;\n\n  // add\n  newTextLabel = [\n    ...newTextLabel.filter(tl => tl.field),\n    ...addFields.map(af => ({\n      ...DEFAULT_TEXT_LABEL,\n      field: af\n    }))\n  ];\n\n  return newTextLabel;\n}\n\nfunction updateTextLabelPropAndValue(idx, prop, value, textLabel) {\n  if (!textLabel[idx].hasOwnProperty(prop)) {\n    return textLabel;\n  }\n\n  let newTextLabel = textLabel.slice();\n\n  if (prop && (value || textLabel.length === 1)) {\n    newTextLabel = textLabel.map((tl, i) => (i === idx ? {...tl, [prop]: value} : tl));\n  } else if (prop === 'field' && value === null && textLabel.length > 1) {\n    // remove label when field value is set to null\n    newTextLabel.splice(idx, 1);\n  }\n\n  return newTextLabel;\n}\n\n/**\n * Update layer base config: dataId, label, column, isVisible\n * @memberof visStateUpdaters\n * @returns nextState\n */\nexport function layerTextLabelChangeUpdater(\n  state: VisState,\n  action: VisStateActions.LayerTextLabelChangeUpdaterAction\n): VisState {\n  const {oldLayer, idx, prop, value} = action;\n  const {textLabel} = oldLayer.config;\n\n  let newTextLabel = textLabel.slice();\n  if (!textLabel[idx] && idx === textLabel.length) {\n    // if idx is set to length, add empty text label\n    newTextLabel = [...textLabel, DEFAULT_TEXT_LABEL];\n  }\n\n  if (idx === 'all' && prop === 'fields') {\n    newTextLabel = addOrRemoveTextLabels(value, textLabel);\n  } else {\n    newTextLabel = updateTextLabelPropAndValue(idx, prop, value, newTextLabel);\n  }\n  // update text label prop and value\n  return layerConfigChangeUpdater(state, {\n    oldLayer,\n    newConfig: {textLabel: newTextLabel}\n  });\n}\n\nfunction validateExistingLayerWithData(dataset, layerClasses, layer) {\n  const loadedLayer = serializeLayer(layer);\n  return validateLayerWithData(dataset, loadedLayer, layerClasses, {\n    allowEmptyColumn: true\n  });\n}\n\n/**\n * Update layer config dataId\n * @memberof visStateUpdaters\n * @returns nextState\n */\nexport function layerDataIdChangeUpdater(\n  state: VisState,\n  action: {\n    oldLayer: Layer;\n    newConfig: {\n      dataId: string;\n    };\n  }\n): VisState {\n  const {oldLayer, newConfig} = action;\n  const {dataId} = newConfig;\n\n  if (!oldLayer || !state.datasets[dataId]) {\n    return state;\n  }\n  const idx = state.layers.findIndex(l => l.id === oldLayer.id);\n\n  let newLayer = oldLayer.updateLayerConfig({dataId});\n  // this may happen when a layer is new (type: null and no columns) but it's not ready to be saved\n  if (newLayer.isValidToSave()) {\n    const validated = validateExistingLayerWithData(\n      state.datasets[dataId],\n      state.layerClasses,\n      newLayer\n    );\n    // if cant validate it with data create a new one\n    if (!validated) {\n      // @ts-expect-error TODO: checking oldLayer.type !== null\n      newLayer = new state.layerClasses[oldLayer.type]({dataId, id: oldLayer.id});\n    } else {\n      newLayer = validated;\n    }\n  }\n\n  newLayer = newLayer.updateLayerConfig({\n    isVisible: oldLayer.config.isVisible,\n    isConfigActive: true\n  });\n\n  newLayer.updateLayerDomain(state.datasets);\n  const {layerData, layer} = calculateLayerData(newLayer, state, undefined);\n\n  return updateStateWithLayerAndData(state, {layerData, layer, idx});\n}\n\nfunction setInitialLayerConfig(layer, datasets, layerClasses) {\n  let newLayer = layer;\n  if (!Object.keys(datasets).length) {\n    // no data is loaded\n    return layer;\n  }\n  if (!layer.config.dataId) {\n    // set layer dataId\n    newLayer = layer.updateLayerConfig({dataId: Object.keys(datasets)[0]});\n  }\n  const dataset = datasets[newLayer.config.dataId];\n  if (!dataset) {\n    return layer;\n  }\n\n  // find defaut layer props\n  const result =\n    typeof layerClasses[newLayer.type].findDefaultLayerProps === 'function'\n      ? layerClasses[newLayer.type].findDefaultLayerProps(dataset, [])\n      : {props: []};\n\n  // an array of possible props, use 1st one\n  const props = Array.isArray(result) ? result : result.props || [];\n\n  if (props.length) {\n    newLayer = new layerClasses[layer.type]({\n      ...props[0],\n      label: newLayer.config.label,\n      dataId: newLayer.config.dataId,\n      isVisible: true,\n      isConfigActive: newLayer.config.isConfigActive\n    });\n\n    return typeof newLayer.setInitialLayerConfig === 'function'\n      ? newLayer.setInitialLayerConfig(dataset)\n      : newLayer;\n  }\n\n  return newLayer;\n}\n/**\n * Update layer type. Previews layer config will be copied if applicable.\n * @memberof visStateUpdaters\n * @public\n */\nexport function layerTypeChangeUpdater(\n  state: VisState,\n  action: VisStateActions.LayerTypeChangeUpdaterAction\n): VisState {\n  const {oldLayer, newType} = action;\n  if (!oldLayer) {\n    return state;\n  }\n  const oldId = oldLayer.id;\n  const idx = state.layers.findIndex(l => l.id === oldId);\n\n  if (!state.layerClasses[newType]) {\n    Console.error(`${newType} is not a valid layer type`);\n    return state;\n  }\n  let newLayer = new state.layerClasses[newType]({\n    // keep old layer lable and isConfigActive\n    label: oldLayer.config.label,\n    isConfigActive: oldLayer.config.isConfigActive\n  });\n\n  if (!oldLayer.type) {\n    // if setting layer type on an empty layer\n    newLayer = setInitialLayerConfig(newLayer, state.datasets, state.layerClasses);\n  } else {\n    // get a mint layer, with new id and type\n    // because deck.gl uses id to match between new and old layer.\n    // If type has changed but id is the same, it will break\n    newLayer.assignConfigToLayer(oldLayer.config, oldLayer.visConfigSettings);\n    newLayer.updateLayerDomain(state.datasets);\n  }\n\n  const {clicked, hoverInfo} = state;\n\n  let newState = {\n    ...state,\n    clicked: oldLayer.isLayerHovered(clicked) ? undefined : clicked,\n    hoverInfo: oldLayer.isLayerHovered(hoverInfo) ? undefined : hoverInfo\n  };\n\n  const {layerData, layer} = calculateLayerData(newLayer, newState);\n  newState = updateStateWithLayerAndData(newState, {layerData, layer, idx});\n\n  if (layer.config.animation.enabled || oldLayer.config.animation.enabled) {\n    newState = updateAnimationDomain(newState);\n  }\n\n  // update splitMap layer id\n  if (state.splitMaps.length) {\n    newState = {\n      ...newState,\n      splitMaps: newState.splitMaps.map(settings => {\n        const {[oldId]: oldLayerMap, ...otherLayers} = settings.layers;\n        return oldId in settings.layers\n          ? {\n              ...settings,\n              layers: {\n                ...otherLayers,\n                [layer.id]: oldLayerMap\n              }\n            }\n          : settings;\n      })\n    };\n  }\n\n  return newState;\n}\n\n/**\n * Update layer visual channel\n * @memberof visStateUpdaters\n * @returns {Object} nextState\n * @public\n */\nexport function layerVisualChannelChangeUpdater(\n  state: VisState,\n  action: VisStateActions.LayerVisualChannelConfigChangeUpdaterAction\n): VisState {\n  const {oldLayer, newConfig, channel} = action;\n  if (!oldLayer.config.dataId) {\n    return state;\n  }\n  const dataset = state.datasets[oldLayer.config.dataId];\n\n  const idx = state.layers.findIndex(l => l.id === oldLayer.id);\n  const newLayer = oldLayer.updateLayerConfig(newConfig);\n\n  newLayer.updateLayerVisualChannel(dataset, channel);\n\n  const oldLayerData = state.layerData[idx];\n  const {layerData, layer} = calculateLayerData(newLayer, state, oldLayerData);\n\n  return updateStateWithLayerAndData(state, {layerData, layer, idx});\n}\n\n/**\n * Update layer `visConfig`\n * @memberof visStateUpdaters\n * @public\n */\nexport function layerVisConfigChangeUpdater(\n  state: VisState,\n  action: VisStateActions.LayerVisConfigChangeUpdaterAction\n): VisState {\n  const {oldLayer} = action;\n  const idx = state.layers.findIndex(l => l.id === oldLayer.id);\n  const props = Object.keys(action.newVisConfig);\n  const newVisConfig = {\n    ...oldLayer.config.visConfig,\n    ...action.newVisConfig\n  };\n\n  const newLayer = oldLayer.updateLayerConfig({visConfig: newVisConfig});\n\n  if (newLayer.shouldCalculateLayerData(props)) {\n    const oldLayerData = state.layerData[idx];\n    const {layerData, layer} = calculateLayerData(newLayer, state, oldLayerData);\n    return updateStateWithLayerAndData(state, {layerData, layer, idx});\n  }\n\n  return updateStateWithLayerAndData(state, {layer: newLayer, idx});\n}\n\n/**\n * Update filter property\n * @memberof visStateUpdaters\n * @public\n */\nexport function setFilterAnimationTimeUpdater(\n  state: VisState,\n  action: VisStateActions.SetFilterAnimationTimeUpdaterAction\n): VisState {\n  return setFilterUpdater(state, action);\n}\n\n/**\n * Update filter animation window\n * @memberof visStateUpdaters\n * @public\n */\nexport function setFilterAnimationWindowUpdater(\n  state: VisState,\n  {id, animationWindow}: VisStateActions.SetFilterAnimationWindowUpdaterAction\n): VisState {\n  return {\n    ...state,\n    filters: state.filters.map(f =>\n      f.id === id\n        ? {\n            ...f,\n            animationWindow\n          }\n        : f\n    )\n  };\n}\n/**\n * Update filter property\n * @memberof visStateUpdaters\n * @public\n */\nexport function setFilterUpdater(\n  state: VisState,\n  action: VisStateActions.SetFilterUpdaterAction\n): VisState {\n  const {idx, prop, value, valueIndex = 0} = action;\n  const oldFilter = state.filters[idx];\n\n  if (!oldFilter) {\n    Console.error(`filters.${idx} is undefined`);\n    return state;\n  }\n  let newFilter = set([prop], value, oldFilter);\n  let newState = state;\n\n  const {dataId} = newFilter;\n\n  // Ensuring backward compatibility\n  let datasetIds = toArray(dataId);\n\n  switch (prop) {\n    // TODO: Next PR for UI if we update dataId, we need to consider two cases:\n    // 1. dataId is empty: create a default filter\n    // 2. Add a new dataset id\n    case FILTER_UPDATER_PROPS.dataId:\n      // if trying to update filter dataId. create an empty new filter\n      newFilter = updateFilterDataId(dataId);\n      break;\n\n    case FILTER_UPDATER_PROPS.name:\n      // we are supporting the current functionality\n      // TODO: Next PR for UI filter name will only update filter name but it won't have side effects\n      // we are gonna use pair of datasets and fieldIdx to update the filter\n      const datasetId = newFilter.dataId[valueIndex];\n      const {filter: updatedFilter, dataset: newDataset} = applyFilterFieldName(\n        newFilter,\n        state.datasets[datasetId],\n        value,\n        valueIndex,\n        {mergeDomain: false}\n      );\n      if (!updatedFilter) {\n        return state;\n      }\n\n      newFilter = updatedFilter;\n\n      if (newFilter.gpu) {\n        newFilter = setFilterGpuMode(newFilter, state.filters);\n        newFilter = assignGpuChannel(newFilter, state.filters);\n      }\n\n      newState = set(['datasets', datasetId], newDataset, state);\n\n      // only filter the current dataset\n      break;\n    case FILTER_UPDATER_PROPS.layerId:\n      // We need to update only datasetId/s if we have added/removed layers\n      // - check for layerId changes (XOR works because of string values)\n      // if no differences between layerIds, don't do any filtering\n      // @ts-ignore\n      const layerIdDifference = xor(newFilter.layerId, oldFilter.layerId);\n\n      const layerDataIds = uniq(\n        layerIdDifference\n          .map(lid =>\n            get(\n              state.layers.find(l => l.id === lid),\n              ['config', 'dataId']\n            )\n          )\n          .filter(d => d)\n      );\n\n      // only filter datasetsIds\n      datasetIds = layerDataIds;\n\n      // Update newFilter dataIds\n      const newDataIds = uniq(\n        newFilter.layerId\n          .map(lid =>\n            get(\n              state.layers.find(l => l.id === lid),\n              ['config', 'dataId']\n            )\n          )\n          .filter(d => d)\n      );\n\n      newFilter = {\n        ...newFilter,\n        dataId: newDataIds\n      };\n\n      break;\n    default:\n      break;\n  }\n\n  const enlargedFilter = state.filters.find(f => f.enlarged);\n\n  if (enlargedFilter && enlargedFilter.id !== newFilter.id) {\n    // there should be only one enlarged filter\n    newFilter.enlarged = false;\n  }\n\n  // save new filters to newState\n  newState = set(['filters', idx], newFilter, newState);\n\n  // if we are currently setting a prop that only requires to filter the current\n  // dataset we will pass only the current dataset to applyFiltersToDatasets and\n  // updateAllLayerDomainData otherwise we pass the all list of datasets as defined in dataId\n  const datasetIdsToFilter = LIMITED_FILTER_EFFECT_PROPS[prop]\n    ? [datasetIds[valueIndex]]\n    : datasetIds;\n\n  // filter data\n  const filteredDatasets = applyFiltersToDatasets(\n    datasetIdsToFilter,\n    newState.datasets,\n    newState.filters,\n    newState.layers\n  );\n\n  newState = set(['datasets'], filteredDatasets, newState);\n  // dataId is an array\n  // pass only the dataset we need to update\n  newState = updateAllLayerDomainData(newState, datasetIdsToFilter, newFilter);\n\n  return newState;\n}\n\n/**\n * Set the property of a filter plot\n * @memberof visStateUpdaters\n * @public\n */\nexport const setFilterPlotUpdater = (\n  state: VisState,\n  {idx, newProp, valueIndex = 0}: VisStateActions.SetFilterPlotUpdaterAction\n): VisState => {\n  let newFilter = {...state.filters[idx], ...newProp};\n  const prop = Object.keys(newProp)[0];\n  if (prop === 'yAxis') {\n    const plotType = getDefaultFilterPlotType(newFilter);\n    // TODO: plot is not supported in multi dataset filter for now\n    if (plotType) {\n      newFilter = {\n        ...newFilter,\n        ...getFilterPlot({...newFilter, plotType}, state.datasets[newFilter.dataId[valueIndex]]),\n        plotType\n      };\n    }\n  }\n\n  return {\n    ...state,\n    filters: state.filters.map((f, i) => (i === idx ? newFilter : f))\n  };\n};\n\n/**\n * Add a new filter\n * @memberof visStateUpdaters\n * @public\n */\nexport const addFilterUpdater = (\n  state: VisState,\n  action: VisStateActions.AddFilterUpdaterAction\n): VisState =>\n  !action.dataId\n    ? state\n    : {\n        ...state,\n        filters: [...state.filters, getDefaultFilter(action.dataId)]\n      };\n\n/**\n * Set layer color palette ui state\n * @memberof visStateUpdaters\n */\nexport const layerColorUIChangeUpdater = (\n  state: VisState,\n  {oldLayer, prop, newConfig}: VisStateActions.LayerColorUIChangeUpdaterAction\n): VisState => {\n  const oldVixConfig = oldLayer.config.visConfig[prop];\n  const newLayer = oldLayer.updateLayerColorUI(prop, newConfig);\n  const newVisConfig = newLayer.config.visConfig[prop];\n  if (oldVixConfig !== newVisConfig) {\n    return layerVisConfigChangeUpdater(state, {\n      oldLayer,\n      newVisConfig: {\n        [prop]: newVisConfig\n      }\n    });\n  }\n  return {\n    ...state,\n    layers: state.layers.map(l => (l.id === oldLayer.id ? newLayer : l))\n  };\n};\n\n/**\n * Start and end filter animation\n * @memberof visStateUpdaters\n * @public\n */\nexport const toggleFilterAnimationUpdater = (\n  state: VisState,\n  action: VisStateActions.ToggleFilterAnimationUpdaterAction\n): VisState => ({\n  ...state,\n  filters: state.filters.map((f, i) => (i === action.idx ? {...f, isAnimating: !f.isAnimating} : f))\n});\n\n/**\n * @memberof visStateUpdaters\n * @public\n */\nexport const toggleLayerAnimationUpdater = (\n  state: VisState,\n  action: VisStateActions.ToggleLayerAnimationUpdaterAction\n): VisState => ({\n  ...state,\n  animationConfig: {\n    ...state.animationConfig,\n    isAnimating: !state.animationConfig.isAnimating\n  }\n});\n\n/**\n * Hide and show layer animation control\n * @memberof visStateUpdaters\n * @public\n */\nexport const toggleLayerAnimationControlUpdater = (\n  state: VisState,\n  action: VisStateActions.ToggleLayerAnimationControlUpdaterAction\n): VisState => ({\n  ...state,\n  animationConfig: {\n    ...state.animationConfig,\n    hideControl: !state.animationConfig.hideControl\n  }\n});\n\n/**\n * Change filter animation speed\n * @memberof visStateUpdaters\n * @public\n */\nexport const updateFilterAnimationSpeedUpdater = (\n  state: VisState,\n  action: VisStateActions.UpdateFilterAnimationSpeedUpdaterAction\n): VisState => ({\n  ...state,\n  filters: state.filters.map((f, i) => (i === action.idx ? {...f, speed: action.speed} : f))\n});\n\n/**\n * Reset animation config current time to a specified value\n * @memberof visStateUpdaters\n * @public\n *\n */\nexport const setLayerAnimationTimeUpdater = (\n  state: VisState,\n  {value}: VisStateActions.SetLayerAnimationTimeUpdaterAction\n): VisState => ({\n  ...state,\n  animationConfig: {\n    ...state.animationConfig,\n    currentTime: value\n  }\n});\n\n/**\n * Update animation speed with the vertical speed slider\n * @memberof visStateUpdaters\n * @public\n *\n */\nexport const updateLayerAnimationSpeedUpdater = (\n  state: VisState,\n  {speed}: VisStateActions.UpdateLayerAnimationSpeedUpdaterAction\n): VisState => {\n  return {\n    ...state,\n    animationConfig: {\n      ...state.animationConfig,\n      speed\n    }\n  };\n};\n\n/**\n * Show larger time filter at bottom for time playback (apply to time filter only)\n * @memberof visStateUpdaters\n * @public\n */\nexport const enlargeFilterUpdater = (\n  state: VisState,\n  action: VisStateActions.EnlargeFilterUpdaterAction\n): VisState => {\n  return {\n    ...state,\n    filters: state.filters.map((f, i) =>\n      i === action.idx\n        ? {\n            ...f,\n            enlarged: !f.enlarged\n          }\n        : f\n    )\n  };\n};\n\n/**\n * Toggles filter feature visibility\n * @memberof visStateUpdaters\n */\nexport const toggleFilterFeatureUpdater = (\n  state: VisState,\n  action: VisStateActions.ToggleFilterFeatureUpdaterAction\n): VisState => {\n  const filter = state.filters[action.idx];\n  const isVisible = get(filter, ['value', 'properties', 'isVisible']);\n  const newFilter = {\n    ...filter,\n    value: featureToFilterValue(filter.value, filter.id, {\n      isVisible: !isVisible\n    })\n  };\n\n  return {\n    ...state,\n    filters: Object.assign([...state.filters], {[action.idx]: newFilter})\n  };\n};\n\n/**\n * Remove a filter\n * @memberof visStateUpdaters\n * @public\n */\nexport const removeFilterUpdater = (\n  state: VisState,\n  action: VisStateActions.RemoveFilterUpdaterAction\n): VisState => {\n  const {idx} = action;\n  const {dataId, id} = state.filters[idx];\n\n  const newFilters = [\n    ...state.filters.slice(0, idx),\n    ...state.filters.slice(idx + 1, state.filters.length)\n  ];\n\n  const filteredDatasets = applyFiltersToDatasets(dataId, state.datasets, newFilters, state.layers);\n  const newEditor =\n    getFilterIdInFeature(state.editor.selectedFeature) === id\n      ? {\n          ...state.editor,\n          selectedFeature: null\n        }\n      : state.editor;\n\n  let newState = set(['filters'], newFilters, state);\n  newState = set(['datasets'], filteredDatasets, newState);\n  newState = set(['editor'], newEditor, newState);\n\n  return updateAllLayerDomainData(newState, dataId, undefined);\n};\n\n/**\n * Add a new layer\n * @memberof visStateUpdaters\n * @public\n */\nexport const addLayerUpdater = (\n  state: VisState,\n  action: VisStateActions.AddLayerUpdaterAction\n): VisState => {\n  let newLayer;\n  let newLayerData;\n  if (action.config) {\n    newLayer = createLayerFromConfig(state, action.config);\n    if (!newLayer) {\n      Console.warn(\n        'Failed to create layer from config, it usually means the config is not be in correct format',\n        action.config\n      );\n      return state;\n    }\n\n    const result = calculateLayerData(newLayer, state);\n    newLayer = result.layer;\n    newLayerData = result.layerData;\n  } else {\n    // create an empty layer with a specific dataset or a default one\n    const defaultDataset = action.datasetId ?? Object.keys(state.datasets)[0];\n    newLayer = new Layer({\n      isVisible: true,\n      isConfigActive: true,\n      dataId: defaultDataset\n    });\n    newLayerData = {};\n  }\n  return {\n    ...state,\n    layers: [...state.layers, newLayer],\n    layerData: [...state.layerData, newLayerData],\n    layerOrder: [...state.layerOrder, state.layerOrder.length],\n    splitMaps: addNewLayersToSplitMap(state.splitMaps, newLayer)\n  };\n};\n\n/**\n * remove layer\n * @memberof visStateUpdaters\n * @public\n */\nexport const removeLayerUpdater = (\n  state: VisState,\n  {idx}: VisStateActions.RemoveLayerUpdaterAction\n): VisState => {\n  const {layers, layerData, clicked, hoverInfo} = state;\n  const layerToRemove = state.layers[idx];\n  const newMaps = removeLayerFromSplitMaps(state.splitMaps, layerToRemove);\n\n  const newState = {\n    ...state,\n    layers: [...layers.slice(0, idx), ...layers.slice(idx + 1, layers.length)],\n    layerData: [...layerData.slice(0, idx), ...layerData.slice(idx + 1, layerData.length)],\n    layerOrder: state.layerOrder.filter(i => i !== idx).map(pid => (pid > idx ? pid - 1 : pid)),\n    clicked: layerToRemove.isLayerHovered(clicked) ? undefined : clicked,\n    hoverInfo: layerToRemove.isLayerHovered(hoverInfo) ? undefined : hoverInfo,\n    splitMaps: newMaps\n    // TODO: update filters, create helper to remove layer form filter (remove layerid and dataid) if mapped\n  };\n\n  return updateAnimationDomain(newState);\n};\n\n/**\n * duplicate layer\n * @memberof visStateUpdaters\n * @public\n */\nexport const duplicateLayerUpdater = (\n  state: VisState,\n  {idx}: VisStateActions.DuplicateLayerUpdaterAction\n): VisState => {\n  const {layers} = state;\n  const original = state.layers[idx];\n  const originalLayerOrderIdx = state.layerOrder.findIndex(i => i === idx);\n\n  if (!original) {\n    Console.warn(`layer.${idx} is undefined`);\n    return state;\n  }\n  let newLabel = `Copy of ${original.config.label}`;\n  let postfix = 0;\n  // eslint-disable-next-line no-loop-func\n  while (layers.find(l => l.config.label === newLabel)) {\n    newLabel = `Copy of ${original.config.label} ${++postfix}`;\n  }\n\n  // collect layer config from original\n  const loadedLayer = serializeLayer(original);\n\n  // assign new id and label to copied layer\n  if (!loadedLayer?.config) {\n    return state;\n  }\n  loadedLayer.config.label = newLabel;\n  loadedLayer.id = generateHashId(LAYER_ID_LENGTH);\n\n  // add layer to state\n  let nextState = addLayerUpdater(state, {config: loadedLayer});\n\n  // new added layer are at the end, move it to be on top of original layer\n  const newLayerOrderIdx = nextState.layerOrder.length - 1;\n  const newLayerOrder = arrayInsert(\n    nextState.layerOrder.slice(0, newLayerOrderIdx),\n    originalLayerOrderIdx,\n    newLayerOrderIdx\n  );\n\n  nextState = {\n    ...nextState,\n    layerOrder: newLayerOrder\n  };\n\n  return updateAnimationDomain(nextState);\n};\n\n/**\n * Reorder layer\n * @memberof visStateUpdaters\n * @public\n */\nexport const reorderLayerUpdater = (\n  state: VisState,\n  {order}: VisStateActions.ReorderLayerUpdaterAction\n): VisState => ({\n  ...state,\n  layerOrder: order\n});\n\n/**\n * Remove a dataset and all layers, filters, tooltip configs that based on it\n * @memberof visStateUpdaters\n * @public\n */\nexport const removeDatasetUpdater = (\n  state: VisState,\n  action: VisStateActions.RemoveDatasetUpdaterAction\n): VisState => {\n  // extract dataset key\n  const {dataId: datasetKey} = action;\n  const {datasets} = state;\n\n  // check if dataset is present\n  if (!datasets[datasetKey]) {\n    return state;\n  }\n\n  /* eslint-disable no-unused-vars */\n  const {\n    layers,\n    datasets: {[datasetKey]: dataset, ...newDatasets}\n  } = state;\n  /* eslint-enable no-unused-vars */\n\n  const indexes = layers.reduce((listOfIndexes, layer, index) => {\n    if (layer.config.dataId === datasetKey) {\n      // @ts-ignore\n      listOfIndexes.push(index);\n    }\n    return listOfIndexes;\n  }, []);\n\n  // remove layers and datasets\n  const {newState} = indexes.reduce(\n    ({newState: currentState, indexCounter}, idx) => {\n      const currentIndex = idx - indexCounter;\n      currentState = removeLayerUpdater(currentState, {idx: currentIndex});\n      indexCounter++;\n      return {newState: currentState, indexCounter};\n    },\n    {newState: {...state, datasets: newDatasets}, indexCounter: 0}\n  );\n\n  // remove filters\n  const filters = state.filters.filter(filter => !filter.dataId.includes(datasetKey));\n\n  // update interactionConfig\n  let {interactionConfig} = state;\n  const {tooltip} = interactionConfig;\n  if (tooltip) {\n    const {config} = tooltip;\n    /* eslint-disable no-unused-vars */\n    const {[datasetKey]: fields, ...fieldsToShow} = config.fieldsToShow;\n    /* eslint-enable no-unused-vars */\n    interactionConfig = {\n      ...interactionConfig,\n      tooltip: {...tooltip, config: {...config, fieldsToShow}}\n    };\n  }\n\n  return {...newState, filters, interactionConfig};\n};\n\n/**\n * update layer blending mode\n * @memberof visStateUpdaters\n * @public\n */\nexport const updateLayerBlendingUpdater = (\n  state: VisState,\n  action: VisStateActions.UpdateLayerBlendingUpdaterAction\n): VisState => ({\n  ...state,\n  layerBlending: action.mode\n});\n\n/**\n * Display dataset table in a modal\n * @memberof visStateUpdaters\n * @public\n */\nexport const showDatasetTableUpdater = (\n  state: VisState,\n  action: VisStateActions.ShowDatasetTableUpdaterAction\n): VisState => {\n  return {\n    ...state,\n    editingDataset: action.dataId\n  };\n};\n\n/**\n * Add custom color for datasets and layers\n * @memberof visStateUpdaters\n * @public\n */\nexport const updateTableColorUpdater = (\n  state: VisState,\n  action: VisStateActions.UpdateDatasetColorUpdater\n): VisState => {\n  const {dataId, newColor} = action;\n  const {datasets} = state;\n\n  if (isRgbColor(newColor)) {\n    const existing = datasets[dataId];\n    existing.updateTableColor(newColor);\n\n    return {\n      ...state,\n      datasets: {\n        ...state.datasets,\n        [dataId]: copyTableAndUpdate(existing, {})\n      }\n    };\n  }\n  return state;\n};\n\n/**\n * reset visState to initial State\n * @memberof visStateUpdaters\n * @public\n */\nexport const resetMapConfigUpdater = (state: VisState): VisState => ({\n  ...INITIAL_VIS_STATE,\n  ...state.initialState,\n  initialState: state.initialState\n});\n\n/**\n * Propagate `visState` reducer with a new configuration. Current config will be override.\n * @memberof visStateUpdaters\n * @public\n */\nexport const receiveMapConfigUpdater = (\n  state: VisState,\n  {\n    payload: {config = {version: ''}, options = {}}\n  }: {\n    type?: typeof ActionTypes.RECEIVE_MAP_CONFIG;\n    payload: ReceiveMapConfigPayload;\n  }\n): VisState => {\n  if (!config.visState) {\n    return state;\n  }\n\n  const {keepExistingConfig} = options;\n\n  // reset config if keepExistingConfig is falsy\n  let mergedState = !keepExistingConfig ? resetMapConfigUpdater(state) : state;\n  for (const merger of state.mergers) {\n    if (isValidMerger(merger) && config.visState[merger.prop]) {\n      mergedState = merger.merge(mergedState, config.visState[merger.prop], true);\n    }\n  }\n\n  return mergedState;\n};\n\n/**\n * Trigger layer hover event with hovered object\n * @memberof visStateUpdaters\n * @public\n */\nexport const layerHoverUpdater = (\n  state: VisState,\n  action: VisStateActions.OnLayerHoverUpdaterAction\n): VisState => ({\n  ...state,\n  hoverInfo: {\n    // deck.gl info is mutable\n    ...action.info\n  }\n});\n\n/* eslint-enable max-statements */\n\n/**\n * Update `interactionConfig`\n * @memberof visStateUpdaters\n * @public\n */\nexport function interactionConfigChangeUpdater(\n  state: VisState,\n  action: VisStateActions.InteractionConfigChangeUpdaterAction\n): VisState {\n  const {config} = action;\n\n  const interactionConfig = {\n    ...state.interactionConfig,\n    ...{[config.id]: config}\n  };\n\n  // Don't enable tooltip and brush at the same time\n  // but coordinates can be shown at all time\n  const contradict = ['brush', 'tooltip'];\n\n  if (\n    contradict.includes(config.id) &&\n    config.enabled &&\n    !state.interactionConfig[config.id].enabled\n  ) {\n    // only enable one interaction at a time\n    contradict.forEach(k => {\n      if (k !== config.id) {\n        interactionConfig[k] = {...interactionConfig[k], enabled: false};\n      }\n    });\n  }\n\n  const newState = {\n    ...state,\n    interactionConfig\n  };\n\n  if (config.id === 'geocoder' && !config.enabled) {\n    return removeDatasetUpdater(newState, {dataId: 'geocoder_dataset'});\n  }\n\n  return newState;\n}\n\n/**\n * Trigger layer click event with clicked object\n * @memberof visStateUpdaters\n * @public\n */\nexport const layerClickUpdater = (\n  state: VisState,\n  action: VisStateActions.OnLayerClickUpdaterAction\n): VisState => ({\n  ...state,\n  mousePos: state.interactionConfig.coordinate.enabled\n    ? {\n        ...state.mousePos,\n        pinned: state.mousePos.pinned ? null : cloneDeep(state.mousePos)\n      }\n    : state.mousePos,\n  clicked: action.info && action.info.picked ? action.info : null\n});\n\n/**\n * Trigger map click event, unselect clicked object\n * @memberof visStateUpdaters\n * @public\n */\nexport const mapClickUpdater = (\n  state: VisState,\n  action: VisStateActions.OnMapClickUpdaterAction\n): VisState => {\n  return {\n    ...state,\n    clicked: null\n  };\n};\n\n/**\n * Trigger map move event\n * @memberof visStateUpdaters\n * @public\n */\nexport const mouseMoveUpdater = (\n  state: VisState,\n  {evt}: VisStateActions.OnMouseMoveUpdaterAction\n): VisState => {\n  if (Object.values(state.interactionConfig).some(config => config.enabled)) {\n    return {\n      ...state,\n      mousePos: {\n        ...state.mousePos,\n        ...(Array.isArray(evt.point) ? {mousePosition: [...evt.point]} : {}),\n        ...(Array.isArray(evt.lngLat) ? {coordinate: [...evt.lngLat]} : {})\n      }\n    };\n  }\n\n  return state;\n};\n/**\n * Toggle visibility of a layer for a split map\n * @memberof visStateUpdaters\n * @public\n */\nexport const toggleSplitMapUpdater = (\n  state: VisState,\n  action: MapStateActions.ToggleSplitMapUpdaterAction\n): VisState =>\n  state.splitMaps && state.splitMaps.length === 0\n    ? {\n        ...state,\n        // maybe we should use an array to store state for a single map as well\n        // if current maps length is equal to 0 it means that we are about to split the view\n        splitMaps: computeSplitMapLayers(state.layers)\n      }\n    : closeSpecificMapAtIndex(state, action);\n\n/**\n * Toggle visibility of a layer in a split map\n * @memberof visStateUpdaters\n * @public\n */\nexport const toggleLayerForMapUpdater = (\n  state: VisState,\n  {mapIndex, layerId}: VisStateActions.ToggleLayerForMapUpdaterAction\n): VisState => {\n  const {splitMaps} = state;\n\n  return {\n    ...state,\n    splitMaps: splitMaps.map((sm, i) =>\n      i === mapIndex\n        ? {\n            ...splitMaps[i],\n            layers: {\n              ...splitMaps[i].layers,\n              // if layerId not in layers, set it to visible\n              [layerId]: !splitMaps[i].layers[layerId]\n            }\n          }\n        : sm\n    )\n  };\n};\n\n/**\n * Add new dataset to `visState`, with option to load a map config along with the datasets\n * @memberof visStateUpdaters\n * @public\n */\n/* eslint-disable max-statements */\n// eslint-disable-next-line complexity\nexport const updateVisDataUpdater = (\n  state: VisState,\n  action: VisStateActions.UpdateVisDataUpdaterAction\n): VisState => {\n  // datasets can be a single data entries or an array of multiple data entries\n  const {config, options} = action;\n  const datasets = toArray(action.datasets);\n\n  const newDataEntries = datasets.reduce(\n    (accu, {info = {}, ...rest} = {}) => ({\n      ...accu,\n      ...(createNewDataEntry({info, ...rest}, state.datasets) || {})\n    }),\n    {}\n  );\n\n  const dataEmpty = Object.keys(newDataEntries).length < 1;\n\n  // apply config if passed from action\n  const previousState = config\n    ? receiveMapConfigUpdater(state, {\n        payload: {config, options}\n      })\n    : state;\n\n  let mergedState = {\n    ...previousState,\n    datasets: {\n      ...previousState.datasets,\n      ...newDataEntries\n    }\n  };\n\n  // merge state with config to be merged\n  for (const merger of mergedState.mergers) {\n    if (isValidMerger(merger) && merger.toMergeProp && mergedState[merger.toMergeProp]) {\n      const toMerge = mergedState[merger.toMergeProp];\n      mergedState[merger.toMergeProp] = INITIAL_VIS_STATE[merger.toMergeProp];\n      mergedState = merger.merge(mergedState, toMerge);\n    }\n  }\n\n  let newLayers = !dataEmpty\n    ? mergedState.layers.filter(l => l.config.dataId && l.config.dataId in newDataEntries)\n    : [];\n\n  if (!newLayers.length && (options || {}).autoCreateLayers !== false) {\n    // no layer merged, find defaults\n    const result = addDefaultLayers(mergedState, newDataEntries);\n    mergedState = result.state;\n    newLayers = result.newLayers;\n  }\n\n  if (mergedState.splitMaps.length) {\n    // if map is split, add new layers to splitMaps\n    newLayers = mergedState.layers.filter(\n      l => l.config.dataId && l.config.dataId in newDataEntries\n    );\n    mergedState = {\n      ...mergedState,\n      splitMaps: addNewLayersToSplitMap(mergedState.splitMaps, newLayers)\n    };\n  }\n\n  // if no tooltips merged add default tooltips\n  Object.keys(newDataEntries).forEach(dataId => {\n    const tooltipFields = mergedState.interactionConfig.tooltip.config.fieldsToShow[dataId];\n    if (!Array.isArray(tooltipFields) || !tooltipFields.length) {\n      mergedState = addDefaultTooltips(mergedState, newDataEntries[dataId]);\n    }\n  });\n\n  let updatedState = updateAllLayerDomainData(\n    mergedState,\n    dataEmpty ? Object.keys(mergedState.datasets) : Object.keys(newDataEntries),\n    undefined\n  );\n\n  // register layer animation domain,\n  // need to be called after layer data is calculated\n  updatedState = updateAnimationDomain(updatedState);\n\n  return updatedState;\n};\n/* eslint-enable max-statements */\n\n/**\n * Rename an existing dataset in `visState`\n * @memberof visStateUpdaters\n * @public\n */\nexport function renameDatasetUpdater(\n  state: VisState,\n  action: VisStateActions.RenameDatasetUpdaterAction\n): VisState {\n  const {dataId, label} = action;\n  const {datasets} = state;\n  const existing = datasets[dataId];\n\n  if (existing) {\n    const newDataset = copyTableAndUpdate(existing, {label});\n    return {\n      ...state,\n      datasets: {\n        ...datasets,\n        [dataId]: newDataset\n      }\n    };\n  }\n\n  // No-op if the dataset doesn't exist\n  return state;\n}\n\n/**\n * When a user clicks on the specific map closing icon\n * the application will close the selected map\n * and will merge the remaining one with the global state\n * TODO: i think in the future this action should be called merge map layers with global settings\n * @param {Object} state `visState`\n * @param {Object} action action\n * @returns {Object} nextState\n */\nexport function closeSpecificMapAtIndex<S extends VisState>(\n  state: S,\n  action: MapStateActions.ToggleSplitMapUpdaterAction\n): S {\n  // retrieve layers meta data from the remaining map that we need to keep\n  const indexToRetrieve = 1 - action.payload;\n  const mapLayers = state.splitMaps[indexToRetrieve]?.layers;\n  const {layers} = state;\n\n  // update layer visibility\n  const newLayers = layers.map(layer =>\n    mapLayers && !mapLayers[layer.id] && layer.config.isVisible\n      ? layer.updateLayerConfig({\n          // if layer.id is not in mapLayers, it should be inVisible\n          isVisible: false\n        })\n      : layer\n  );\n\n  // delete map\n  return {\n    ...state,\n    layers: newLayers,\n    splitMaps: []\n  };\n}\n\n/**\n * Trigger file loading dispatch `addDataToMap` if succeed, or `loadFilesErr` if failed\n * @memberof visStateUpdaters\n * @public\n */\nexport const loadFilesUpdater = (\n  state: VisState,\n  action: VisStateActions.LoadFilesUpdaterAction\n): VisState => {\n  const {files, onFinish = loadFilesSuccess} = action;\n  if (!files.length) {\n    return state;\n  }\n\n  const fileLoadingProgress = Array.from(files).reduce(\n    (accu, f, i) => merge_(initialFileLoadingProgress(f, i))(accu),\n    {}\n  );\n\n  const fileLoading = {\n    fileCache: [],\n    filesToLoad: files,\n    onFinish\n  };\n\n  const nextState = merge_({fileLoadingProgress, fileLoading})(state);\n\n  return loadNextFileUpdater(nextState);\n};\n\n/**\n * Sucessfully loaded one file, move on to the next one\n * @memberof visStateUpdaters\n * @public\n */\nexport function loadFileStepSuccessUpdater(\n  state: VisState,\n  action: VisStateActions.LoadFileStepSuccessAction\n): VisState {\n  if (!state.fileLoading) {\n    return state;\n  }\n  const {fileName, fileCache} = action;\n  const {filesToLoad, onFinish} = state.fileLoading;\n  const stateWithProgress = updateFileLoadingProgressUpdater(state, {\n    fileName,\n    progress: {percent: 1, message: 'Done'}\n  });\n\n  // save processed file to fileCache\n  const stateWithCache = pick_('fileLoading')(merge_({fileCache}))(stateWithProgress);\n\n  return withTask(\n    stateWithCache,\n    DELAY_TASK(200).map(filesToLoad.length ? loadNextFile : () => onFinish(fileCache))\n  );\n}\n\n// withTask<T>(state: T, task: any): T\n\n/**\n *\n * @memberof visStateUpdaters\n * @public\n */\nexport function loadNextFileUpdater(state: VisState): VisState {\n  if (!state.fileLoading) {\n    return state;\n  }\n  const {filesToLoad} = state.fileLoading;\n  const [file, ...remainingFilesToLoad] = filesToLoad;\n\n  // save filesToLoad to state\n  const nextState = pick_('fileLoading')(merge_({filesToLoad: remainingFilesToLoad}))(state);\n\n  const stateWithProgress = updateFileLoadingProgressUpdater(nextState, {\n    fileName: file.name,\n    progress: {percent: 0, message: 'loading...'}\n  });\n\n  const {loaders, loadOptions} = state;\n  return withTask(\n    stateWithProgress,\n    makeLoadFileTask(\n      file,\n      nextState.fileLoading && nextState.fileLoading.fileCache,\n      loaders,\n      loadOptions\n    )\n  );\n}\n\nexport function makeLoadFileTask(file, fileCache, loaders: Loader[] = [], loadOptions = {}) {\n  return LOAD_FILE_TASK({file, fileCache, loaders, loadOptions}).bimap(\n    // prettier ignore\n    // success\n    gen =>\n      nextFileBatch({\n        gen,\n        fileName: file.name,\n        onFinish: result =>\n          processFileContent({\n            content: result,\n            fileCache\n          })\n      }),\n\n    // error\n    err => loadFilesErr(file.name, err)\n  );\n}\n\n/**\n *\n * @memberof visStateUpdaters\n * @public\n */\nexport function processFileContentUpdater(\n  state: VisState,\n  action: VisStateActions.ProcessFileContentUpdaterAction\n): VisState {\n  const {content, fileCache} = action.payload;\n\n  const stateWithProgress = updateFileLoadingProgressUpdater(state, {\n    fileName: content.fileName,\n    progress: {percent: 1, message: 'processing...'}\n  });\n\n  return withTask(\n    stateWithProgress,\n    PROCESS_FILE_DATA({content, fileCache}).bimap(\n      result => loadFileStepSuccess({fileName: content.fileName, fileCache: result}),\n      err => loadFilesErr(content.fileName, err)\n    )\n  );\n}\n\nexport function parseProgress(prevProgress = {}, progress) {\n  // This happens when receiving query metadata or other cases we don't\n  // have an update for the user.\n  if (!progress || !progress.percent) {\n    return {};\n  }\n\n  return {\n    percent: progress.percent\n  };\n}\n\n/**\n * gets called with payload = AsyncGenerator<???>\n * @memberof visStateUpdaters\n * @public\n */\nexport const nextFileBatchUpdater = (\n  state: VisState,\n  {\n    payload: {gen, fileName, progress, accumulated, onFinish}\n  }: VisStateActions.NextFileBatchUpdaterAction\n): VisState => {\n  const stateWithProgress = updateFileLoadingProgressUpdater(state, {\n    fileName,\n    progress: parseProgress(state.fileLoadingProgress[fileName], progress)\n  });\n  return withTask(\n    stateWithProgress,\n    UNWRAP_TASK(gen.next()).bimap(\n      ({value, done}) => {\n        return done\n          ? onFinish(accumulated)\n          : nextFileBatch({\n              gen,\n              fileName,\n              progress: value.progress,\n              accumulated: value,\n              onFinish\n            });\n      },\n      err => loadFilesErr(fileName, err)\n    )\n  );\n};\n\n/**\n * Trigger loading file error\n * @memberof visStateUpdaters\n * @public\n */\nexport const loadFilesErrUpdater = (\n  state: VisState,\n  {error, fileName}: VisStateActions.LoadFilesErrUpdaterAction\n): VisState => {\n  // update ui with error message\n  Console.warn(error);\n  if (!state.fileLoading) {\n    return state;\n  }\n  const {filesToLoad, onFinish, fileCache} = state.fileLoading;\n\n  const nextState = updateFileLoadingProgressUpdater(state, {\n    fileName,\n    progress: {error}\n  });\n\n  // kick off next file or finish\n  return withTask(\n    nextState,\n    DELAY_TASK(200).map(filesToLoad.length ? loadNextFile : () => onFinish(fileCache))\n  );\n};\n\n/**\n * When select dataset for export, apply cpu filter to selected dataset\n * @memberof visStateUpdaters\n * @public\n */\nexport const applyCPUFilterUpdater = (\n  state: VisState,\n  {dataId}: VisStateActions.ApplyCPUFilterUpdaterAction\n): VisState => {\n  // apply cpuFilter\n  const dataIds = toArray(dataId);\n\n  return dataIds.reduce((accu, id) => filterDatasetCPU(accu, id), state);\n};\n\n/**\n * User input to update the info of the map\n * @memberof visStateUpdaters\n * @public\n */\nexport const setMapInfoUpdater = (\n  state: VisState,\n  action: VisStateActions.SetMapInfoUpdaterAction\n): VisState => ({\n  ...state,\n  mapInfo: {\n    ...state.mapInfo,\n    ...action.info\n  }\n});\n/**\n * Helper function to update All layer domain and layer data of state\n */\nexport function addDefaultLayers(\n  state: VisState,\n  datasets: Datasets\n): {state: VisState; newLayers: Layer[]} {\n  const empty: Layer[] = [];\n  const defaultLayers = Object.values(datasets).reduce((accu: Layer[], dataset) => {\n    const foundLayers = findDefaultLayer(dataset, state.layerClasses);\n    return foundLayers && foundLayers.length ? accu.concat(foundLayers) : accu;\n  }, empty);\n\n  return {\n    state: {\n      ...state,\n      layers: [...state.layers, ...defaultLayers],\n      layerOrder: [\n        // put new layers on top of old ones\n        ...defaultLayers.map((_, i) => state.layers.length + i),\n        ...state.layerOrder\n      ]\n    },\n    newLayers: defaultLayers\n  };\n}\n\n/**\n * helper function to find default tooltips\n * @param {Object} state\n * @param {Object} dataset\n * @returns {Object} nextState\n */\nexport function addDefaultTooltips(state, dataset) {\n  const tooltipFields = findFieldsToShow({\n    ...dataset,\n    maxDefaultTooltips: state.maxDefaultTooltips\n  });\n  const merged = {\n    ...state.interactionConfig.tooltip.config.fieldsToShow,\n    ...tooltipFields\n  };\n\n  return set(['interactionConfig', 'tooltip', 'config', 'fieldsToShow'], merged, state);\n}\n\nexport function initialFileLoadingProgress(file, index) {\n  const fileName = file.name || `Untitled File ${index}`;\n  return {\n    [fileName]: {\n      // percent of current file\n      percent: 0,\n      message: '',\n      fileName,\n      error: null\n    }\n  };\n}\n\nexport function updateFileLoadingProgressUpdater(state, {fileName, progress}) {\n  // @ts-expect-error\n  return pick_('fileLoadingProgress')(pick_(fileName)(merge_(progress)))(state);\n}\n/**\n * Helper function to update layer domains for an array of datasets\n */\nexport function updateAllLayerDomainData(\n  state: VisState,\n  dataId: string | string[],\n  updatedFilter?: Filter\n): VisState {\n  const dataIds = typeof dataId === 'string' ? [dataId] : dataId;\n  const newLayers: Layer[] = [];\n  const newLayerData: any[] = [];\n\n  state.layers.forEach((oldLayer, i) => {\n    if (oldLayer.config.dataId && dataIds.includes(oldLayer.config.dataId)) {\n      // No need to recalculate layer domain if filter has fixed domain\n      const newLayer =\n        updatedFilter && updatedFilter.fixedDomain\n          ? oldLayer\n          : oldLayer.updateLayerDomain(state.datasets, updatedFilter);\n\n      const {layerData, layer} = calculateLayerData(newLayer, state, state.layerData[i]);\n\n      newLayers.push(layer);\n      newLayerData.push(layerData);\n    } else {\n      newLayers.push(oldLayer);\n      newLayerData.push(state.layerData[i]);\n    }\n  });\n\n  const newState = {\n    ...state,\n    layers: newLayers,\n    layerData: newLayerData\n  };\n\n  return newState;\n}\n\nexport function updateAnimationDomain<S extends VisState>(state: S): S {\n  // merge all animatable layer domain and update global config\n  const animatableLayers = state.layers.filter(\n    l =>\n      l.config.isVisible &&\n      l.config.animation &&\n      l.config.animation.enabled &&\n      // @ts-expect-error trip-layer-only\n      Array.isArray(l.animationDomain)\n  );\n\n  if (!animatableLayers.length) {\n    return {\n      ...state,\n      animationConfig: {\n        ...state.animationConfig,\n        domain: null,\n        defaultTimeFormat: null\n      }\n    };\n  }\n\n  const mergedDomain: [number, number] = animatableLayers.reduce(\n    (accu, layer) => [\n      // @ts-expect-error trip-layer-only\n      Math.min(accu[0], layer.animationDomain[0]),\n      // @ts-expect-error trip-layer-only\n      Math.max(accu[1], layer.animationDomain[1])\n    ],\n    [Number(Infinity), -Infinity]\n  );\n  const defaultTimeFormat = getTimeWidgetTitleFormatter(mergedDomain);\n\n  return {\n    ...state,\n    animationConfig: {\n      ...state.animationConfig,\n      currentTime: isInRange(state.animationConfig.currentTime, mergedDomain)\n        ? state.animationConfig.currentTime\n        : mergedDomain[0],\n      domain: mergedDomain,\n      defaultTimeFormat\n    }\n  };\n}\n\n/**\n * Update the status of the editor\n * @memberof visStateUpdaters\n */\nexport const setEditorModeUpdater = (\n  state: VisState,\n  {mode}: VisStateActions.SetEditorModeUpdaterAction\n): VisState => ({\n  ...state,\n  editor: {\n    ...state.editor,\n    mode,\n    selectedFeature: null\n  }\n});\n\n// const featureToFilterValue = (feature) => ({...feature, id: feature.id});\n/**\n * Update editor features\n * @memberof visStateUpdaters\n */\nexport function setFeaturesUpdater(\n  state: VisState,\n  {features = []}: VisStateActions.SetFeaturesUpdaterAction\n): VisState {\n  const lastFeature = features.length && features[features.length - 1];\n\n  const newState = {\n    ...state,\n    editor: {\n      ...state.editor,\n      // only save none filter features to editor\n      features: features.filter(f => !getFilterIdInFeature(f)),\n      mode: lastFeature && lastFeature.properties.isClosed ? EDITOR_MODES.EDIT : state.editor.mode\n    }\n  };\n\n  // Retrieve existing feature\n  const {selectedFeature} = state.editor;\n\n  // If no feature is selected we can simply return since no operations\n  if (!selectedFeature) {\n    return newState;\n  }\n\n  // TODO: check if the feature has changed\n  const feature = features.find(f => f.id === selectedFeature.id);\n\n  // if feature is part of a filter\n  const filterId = feature && getFilterIdInFeature(feature);\n  if (filterId && feature) {\n    const featureValue = featureToFilterValue(feature, filterId);\n    const filterIdx = state.filters.findIndex(fil => fil.id === filterId);\n    // @ts-ignore\n    return setFilterUpdater(newState, {\n      idx: filterIdx,\n      prop: 'value',\n      value: featureValue\n    });\n  }\n\n  return newState;\n}\n\n/**\n * Set the current selected feature\n * @memberof uiStateUpdaters\n */\nexport const setSelectedFeatureUpdater = (\n  state: VisState,\n  {feature}: VisStateActions.SetSelectedFeatureUpdaterAction\n): VisState => ({\n  ...state,\n  editor: {\n    ...state.editor,\n    selectedFeature: feature\n  }\n});\n\n/**\n * Delete existing feature from filters\n * @memberof visStateUpdaters\n */\nexport function deleteFeatureUpdater(\n  state: VisState,\n  {feature}: VisStateActions.DeleteFeatureUpdaterAction\n): VisState {\n  if (!feature) {\n    return state;\n  }\n\n  const newState = {\n    ...state,\n    editor: {\n      ...state.editor,\n      selectedFeature: null\n    }\n  };\n\n  if (getFilterIdInFeature(feature)) {\n    const filterIdx = newState.filters.findIndex(f => f.id === getFilterIdInFeature(feature));\n\n    return filterIdx > -1 ? removeFilterUpdater(newState, {idx: filterIdx}) : newState;\n  }\n\n  // modify editor object\n  const newEditor = {\n    ...state.editor,\n    features: state.editor.features.filter(f => f.id !== feature.id),\n    selectedFeature: null\n  };\n\n  return {\n    ...state,\n    editor: newEditor\n  };\n}\n\n/**\n * Toggle feature as layer filter\n * @memberof visStateUpdaters\n */\nexport function setPolygonFilterLayerUpdater(\n  state: VisState,\n  payload: VisStateActions.SetPolygonFilterLayerUpdaterAction\n): VisState {\n  const {layer, feature} = payload;\n  const filterId = getFilterIdInFeature(feature);\n\n  // let newFilter = null;\n  let filterIdx;\n  let newLayerId = [layer.id];\n  let newState = state;\n  // If polygon filter already exists, we need to find out if the current layer is already included\n  if (filterId) {\n    filterIdx = state.filters.findIndex(f => f.id === filterId);\n\n    if (!state.filters[filterIdx]) {\n      // what if filter doesn't exist?... not possible.\n      // because features in the editor is passed in from filters and editors.\n      // but we will move this feature back to editor just in case\n      const noneFilterFeature = {\n        ...feature,\n        properties: {\n          ...feature.properties,\n          filterId: null\n        }\n      };\n\n      return {\n        ...state,\n        editor: {\n          ...state.editor,\n          features: [...state.editor.features, noneFilterFeature],\n          selectedFeature: noneFilterFeature\n        }\n      };\n    }\n    const filter = state.filters[filterIdx];\n    const {layerId = []} = filter;\n    const isLayerIncluded = layerId.includes(layer.id);\n\n    newLayerId = isLayerIncluded\n      ? // if layer is included, remove it\n        layerId.filter(l => l !== layer.id)\n      : [...layerId, layer.id];\n  } else {\n    // if we haven't create the polygon filter, create it\n    const newFilter = generatePolygonFilter([], feature);\n    filterIdx = state.filters.length;\n\n    // add feature, remove feature from eidtor\n    newState = {\n      ...state,\n      filters: [...state.filters, newFilter],\n      editor: {\n        ...state.editor,\n        features: state.editor.features.filter(f => f.id !== feature.id),\n        selectedFeature: newFilter.value\n      }\n    };\n  }\n\n  return setFilterUpdater(newState, {\n    idx: filterIdx,\n    prop: 'layerId',\n    value: newLayerId\n  });\n}\n\n/**\n * @memberof visStateUpdaters\n * @public\n */\nexport function sortTableColumnUpdater(\n  state: VisState,\n  {dataId, column, mode}: VisStateActions.SortTableColumnUpdaterAction\n): VisState {\n  const dataset = state.datasets[dataId];\n  if (!dataset) {\n    return state;\n  }\n  let sortMode = mode;\n  if (!sortMode) {\n    const currentMode = get(dataset, ['sortColumn', column]);\n    // @ts-ignore - should be fixable in a TS file\n    sortMode = currentMode\n      ? Object.keys(SORT_ORDER).find(m => m !== currentMode)\n      : SORT_ORDER.ASCENDING;\n  }\n\n  const sorted = sortDatasetByColumn(dataset, column, sortMode);\n  return set(['datasets', dataId], sorted, state);\n}\n\n/**\n * @memberof visStateUpdaters\n * @public\n */\nexport function pinTableColumnUpdater(\n  state: VisState,\n  {dataId, column}: VisStateActions.PinTableColumnUpdaterAction\n): VisState {\n  const dataset = state.datasets[dataId];\n  if (!dataset) {\n    return state;\n  }\n  const newDataset = pinTableColumns(dataset, column);\n\n  return set(['datasets', dataId], newDataset, state);\n}\n\n/**\n * Copy column content as strings\n * @memberof visStateUpdaters\n * @public\n */\nexport function copyTableColumnUpdater(\n  state: VisState,\n  {dataId, column}: VisStateActions.CopyTableColumnUpdaterAction\n): VisState {\n  const dataset = state.datasets[dataId];\n  if (!dataset) {\n    return state;\n  }\n  const fieldIdx = dataset.fields.findIndex(f => f.name === column);\n  if (fieldIdx < 0) {\n    return state;\n  }\n  const {type} = dataset.fields[fieldIdx];\n  const text = dataset.dataContainer\n    .map(row => parseFieldValue(row.valueAt(fieldIdx), type), true)\n    .join('\\n');\n\n  copy(text);\n\n  return state;\n}\n\n/**\n * Update editor\n */\nexport function toggleEditorVisibilityUpdater(\n  state: VisState,\n  action: VisStateActions.ToggleEditorVisibilityUpdaterAction\n): VisState {\n  return {\n    ...state,\n    editor: {\n      ...state.editor,\n      visible: !state.editor.visible\n    }\n  };\n}\n\nexport function setFilterAnimationTimeConfigUpdater(\n  state: VisState,\n  {idx, config}: VisStateActions.SetFilterAnimationTimeConfigAction\n): VisState {\n  const oldFilter = state.filters[idx];\n  if (!oldFilter) {\n    Console.error(`filters.${idx} is undefined`);\n    return state;\n  }\n  if (oldFilter.type !== FILTER_TYPES.timeRange) {\n    Console.error(\n      `setFilterAnimationTimeConfig can only be called to update a time filter. check filter.type === 'timeRange'`\n    );\n    return state;\n  }\n\n  const updates = checkTimeConfigArgs(config);\n\n  return pick_('filters')(swap_(merge_(updates)(oldFilter)))(state);\n}\n\nfunction checkTimeConfigArgs(config) {\n  const allowed = ['timeFormat', 'timezone'];\n  return Object.keys(config).reduce((accu, prop) => {\n    if (!allowed.includes(prop)) {\n      Console.error(\n        `setLayerAnimationTimeConfig takes timeFormat and/or timezone as options, found ${prop}`\n      );\n      return accu;\n    }\n\n    // here we are NOT checking if timezone or timeFormat input is valid\n    accu[prop] = config[prop];\n    return accu;\n  }, {});\n}\n/**\n * Update editor\n */\nexport function setLayerAnimationTimeConfigUpdater(\n  state: VisState,\n  {config}: VisStateActions.SetLayerAnimationTimeConfigAction\n): VisState {\n  if (!config) {\n    return state;\n  }\n  const updates = checkTimeConfigArgs(config);\n  return pick_('animationConfig')(merge_(updates))(state);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}