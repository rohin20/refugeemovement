{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Texture2D } from '@luma.gl/core';\nimport { equals } from '@math.gl/core';\nimport MaskPass from '../../passes/mask-pass';\nimport { OPERATION } from '../../lib/constants';\nimport { getMaskBounds, getMaskViewport } from './utils';\nimport log from '../../utils/log';\nvar MaskEffect = /*#__PURE__*/function () {\n  function MaskEffect() {\n    _classCallCheck(this, MaskEffect);\n    _defineProperty(this, \"id\", 'mask-effect');\n    _defineProperty(this, \"props\", null);\n    _defineProperty(this, \"useInPicking\", true);\n    _defineProperty(this, \"dummyMaskMap\", void 0);\n    _defineProperty(this, \"channels\", []);\n    _defineProperty(this, \"masks\", null);\n    _defineProperty(this, \"maskPass\", void 0);\n    _defineProperty(this, \"maskMap\", void 0);\n    _defineProperty(this, \"lastViewport\", void 0);\n  }\n  _createClass(MaskEffect, [{\n    key: \"preRender\",\n    value: function preRender(gl, _ref) {\n      var layers = _ref.layers,\n        layerFilter = _ref.layerFilter,\n        viewports = _ref.viewports,\n        onViewportActive = _ref.onViewportActive,\n        views = _ref.views;\n      if (!this.dummyMaskMap) {\n        this.dummyMaskMap = new Texture2D(gl, {\n          width: 1,\n          height: 1\n        });\n      }\n      var maskLayers = layers.filter(function (l) {\n        return l.props.visible && l.props.operation === OPERATION.MASK;\n      });\n      if (maskLayers.length === 0) {\n        this.masks = null;\n        this.channels.length = 0;\n        return;\n      }\n      this.masks = {};\n      if (!this.maskPass) {\n        this.maskPass = new MaskPass(gl, {\n          id: 'default-mask'\n        });\n        this.maskMap = this.maskPass.maskMap;\n      }\n      var channelMap = this._sortMaskChannels(maskLayers);\n      var viewport = viewports[0];\n      var viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n      for (var maskId in channelMap) {\n        this._renderChannel(channelMap[maskId], {\n          layerFilter: layerFilter,\n          onViewportActive: onViewportActive,\n          views: views,\n          viewport: viewport,\n          viewportChanged: viewportChanged\n        });\n      }\n    }\n  }, {\n    key: \"_renderChannel\",\n    value: function _renderChannel(channelInfo, _ref2) {\n      var layerFilter = _ref2.layerFilter,\n        onViewportActive = _ref2.onViewportActive,\n        views = _ref2.views,\n        viewport = _ref2.viewport,\n        viewportChanged = _ref2.viewportChanged;\n      var oldChannelInfo = this.channels[channelInfo.index];\n      if (!oldChannelInfo) {\n        return;\n      }\n      var maskChanged = channelInfo === oldChannelInfo || oldChannelInfo.layers.length !== channelInfo.layers.length || channelInfo.layerBounds.some(function (b, i) {\n        return b !== oldChannelInfo.layerBounds[i];\n      });\n      channelInfo.bounds = oldChannelInfo.bounds;\n      channelInfo.maskBounds = oldChannelInfo.maskBounds;\n      this.channels[channelInfo.index] = channelInfo;\n      if (maskChanged || viewportChanged) {\n        this.lastViewport = viewport;\n        channelInfo.bounds = getMaskBounds({\n          layers: channelInfo.layers,\n          viewport: viewport\n        });\n        if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n          var maskPass = this.maskPass,\n            maskMap = this.maskMap;\n          var maskViewport = getMaskViewport({\n            bounds: channelInfo.bounds,\n            viewport: viewport,\n            width: maskMap.width,\n            height: maskMap.height\n          });\n          channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n          maskPass.render({\n            pass: 'mask',\n            channel: channelInfo.index,\n            layers: channelInfo.layers,\n            layerFilter: layerFilter,\n            viewports: maskViewport ? [maskViewport] : [],\n            onViewportActive: onViewportActive,\n            views: views,\n            moduleParameters: {\n              devicePixelRatio: 1\n            }\n          });\n        }\n      }\n      this.masks[channelInfo.id] = {\n        index: channelInfo.index,\n        bounds: channelInfo.maskBounds,\n        coordinateOrigin: channelInfo.coordinateOrigin,\n        coordinateSystem: channelInfo.coordinateSystem\n      };\n    }\n  }, {\n    key: \"_sortMaskChannels\",\n    value: function _sortMaskChannels(maskLayers) {\n      var _this = this;\n      var channelMap = {};\n      var channelCount = 0;\n      var _iterator = _createForOfIteratorHelper(maskLayers),\n        _step;\n      try {\n        var _loop = function _loop() {\n          var layer = _step.value;\n          var id = layer.root.id;\n          var channelInfo = channelMap[id];\n          if (!channelInfo) {\n            if (++channelCount > 4) {\n              log.warn('Too many mask layers. The max supported is 4')();\n              return \"continue\";\n            }\n            channelInfo = {\n              id: id,\n              index: _this.channels.findIndex(function (c) {\n                return (c === null || c === void 0 ? void 0 : c.id) === id;\n              }),\n              layers: [],\n              layerBounds: [],\n              coordinateOrigin: layer.root.props.coordinateOrigin,\n              coordinateSystem: layer.root.props.coordinateSystem\n            };\n            channelMap[id] = channelInfo;\n          }\n          channelInfo.layers.push(layer);\n          channelInfo.layerBounds.push(layer.getBounds());\n        };\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _ret = _loop();\n          if (_ret === \"continue\") continue;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      for (var i = 0; i < 4; i++) {\n        var channelInfo = this.channels[i];\n        if (!channelInfo || !(channelInfo.id in channelMap)) {\n          this.channels[i] = null;\n        }\n      }\n      for (var maskId in channelMap) {\n        var _channelInfo = channelMap[maskId];\n        if (_channelInfo.index < 0) {\n          _channelInfo.index = this.channels.findIndex(function (c) {\n            return !c;\n          });\n          this.channels[_channelInfo.index] = _channelInfo;\n        }\n      }\n      return channelMap;\n    }\n  }, {\n    key: \"getModuleParameters\",\n    value: function getModuleParameters() {\n      return {\n        maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n        maskChannels: this.masks\n      };\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      if (this.dummyMaskMap) {\n        this.dummyMaskMap.delete();\n        this.dummyMaskMap = undefined;\n      }\n      if (this.maskPass) {\n        this.maskPass.delete();\n        this.maskPass = undefined;\n        this.maskMap = undefined;\n      }\n      this.lastViewport = undefined;\n      this.masks = null;\n      this.channels.length = 0;\n    }\n  }]);\n  return MaskEffect;\n}();\nexport { MaskEffect as default };","map":{"version":3,"names":["Texture2D","equals","MaskPass","OPERATION","getMaskBounds","getMaskViewport","log","MaskEffect","_classCallCheck","_defineProperty","_createClass","key","value","preRender","gl","_ref","layers","layerFilter","viewports","onViewportActive","views","dummyMaskMap","width","height","maskLayers","filter","l","props","visible","operation","MASK","length","masks","channels","maskPass","id","maskMap","channelMap","_sortMaskChannels","viewport","viewportChanged","lastViewport","maskId","_renderChannel","channelInfo","_ref2","oldChannelInfo","index","maskChanged","layerBounds","some","b","i","bounds","maskBounds","maskViewport","getBounds","render","pass","channel","moduleParameters","devicePixelRatio","coordinateOrigin","coordinateSystem","_this","channelCount","_iterator","_createForOfIteratorHelper","_step","_loop","layer","root","warn","findIndex","c","push","s","n","done","_ret","err","e","f","getModuleParameters","maskChannels","cleanup","delete","undefined","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/core/src/effects/mask/mask-effect.ts"],"sourcesContent":["import {Texture2D} from '@luma.gl/core';\n// import {readPixelsToArray} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport MaskPass from '../../passes/mask-pass';\nimport {OPERATION} from '../../lib/constants';\nimport {getMaskBounds, getMaskViewport} from './utils';\nimport log from '../../utils/log';\n\nimport type {Effect, PreRenderOptions} from '../../lib/effect';\nimport type Layer from '../../lib/layer';\nimport type Viewport from '../../viewports/viewport';\nimport type {MaskBounds} from './utils';\nimport type {CoordinateSystem} from '../../lib/constants';\n\ntype Mask = {\n  /** The channel index */\n  index: number;\n  bounds: MaskBounds;\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\ntype Channel = {\n  id: string;\n  index: number;\n  layers: Layer[];\n  bounds: MaskBounds;\n  maskBounds: MaskBounds;\n  layerBounds: MaskBounds[];\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\n// Class to manage mask effect\nexport default class MaskEffect implements Effect {\n  id = 'mask-effect';\n  props = null;\n  useInPicking = true;\n\n  private dummyMaskMap?: Texture2D;\n  private channels: (Channel | null)[] = [];\n  private masks: Record<string, Mask> | null = null;\n  private maskPass?: MaskPass;\n  private maskMap?: Texture2D;\n  private lastViewport?: Viewport;\n\n  preRender(\n    gl: WebGLRenderingContext,\n    {layers, layerFilter, viewports, onViewportActive, views}: PreRenderOptions\n  ): void {\n    if (!this.dummyMaskMap) {\n      this.dummyMaskMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation === OPERATION.MASK);\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return;\n    }\n    this.masks = {};\n\n    if (!this.maskPass) {\n      this.maskPass = new MaskPass(gl, {id: 'default-mask'});\n      this.maskMap = this.maskPass.maskMap;\n    }\n\n    // Map layers to channels\n    const channelMap = this._sortMaskChannels(maskLayers);\n    // TODO - support multiple views\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    for (const maskId in channelMap) {\n      this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n    }\n\n    // // Debug show FBO contents on screen\n    // const color = readPixelsToArray(this.maskMap);\n    // let canvas = document.getElementById('fbo-canvas');\n    // if (!canvas) {\n    //   canvas = document.createElement('canvas');\n    //   canvas.id = 'fbo-canvas';\n    //   canvas.width = this.maskMap.width;\n    //   canvas.height = this.maskMap.height;\n    //   canvas.style.zIndex = 100;\n    //   canvas.style.position = 'absolute';\n    //   canvas.style.right = 0;\n    //   canvas.style.border = 'blue 1px solid';\n    //   canvas.style.width = '256px';\n    //   canvas.style.transform = 'scaleY(-1)';\n    //   document.body.appendChild(canvas);\n    // }\n    // const ctx = canvas.getContext('2d');\n    // const imageData = ctx.createImageData(this.maskMap.width, this.maskMap.height);\n    // for (let i = 0; i < color.length; i += 4) {\n    //   imageData.data[i + 0] = color[i + 0];\n    //   imageData.data[i + 1] = color[i + 1];\n    //   imageData.data[i + 2] = color[i + 2];\n    //   imageData.data[i + 3] = color[i + 3] + 128;\n    // }\n    // ctx.putImageData(imageData, 0, 0);\n  }\n\n  private _renderChannel(\n    channelInfo: Channel,\n    {\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ) {\n    const oldChannelInfo = this.channels[channelInfo.index];\n    if (!oldChannelInfo) {\n      return;\n    }\n\n    const maskChanged =\n      // If a channel is new\n      channelInfo === oldChannelInfo ||\n      // If sublayers have changed\n      oldChannelInfo.layers.length !== channelInfo.layers.length ||\n      // If a sublayer's positions have been updated, the cached bounds will change shallowly\n      channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      // Recalculate mask bounds\n      this.lastViewport = viewport;\n\n      channelInfo.bounds = getMaskBounds({layers: channelInfo.layers, viewport});\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        // Rerender mask FBO\n        const {maskPass, maskMap} = this;\n\n        const maskViewport = getMaskViewport({\n          bounds: channelInfo.bounds,\n          viewport,\n          width: maskMap.width,\n          height: maskMap.height\n        });\n\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n\n        // @ts-ignore (2532) This method is only called from preRender where maskPass is defined\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          moduleParameters: {\n            devicePixelRatio: 1\n          }\n        });\n      }\n    }\n\n    // @ts-ignore (2532) This method is only called from preRender where masks is defined\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n  }\n\n  /**\n   * Find a channel to render each mask into\n   * If a maskId already exists, diff and update the existing channel\n   * Otherwise replace a removed mask\n   * Otherwise create a new channel\n   * Returns a map from mask layer id to channel info\n   */\n  private _sortMaskChannels(maskLayers: Layer[]): Record<string, Channel> {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {id} = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue; // eslint-disable-line no-continue\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => c?.id === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        // The mask id at this channel no longer exists\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n\n  getModuleParameters(): {\n    maskMap: Texture2D;\n    maskChannels: Record<string, Mask> | null;\n  } {\n    return {\n      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n      maskChannels: this.masks\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}