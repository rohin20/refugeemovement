{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateMapboxLayers = generateMapboxLayers;\nexports.updateMapboxLayers = updateMapboxLayers;\nexports.geoJsonFromData = geoJsonFromData;\nexports.gpuFilterToMapboxFilter = gpuFilterToMapboxFilter;\nexports.prefixGpuField = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _baseLayer = require(\"./base-layer\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n/**\n * This function will convert layers to mapbox layers\n * @param layers the layers to be converted\n * @param layerData extra layer information\n * @param layerOrder the order by which we should convert layers\n * @param layersToRender {[id]: true | false} object whether each layer should be rendered\n * @returns\n */\nfunction generateMapboxLayers() {\n  var layers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var layerData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var layerOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var layersToRender = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (layerData.length > 0) {\n    return layerOrder.slice().reverse().filter(function (idx) {\n      return layers[idx].overlayType === _baseLayer.OVERLAY_TYPE_CONST.mapboxgl && layersToRender[layers[idx].id];\n    }).reduce(function (accu, index) {\n      var layer = layers[index];\n      return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, layer.id, {\n        id: layer.id,\n        data: layerData[index].data,\n        isVisible: layer.config.isVisible,\n        config: layerData[index].config,\n        hidden: layer.config.hidden,\n        sourceId: layerData[index].config.source\n      }));\n    }, {});\n  }\n  return {};\n}\n\n/**\n * Update mapbox layers on the given map\n * @param map\n * @param newLayers Map of new mapbox layers to be displayed\n * @param oldLayers Map of the old layers to be compare with the current ones to detect deleted layers\n *                  {layerId: sourceId}\n */\nfunction updateMapboxLayers(map) {\n  var newLayers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var oldLayers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  // delete no longer existed old layers\n  if (oldLayers) {\n    checkAndRemoveOldLayers(map, oldLayers, newLayers);\n  } // insert or update new layer\n\n  Object.values(newLayers).forEach(function (overlay) {\n    var layerId = overlay.id,\n      config = overlay.config,\n      data = overlay.data,\n      sourceId = overlay.sourceId,\n      isVisible = overlay.isVisible;\n    if (!data && !config) {\n      return;\n    }\n    var _ref = oldLayers && oldLayers[layerId] || {},\n      oldData = _ref.data,\n      oldConfig = _ref.config;\n    if (data && data !== oldData) {\n      updateSourceData(map, sourceId, data);\n    } // compare with previous configs\n\n    if (oldConfig !== config) {\n      updateLayerConfig(map, layerId, config, isVisible);\n    }\n  });\n}\nfunction checkAndRemoveOldLayers(map, oldLayers, newLayers) {\n  Object.keys(oldLayers).forEach(function (layerId) {\n    if (!newLayers[layerId]) {\n      map.removeLayer(layerId);\n    }\n  });\n}\nfunction updateLayerConfig(map, layerId, config, isVisible) {\n  var mapboxLayer = map.getLayer(layerId);\n  if (mapboxLayer) {\n    // check if layer already is set\n    // remove it if exists\n    map.removeLayer(layerId);\n  }\n  map.addLayer(config);\n  map.setLayoutProperty(layerId, 'visibility', isVisible ? 'visible' : 'none');\n}\nfunction updateSourceData(map, sourceId, data) {\n  var source = map.getSource(sourceId);\n  if (!source) {\n    map.addSource(sourceId, {\n      type: 'geojson',\n      data: data\n    });\n  } else {\n    source.setData(data);\n  }\n}\n/**\n *\n * @param filteredIndex\n * @param getGeometry {({index: number}) => any}\n * @param getProperties {({index: number}) => any}\n * @returns FeatureCollection\n */\n\nfunction geoJsonFromData() {\n  var filteredIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var getGeometry = arguments.length > 1 ? arguments[1] : undefined;\n  var getProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (d) {};\n  var geojson = {\n    type: 'FeatureCollection',\n    features: []\n  };\n  for (var i = 0; i < filteredIndex.length; i++) {\n    var index = filteredIndex[i];\n    var rowIndex = {\n      index: index\n    };\n    var geometry = getGeometry(rowIndex);\n    if (geometry) {\n      geojson.features.push({\n        type: 'Feature',\n        properties: _objectSpread({\n          index: index\n        }, getProperties(rowIndex)),\n        geometry: geometry\n      });\n    }\n  }\n  return geojson;\n}\nvar prefixGpuField = function prefixGpuField(name) {\n  return \"gpu:\".concat(name);\n};\nexports.prefixGpuField = prefixGpuField;\nfunction gpuFilterToMapboxFilter(gpuFilter) {\n  var filterRange = gpuFilter.filterRange,\n    filterValueUpdateTriggers = gpuFilter.filterValueUpdateTriggers;\n  var hasFilter = Object.values(filterValueUpdateTriggers).filter(function (d) {\n    return d;\n  });\n  if (!hasFilter.length) {\n    return null;\n  }\n  var condition = ['all']; // [\">=\", key, value]\n  // [\"<=\", key, value]\n\n  var expressions = Object.values(filterValueUpdateTriggers).reduce(function (accu, name, i) {\n    return name ? [].concat((0, _toConsumableArray2[\"default\"])(accu), [['>=', prefixGpuField(name), filterRange[i][0]], ['<=', prefixGpuField(name), filterRange[i][1]]]) : accu;\n  }, condition);\n  return expressions;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","generateMapboxLayers","updateMapboxLayers","geoJsonFromData","gpuFilterToMapboxFilter","prefixGpuField","_toConsumableArray2","_interopRequireDefault","require","_defineProperty2","_baseLayer","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","layerData","undefined","layerOrder","slice","reverse","idx","layers","overlayType","OVERLAY_TYPE_CONST","mapboxgl","layersToRender","id","reduce","accu","index","layer","data","isVisible","config","hidden","sourceId","newLayers","oldLayers","checkAndRemoveOldLayers","map","values","overlay","layerId","_ref","oldData","oldConfig","updateLayerConfig","mapboxLayer","getLayer","removeLayer","addLayer","setLayoutProperty","getSource","addSource","type","filteredIndex","getGeometry","getProperties","d","geojson","rowIndex","geometry","features","properties","name","concat"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/layers/src/mapbox-utils.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport Layer, {OVERLAY_TYPE_CONST} from './base-layer';\nimport {Feature} from 'geojson';\n\n/**\n * This function will convert layers to mapbox layers\n * @param layers the layers to be converted\n * @param layerData extra layer information\n * @param layerOrder the order by which we should convert layers\n * @param layersToRender {[id]: true | false} object whether each layer should be rendered\n * @returns\n */\nexport function generateMapboxLayers(\n  layers: Layer[] = [],\n  layerData: any[] = [],\n  layerOrder: number[] = [],\n  layersToRender: {[key: string]: boolean} = {}\n): {[key: string]: Layer} {\n  if (layerData.length > 0) {\n    return layerOrder\n      .slice()\n      .reverse()\n      .filter(\n        idx =>\n          layers[idx].overlayType === OVERLAY_TYPE_CONST.mapboxgl && layersToRender[layers[idx].id]\n      )\n      .reduce((accu, index) => {\n        const layer = layers[index];\n        return {\n          ...accu,\n          [layer.id]: {\n            id: layer.id,\n            data: layerData[index].data,\n            isVisible: layer.config.isVisible,\n            config: layerData[index].config,\n            hidden: layer.config.hidden,\n            sourceId: layerData[index].config.source\n          }\n        };\n      }, {});\n  }\n\n  return {};\n}\n\ntype newLayersType = {\n  [key: string]: Layer & Partial<{data: any; sourceId: any; isVisible: boolean}>;\n};\ntype oldLayersType = {[key: string]: Layer & {data?: any}};\n/**\n * Update mapbox layers on the given map\n * @param map\n * @param newLayers Map of new mapbox layers to be displayed\n * @param oldLayers Map of the old layers to be compare with the current ones to detect deleted layers\n *                  {layerId: sourceId}\n */\nexport function updateMapboxLayers(\n  map,\n  newLayers: newLayersType = {},\n  oldLayers: oldLayersType | null = null\n) {\n  // delete no longer existed old layers\n  if (oldLayers) {\n    checkAndRemoveOldLayers(map, oldLayers, newLayers);\n  }\n\n  // insert or update new layer\n  Object.values(newLayers).forEach(overlay => {\n    const {id: layerId, config, data, sourceId, isVisible} = overlay;\n    if (!data && !config) {\n      return;\n    }\n\n    const {data: oldData, config: oldConfig} = (oldLayers && oldLayers[layerId]) || {};\n\n    if (data && data !== oldData) {\n      updateSourceData(map, sourceId, data);\n    }\n\n    // compare with previous configs\n    if (oldConfig !== config) {\n      updateLayerConfig(map, layerId, config, isVisible);\n    }\n  });\n}\n\nfunction checkAndRemoveOldLayers(map, oldLayers: oldLayersType, newLayers: newLayersType) {\n  Object.keys(oldLayers).forEach(layerId => {\n    if (!newLayers[layerId]) {\n      map.removeLayer(layerId);\n    }\n  });\n}\n\nfunction updateLayerConfig(map, layerId, config, isVisible) {\n  const mapboxLayer = map.getLayer(layerId);\n\n  if (mapboxLayer) {\n    // check if layer already is set\n    // remove it if exists\n    map.removeLayer(layerId);\n  }\n\n  map.addLayer(config);\n  map.setLayoutProperty(layerId, 'visibility', isVisible ? 'visible' : 'none');\n}\n\nfunction updateSourceData(map, sourceId, data) {\n  const source = map.getSource(sourceId);\n\n  if (!source) {\n    map.addSource(sourceId, {\n      type: 'geojson',\n      data\n    });\n  } else {\n    source.setData(data);\n  }\n}\n\n/**\n *\n * @param filteredIndex\n * @param getGeometry {({index: number}) => any}\n * @param getProperties {({index: number}) => any}\n * @returns FeatureCollection\n */\nexport function geoJsonFromData(\n  filteredIndex: number[] = [],\n  getGeometry: {({index: number}): any},\n  getProperties: {({index: number}): any} = d => {}\n) {\n  const geojson: {type: string; features: Feature[]} = {\n    type: 'FeatureCollection',\n    features: []\n  };\n\n  for (let i = 0; i < filteredIndex.length; i++) {\n    const index = filteredIndex[i];\n    const rowIndex = {index};\n    const geometry = getGeometry(rowIndex);\n\n    if (geometry) {\n      geojson.features.push({\n        type: 'Feature',\n        properties: {\n          index,\n          ...getProperties(rowIndex)\n        },\n        geometry\n      });\n    }\n  }\n\n  return geojson;\n}\n\nexport const prefixGpuField = name => `gpu:${name}`;\n\nexport function gpuFilterToMapboxFilter(gpuFilter) {\n  const {filterRange, filterValueUpdateTriggers} = gpuFilter;\n\n  const hasFilter = Object.values(filterValueUpdateTriggers).filter(d => d);\n\n  if (!hasFilter.length) {\n    return null;\n  }\n\n  const condition = ['all'];\n\n  // [\">=\", key, value]\n  // [\"<=\", key, value]\n  const expressions = Object.values(filterValueUpdateTriggers).reduce(\n    (accu: any[], name, i) =>\n      name\n        ? [\n            ...accu,\n            ['>=', prefixGpuField(name), filterRange[i][0]],\n            ['<=', prefixGpuField(name), filterRange[i][1]]\n          ]\n        : accu,\n    condition\n  );\n\n  return expressions;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}