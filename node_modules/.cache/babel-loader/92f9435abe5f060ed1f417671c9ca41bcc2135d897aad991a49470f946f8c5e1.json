{"ast":null,"code":"import _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Attribute from './attribute';\nimport log from '../../utils/log';\nimport debug from '../../debug';\nimport AttributeTransitionManager from './attribute-transition-manager';\nvar TRACE_INVALIDATE = 'attributeManager.invalidate';\nvar TRACE_UPDATE_START = 'attributeManager.updateStart';\nvar TRACE_UPDATE_END = 'attributeManager.updateEnd';\nvar TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nvar TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nvar TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\nvar AttributeManager = /*#__PURE__*/function () {\n  function AttributeManager(gl) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$id = _ref.id,\n      id = _ref$id === void 0 ? 'attribute-manager' : _ref$id,\n      stats = _ref.stats,\n      timeline = _ref.timeline;\n    _classCallCheck(this, AttributeManager);\n    _defineProperty(this, \"id\", void 0);\n    _defineProperty(this, \"gl\", void 0);\n    _defineProperty(this, \"attributes\", void 0);\n    _defineProperty(this, \"updateTriggers\", void 0);\n    _defineProperty(this, \"needsRedraw\", void 0);\n    _defineProperty(this, \"userData\", void 0);\n    _defineProperty(this, \"stats\", void 0);\n    _defineProperty(this, \"attributeTransitionManager\", void 0);\n    this.id = id;\n    this.gl = gl;\n    this.attributes = {};\n    this.updateTriggers = {};\n    this.needsRedraw = true;\n    this.userData = {};\n    this.stats = stats;\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: \"\".concat(id, \"-transitions\"),\n      timeline: timeline\n    });\n    Object.seal(this);\n  }\n  _createClass(AttributeManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      for (var attributeName in this.attributes) {\n        this.attributes[attributeName].delete();\n      }\n      this.attributeTransitionManager.finalize();\n    }\n  }, {\n    key: \"getNeedsRedraw\",\n    value: function getNeedsRedraw() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        clearRedrawFlags: false\n      };\n      var redraw = this.needsRedraw;\n      this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n      return redraw && this.id;\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      this.needsRedraw = true;\n    }\n  }, {\n    key: \"add\",\n    value: function add(attributes) {\n      this._add(attributes);\n    }\n  }, {\n    key: \"addInstanced\",\n    value: function addInstanced(attributes) {\n      this._add(attributes, {\n        instanced: 1\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(attributeNameArray) {\n      var _iterator = _createForOfIteratorHelper(attributeNameArray),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var name = _step.value;\n          if (this.attributes[name] !== undefined) {\n            this.attributes[name].delete();\n            delete this.attributes[name];\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(triggerName, dataRange) {\n      var invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n      debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n    }\n  }, {\n    key: \"invalidateAll\",\n    value: function invalidateAll(dataRange) {\n      for (var attributeName in this.attributes) {\n        this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n      }\n      debug(TRACE_INVALIDATE, this, 'all');\n    }\n  }, {\n    key: \"update\",\n    value: function update(_ref2) {\n      var data = _ref2.data,\n        numInstances = _ref2.numInstances,\n        _ref2$startIndices = _ref2.startIndices,\n        startIndices = _ref2$startIndices === void 0 ? null : _ref2$startIndices,\n        transitions = _ref2.transitions,\n        _ref2$props = _ref2.props,\n        props = _ref2$props === void 0 ? {} : _ref2$props,\n        _ref2$buffers = _ref2.buffers,\n        buffers = _ref2$buffers === void 0 ? {} : _ref2$buffers,\n        _ref2$context = _ref2.context,\n        context = _ref2$context === void 0 ? {} : _ref2$context;\n      var updated = false;\n      debug(TRACE_UPDATE_START, this);\n      if (this.stats) {\n        this.stats.get('Update Attributes').timeStart();\n      }\n      for (var attributeName in this.attributes) {\n        var attribute = this.attributes[attributeName];\n        var accessorName = attribute.settings.accessor;\n        attribute.startIndices = startIndices;\n        attribute.numInstances = numInstances;\n        if (props[attributeName]) {\n          log.removed(\"props.\".concat(attributeName), \"data.attributes.\".concat(attributeName))();\n        }\n        if (attribute.setExternalBuffer(buffers[attributeName])) {} else if (attribute.setBinaryValue(typeof accessorName === 'string' ? buffers[accessorName] : undefined, data.startIndices)) {} else if (typeof accessorName === 'string' && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {} else if (attribute.needsUpdate()) {\n          updated = true;\n          this._updateAttribute({\n            attribute: attribute,\n            numInstances: numInstances,\n            data: data,\n            props: props,\n            context: context\n          });\n        }\n        this.needsRedraw = this.needsRedraw || attribute.needsRedraw();\n      }\n      if (updated) {\n        debug(TRACE_UPDATE_END, this, numInstances);\n      }\n      if (this.stats) {\n        this.stats.get('Update Attributes').timeEnd();\n      }\n      this.attributeTransitionManager.update({\n        attributes: this.attributes,\n        numInstances: numInstances,\n        transitions: transitions\n      });\n    }\n  }, {\n    key: \"updateTransition\",\n    value: function updateTransition() {\n      var attributeTransitionManager = this.attributeTransitionManager;\n      var transitionUpdated = attributeTransitionManager.run();\n      this.needsRedraw = this.needsRedraw || transitionUpdated;\n      return transitionUpdated;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"getChangedAttributes\",\n    value: function getChangedAttributes() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        clearChangedFlags: false\n      };\n      var attributes = this.attributes,\n        attributeTransitionManager = this.attributeTransitionManager;\n      var changedAttributes = _objectSpread({}, attributeTransitionManager.getAttributes());\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n        if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n          changedAttributes[attributeName] = attribute;\n        }\n      }\n      return changedAttributes;\n    }\n  }, {\n    key: \"getShaderAttributes\",\n    value: function getShaderAttributes(attributes) {\n      var excludeAttributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (!attributes) {\n        attributes = this.getAttributes();\n      }\n      var shaderAttributes = {};\n      for (var attributeName in attributes) {\n        if (!excludeAttributes[attributeName]) {\n          Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());\n        }\n      }\n      return shaderAttributes;\n    }\n  }, {\n    key: \"_add\",\n    value: function _add(attributes) {\n      var extraProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n        this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);\n      }\n      this._mapUpdateTriggersToAttributes();\n    }\n  }, {\n    key: \"_createAttribute\",\n    value: function _createAttribute(name, attribute, extraProps) {\n      var props = _objectSpread(_objectSpread({}, attribute), {}, {\n        id: name,\n        size: attribute.isIndexed && 1 || attribute.size || 1,\n        divisor: extraProps.instanced ? 1 : attribute.divisor || 0\n      });\n      return new Attribute(this.gl, props);\n    }\n  }, {\n    key: \"_mapUpdateTriggersToAttributes\",\n    value: function _mapUpdateTriggersToAttributes() {\n      var _this = this;\n      var triggers = {};\n      var _loop = function _loop(attributeName) {\n        var attribute = _this.attributes[attributeName];\n        attribute.getUpdateTriggers().forEach(function (triggerName) {\n          if (!triggers[triggerName]) {\n            triggers[triggerName] = [];\n          }\n          triggers[triggerName].push(attributeName);\n        });\n      };\n      for (var attributeName in this.attributes) {\n        _loop(attributeName);\n      }\n      this.updateTriggers = triggers;\n    }\n  }, {\n    key: \"_invalidateTrigger\",\n    value: function _invalidateTrigger(triggerName, dataRange) {\n      var attributes = this.attributes,\n        updateTriggers = this.updateTriggers;\n      var invalidatedAttributes = updateTriggers[triggerName];\n      if (invalidatedAttributes) {\n        invalidatedAttributes.forEach(function (name) {\n          var attribute = attributes[name];\n          if (attribute) {\n            attribute.setNeedsUpdate(attribute.id, dataRange);\n          }\n        });\n      }\n      return invalidatedAttributes;\n    }\n  }, {\n    key: \"_updateAttribute\",\n    value: function _updateAttribute(opts) {\n      var attribute = opts.attribute,\n        numInstances = opts.numInstances;\n      debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n      if (attribute.constant) {\n        attribute.setConstantValue(attribute.value);\n        return;\n      }\n      if (attribute.allocate(numInstances)) {\n        debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n      }\n      var updated = attribute.updateBuffer(opts);\n      if (updated) {\n        this.needsRedraw = true;\n        debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n      }\n    }\n  }]);\n  return AttributeManager;\n}();\nexport { AttributeManager as default };","map":{"version":3,"names":["Attribute","log","debug","AttributeTransitionManager","TRACE_INVALIDATE","TRACE_UPDATE_START","TRACE_UPDATE_END","TRACE_ATTRIBUTE_UPDATE_START","TRACE_ATTRIBUTE_ALLOCATE","TRACE_ATTRIBUTE_UPDATE_END","AttributeManager","gl","_ref","arguments","length","undefined","_ref$id","id","stats","timeline","_classCallCheck","_defineProperty","attributes","updateTriggers","needsRedraw","userData","attributeTransitionManager","concat","Object","seal","_createClass","key","value","finalize","attributeName","delete","getNeedsRedraw","opts","clearRedrawFlags","redraw","setNeedsRedraw","add","_add","addInstanced","instanced","remove","attributeNameArray","_iterator","_createForOfIteratorHelper","_step","s","n","done","name","err","e","f","invalidate","triggerName","dataRange","invalidatedAttributes","_invalidateTrigger","invalidateAll","setNeedsUpdate","update","_ref2","data","numInstances","_ref2$startIndices","startIndices","transitions","_ref2$props","props","_ref2$buffers","buffers","_ref2$context","context","updated","get","timeStart","attribute","accessorName","settings","accessor","removed","setExternalBuffer","setBinaryValue","setConstantValue","needsUpdate","_updateAttribute","timeEnd","updateTransition","transitionUpdated","run","getAttributes","getChangedAttributes","clearChangedFlags","changedAttributes","_objectSpread","hasAttribute","getShaderAttributes","excludeAttributes","shaderAttributes","assign","extraProps","_createAttribute","_mapUpdateTriggersToAttributes","size","isIndexed","divisor","_this","triggers","_loop","getUpdateTriggers","forEach","push","constant","allocate","updateBuffer","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/core/src/lib/attribute/attribute-manager.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable guard-for-in */\nimport Attribute, {AttributeOptions} from './attribute';\nimport {IShaderAttribute} from './shader-attribute';\nimport log from '../../utils/log';\nimport debug from '../../debug';\nimport {NumericArray} from '../../types/types';\n\nimport AttributeTransitionManager from './attribute-transition-manager';\n\nimport type {Stats} from '@probe.gl/stats';\nimport type {Timeline} from '@luma.gl/engine';\n\nconst TRACE_INVALIDATE = 'attributeManager.invalidate';\nconst TRACE_UPDATE_START = 'attributeManager.updateStart';\nconst TRACE_UPDATE_END = 'attributeManager.updateEnd';\nconst TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nconst TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nconst TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\n\nexport default class AttributeManager {\n  /**\n   * @classdesc\n   * Automated attribute generation and management. Suitable when a set of\n   * vertex shader attributes are generated by iteration over a data array,\n   * and updates to these attributes are needed either when the data itself\n   * changes, or when other data relevant to the calculations change.\n   *\n   * - First the application registers descriptions of its dynamic vertex\n   *   attributes using AttributeManager.add().\n   * - Then, when any change that affects attributes is detected by the\n   *   application, the app will call AttributeManager.invalidate().\n   * - Finally before it renders, it calls AttributeManager.update() to\n   *   ensure that attributes are automatically rebuilt if anything has been\n   *   invalidated.\n   *\n   * The application provided update functions describe how attributes\n   * should be updated from a data array and are expected to traverse\n   * that data array (or iterable) and fill in the attribute's typed array.\n   *\n   * Note that the attribute manager intentionally does not do advanced\n   * change detection, but instead makes it easy to build such detection\n   * by offering the ability to \"invalidate\" each attribute separately.\n   */\n  id: string;\n  gl: WebGLRenderingContext;\n  attributes: Record<string, Attribute>;\n  updateTriggers: {[name: string]: string[]};\n  needsRedraw: string | boolean;\n  userData: any;\n\n  private stats?: Stats;\n  private attributeTransitionManager: AttributeTransitionManager;\n\n  constructor(\n    gl: WebGLRenderingContext,\n    {\n      id = 'attribute-manager',\n      stats,\n      timeline\n    }: {\n      id?: string;\n      stats?: Stats;\n      timeline?: Timeline;\n    } = {}\n  ) {\n    this.id = id;\n    this.gl = gl;\n\n    this.attributes = {};\n\n    this.updateTriggers = {};\n    this.needsRedraw = true;\n\n    this.userData = {};\n    this.stats = stats;\n\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: `${id}-transitions`,\n      timeline\n    });\n\n    // For debugging sanity, prevent uninitialized members\n    Object.seal(this);\n  }\n\n  finalize() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].delete();\n    }\n    this.attributeTransitionManager.finalize();\n  }\n\n  // Returns the redraw flag, optionally clearing it.\n  // Redraw flag will be set if any attributes attributes changed since\n  // flag was last cleared.\n  //\n  // @param {String} [clearRedrawFlags=false] - whether to clear the flag\n  // @return {false|String} - reason a redraw is needed.\n  getNeedsRedraw(opts: {clearRedrawFlags?: boolean} = {clearRedrawFlags: false}): string | false {\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n    return redraw && this.id;\n  }\n\n  // Sets the redraw flag.\n  // @param {Boolean} redraw=true\n  setNeedsRedraw() {\n    this.needsRedraw = true;\n  }\n\n  // Adds attributes\n  add(attributes: {[id: string]: AttributeOptions}) {\n    this._add(attributes);\n  }\n\n  // Adds attributes\n  addInstanced(attributes: {[id: string]: AttributeOptions}) {\n    this._add(attributes, {instanced: 1});\n  }\n\n  /**\n   * Removes attributes\n   * Takes an array of attribute names and delete them from\n   * the attribute map if they exists\n   *\n   * @example\n   * attributeManager.remove(['position']);\n   *\n   * @param {Object} attributeNameArray - attribute name array (see above)\n   */\n  remove(attributeNameArray: string[]) {\n    for (const name of attributeNameArray) {\n      if (this.attributes[name] !== undefined) {\n        this.attributes[name].delete();\n        delete this.attributes[name];\n      }\n    }\n  }\n\n  // Marks an attribute for update\n  invalidate(triggerName: string, dataRange?: {startRow?: number; endRow?: number}) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n  }\n\n  invalidateAll(dataRange?: {startRow?: number; endRow?: number}) {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n    }\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, 'all');\n  }\n\n  // Ensure all attribute buffers are updated from props or data.\n  update({\n    data,\n    numInstances,\n    startIndices = null,\n    transitions,\n    props = {},\n    buffers = {},\n    context = {}\n  }: {\n    data: any;\n    numInstances: number;\n    startIndices?: NumericArray | null;\n    transitions: any;\n    props: any;\n    buffers: any;\n    context: any;\n  }) {\n    // keep track of whether some attributes are updated\n    let updated = false;\n\n    debug(TRACE_UPDATE_START, this);\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeStart();\n    }\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      const accessorName = attribute.settings.accessor;\n      attribute.startIndices = startIndices;\n      attribute.numInstances = numInstances;\n\n      if (props[attributeName]) {\n        log.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();\n      }\n\n      if (attribute.setExternalBuffer(buffers[attributeName])) {\n        // Step 1: try update attribute directly from external buffers\n      } else if (\n        attribute.setBinaryValue(\n          typeof accessorName === 'string' ? buffers[accessorName] : undefined,\n          data.startIndices\n        )\n      ) {\n        // Step 2: try set packed value from external typed array\n      } else if (\n        typeof accessorName === 'string' &&\n        !buffers[accessorName] &&\n        attribute.setConstantValue(props[accessorName])\n      ) {\n        // Step 3: try set constant value from props\n        // Note: if buffers[accessorName] is supplied, ignore props[accessorName]\n        // This may happen when setBinaryValue falls through to use the auto updater\n      } else if (attribute.needsUpdate()) {\n        // Step 4: update via updater callback\n        updated = true;\n        this._updateAttribute({\n          attribute,\n          numInstances,\n          data,\n          props,\n          context\n        });\n      }\n\n      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();\n    }\n\n    if (updated) {\n      // Only initiate alloc/update (and logging) if actually needed\n      debug(TRACE_UPDATE_END, this, numInstances);\n    }\n\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeEnd();\n    }\n\n    this.attributeTransitionManager.update({\n      attributes: this.attributes,\n      numInstances,\n      transitions\n    });\n  }\n\n  // Update attribute transition to the current timestamp\n  // Returns `true` if any transition is in progress\n  updateTransition() {\n    const {attributeTransitionManager} = this;\n    const transitionUpdated = attributeTransitionManager.run();\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n\n  /**\n   * Returns all attribute descriptors\n   * Note: Format matches luma.gl Model/Program.setAttributes()\n   * @return {Object} attributes - descriptors\n   */\n  getAttributes(): {[id: string]: Attribute} {\n    return this.attributes;\n  }\n\n  /**\n   * Returns changed attribute descriptors\n   * This indicates which WebGLBuffers need to be updated\n   * @return {Object} attributes - descriptors\n   */\n  getChangedAttributes(opts: {clearChangedFlags?: boolean} = {clearChangedFlags: false}): {\n    [id: string]: Attribute;\n  } {\n    const {attributes, attributeTransitionManager} = this;\n\n    const changedAttributes = {...attributeTransitionManager.getAttributes()};\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n\n    return changedAttributes;\n  }\n\n  // Returns shader attributes\n  getShaderAttributes(\n    attributes?: {[id: string]: Attribute},\n    excludeAttributes: Record<string, boolean> = {}\n  ): {[id: string]: IShaderAttribute} {\n    if (!attributes) {\n      attributes = this.getAttributes();\n    }\n    const shaderAttributes = {};\n    for (const attributeName in attributes) {\n      if (!excludeAttributes[attributeName]) {\n        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());\n      }\n    }\n    return shaderAttributes;\n  }\n\n  // PRIVATE METHODS\n\n  // Used to register an attribute\n  private _add(attributes: {[id: string]: AttributeOptions}, extraProps: any = {}) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      // Initialize the attribute descriptor, with WebGL and metadata fields\n      this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);\n    }\n\n    this._mapUpdateTriggersToAttributes();\n  }\n  /* eslint-enable max-statements */\n\n  private _createAttribute(name: string, attribute: AttributeOptions, extraProps: any) {\n    // For expected default values see:\n    // https://github.com/visgl/luma.gl/blob/1affe21352e289eeaccee2a876865138858a765c/modules/webgl/src/classes/accessor.js#L5-L13\n    // and https://deck.gl/docs/api-reference/core/attribute-manager#add\n    const props: AttributeOptions = {\n      ...attribute,\n      id: name,\n      size: (attribute.isIndexed && 1) || attribute.size || 1,\n      divisor: extraProps.instanced ? 1 : attribute.divisor || 0\n    };\n\n    return new Attribute(this.gl, props);\n  }\n\n  // build updateTrigger name to attribute name mapping\n  private _mapUpdateTriggersToAttributes() {\n    const triggers: {[name: string]: string[]} = {};\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.getUpdateTriggers().forEach(triggerName => {\n        if (!triggers[triggerName]) {\n          triggers[triggerName] = [];\n        }\n        triggers[triggerName].push(attributeName);\n      });\n    }\n\n    this.updateTriggers = triggers;\n  }\n\n  private _invalidateTrigger(\n    triggerName: string,\n    dataRange?: {startRow?: number; endRow?: number}\n  ): string[] {\n    const {attributes, updateTriggers} = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n\n    if (invalidatedAttributes) {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n        if (attribute) {\n          attribute.setNeedsUpdate(attribute.id, dataRange);\n        }\n      });\n    }\n    return invalidatedAttributes;\n  }\n\n  private _updateAttribute(opts: {\n    attribute: Attribute;\n    numInstances: number;\n    data: any;\n    props: any;\n    context: any;\n  }) {\n    const {attribute, numInstances} = opts;\n    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n\n    if (attribute.constant) {\n      // The attribute is flagged as constant outside of an update cycle\n      // Skip allocation and updater call\n      attribute.setConstantValue(attribute.value as NumericArray);\n      return;\n    }\n\n    if (attribute.allocate(numInstances)) {\n      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n    }\n\n    // Calls update on any buffers that need update\n    const updated = attribute.updateBuffer(opts);\n    if (updated) {\n      this.needsRedraw = true;\n      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}