{"ast":null,"code":"import { Vector3, toRadians, toDegrees, config } from '@math.gl/core';\nimport { WGS84_CONSTANTS } from './constants';\nfunction identity(x) {\n  return x;\n}\nvar scratchVector = new Vector3();\nexport function fromCartographic(cartographic) {\n  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n  if ('longitude' in cartographic) {\n    result[0] = map(cartographic.longitude);\n    result[1] = map(cartographic.latitude);\n    result[2] = cartographic.height;\n  } else if ('x' in cartographic) {\n    result[0] = map(cartographic.x);\n    result[1] = map(cartographic.y);\n    result[2] = cartographic.z;\n  } else {\n    result[0] = map(cartographic[0]);\n    result[1] = map(cartographic[1]);\n    result[2] = cartographic[2];\n  }\n  return result;\n}\nexport function fromCartographicToRadians(cartographic) {\n  var vector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? identity : toRadians);\n}\nexport function fromCartographicToDegrees(cartographic) {\n  var vector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? toDegrees : identity);\n}\nexport function toCartographic(vector, cartographic) {\n  var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n  if ('longitude' in cartographic) {\n    cartographic.longitude = map(vector[0]);\n    cartographic.latitude = map(vector[1]);\n    cartographic.height = vector[2];\n  } else if ('x' in cartographic) {\n    cartographic.x = map(vector[0]);\n    cartographic.y = map(vector[1]);\n    cartographic.z = vector[2];\n  } else {\n    cartographic[0] = map(vector[0]);\n    cartographic[1] = map(vector[1]);\n    cartographic[2] = vector[2];\n  }\n  return cartographic;\n}\nexport function toCartographicFromRadians(vector, cartographic) {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? identity : toDegrees);\n}\nexport function toCartographicFromDegrees(vector, cartographic) {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? toRadians : identity);\n}\nexport function isWGS84(vector) {\n  if (!vector) {\n    return false;\n  }\n  scratchVector.from(vector);\n  var oneOverRadiiSquared = WGS84_CONSTANTS.oneOverRadiiSquared,\n    centerToleranceSquared = WGS84_CONSTANTS.centerToleranceSquared;\n  var x2 = vector[0] * vector[0] * oneOverRadiiSquared[0];\n  var y2 = vector[1] * vector[1] * oneOverRadiiSquared[1];\n  var z2 = vector[2] * vector[2] * oneOverRadiiSquared[2];\n  return Math.abs(x2 + y2 + z2 - 1) < centerToleranceSquared;\n}","map":{"version":3,"names":["Vector3","toRadians","toDegrees","config","WGS84_CONSTANTS","identity","x","scratchVector","fromCartographic","cartographic","result","arguments","length","undefined","map","longitude","latitude","height","y","z","fromCartographicToRadians","vector","_cartographicRadians","fromCartographicToDegrees","toCartographic","toCartographicFromRadians","toCartographicFromDegrees","isWGS84","from","oneOverRadiiSquared","centerToleranceSquared","x2","y2","z2","Math","abs"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@math.gl/geospatial/src/type-utils.ts"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport type {NumericArray} from '@math.gl/core';\nimport {Vector3, toRadians, toDegrees, config} from '@math.gl/core';\nimport {WGS84_CONSTANTS} from './constants';\n\ntype LngLatHeightObject = {\n  longitude: number;\n  latitude: number;\n  height: number;\n};\n\ntype XYZObject = {\n  x: number;\n  y: number;\n  z: number;\n};\n\ntype Cartographic = LngLatHeightObject | XYZObject | NumericArray;\n\nfunction identity(x: number): number {\n  return x;\n}\n\nconst scratchVector = new Vector3();\n\nexport function fromCartographic(cartographic: Cartographic): number[];\nexport function fromCartographic<NumArrayT>(\n  cartographic: Cartographic,\n  result: NumArrayT,\n  map?: (x: number) => number\n): NumArrayT;\nexport function fromCartographic(\n  cartographic: Cartographic,\n  result = [] as number[],\n  map = identity\n): number[] {\n  if ('longitude' in cartographic) {\n    result[0] = map(cartographic.longitude);\n    result[1] = map(cartographic.latitude);\n    result[2] = cartographic.height;\n  } else if ('x' in cartographic) {\n    result[0] = map(cartographic.x);\n    result[1] = map(cartographic.y);\n    result[2] = cartographic.z;\n  } else {\n    result[0] = map(cartographic[0]);\n    result[1] = map(cartographic[1]);\n    result[2] = cartographic[2];\n  }\n  return result;\n}\n\nexport function fromCartographicToRadians(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToRadians<TArray>(\n  cartographic: Cartographic,\n  result: TArray\n): TArray;\nexport function fromCartographicToRadians(\n  cartographic: Cartographic,\n  vector = [] as number[]\n): number[] {\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? identity : toRadians);\n}\n\nexport function fromCartographicToDegrees(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToDegrees<TArray>(\n  cartographic: Cartographic,\n  result: TArray\n): TArray;\nexport function fromCartographicToDegrees(\n  cartographic: Cartographic,\n  vector = [] as number[]\n): number[] {\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? toDegrees : identity);\n}\n\nexport function toCartographic<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T,\n  map: (x: number) => number = identity\n): T {\n  if ('longitude' in cartographic) {\n    cartographic.longitude = map(vector[0]);\n    cartographic.latitude = map(vector[1]);\n    cartographic.height = vector[2];\n  } else if ('x' in cartographic) {\n    cartographic.x = map(vector[0]);\n    cartographic.y = map(vector[1]);\n    cartographic.z = vector[2];\n  } else {\n    cartographic[0] = map(vector[0]);\n    cartographic[1] = map(vector[1]);\n    cartographic[2] = vector[2];\n  }\n  return cartographic;\n}\n\nexport function toCartographicFromRadians<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T\n): T {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? identity : toDegrees);\n}\n\nexport function toCartographicFromDegrees<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T\n): T {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? toRadians : identity);\n}\n\n// Estimates if a vector is close to the surface of the WGS84 Ellipsoid\nexport function isWGS84(vector: Readonly<NumericArray>): boolean {\n  if (!vector) {\n    return false;\n  }\n  scratchVector.from(vector);\n  const {oneOverRadiiSquared, centerToleranceSquared} = WGS84_CONSTANTS;\n  const x2 = vector[0] * vector[0] * oneOverRadiiSquared[0];\n  const y2 = vector[1] * vector[1] * oneOverRadiiSquared[1];\n  const z2 = vector[2] * vector[2] * oneOverRadiiSquared[2];\n  return Math.abs(x2 + y2 + z2 - 1) < centerToleranceSquared;\n}\n\n/*\n\nexport function fromCartographic(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographic(cartographic: Cartographic, result: TypedArray): TypedArray;\nexport function fromCartographicToRadians(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToRadians(\n  cartographic: Cartographic,\n  result: TypedArray\n): TypedArray;\nexport function fromCartographicToDegrees(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToDegrees(\n  cartographic: Cartographic,\n  result: TypedArray\n): TypedArray;\n\nexport function toCartographic(vector: number[] | TypedArray, result: Cartographic): number[];\nexport function toCartographicFromRadians(\n  vector: number[] | TypedArray,\n  result: Cartographic\n): number[];\nexport function toCartographicFromDegrees(\n  vector: number[] | TypedArray,\n  result: Cartographic\n): number[];\n\n// Estimates if a vector is close to the surface of the WGS84 Ellipsoid\nexport function isWGS84(vector: number[] | TypedArray): boolean;\n*/\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}