{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getValueFunc = getValueFunc;\nexports.getScaleFunctor = getScaleFunctor;\nexports.getGetValue = getGetValue;\nexports.getDimensionSortedBins = getDimensionSortedBins;\nexports.getDimensionValueDomain = getDimensionValueDomain;\nexports.getDimensionScale = getDimensionScale;\nexports.getAggregatedData = getAggregatedData;\nexports[\"default\"] = exports.defaultDimensions = exports.defaultElevationDimension = exports.defaultColorDimension = exports.defaultAggregation = exports.DECK_AGGREGATION_MAP = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _aggregationLayers = require(\"@deck.gl/aggregation-layers\");\nvar _window = require(\"global/window\");\nvar _utils = require(\"@kepler.gl/utils\");\nvar _constants = require(\"@kepler.gl/constants\");\nvar _DECK_AGGREGATION_MAP;\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar DECK_AGGREGATION_MAP = (_DECK_AGGREGATION_MAP = {}, (0, _defineProperty2[\"default\"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.SUM, _constants.AGGREGATION_TYPES.sum), (0, _defineProperty2[\"default\"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.MEAN, _constants.AGGREGATION_TYPES.average), (0, _defineProperty2[\"default\"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.MIN, _constants.AGGREGATION_TYPES.minimum), (0, _defineProperty2[\"default\"])(_DECK_AGGREGATION_MAP, _aggregationLayers.AGGREGATION_OPERATION.MAX, _constants.AGGREGATION_TYPES.maximum), _DECK_AGGREGATION_MAP);\nexports.DECK_AGGREGATION_MAP = DECK_AGGREGATION_MAP;\nfunction getValueFunc(aggregation, accessor) {\n  if (!aggregation || !_aggregationLayers.AGGREGATION_OPERATION[aggregation.toUpperCase()]) {\n    _window.console.warn(\"Aggregation \".concat(aggregation, \" is not supported\"));\n  }\n  var op = _aggregationLayers.AGGREGATION_OPERATION[aggregation.toUpperCase()] || _aggregationLayers.AGGREGATION_OPERATION.SUM;\n  var keplerOp = DECK_AGGREGATION_MAP[op];\n  return function (pts) {\n    return (0, _utils.aggregate)(pts.map(accessor), keplerOp);\n  };\n}\nfunction getScaleFunctor(scaleType) {\n  if (!scaleType || !_constants.SCALE_FUNC[scaleType]) {\n    _window.console.warn(\"Scale \".concat(scaleType, \" is not supported\"));\n  }\n  return _constants.SCALE_FUNC[scaleType] || _constants.SCALE_FUNC.quantize;\n}\nfunction nop() {}\nfunction getGetValue(step, props, dimensionUpdater) {\n  var key = dimensionUpdater.key;\n  var _step$triggers = step.triggers,\n    value = _step$triggers.value,\n    weight = _step$triggers.weight,\n    aggregation = _step$triggers.aggregation;\n  var getValue = props[value.prop];\n  if (getValue === null) {\n    // If `getValue` is not provided from props, build it with aggregation and weight.\n    getValue = getValueFunc(props[aggregation.prop], props[weight.prop]);\n  }\n  if (getValue) {\n    this._setDimensionState(key, {\n      getValue: getValue\n    });\n  }\n}\nfunction getDimensionSortedBins(step, props, dimensionUpdater) {\n  var key = dimensionUpdater.key;\n  var getValue = this.state.dimensions[key].getValue; // @ts-expect-error\n\n  var sortedBins = new _aggregationLayers._BinSorter(this.state.layerData.data || [], {\n    getValue: getValue,\n    filterData: props._filterData\n  });\n  this._setDimensionState(key, {\n    sortedBins: sortedBins\n  });\n}\nfunction getDimensionValueDomain(step, props, dimensionUpdater) {\n  var key = dimensionUpdater.key;\n  var _step$triggers2 = step.triggers,\n    lowerPercentile = _step$triggers2.lowerPercentile,\n    upperPercentile = _step$triggers2.upperPercentile,\n    scaleType = _step$triggers2.scaleType;\n  if (!this.state.dimensions[key].sortedBins) {\n    // the previous step should set sortedBins, if not, something went wrong\n    return;\n  } // for log and sqrt scale, returns linear domain by default\n  // TODO: support other scale function domain in bin sorter\n\n  var valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);\n  this._setDimensionState(key, {\n    valueDomain: valueDomain\n  });\n}\nfunction getDimensionScale(step, props, dimensionUpdater) {\n  var key = dimensionUpdater.key;\n  var _step$triggers3 = step.triggers,\n    domain = _step$triggers3.domain,\n    range = _step$triggers3.range,\n    scaleType = _step$triggers3.scaleType;\n  var onSet = step.onSet;\n  if (!this.state.dimensions[key].valueDomain) {\n    // the previous step should set valueDomain, if not, something went wrong\n    return;\n  }\n  var dimensionRange = props[range.prop];\n  var dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n  var scaleFunctor = getScaleFunctor(scaleType && props[scaleType.prop])();\n  var scaleFunc = scaleFunctor.domain(dimensionDomain).range(dimensionRange);\n  if ((0, _typeof2[\"default\"])(onSet) === 'object' && typeof props[onSet.props] === 'function') {\n    props[onSet.props](scaleFunc.domain());\n  }\n  this._setDimensionState(key, {\n    scaleFunc: scaleFunc\n  });\n}\nfunction normalizeResult() {\n  var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  // support previous hexagonAggregator API\n  if (result.hexagons) {\n    return Object.assign({\n      data: result.hexagons\n    }, result);\n  } else if (result.layerData) {\n    return Object.assign({\n      data: result.layerData\n    }, result);\n  }\n  return result;\n}\nfunction getAggregatedData(step, props, aggregation, aggregationParams) {\n  var aggr = step.triggers.aggregator;\n  var aggregator = props[aggr.prop]; // result should contain a data array and other props\n  // result = {data: [], ...other props}\n\n  var result = aggregator(props, aggregationParams);\n  this.setState({\n    layerData: normalizeResult(result)\n  });\n}\nvar defaultAggregation = {\n  key: 'position',\n  updateSteps: [{\n    key: 'aggregate',\n    triggers: {\n      cellSize: {\n        prop: 'cellSize'\n      },\n      position: {\n        prop: 'getPosition',\n        updateTrigger: 'getPosition'\n      },\n      aggregator: {\n        prop: 'gridAggregator'\n      }\n    },\n    updater: getAggregatedData\n  }]\n};\nexports.defaultAggregation = defaultAggregation;\nfunction getSubLayerAccessor(dimensionState, dimension, layerProps) {\n  return function (cell) {\n    var sortedBins = dimensionState.sortedBins,\n      scaleFunc = dimensionState.scaleFunc;\n    var bin = sortedBins.binMap[cell.index];\n    if (bin && bin.counts === 0) {\n      // no points left in bin after filtering\n      return dimension.nullValue;\n    }\n    var cv = bin && bin.value;\n    var domain = scaleFunc.domain();\n    var isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1]; // if cell value is outside domain, set alpha to 0\n\n    return isValueInDomain ? scaleFunc(cv) : dimension.nullValue;\n  };\n}\nvar defaultColorDimension = {\n  key: 'fillColor',\n  accessor: 'getFillColor',\n  getPickingInfo: function getPickingInfo(dimensionState, cell) {\n    if (!cell) {\n      return {};\n    }\n    var sortedBins = dimensionState.sortedBins;\n    var colorValue = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n    return {\n      colorValue: colorValue\n    };\n  },\n  nullValue: [0, 0, 0, 0],\n  updateSteps: [{\n    key: 'getValue',\n    triggers: {\n      value: {\n        prop: 'getColorValue',\n        updateTrigger: 'getColorValue'\n      },\n      weight: {\n        prop: 'getColorWeight',\n        updateTrigger: 'getColorWeight'\n      },\n      aggregation: {\n        prop: 'colorAggregation'\n      }\n    },\n    updater: getGetValue\n  }, {\n    key: 'getBins',\n    triggers: {\n      _filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    },\n    updater: getDimensionSortedBins\n  }, {\n    key: 'getDomain',\n    triggers: {\n      lowerPercentile: {\n        prop: 'lowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'upperPercentile'\n      },\n      scaleType: {\n        prop: 'colorScaleType'\n      }\n    },\n    updater: getDimensionValueDomain\n  }, {\n    key: 'getScaleFunc',\n    triggers: {\n      domain: {\n        prop: 'colorDomain'\n      },\n      range: {\n        prop: 'colorRange'\n      },\n      scaleType: {\n        prop: 'colorScaleType'\n      }\n    },\n    onSet: {\n      props: 'onSetColorDomain'\n    },\n    updater: getDimensionScale\n  }],\n  getSubLayerAccessor: getSubLayerAccessor\n};\nexports.defaultColorDimension = defaultColorDimension;\nvar defaultElevationDimension = {\n  key: 'elevation',\n  accessor: 'getElevation',\n  getPickingInfo: function getPickingInfo(dimensionState, cell) {\n    if (!cell) {\n      return {};\n    }\n    var sortedBins = dimensionState.sortedBins;\n    var elevationValue = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n    return {\n      elevationValue: elevationValue\n    };\n  },\n  nullValue: -1,\n  updateSteps: [{\n    key: 'getValue',\n    triggers: {\n      value: {\n        prop: 'getElevationValue',\n        updateTrigger: 'getElevationValue'\n      },\n      weight: {\n        prop: 'getElevationWeight',\n        updateTrigger: 'getElevationWeight'\n      },\n      aggregation: {\n        prop: 'elevationAggregation'\n      }\n    },\n    updater: getGetValue\n  }, {\n    key: 'getBins',\n    triggers: {\n      _filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    },\n    updater: getDimensionSortedBins\n  }, {\n    key: 'getDomain',\n    triggers: {\n      lowerPercentile: {\n        prop: 'elevationLowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'elevationUpperPercentile'\n      },\n      scaleType: {\n        prop: 'elevationScaleType'\n      }\n    },\n    updater: getDimensionValueDomain\n  }, {\n    key: 'getScaleFunc',\n    triggers: {\n      domain: {\n        prop: 'elevationDomain'\n      },\n      range: {\n        prop: 'elevationRange'\n      },\n      scaleType: {\n        prop: 'elevationScaleType'\n      }\n    },\n    onSet: {\n      props: 'onSetElevationDomain'\n    },\n    updater: getDimensionScale\n  }],\n  getSubLayerAccessor: getSubLayerAccessor\n};\nexports.defaultElevationDimension = defaultElevationDimension;\nvar _defaultDimensions = [defaultColorDimension, defaultElevationDimension];\nexports.defaultDimensions = _defaultDimensions;\nvar CPUAggregator = /*#__PURE__*/function () {\n  function CPUAggregator() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0, _classCallCheck2[\"default\"])(this, CPUAggregator);\n    this.state = _objectSpread({\n      layerData: {},\n      dimensions: {// color: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // },\n        // elevation: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // }\n      }\n    }, opts.initialState);\n    this.dimensionUpdaters = {};\n    this.aggregationUpdater = opts.aggregation || defaultAggregation;\n    this._addDimension(opts.dimensions || _defaultDimensions);\n  }\n  (0, _createClass2[\"default\"])(CPUAggregator, [{\n    key: \"updateAllDimensions\",\n    value: function updateAllDimensions(props) {\n      var dimensionChanges = []; // update all dimensions\n\n      for (var dim in this.dimensionUpdaters) {\n        var updaters = this._accumulateUpdaters(0, props, this.dimensionUpdaters[dim]);\n        dimensionChanges = dimensionChanges.concat(updaters);\n      }\n      dimensionChanges.forEach(function (f) {\n        return typeof f === 'function' && f();\n      });\n    }\n  }, {\n    key: \"updateAggregation\",\n    value: function updateAggregation(props, aggregationParams) {\n      var updaters = this._accumulateUpdaters(0, props, this.aggregationUpdater);\n      updaters.forEach(function (f) {\n        return typeof f === 'function' && f(aggregationParams);\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts, aggregationParams) {\n      var oldProps = opts.oldProps,\n        props = opts.props,\n        changeFlags = opts.changeFlags;\n      var dimensionChanges = [];\n      if (changeFlags.dataChanged) {\n        // if data changed update everything\n        this.updateAggregation(props, aggregationParams);\n        this.updateAllDimensions(props);\n        return this.state;\n      }\n      var aggregationChanges = this._getAggregationChanges(oldProps, props, changeFlags);\n      if (aggregationChanges && aggregationChanges.length) {\n        // get aggregatedData\n        aggregationChanges.forEach(function (f) {\n          return typeof f === 'function' && f(aggregationParams);\n        });\n        this.updateAllDimensions(props);\n      } else {\n        // only update dimensions\n        dimensionChanges = this._getDimensionChanges(oldProps, props, changeFlags) || [];\n        dimensionChanges.forEach(function (f) {\n          return typeof f === 'function' && f();\n        });\n      }\n      return this.state;\n    } // Update private state\n  }, {\n    key: \"setState\",\n    value: function setState(updateObject) {\n      this.state = Object.assign({}, this.state, updateObject);\n    } // Update private state.dimensions\n  }, {\n    key: \"_setDimensionState\",\n    value: function _setDimensionState(key, updateObject) {\n      this.setState({\n        dimensions: Object.assign({}, this.state.dimensions, (0, _defineProperty2[\"default\"])({}, key, Object.assign({}, this.state.dimensions[key], updateObject)))\n      });\n    }\n  }, {\n    key: \"_addAggregation\",\n    value: function _addAggregation(aggregation) {\n      this.aggregationUpdater = aggregation;\n    }\n  }, {\n    key: \"_addDimension\",\n    value: function _addDimension() {\n      var _this = this;\n      var dimensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      dimensions.forEach(function (dimension) {\n        var key = dimension.key;\n        _this.dimensionUpdaters[key] = dimension;\n      });\n    }\n  }, {\n    key: \"_needUpdateStep\",\n    value: function _needUpdateStep(dimensionStep, oldProps, props, changeFlags) {\n      // whether need to update current dimension step\n      // dimension step is the value, domain, scaleFunction of each dimension\n      // each step is an object with properties links to layer prop and whether the prop is\n      // controlled by updateTriggers\n      return Object.values(dimensionStep.triggers).some(function (item) {\n        if (item.updateTrigger) {\n          // check based on updateTriggers change first\n          return changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);\n        } // fallback to direct comparison\n\n        return oldProps[item.prop] !== props[item.prop];\n      });\n    }\n  }, {\n    key: \"_accumulateUpdaters\",\n    value: function _accumulateUpdaters(step, props, dimension) {\n      var updaters = [];\n      for (var i = step; i < dimension.updateSteps.length; i++) {\n        var updater = dimension.updateSteps[i].updater;\n        if (typeof updater === 'function') {\n          updaters.push(updater.bind(this, dimension.updateSteps[i], props, dimension));\n        }\n      }\n      return updaters;\n    }\n  }, {\n    key: \"_getAllUpdaters\",\n    value: function _getAllUpdaters(dimension, oldProps, props, changeFlags) {\n      var _this2 = this;\n      var updaters = [];\n      var needUpdateStep = dimension.updateSteps.findIndex(function (step) {\n        return _this2._needUpdateStep(step, oldProps, props, changeFlags);\n      });\n      if (needUpdateStep > -1) {\n        updaters = updaters.concat(this._accumulateUpdaters(needUpdateStep, props, dimension));\n      }\n      return updaters;\n    }\n  }, {\n    key: \"_getAggregationChanges\",\n    value: function _getAggregationChanges(oldProps, props, changeFlags) {\n      var updaters = this._getAllUpdaters(this.aggregationUpdater, oldProps, props, changeFlags);\n      return updaters.length ? updaters : null;\n    }\n  }, {\n    key: \"_getDimensionChanges\",\n    value: function _getDimensionChanges(oldProps, props, changeFlags) {\n      var updaters = []; // get dimension to be updated\n\n      for (var _key in this.dimensionUpdaters) {\n        // return the first triggered updater for each dimension\n        var dimension = this.dimensionUpdaters[_key];\n        var dimensionUpdaters = this._getAllUpdaters(dimension, oldProps, props, changeFlags);\n        updaters = updaters.concat(dimensionUpdaters);\n      }\n      return updaters.length ? updaters : null;\n    }\n  }, {\n    key: \"getUpdateTriggers\",\n    value: function getUpdateTriggers(props) {\n      var _this3 = this;\n      var _updateTriggers = props.updateTriggers || {};\n      var updateTriggers = {};\n      var _loop = function _loop(_key2) {\n        var _this3$dimensionUpdat = _this3.dimensionUpdaters[_key2],\n          accessor = _this3$dimensionUpdat.accessor,\n          updateSteps = _this3$dimensionUpdat.updateSteps; // fold dimension triggers into each accessor\n\n        updateTriggers[accessor] = {};\n        updateSteps.forEach(function (step) {\n          Object.values(step.triggers || []).forEach(function (_ref) {\n            var prop = _ref.prop,\n              updateTrigger = _ref.updateTrigger;\n            if (updateTrigger) {\n              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n              // and updateTriggers is passed in from layer prop\n              // fold the updateTriggers into accessor\n              var fromProp = _updateTriggers[updateTrigger];\n              if ((0, _typeof2[\"default\"])(fromProp) === 'object' && !Array.isArray(fromProp)) {\n                // if updateTrigger is an object spread it\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              // if prop is not based on updateTrigger\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          });\n        });\n      };\n      for (var _key2 in this.dimensionUpdaters) {\n        _loop(_key2);\n      }\n      return updateTriggers;\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref2, layerProps) {\n      var info = _ref2.info;\n      var isPicked = info.picked && info.index > -1;\n      var object = null;\n      var cell = isPicked ? this.state.layerData.data[info.index] : null;\n      if (cell) {\n        var binInfo = {};\n        for (var _key3 in this.dimensionUpdaters) {\n          var getPickingInfo = this.dimensionUpdaters[_key3].getPickingInfo;\n          if (typeof getPickingInfo === 'function') {\n            binInfo = Object.assign({}, binInfo, getPickingInfo(this.state.dimensions[_key3], cell, layerProps));\n          }\n        }\n        object = Object.assign(binInfo, cell, {\n          points: cell.filteredPoints || cell.points\n        });\n      } // add bin  and  to info\n\n      return Object.assign(info, {\n        picked: Boolean(object),\n        // override object with picked cell\n        object: object\n      });\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor(dimensionKey, layerProps) {\n      if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n        return nop;\n      }\n      return this.dimensionUpdaters[dimensionKey].getSubLayerAccessor(this.state.dimensions[dimensionKey], this.dimensionUpdaters[dimensionKey], layerProps);\n    }\n  }], [{\n    key: \"defaultDimensions\",\n    value: function defaultDimensions() {\n      return _defaultDimensions;\n    }\n  }]);\n  return CPUAggregator;\n}();\nexports[\"default\"] = CPUAggregator;\nCPUAggregator.getDimensionScale = getDimensionScale;","map":{"version":3,"names":["Object","defineProperty","exports","getScaleFunctor","getDimensionSortedBins","_createClass2","_interopRequireDefault","require","_defineProperty2","_aggregationLayers","_window","_utils","_constants","_DECK_AGGREGATION_MAP","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","DECK_AGGREGATION_MAP","aggregation","AGGREGATION_OPERATION","toUpperCase","op","SUM","keplerOp","pts","aggregate","map","accessor","scaleType","SCALE_FUNC","quantize","nop","getGetValue","step","props","dimensionUpdater","_step$triggers","triggers","weight","getValue","value","prop","getValueFunc","_setDimensionState","state","dimensions","sortedBins","_BinSorter","layerData","data","_step$triggers2","lowerPercentile","upperPercentile","valueDomain","getValueDomainByScale","getDimensionScale","_step$triggers3","domain","range","dimensionRange","dimensionDomain","scaleFunctor","scaleFunc","_typeof2","onSet","normalizeResult","result","hexagons","assign","getAggregatedData","aggregationParams","aggr","aggregator","setState","updateSteps","cellSize","position","updateTrigger","updater","getSubLayerAccessor","dimensionState","dimension","layerProps","cell","bin","binMap","index","nullValue","cv","isValueInDomain","defaultColorDimension","getPickingInfo","colorValue","_filterData","getDimensionValueDomain","defaultElevationDimension","elevationValue","_defaultDimensions","defaultDimensions","CPUAggregator","_classCallCheck2","opts","initialState","dimensionUpdaters","updateAllDimensions","dimensionChanges","updaters","_accumulateUpdaters","dim","concat","f","updateAggregation","updateState","oldProps","changeFlags","dataChanged","aggregationChanges","_getDimensionChanges","updateObject","_addAggregation","aggregationUpdater","_addDimension","undefined","_needUpdateStep","dimensionStep","values","some","item","updateTriggersChanged","all","bind","_getAllUpdaters","needUpdateStep","findIndex","_getAggregationChanges","_key","getUpdateTriggers","_this3","updateTriggers","_loop","_key2","_this3$dimensionUpdat","_ref","fromProp","_updateTriggers","_ref2","isPicked","info","binInfo","_key3"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/deckgl-layers/src/layer-utils/cpu-aggregator.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable guard-for-in */\nimport {AGGREGATION_OPERATION, _BinSorter as BinSorter} from '@deck.gl/aggregation-layers';\nimport {console as Console} from 'global/window';\n\nimport {aggregate} from '@kepler.gl/utils';\nimport {AGGREGATION_TYPES, SCALE_FUNC} from '@kepler.gl/constants';\nimport {RGBAColor} from '@kepler.gl/types';\n\nexport type UpdaterType = (this: CPUAggregator, step, props, dimensionUpdater) => void;\nexport type BindedUpdaterType = () => void;\nexport type AggregatedUpdaterType = (\n  this: CPUAggregator,\n  step,\n  props,\n  aggregation,\n  aggregationParams\n) => void;\nexport type BindedAggregatedUpdaterType = (aggregationParams) => void;\n\nexport type UpdateStepsType = {\n  key: string;\n  triggers: {\n    [key: string]: {\n      prop: string;\n      updateTrigger?: string;\n    };\n  };\n  onSet?: {\n    props: string;\n  };\n  updater: UpdaterType;\n};\n\nexport type DimensionType<ValueType = any> = {\n  key: string;\n  accessor: string;\n  getPickingInfo: (dimensionState, cell, layerProps?) => any;\n  nullValue: ValueType;\n  updateSteps: UpdateStepsType[];\n  getSubLayerAccessor;\n};\n\nexport type AggregationUpdateStepsType = {\n  key: string;\n  triggers: {\n    [key: string]: {\n      prop: string;\n      updateTrigger?: string;\n    };\n  };\n  updater: AggregatedUpdaterType;\n};\n\nexport type AggregationType = {\n  key: string;\n  updateSteps: AggregationUpdateStepsType[];\n};\n\nexport const DECK_AGGREGATION_MAP = {\n  [AGGREGATION_OPERATION.SUM]: AGGREGATION_TYPES.sum,\n  [AGGREGATION_OPERATION.MEAN]: AGGREGATION_TYPES.average,\n  [AGGREGATION_OPERATION.MIN]: AGGREGATION_TYPES.minimum,\n  [AGGREGATION_OPERATION.MAX]: AGGREGATION_TYPES.maximum\n};\n\nexport function getValueFunc(aggregation, accessor) {\n  if (!aggregation || !AGGREGATION_OPERATION[aggregation.toUpperCase()]) {\n    Console.warn(`Aggregation ${aggregation} is not supported`);\n  }\n\n  const op = AGGREGATION_OPERATION[aggregation.toUpperCase()] || AGGREGATION_OPERATION.SUM;\n  const keplerOp = DECK_AGGREGATION_MAP[op];\n\n  return pts => aggregate(pts.map(accessor), keplerOp);\n}\n\nexport function getScaleFunctor(scaleType) {\n  if (!scaleType || !SCALE_FUNC[scaleType]) {\n    Console.warn(`Scale ${scaleType} is not supported`);\n  }\n  return SCALE_FUNC[scaleType] || SCALE_FUNC.quantize;\n}\n\nfunction nop() {}\n\nexport function getGetValue(this: CPUAggregator, step, props, dimensionUpdater) {\n  const {key} = dimensionUpdater;\n  const {value, weight, aggregation} = step.triggers;\n\n  let getValue = props[value.prop];\n\n  if (getValue === null) {\n    // If `getValue` is not provided from props, build it with aggregation and weight.\n    getValue = getValueFunc(props[aggregation.prop], props[weight.prop]);\n  }\n\n  if (getValue) {\n    this._setDimensionState(key, {getValue});\n  }\n}\n\nexport function getDimensionSortedBins(this: CPUAggregator, step, props, dimensionUpdater) {\n  const {key} = dimensionUpdater;\n  const {getValue} = this.state.dimensions[key];\n  // @ts-expect-error\n  const sortedBins = new BinSorter(this.state.layerData.data || [], {\n    getValue,\n    filterData: props._filterData\n  });\n  this._setDimensionState(key, {sortedBins});\n}\n\nexport function getDimensionValueDomain(this: CPUAggregator, step, props, dimensionUpdater) {\n  const {key} = dimensionUpdater;\n  const {\n    triggers: {lowerPercentile, upperPercentile, scaleType}\n  } = step;\n\n  if (!this.state.dimensions[key].sortedBins) {\n    // the previous step should set sortedBins, if not, something went wrong\n    return;\n  }\n\n  // for log and sqrt scale, returns linear domain by default\n  // TODO: support other scale function domain in bin sorter\n  const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(\n    props[scaleType.prop],\n    [props[lowerPercentile.prop], props[upperPercentile.prop]]\n  );\n\n  this._setDimensionState(key, {valueDomain});\n}\n\nexport function getDimensionScale(this: CPUAggregator, step, props, dimensionUpdater) {\n  const {key} = dimensionUpdater;\n  const {domain, range, scaleType} = step.triggers;\n  const {onSet} = step;\n  if (!this.state.dimensions[key].valueDomain) {\n    // the previous step should set valueDomain, if not, something went wrong\n    return;\n  }\n\n  const dimensionRange = props[range.prop];\n  const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n\n  const scaleFunctor = getScaleFunctor(scaleType && props[scaleType.prop])();\n\n  const scaleFunc = scaleFunctor.domain(dimensionDomain).range(dimensionRange);\n\n  if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n    props[onSet.props](scaleFunc.domain());\n  }\n  this._setDimensionState(key, {scaleFunc});\n}\n\nfunction normalizeResult(result: {hexagons?; layerData?} = {}) {\n  // support previous hexagonAggregator API\n  if (result.hexagons) {\n    return Object.assign({data: result.hexagons}, result);\n  } else if (result.layerData) {\n    return Object.assign({data: result.layerData}, result);\n  }\n\n  return result;\n}\n\nexport function getAggregatedData(\n  this: CPUAggregator,\n  step,\n  props,\n  aggregation,\n  aggregationParams\n) {\n  const {\n    triggers: {aggregator: aggr}\n  } = step;\n  const aggregator = props[aggr.prop];\n\n  // result should contain a data array and other props\n  // result = {data: [], ...other props}\n  const result = aggregator(props, aggregationParams);\n  this.setState({\n    layerData: normalizeResult(result)\n  });\n}\n\nexport const defaultAggregation: AggregationType = {\n  key: 'position',\n  updateSteps: [\n    {\n      key: 'aggregate',\n      triggers: {\n        cellSize: {\n          prop: 'cellSize'\n        },\n        position: {\n          prop: 'getPosition',\n          updateTrigger: 'getPosition'\n        },\n        aggregator: {\n          prop: 'gridAggregator'\n        }\n      },\n      updater: getAggregatedData\n    }\n  ]\n};\n\nfunction getSubLayerAccessor(dimensionState, dimension, layerProps) {\n  return cell => {\n    const {sortedBins, scaleFunc} = dimensionState;\n    const bin = sortedBins.binMap[cell.index];\n\n    if (bin && bin.counts === 0) {\n      // no points left in bin after filtering\n      return dimension.nullValue;\n    }\n\n    const cv = bin && bin.value;\n    const domain = scaleFunc.domain();\n\n    const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n\n    // if cell value is outside domain, set alpha to 0\n    return isValueInDomain ? scaleFunc(cv) : dimension.nullValue;\n  };\n}\n\nexport const defaultColorDimension: DimensionType<RGBAColor> = {\n  key: 'fillColor',\n  accessor: 'getFillColor',\n  getPickingInfo: (dimensionState, cell) => {\n    if (!cell) {\n      return {};\n    }\n    const {sortedBins} = dimensionState;\n    const colorValue = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n    return {colorValue};\n  },\n  nullValue: [0, 0, 0, 0],\n  updateSteps: [\n    {\n      key: 'getValue',\n      triggers: {\n        value: {\n          prop: 'getColorValue',\n          updateTrigger: 'getColorValue'\n        },\n        weight: {\n          prop: 'getColorWeight',\n          updateTrigger: 'getColorWeight'\n        },\n        aggregation: {\n          prop: 'colorAggregation'\n        }\n      },\n      updater: getGetValue\n    },\n    {\n      key: 'getBins',\n      triggers: {\n        _filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      },\n      updater: getDimensionSortedBins\n    },\n    {\n      key: 'getDomain',\n      triggers: {\n        lowerPercentile: {\n          prop: 'lowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'upperPercentile'\n        },\n        scaleType: {prop: 'colorScaleType'}\n      },\n      updater: getDimensionValueDomain\n    },\n    {\n      key: 'getScaleFunc',\n      triggers: {\n        domain: {prop: 'colorDomain'},\n        range: {prop: 'colorRange'},\n        scaleType: {prop: 'colorScaleType'}\n      },\n      onSet: {\n        props: 'onSetColorDomain'\n      },\n      updater: getDimensionScale\n    }\n  ],\n  getSubLayerAccessor\n};\n\nexport const defaultElevationDimension: DimensionType<number> = {\n  key: 'elevation',\n  accessor: 'getElevation',\n  getPickingInfo: (dimensionState, cell) => {\n    if (!cell) {\n      return {};\n    }\n    const {sortedBins} = dimensionState;\n    const elevationValue = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n    return {elevationValue};\n  },\n  nullValue: -1,\n  updateSteps: [\n    {\n      key: 'getValue',\n      triggers: {\n        value: {\n          prop: 'getElevationValue',\n          updateTrigger: 'getElevationValue'\n        },\n        weight: {\n          prop: 'getElevationWeight',\n          updateTrigger: 'getElevationWeight'\n        },\n        aggregation: {\n          prop: 'elevationAggregation'\n        }\n      },\n      updater: getGetValue\n    },\n    {\n      key: 'getBins',\n      triggers: {\n        _filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      },\n      updater: getDimensionSortedBins\n    },\n    {\n      key: 'getDomain',\n      triggers: {\n        lowerPercentile: {\n          prop: 'elevationLowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'elevationUpperPercentile'\n        },\n        scaleType: {prop: 'elevationScaleType'}\n      },\n      updater: getDimensionValueDomain\n    },\n    {\n      key: 'getScaleFunc',\n      triggers: {\n        domain: {prop: 'elevationDomain'},\n        range: {prop: 'elevationRange'},\n        scaleType: {prop: 'elevationScaleType'}\n      },\n      onSet: {\n        props: 'onSetElevationDomain'\n      },\n      updater: getDimensionScale\n    }\n  ],\n  getSubLayerAccessor\n};\n\nexport const defaultDimensions = [defaultColorDimension, defaultElevationDimension];\n\nexport type CPUAggregatorState = {layerData: {data?}; dimensions: {}; geoJSON?; clusterBuilder?};\n\nexport default class CPUAggregator {\n  static getDimensionScale: any;\n  state: CPUAggregatorState;\n  dimensionUpdaters: {[key: string]: DimensionType};\n  aggregationUpdater: AggregationType;\n\n  constructor(\n    opts: {\n      initialState?: CPUAggregatorState;\n      dimensions?: DimensionType[];\n      aggregation?: AggregationType;\n    } = {}\n  ) {\n    this.state = {\n      layerData: {},\n      dimensions: {\n        // color: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // },\n        // elevation: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // }\n      },\n      ...opts.initialState\n    };\n\n    this.dimensionUpdaters = {};\n    this.aggregationUpdater = opts.aggregation || defaultAggregation;\n\n    this._addDimension(opts.dimensions || defaultDimensions);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateAllDimensions(props) {\n    let dimensionChanges: BindedUpdaterType[] = [];\n    // update all dimensions\n    for (const dim in this.dimensionUpdaters) {\n      const updaters = this._accumulateUpdaters(0, props, this.dimensionUpdaters[dim]);\n      dimensionChanges = dimensionChanges.concat(updaters);\n    }\n\n    dimensionChanges.forEach(f => typeof f === 'function' && f());\n  }\n\n  updateAggregation(props, aggregationParams) {\n    const updaters = this._accumulateUpdaters(0, props, this.aggregationUpdater);\n    updaters.forEach(f => typeof f === 'function' && f(aggregationParams));\n  }\n\n  updateState(opts, aggregationParams) {\n    const {oldProps, props, changeFlags} = opts;\n    let dimensionChanges: BindedUpdaterType[] = [];\n\n    if (changeFlags.dataChanged) {\n      // if data changed update everything\n      this.updateAggregation(props, aggregationParams);\n      this.updateAllDimensions(props);\n\n      return this.state;\n    }\n\n    const aggregationChanges = this._getAggregationChanges(oldProps, props, changeFlags);\n\n    if (aggregationChanges && aggregationChanges.length) {\n      // get aggregatedData\n      aggregationChanges.forEach(f => typeof f === 'function' && f(aggregationParams));\n      this.updateAllDimensions(props);\n    } else {\n      // only update dimensions\n      dimensionChanges = this._getDimensionChanges(oldProps, props, changeFlags) || [];\n      dimensionChanges.forEach(f => typeof f === 'function' && f());\n    }\n\n    return this.state;\n  }\n\n  // Update private state\n  setState(updateObject) {\n    this.state = Object.assign({}, this.state, updateObject);\n  }\n\n  // Update private state.dimensions\n  _setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: Object.assign({}, this.state.dimensions, {\n        [key]: Object.assign({}, this.state.dimensions[key], updateObject)\n      })\n    });\n  }\n\n  _addAggregation(aggregation: AggregationType) {\n    this.aggregationUpdater = aggregation;\n  }\n\n  _addDimension(dimensions: DimensionType[] = []) {\n    dimensions.forEach(dimension => {\n      const {key} = dimension;\n      this.dimensionUpdaters[key] = dimension;\n    });\n  }\n\n  _needUpdateStep(\n    dimensionStep: UpdateStepsType | AggregationUpdateStepsType,\n    oldProps,\n    props,\n    changeFlags\n  ) {\n    // whether need to update current dimension step\n    // dimension step is the value, domain, scaleFunction of each dimension\n    // each step is an object with properties links to layer prop and whether the prop is\n    // controlled by updateTriggers\n    return Object.values(dimensionStep.triggers).some(item => {\n      if (item.updateTrigger) {\n        // check based on updateTriggers change first\n        return (\n          changeFlags.updateTriggersChanged &&\n          (changeFlags.updateTriggersChanged.all ||\n            changeFlags.updateTriggersChanged[item.updateTrigger])\n        );\n      }\n      // fallback to direct comparison\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  _accumulateUpdaters<UpdaterObjectType extends DimensionType | AggregationType>(\n    step,\n    props,\n    dimension: UpdaterObjectType\n  ) {\n    type LocalUpdaterType = UpdaterObjectType extends DimensionType\n      ? BindedUpdaterType\n      : BindedAggregatedUpdaterType;\n    const updaters: LocalUpdaterType[] = [];\n    for (let i = step; i < dimension.updateSteps.length; i++) {\n      const updater = dimension.updateSteps[i].updater;\n      if (typeof updater === 'function') {\n        updaters.push(\n          updater.bind(this, dimension.updateSteps[i], props, dimension) as LocalUpdaterType\n        );\n      }\n    }\n\n    return updaters;\n  }\n\n  _getAllUpdaters<UpdaterObjectType extends DimensionType | AggregationType>(\n    dimension: UpdaterObjectType,\n    oldProps,\n    props,\n    changeFlags\n  ) {\n    type LocalUpdaterType = UpdaterObjectType extends DimensionType\n      ? BindedUpdaterType\n      : BindedAggregatedUpdaterType;\n    let updaters: LocalUpdaterType[] = [];\n    const needUpdateStep = dimension.updateSteps.findIndex(step =>\n      this._needUpdateStep(step, oldProps, props, changeFlags)\n    );\n\n    if (needUpdateStep > -1) {\n      updaters = updaters.concat(this._accumulateUpdaters(needUpdateStep, props, dimension));\n    }\n\n    return updaters;\n  }\n\n  _getAggregationChanges(oldProps, props, changeFlags) {\n    const updaters = this._getAllUpdaters(this.aggregationUpdater, oldProps, props, changeFlags);\n    return updaters.length ? updaters : null;\n  }\n\n  _getDimensionChanges(oldProps, props, changeFlags) {\n    let updaters: BindedUpdaterType[] = [];\n\n    // get dimension to be updated\n    for (const key in this.dimensionUpdaters) {\n      // return the first triggered updater for each dimension\n      const dimension = this.dimensionUpdaters[key];\n      const dimensionUpdaters = this._getAllUpdaters(dimension, oldProps, props, changeFlags);\n      updaters = updaters.concat(dimensionUpdaters);\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {\n        accessor,\n        updateSteps\n      }: {accessor; updateSteps: UpdateStepsType[]} = this.dimensionUpdaters[key];\n      // fold dimension triggers into each accessor\n      updateTriggers[accessor] = {};\n\n      updateSteps.forEach(step => {\n        Object.values(step.triggers || []).forEach(({prop, updateTrigger}) => {\n          if (updateTrigger) {\n            // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n            // and updateTriggers is passed in from layer prop\n            // fold the updateTriggers into accessor\n            const fromProp = _updateTriggers[updateTrigger];\n            if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n              // if updateTrigger is an object spread it\n              Object.assign(updateTriggers[accessor], fromProp);\n            } else if (fromProp !== undefined) {\n              updateTriggers[accessor][prop] = fromProp;\n            }\n          } else {\n            // if prop is not based on updateTrigger\n            updateTriggers[accessor][prop] = props[prop];\n          }\n        });\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getPickingInfo({info}, layerProps) {\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n    const cell = isPicked ? this.state.layerData.data[info.index] : null;\n    if (cell) {\n      let binInfo = {};\n      for (const key in this.dimensionUpdaters) {\n        const {getPickingInfo} = this.dimensionUpdaters[key];\n        if (typeof getPickingInfo === 'function') {\n          binInfo = Object.assign(\n            {},\n            binInfo,\n            getPickingInfo(this.state.dimensions[key], cell, layerProps)\n          );\n        }\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    // add bin  and  to info\n    return Object.assign(info, {\n      picked: Boolean(object),\n      // override object with picked cell\n      object\n    });\n  }\n\n  getAccessor(dimensionKey, layerProps) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n    return this.dimensionUpdaters[dimensionKey].getSubLayerAccessor(\n      this.state.dimensions[dimensionKey],\n      this.dimensionUpdaters[dimensionKey],\n      layerProps\n    );\n  }\n}\n\nCPUAggregator.getDimensionScale = getDimensionScale;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}