{"ast":null,"code":"import _regeneratorRuntime from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\nvar EXT_FEATURE_METADATA = 'EXT_feature_metadata';\nexport var name = EXT_FEATURE_METADATA;\nexport function decode(_x) {\n  return _decode.apply(this, arguments);\n}\nfunction _decode() {\n  _decode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(gltfData) {\n    var scenegraph;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          scenegraph = new GLTFScenegraph(gltfData);\n          decodeExtFeatureMetadata(scenegraph);\n        case 2:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _decode.apply(this, arguments);\n}\nfunction decodeExtFeatureMetadata(scenegraph) {\n  var _extension$schema;\n  var extension = scenegraph.getExtension(EXT_FEATURE_METADATA);\n  var schemaClasses = extension === null || extension === void 0 ? void 0 : (_extension$schema = extension.schema) === null || _extension$schema === void 0 ? void 0 : _extension$schema.classes;\n  var featureTables = extension === null || extension === void 0 ? void 0 : extension.featureTables;\n  var featureTextures = extension === null || extension === void 0 ? void 0 : extension.featureTextures;\n  if (featureTextures) {\n    console.warn('featureTextures is not yet supported in the \"EXT_feature_metadata\" extension.');\n  }\n  if (schemaClasses && featureTables) {\n    for (var schemaName in schemaClasses) {\n      var schemaClass = schemaClasses[schemaName];\n      var featureTable = findFeatureTableByName(featureTables, schemaName);\n      if (featureTable) {\n        handleFeatureTableProperties(scenegraph, featureTable, schemaClass);\n      }\n    }\n  }\n}\nfunction handleFeatureTableProperties(scenegraph, featureTable, schemaClass) {\n  for (var propertyName in schemaClass.properties) {\n    var _featureTable$propert;\n    var schemaProperty = schemaClass.properties[propertyName];\n    var featureTableProperty = featureTable === null || featureTable === void 0 ? void 0 : (_featureTable$propert = featureTable.properties) === null || _featureTable$propert === void 0 ? void 0 : _featureTable$propert[propertyName];\n    var numberOfFeatures = featureTable.count;\n    if (featureTableProperty) {\n      var data = getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty);\n      featureTableProperty.data = data;\n    }\n  }\n}\nfunction getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty) {\n  var bufferView = featureTableProperty.bufferView;\n  var data = scenegraph.getTypedArrayForBufferView(bufferView);\n  switch (schemaProperty.type) {\n    case 'STRING':\n      {\n        var stringOffsetBufferView = featureTableProperty.stringOffsetBufferView;\n        var offsetsData = scenegraph.getTypedArrayForBufferView(stringOffsetBufferView);\n        data = getStringAttributes(data, offsetsData, numberOfFeatures);\n        break;\n      }\n    default:\n  }\n  return data;\n}\nfunction findFeatureTableByName(featureTables, schemaClassName) {\n  for (var featureTableName in featureTables) {\n    var featureTable = featureTables[featureTableName];\n    if (featureTable.class === schemaClassName) {\n      return featureTable;\n    }\n  }\n  return null;\n}\nfunction getStringAttributes(data, offsetsData, stringsCount) {\n  var stringsArray = [];\n  var textDecoder = new TextDecoder('utf8');\n  var stringOffset = 0;\n  var bytesPerStringSize = 4;\n  for (var index = 0; index < stringsCount; index++) {\n    var stringByteSize = offsetsData[(index + 1) * bytesPerStringSize] - offsetsData[index * bytesPerStringSize];\n    var stringData = data.subarray(stringOffset, stringByteSize + stringOffset);\n    var stringAttribute = textDecoder.decode(stringData);\n    stringsArray.push(stringAttribute);\n    stringOffset += stringByteSize;\n  }\n  return stringsArray;\n}","map":{"version":3,"names":["GLTFScenegraph","EXT_FEATURE_METADATA","name","decode","_x","_decode","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","gltfData","scenegraph","wrap","_callee$","_context","prev","next","decodeExtFeatureMetadata","stop","_extension$schema","extension","getExtension","schemaClasses","schema","classes","featureTables","featureTextures","console","warn","schemaName","schemaClass","featureTable","findFeatureTableByName","handleFeatureTableProperties","propertyName","properties","_featureTable$propert","schemaProperty","featureTableProperty","numberOfFeatures","count","data","getPropertyDataFromBinarySource","bufferView","getTypedArrayForBufferView","type","stringOffsetBufferView","offsetsData","getStringAttributes","schemaClassName","featureTableName","class","stringsCount","stringsArray","textDecoder","TextDecoder","stringOffset","bytesPerStringSize","index","stringByteSize","stringData","subarray","stringAttribute","push"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/gltf/src/lib/extensions/deprecated/EXT_feature_metadata.ts"],"sourcesContent":["/* eslint-disable camelcase */\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\nimport {\n  ClassProperty,\n  EXT_feature_metadata_class_object,\n  EXT_feature_metadata_feature_table,\n  FeatureTableProperty,\n  GLTF_EXT_feature_metadata\n} from '../../types/gltf-json-schema';\n\n/** Extension name */\nconst EXT_FEATURE_METADATA = 'EXT_feature_metadata';\n\nexport const name = EXT_FEATURE_METADATA;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  decodeExtFeatureMetadata(scenegraph);\n}\n\n/**\n * Decodes feature metadata from extension\n * @param scenegraph\n */\nfunction decodeExtFeatureMetadata(scenegraph: GLTFScenegraph): void {\n  const extension: GLTF_EXT_feature_metadata | null = scenegraph.getExtension(EXT_FEATURE_METADATA);\n  const schemaClasses = extension?.schema?.classes;\n  const featureTables = extension?.featureTables;\n  const featureTextures = extension?.featureTextures;\n\n  if (featureTextures) {\n    /*\n     * TODO add support for featureTextures\n     * Spec - https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata#feature-textures\n     */\n    // eslint-disable-next-line no-console\n    console.warn('featureTextures is not yet supported in the \"EXT_feature_metadata\" extension.');\n  }\n\n  if (schemaClasses && featureTables) {\n    for (const schemaName in schemaClasses) {\n      const schemaClass = schemaClasses[schemaName];\n      const featureTable = findFeatureTableByName(featureTables, schemaName);\n\n      if (featureTable) {\n        handleFeatureTableProperties(scenegraph, featureTable, schemaClass);\n      }\n    }\n  }\n}\n\n/**\n * Navigate throw all properies in feature table and gets properties data.\n * @param scenegraph\n * @param featureTable\n * @param schemaClass\n */\nfunction handleFeatureTableProperties(\n  scenegraph: GLTFScenegraph,\n  featureTable: EXT_feature_metadata_feature_table,\n  schemaClass: EXT_feature_metadata_class_object\n): void {\n  for (const propertyName in schemaClass.properties) {\n    const schemaProperty = schemaClass.properties[propertyName];\n    const featureTableProperty = featureTable?.properties?.[propertyName];\n    const numberOfFeatures = featureTable.count;\n\n    if (featureTableProperty) {\n      const data = getPropertyDataFromBinarySource(\n        scenegraph,\n        schemaProperty,\n        numberOfFeatures,\n        featureTableProperty\n      );\n      featureTableProperty.data = data;\n    }\n  }\n}\n\n/**\n * Decode properties from binary sourse based on property type.\n * @param scenegraph\n * @param schemaProperty\n * @param numberOfFeatures\n * @param featureTableProperty\n */\nfunction getPropertyDataFromBinarySource(\n  scenegraph: GLTFScenegraph,\n  schemaProperty: ClassProperty,\n  numberOfFeatures: number,\n  featureTableProperty: FeatureTableProperty\n): Uint8Array | string[] {\n  const bufferView = featureTableProperty.bufferView;\n  // TODO think maybe we shouldn't get data only in Uint8Array format.\n  let data: Uint8Array | string[] = scenegraph.getTypedArrayForBufferView(bufferView);\n\n  switch (schemaProperty.type) {\n    case 'STRING': {\n      // stringOffsetBufferView should be available for string type.\n      const stringOffsetBufferView = featureTableProperty.stringOffsetBufferView!;\n      const offsetsData = scenegraph.getTypedArrayForBufferView(stringOffsetBufferView);\n      data = getStringAttributes(data, offsetsData, numberOfFeatures);\n      break;\n    }\n    default:\n  }\n\n  return data;\n}\n\n/**\n * Find the feature table by class name.\n * @param featureTables\n * @param schemaClassName\n */\nfunction findFeatureTableByName(\n  featureTables: {[key: string]: EXT_feature_metadata_feature_table},\n  schemaClassName: string\n): EXT_feature_metadata_feature_table | null {\n  for (const featureTableName in featureTables) {\n    const featureTable = featureTables[featureTableName];\n\n    if (featureTable.class === schemaClassName) {\n      return featureTable;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Getting string attributes from binary data.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata#strings\n * @param data\n * @param offsetsData\n * @param stringsCount\n */\nfunction getStringAttributes(\n  data: Uint8Array,\n  offsetsData: Uint8Array,\n  stringsCount: number\n): string[] {\n  const stringsArray: string[] = [];\n  const textDecoder = new TextDecoder('utf8');\n\n  let stringOffset = 0;\n  const bytesPerStringSize = 4;\n\n  for (let index = 0; index < stringsCount; index++) {\n    // TODO check if it is multiplication on bytesPerStringSize is valid operation?\n    const stringByteSize =\n      offsetsData[(index + 1) * bytesPerStringSize] - offsetsData[index * bytesPerStringSize];\n    const stringData = data.subarray(stringOffset, stringByteSize + stringOffset);\n    const stringAttribute = textDecoder.decode(stringData);\n\n    stringsArray.push(stringAttribute);\n    stringOffset += stringByteSize;\n  }\n\n  return stringsArray;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}