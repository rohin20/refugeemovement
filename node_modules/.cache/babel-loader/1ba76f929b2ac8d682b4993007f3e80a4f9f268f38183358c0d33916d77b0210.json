{"ast":null,"code":"import { copyPaddedStringToDataView, copyPaddedArrayBufferToDataView } from '@loaders.gl/loader-utils';\nvar MAGIC_glTF = 0x46546c67;\nvar MAGIC_JSON = 0x4e4f534a;\nvar MAGIC_BIN = 0x004e4942;\nvar LE = true;\nexport default function encodeGLBSync(glb, dataView) {\n  var byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _glb$magic = glb.magic,\n    magic = _glb$magic === void 0 ? MAGIC_glTF : _glb$magic,\n    _glb$version = glb.version,\n    version = _glb$version === void 0 ? 2 : _glb$version,\n    _glb$json = glb.json,\n    json = _glb$json === void 0 ? {} : _glb$json,\n    binary = glb.binary;\n  var byteOffsetStart = byteOffset;\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, magic, LE);\n    dataView.setUint32(byteOffset + 4, version, LE);\n    dataView.setUint32(byteOffset + 8, 0, LE);\n  }\n  var byteOffsetFileLength = byteOffset + 8;\n  byteOffset += 12;\n  var byteOffsetJsonHeader = byteOffset;\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, 0, LE);\n    dataView.setUint32(byteOffset + 4, MAGIC_JSON, LE);\n  }\n  byteOffset += 8;\n  var jsonString = JSON.stringify(json);\n  byteOffset = copyPaddedStringToDataView(dataView, byteOffset, jsonString, 4);\n  if (dataView) {\n    var jsonByteLength = byteOffset - byteOffsetJsonHeader - 8;\n    dataView.setUint32(byteOffsetJsonHeader + 0, jsonByteLength, LE);\n  }\n  if (binary) {\n    var byteOffsetBinHeader = byteOffset;\n    if (dataView) {\n      dataView.setUint32(byteOffset + 0, 0, LE);\n      dataView.setUint32(byteOffset + 4, MAGIC_BIN, LE);\n    }\n    byteOffset += 8;\n    byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, binary, 4);\n    if (dataView) {\n      var binByteLength = byteOffset - byteOffsetBinHeader - 8;\n      dataView.setUint32(byteOffsetBinHeader + 0, binByteLength, LE);\n    }\n  }\n  if (dataView) {\n    var fileByteLength = byteOffset - byteOffsetStart;\n    dataView.setUint32(byteOffsetFileLength, fileByteLength, LE);\n  }\n  return byteOffset;\n}","map":{"version":3,"names":["copyPaddedStringToDataView","copyPaddedArrayBufferToDataView","MAGIC_glTF","MAGIC_JSON","MAGIC_BIN","LE","encodeGLBSync","glb","dataView","byteOffset","arguments","length","undefined","options","_glb$magic","magic","_glb$version","version","_glb$json","json","binary","byteOffsetStart","setUint32","byteOffsetFileLength","byteOffsetJsonHeader","jsonString","JSON","stringify","jsonByteLength","byteOffsetBinHeader","binByteLength","fileByteLength"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/gltf/src/lib/encoders/encode-glb.ts"],"sourcesContent":["/* eslint-disable camelcase, max-statements */\nimport {\n  copyPaddedStringToDataView,\n  copyPaddedArrayBufferToDataView\n} from '@loaders.gl/loader-utils';\n\nconst MAGIC_glTF = 0x46546c67; // glTF in ASCII\nconst MAGIC_JSON = 0x4e4f534a; // JSON in ASCII\nconst MAGIC_BIN = 0x004e4942; // BIN\\0 in ASCII\n\nconst LE = true; // Binary GLTF is little endian.\n\n// Encode the full GLB buffer with header etc\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#\n// glb-file-format-specification\nexport default function encodeGLBSync(glb, dataView, byteOffset = 0, options = {}) {\n  const {magic = MAGIC_glTF, version = 2, json = {}, binary} = glb;\n\n  const byteOffsetStart = byteOffset;\n\n  // Write GLB Header\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, magic, LE); // Magic number (the ASCII string 'glTF').\n    dataView.setUint32(byteOffset + 4, version, LE); // Version 2 of binary glTF container format uint32\n    dataView.setUint32(byteOffset + 8, 0, LE); // Total byte length of generated file (uint32), will be set last\n  }\n  const byteOffsetFileLength = byteOffset + 8;\n  byteOffset += 12; // GLB_FILE_HEADER_SIZE\n\n  // Write the JSON chunk header\n  const byteOffsetJsonHeader = byteOffset;\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, 0, LE); // Byte length of json chunk (will be written later)\n    dataView.setUint32(byteOffset + 4, MAGIC_JSON, LE); // Chunk type\n  }\n  byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n\n  // Write the JSON chunk\n  const jsonString = JSON.stringify(json);\n  byteOffset = copyPaddedStringToDataView(dataView, byteOffset, jsonString, 4);\n\n  // Now we know the JSON chunk length so we can write it.\n  if (dataView) {\n    const jsonByteLength = byteOffset - byteOffsetJsonHeader - 8; // GLB_CHUNK_HEADER_SIZE\n    dataView.setUint32(byteOffsetJsonHeader + 0, jsonByteLength, LE); // Byte length of json chunk (uint32)\n  }\n\n  // Write the BIN chunk if present. The BIN chunk is optional.\n  if (binary) {\n    const byteOffsetBinHeader = byteOffset;\n\n    // Write the BIN chunk header\n    if (dataView) {\n      dataView.setUint32(byteOffset + 0, 0, LE); // Byte length BIN (uint32)\n      dataView.setUint32(byteOffset + 4, MAGIC_BIN, LE); // Chunk type\n    }\n    byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n\n    byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, binary, 4);\n\n    // Now we know the BIN chunk length so we can write it.\n    if (dataView) {\n      const binByteLength = byteOffset - byteOffsetBinHeader - 8; // GLB_CHUNK_HEADER_SIZE\n      dataView.setUint32(byteOffsetBinHeader + 0, binByteLength, LE); // Byte length BIN (uint32)\n    }\n  }\n\n  // Now we know the glb file length so we can write it.\n  if (dataView) {\n    const fileByteLength = byteOffset - byteOffsetStart;\n    dataView.setUint32(byteOffsetFileLength, fileByteLength, LE); // Total byte length of generated file (uint32)\n  }\n\n  return byteOffset;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}