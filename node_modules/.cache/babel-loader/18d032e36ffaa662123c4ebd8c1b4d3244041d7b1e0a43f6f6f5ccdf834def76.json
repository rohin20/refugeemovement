{"ast":null,"code":"/**\n * Gets the dimensions of the element, accounting for API differences between\n * `window` and other DOM elements.\n */\n// TODO Move this into WindowScroller and import from there\nvar isWindow = function isWindow(element) {\n  return element === window;\n};\nvar getBoundingBox = function getBoundingBox(element) {\n  return element.getBoundingClientRect();\n};\nexport function getDimensions(scrollElement, props) {\n  if (!scrollElement) {\n    return {\n      height: props.serverHeight,\n      width: props.serverWidth\n    };\n  } else if (isWindow(scrollElement)) {\n    var _window = window,\n      innerHeight = _window.innerHeight,\n      innerWidth = _window.innerWidth;\n    return {\n      height: typeof innerHeight === 'number' ? innerHeight : 0,\n      width: typeof innerWidth === 'number' ? innerWidth : 0\n    };\n  } else {\n    return getBoundingBox(scrollElement);\n  }\n}\n/**\n * Gets the vertical and horizontal position of an element within its scroll container.\n * Elements that have been “scrolled past” return negative values.\n * Handles edge-case where a user is navigating back (history) from an already-scrolled page.\n * In this case the body’s top or left position will be a negative number and this element’s top or left will be increased (by that amount).\n */\n\nexport function getPositionOffset(element, container) {\n  if (isWindow(container) && document.documentElement) {\n    var containerElement = document.documentElement;\n    var elementRect = getBoundingBox(element);\n    var containerRect = getBoundingBox(containerElement);\n    return {\n      top: elementRect.top - containerRect.top,\n      left: elementRect.left - containerRect.left\n    };\n  } else {\n    var scrollOffset = getScrollOffset(container);\n    var _elementRect = getBoundingBox(element);\n    var _containerRect = getBoundingBox(container);\n    return {\n      top: _elementRect.top + scrollOffset.top - _containerRect.top,\n      left: _elementRect.left + scrollOffset.left - _containerRect.left\n    };\n  }\n}\n/**\n * Gets the vertical and horizontal scroll amount of the element, accounting for IE compatibility\n * and API differences between `window` and other DOM elements.\n */\n\nexport function getScrollOffset(element) {\n  if (isWindow(element) && document.documentElement) {\n    return {\n      top: 'scrollY' in window ? window.scrollY : document.documentElement.scrollTop,\n      left: 'scrollX' in window ? window.scrollX : document.documentElement.scrollLeft\n    };\n  } else {\n    return {\n      top: element.scrollTop,\n      left: element.scrollLeft\n    };\n  }\n}","map":{"version":3,"names":["isWindow","element","window","getBoundingBox","getBoundingClientRect","getDimensions","scrollElement","props","height","serverHeight","width","serverWidth","_window","innerHeight","innerWidth","getPositionOffset","container","document","documentElement","containerElement","elementRect","containerRect","top","left","scrollOffset","getScrollOffset","_elementRect","_containerRect","scrollY","scrollTop","scrollX","scrollLeft"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/react-virtualized/dist/es/WindowScroller/utils/dimensions.js"],"sourcesContent":["/**\n * Gets the dimensions of the element, accounting for API differences between\n * `window` and other DOM elements.\n */\n// TODO Move this into WindowScroller and import from there\nvar isWindow = function isWindow(element) {\n  return element === window;\n};\n\nvar getBoundingBox = function getBoundingBox(element) {\n  return element.getBoundingClientRect();\n};\n\nexport function getDimensions(scrollElement, props) {\n  if (!scrollElement) {\n    return {\n      height: props.serverHeight,\n      width: props.serverWidth\n    };\n  } else if (isWindow(scrollElement)) {\n    var _window = window,\n        innerHeight = _window.innerHeight,\n        innerWidth = _window.innerWidth;\n    return {\n      height: typeof innerHeight === 'number' ? innerHeight : 0,\n      width: typeof innerWidth === 'number' ? innerWidth : 0\n    };\n  } else {\n    return getBoundingBox(scrollElement);\n  }\n}\n/**\n * Gets the vertical and horizontal position of an element within its scroll container.\n * Elements that have been “scrolled past” return negative values.\n * Handles edge-case where a user is navigating back (history) from an already-scrolled page.\n * In this case the body’s top or left position will be a negative number and this element’s top or left will be increased (by that amount).\n */\n\nexport function getPositionOffset(element, container) {\n  if (isWindow(container) && document.documentElement) {\n    var containerElement = document.documentElement;\n    var elementRect = getBoundingBox(element);\n    var containerRect = getBoundingBox(containerElement);\n    return {\n      top: elementRect.top - containerRect.top,\n      left: elementRect.left - containerRect.left\n    };\n  } else {\n    var scrollOffset = getScrollOffset(container);\n\n    var _elementRect = getBoundingBox(element);\n\n    var _containerRect = getBoundingBox(container);\n\n    return {\n      top: _elementRect.top + scrollOffset.top - _containerRect.top,\n      left: _elementRect.left + scrollOffset.left - _containerRect.left\n    };\n  }\n}\n/**\n * Gets the vertical and horizontal scroll amount of the element, accounting for IE compatibility\n * and API differences between `window` and other DOM elements.\n */\n\nexport function getScrollOffset(element) {\n  if (isWindow(element) && document.documentElement) {\n    return {\n      top: 'scrollY' in window ? window.scrollY : document.documentElement.scrollTop,\n      left: 'scrollX' in window ? window.scrollX : document.documentElement.scrollLeft\n    };\n  } else {\n    return {\n      top: element.scrollTop,\n      left: element.scrollLeft\n    };\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,IAAIA,QAAQ,GAAG,SAASA,QAAQA,CAACC,OAAO,EAAE;EACxC,OAAOA,OAAO,KAAKC,MAAM;AAC3B,CAAC;AAED,IAAIC,cAAc,GAAG,SAASA,cAAcA,CAACF,OAAO,EAAE;EACpD,OAAOA,OAAO,CAACG,qBAAqB,EAAE;AACxC,CAAC;AAED,OAAO,SAASC,aAAaA,CAACC,aAAa,EAAEC,KAAK,EAAE;EAClD,IAAI,CAACD,aAAa,EAAE;IAClB,OAAO;MACLE,MAAM,EAAED,KAAK,CAACE,YAAY;MAC1BC,KAAK,EAAEH,KAAK,CAACI;IACf,CAAC;EACH,CAAC,MAAM,IAAIX,QAAQ,CAACM,aAAa,CAAC,EAAE;IAClC,IAAIM,OAAO,GAAGV,MAAM;MAChBW,WAAW,GAAGD,OAAO,CAACC,WAAW;MACjCC,UAAU,GAAGF,OAAO,CAACE,UAAU;IACnC,OAAO;MACLN,MAAM,EAAE,OAAOK,WAAW,KAAK,QAAQ,GAAGA,WAAW,GAAG,CAAC;MACzDH,KAAK,EAAE,OAAOI,UAAU,KAAK,QAAQ,GAAGA,UAAU,GAAG;IACvD,CAAC;EACH,CAAC,MAAM;IACL,OAAOX,cAAc,CAACG,aAAa,CAAC;EACtC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASS,iBAAiBA,CAACd,OAAO,EAAEe,SAAS,EAAE;EACpD,IAAIhB,QAAQ,CAACgB,SAAS,CAAC,IAAIC,QAAQ,CAACC,eAAe,EAAE;IACnD,IAAIC,gBAAgB,GAAGF,QAAQ,CAACC,eAAe;IAC/C,IAAIE,WAAW,GAAGjB,cAAc,CAACF,OAAO,CAAC;IACzC,IAAIoB,aAAa,GAAGlB,cAAc,CAACgB,gBAAgB,CAAC;IACpD,OAAO;MACLG,GAAG,EAAEF,WAAW,CAACE,GAAG,GAAGD,aAAa,CAACC,GAAG;MACxCC,IAAI,EAAEH,WAAW,CAACG,IAAI,GAAGF,aAAa,CAACE;IACzC,CAAC;EACH,CAAC,MAAM;IACL,IAAIC,YAAY,GAAGC,eAAe,CAACT,SAAS,CAAC;IAE7C,IAAIU,YAAY,GAAGvB,cAAc,CAACF,OAAO,CAAC;IAE1C,IAAI0B,cAAc,GAAGxB,cAAc,CAACa,SAAS,CAAC;IAE9C,OAAO;MACLM,GAAG,EAAEI,YAAY,CAACJ,GAAG,GAAGE,YAAY,CAACF,GAAG,GAAGK,cAAc,CAACL,GAAG;MAC7DC,IAAI,EAAEG,YAAY,CAACH,IAAI,GAAGC,YAAY,CAACD,IAAI,GAAGI,cAAc,CAACJ;IAC/D,CAAC;EACH;AACF;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASE,eAAeA,CAACxB,OAAO,EAAE;EACvC,IAAID,QAAQ,CAACC,OAAO,CAAC,IAAIgB,QAAQ,CAACC,eAAe,EAAE;IACjD,OAAO;MACLI,GAAG,EAAE,SAAS,IAAIpB,MAAM,GAAGA,MAAM,CAAC0B,OAAO,GAAGX,QAAQ,CAACC,eAAe,CAACW,SAAS;MAC9EN,IAAI,EAAE,SAAS,IAAIrB,MAAM,GAAGA,MAAM,CAAC4B,OAAO,GAAGb,QAAQ,CAACC,eAAe,CAACa;IACxE,CAAC;EACH,CAAC,MAAM;IACL,OAAO;MACLT,GAAG,EAAErB,OAAO,CAAC4B,SAAS;MACtBN,IAAI,EAAEtB,OAAO,CAAC8B;IAChB,CAAC;EACH;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}