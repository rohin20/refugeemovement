{"ast":null,"code":"import _regeneratorRuntime from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BasisLoader, selectSupportedBasisFormat } from '@loaders.gl/textures';\nimport { ImageLoader } from '@loaders.gl/images';\nimport { parseJSON, sliceArrayBuffer } from '@loaders.gl/loader-utils';\nimport { assert } from '../utils/assert';\nimport { resolveUrl } from '../gltf-utils/resolve-url';\nimport { getTypedArrayForBufferView } from '../gltf-utils/get-typed-array';\nimport { preprocessExtensions, decodeExtensions } from '../api/gltf-extensions';\nimport { normalizeGLTFV1 } from '../api/normalize-gltf-v1';\nimport { postProcessGLTF } from '../api/post-process-gltf';\nimport parseGLBSync, { isGLB } from './parse-glb';\nexport function isGLTF(arrayBuffer, options) {\n  var byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\nexport function parseGLTF(_x, _x2) {\n  return _parseGLTF.apply(this, arguments);\n}\nfunction _parseGLTF() {\n  _parseGLTF = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(gltf, arrayBufferOrString) {\n    var _options$gltf,\n      _options$gltf2,\n      _options$gltf3,\n      _options$gltf4,\n      byteOffset,\n      options,\n      context,\n      promises,\n      _promise,\n      promise,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          byteOffset = _args.length > 2 && _args[2] !== undefined ? _args[2] : 0;\n          options = _args.length > 3 ? _args[3] : undefined;\n          context = _args.length > 4 ? _args[4] : undefined;\n          parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n          normalizeGLTFV1(gltf, {\n            normalize: options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.normalize\n          });\n          preprocessExtensions(gltf, options, context);\n          promises = [];\n          if (!(options !== null && options !== void 0 && (_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadBuffers && gltf.json.buffers)) {\n            _context.next = 10;\n            break;\n          }\n          _context.next = 10;\n          return loadBuffers(gltf, options, context);\n        case 10:\n          if (options !== null && options !== void 0 && (_options$gltf3 = options.gltf) !== null && _options$gltf3 !== void 0 && _options$gltf3.loadImages) {\n            _promise = loadImages(gltf, options, context);\n            promises.push(_promise);\n          }\n          promise = decodeExtensions(gltf, options, context);\n          promises.push(promise);\n          _context.next = 15;\n          return Promise.all(promises);\n        case 15:\n          return _context.abrupt(\"return\", options !== null && options !== void 0 && (_options$gltf4 = options.gltf) !== null && _options$gltf4 !== void 0 && _options$gltf4.postProcess ? postProcessGLTF(gltf, options) : gltf);\n        case 16:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _parseGLTF.apply(this, arguments);\n}\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    var textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n  if (typeof data === 'string') {\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    var glb = {};\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n    assert(glb.type === 'glTF', \"Invalid GLB magic string \".concat(glb.type));\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n  var buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    var binChunks = gltf._glb.binChunks;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n  }\n  var images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\nfunction loadBuffers(_x3, _x4, _x5) {\n  return _loadBuffers.apply(this, arguments);\n}\nfunction _loadBuffers() {\n  _loadBuffers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(gltf, options, context) {\n    var buffers, i, buffer, _context$fetch, _response$arrayBuffer, fetch, uri, response, arrayBuffer;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          buffers = gltf.json.buffers || [];\n          i = 0;\n        case 2:\n          if (!(i < buffers.length)) {\n            _context2.next = 22;\n            break;\n          }\n          buffer = buffers[i];\n          if (!buffer.uri) {\n            _context2.next = 18;\n            break;\n          }\n          fetch = context.fetch;\n          assert(fetch);\n          uri = resolveUrl(buffer.uri, options);\n          _context2.next = 10;\n          return context === null || context === void 0 ? void 0 : (_context$fetch = context.fetch) === null || _context$fetch === void 0 ? void 0 : _context$fetch.call(context, uri);\n        case 10:\n          response = _context2.sent;\n          _context2.next = 13;\n          return response === null || response === void 0 ? void 0 : (_response$arrayBuffer = response.arrayBuffer) === null || _response$arrayBuffer === void 0 ? void 0 : _response$arrayBuffer.call(response);\n        case 13:\n          arrayBuffer = _context2.sent;\n          gltf.buffers[i] = {\n            arrayBuffer: arrayBuffer,\n            byteOffset: 0,\n            byteLength: arrayBuffer.byteLength\n          };\n          delete buffer.uri;\n          _context2.next = 19;\n          break;\n        case 18:\n          if (gltf.buffers[i] === null) {\n            gltf.buffers[i] = {\n              arrayBuffer: new ArrayBuffer(buffer.byteLength),\n              byteOffset: 0,\n              byteLength: buffer.byteLength\n            };\n          }\n        case 19:\n          ++i;\n          _context2.next = 2;\n          break;\n        case 22:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _loadBuffers.apply(this, arguments);\n}\nfunction loadImages(_x6, _x7, _x8) {\n  return _loadImages.apply(this, arguments);\n}\nfunction _loadImages() {\n  _loadImages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(gltf, options, context) {\n    var imageIndices, images, promises, _iterator2, _step2, imageIndex;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          imageIndices = getReferencesImageIndices(gltf);\n          images = gltf.json.images || [];\n          promises = [];\n          _iterator2 = _createForOfIteratorHelper(imageIndices);\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              imageIndex = _step2.value;\n              promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          _context3.next = 7;\n          return Promise.all(promises);\n        case 7:\n          return _context3.abrupt(\"return\", _context3.sent);\n        case 8:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _loadImages.apply(this, arguments);\n}\nfunction getReferencesImageIndices(gltf) {\n  var imageIndices = new Set();\n  var textures = gltf.json.textures || [];\n  var _iterator = _createForOfIteratorHelper(textures),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var texture = _step.value;\n      if (texture.source !== undefined) {\n        imageIndices.add(texture.source);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return Array.from(imageIndices).sort();\n}\nfunction loadImage(_x9, _x10, _x11, _x12, _x13) {\n  return _loadImage.apply(this, arguments);\n}\nfunction _loadImage() {\n  _loadImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(gltf, image, index, options, context) {\n    var fetch, parse, arrayBuffer, uri, response, array, parsedImage;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          fetch = context.fetch, parse = context.parse;\n          if (!(image.uri && !image.hasOwnProperty('bufferView'))) {\n            _context4.next = 10;\n            break;\n          }\n          uri = resolveUrl(image.uri, options);\n          _context4.next = 5;\n          return fetch(uri);\n        case 5:\n          response = _context4.sent;\n          _context4.next = 8;\n          return response.arrayBuffer();\n        case 8:\n          arrayBuffer = _context4.sent;\n          image.bufferView = {\n            data: arrayBuffer\n          };\n        case 10:\n          if (Number.isFinite(image.bufferView)) {\n            array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n            arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n          }\n          assert(arrayBuffer, 'glTF image has no data');\n          _context4.next = 14;\n          return parse(arrayBuffer, [ImageLoader, BasisLoader], {\n            mimeType: image.mimeType,\n            basis: options.basis || {\n              format: selectSupportedBasisFormat()\n            }\n          }, context);\n        case 14:\n          parsedImage = _context4.sent;\n          if (parsedImage && parsedImage[0]) {\n            parsedImage = {\n              compressed: true,\n              mipmaps: false,\n              width: parsedImage[0].width,\n              height: parsedImage[0].height,\n              data: parsedImage[0]\n            };\n          }\n          gltf.images = gltf.images || [];\n          gltf.images[index] = parsedImage;\n        case 18:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _loadImage.apply(this, arguments);\n}","map":{"version":3,"names":["BasisLoader","selectSupportedBasisFormat","ImageLoader","parseJSON","sliceArrayBuffer","assert","resolveUrl","getTypedArrayForBufferView","preprocessExtensions","decodeExtensions","normalizeGLTFV1","postProcessGLTF","parseGLBSync","isGLB","isGLTF","arrayBuffer","options","byteOffset","parseGLTF","_x","_x2","_parseGLTF","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","gltf","arrayBufferOrString","_options$gltf","_options$gltf2","_options$gltf3","_options$gltf4","context","promises","_promise","promise","_args","wrap","_callee$","_context","prev","next","length","undefined","parseGLTFContainerSync","normalize","loadBuffers","json","buffers","loadImages","push","Promise","all","abrupt","postProcess","stop","data","uri","baseUri","ArrayBuffer","textDecoder","TextDecoder","decode","glb","type","concat","_glb","Array","fill","header","hasBinChunk","binChunks","byteLength","images","_x3","_x4","_x5","_loadBuffers","_callee2","i","buffer","_context$fetch","_response$arrayBuffer","fetch","response","_callee2$","_context2","call","sent","_x6","_x7","_x8","_loadImages","_callee3","imageIndices","_iterator2","_step2","imageIndex","_callee3$","_context3","getReferencesImageIndices","_createForOfIteratorHelper","s","n","done","value","loadImage","err","e","f","Set","textures","_iterator","_step","texture","source","add","from","sort","_x9","_x10","_x11","_x12","_x13","_loadImage","_callee4","image","index","parse","array","parsedImage","_callee4$","_context4","hasOwnProperty","bufferView","Number","isFinite","mimeType","basis","format","compressed","mipmaps","width","height"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/gltf/src/lib/parsers/parse-gltf.ts"],"sourcesContent":["/* eslint-disable camelcase, max-statements, no-restricted-globals */\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {BasisLoader, selectSupportedBasisFormat} from '@loaders.gl/textures';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport type {GLB} from '../types/glb-types';\nimport type {GLTFWithBuffers} from '../types/gltf-types';\n\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {resolveUrl} from '../gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from '../gltf-utils/get-typed-array';\nimport {preprocessExtensions, decodeExtensions} from '../api/gltf-extensions';\nimport {normalizeGLTFV1} from '../api/normalize-gltf-v1';\nimport {postProcessGLTF} from '../api/post-process-gltf';\nimport parseGLBSync, {isGLB} from './parse-glb';\n\nexport type GLTFParseOptions = {\n  normalize?: boolean;\n  loadImages?: boolean;\n  loadBuffers?: boolean;\n  decompressMeshes?: boolean;\n  postProcess?: boolean;\n  excludeExtensions?: string[];\n};\n\n// export type GLTFOptions = {\n//   gltf?: GLTFParseOptions;\n// };\n\nexport function isGLTF(arrayBuffer, options?): boolean {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\n\nexport async function parseGLTF(\n  gltf: GLTFWithBuffers,\n  arrayBufferOrString,\n  byteOffset = 0,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  normalizeGLTFV1(gltf, {normalize: options?.gltf?.normalize});\n\n  preprocessExtensions(gltf, options, context);\n\n  const promises: Promise<any>[] = [];\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options?.gltf?.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options?.gltf?.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb: GLB = {} as GLB;\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n/** Asynchronously fetch and parse buffers, store in buffers array outside of json\n * TODO - traverse gltf and determine which buffers are actually needed\n */\nasync function loadBuffers(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  // TODO\n  const buffers = gltf.json.buffers || [];\n  for (let i = 0; i < buffers.length; ++i) {\n    const buffer = buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await context?.fetch?.(uri);\n      const arrayBuffer = await response?.arrayBuffer?.();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    } else if (gltf.buffers[i] === null) {\n      gltf.buffers[i] = {\n        arrayBuffer: new ArrayBuffer(buffer.byteLength),\n        byteOffset: 0,\n        byteLength: buffer.byteLength\n      };\n    }\n  }\n}\n\n/**\n * Loads all images\n * TODO - traverse gltf and determine which images are actually needed\n * @param gltf\n * @param options\n * @param context\n * @returns\n */\nasync function loadImages(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  const imageIndices = getReferencesImageIndices(gltf);\n\n  const images = gltf.json.images || [];\n\n  const promises: Promise<any>[] = [];\n  for (const imageIndex of imageIndices) {\n    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n/** Make sure we only load images that are actually referenced by textures */\nfunction getReferencesImageIndices(gltf: GLTFWithBuffers): number[] {\n  const imageIndices = new Set<number>();\n\n  const textures = gltf.json.textures || [];\n  for (const texture of textures) {\n    if (texture.source !== undefined) {\n      imageIndices.add(texture.source);\n    }\n  }\n\n  return Array.from(imageIndices).sort();\n}\n\n/** Asynchronously fetches and parses one image, store in images array outside of json */\nasync function loadImage(\n  gltf: GLTFWithBuffers,\n  image,\n  index: number,\n  options,\n  context: LoaderContext\n) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri && !image.hasOwnProperty('bufferView')) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n    image.bufferView = {\n      data: arrayBuffer\n    };\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  let parsedImage = await parse(\n    arrayBuffer,\n    [ImageLoader, BasisLoader],\n    {mimeType: image.mimeType, basis: options.basis || {format: selectSupportedBasisFormat()}},\n    context\n  );\n\n  if (parsedImage && parsedImage[0]) {\n    parsedImage = {\n      compressed: true,\n      mipmaps: false,\n      width: parsedImage[0].width,\n      height: parsedImage[0].height,\n      data: parsedImage[0]\n    };\n  }\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  // Store the loaded image\n  gltf.images = gltf.images || [];\n  gltf.images[index] = parsedImage;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}