{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.renderedSize = renderedSize;\nexports.adjustCellsToContainer = adjustCellsToContainer;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _document = _interopRequireDefault(require(\"global/document\"));\nvar _utils = require(\"@kepler.gl/utils\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar MIN_GHOST_CELL_SIZE = 200;\nvar MIN_CELL_SIZE = 45;\n\n/**\n * Measure rows and column content to determine min width for each column\n * @param {RenderSizeParam} param0\n */\nfunction renderedSize(_ref) {\n  var _ref$text = _ref.text,\n    dataContainer = _ref$text.dataContainer,\n    column = _ref$text.column,\n    _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'string' : _ref$type,\n    colIdx = _ref.colIdx,\n    _ref$numRowsToCalcula = _ref.numRowsToCalculate,\n    numRowsToCalculate = _ref$numRowsToCalcula === void 0 ? 10 : _ref$numRowsToCalcula,\n    _ref$fontSize = _ref.fontSize,\n    fontSize = _ref$fontSize === void 0 ? 12 : _ref$fontSize,\n    _ref$font = _ref.font,\n    font = _ref$font === void 0 ? 'Lato' : _ref$font,\n    _ref$cellPadding = _ref.cellPadding,\n    cellPadding = _ref$cellPadding === void 0 ? 40 : _ref$cellPadding,\n    _ref$maxCellSize = _ref.maxCellSize,\n    maxCellSize = _ref$maxCellSize === void 0 ? 500 : _ref$maxCellSize,\n    _ref$maxHeaderSize = _ref.maxHeaderSize,\n    maxHeaderSize = _ref$maxHeaderSize === void 0 ? 500 : _ref$maxHeaderSize,\n    _ref$minCellSize = _ref.minCellSize,\n    minCellSize = _ref$minCellSize === void 0 ? MIN_CELL_SIZE : _ref$minCellSize,\n    _ref$optionsButton = _ref.optionsButton,\n    optionsButton = _ref$optionsButton === void 0 ? 30 : _ref$optionsButton;\n  if (!_document[\"default\"]) {\n    return {\n      row: 0,\n      header: 0\n    };\n  }\n  var textCanvas = _document[\"default\"].createElement('canvas');\n  _document[\"default\"].body.appendChild(textCanvas);\n  var context = textCanvas.getContext('2d');\n  context.font = [fontSize, font].join('px ');\n  var rowsToSample = (0, _toConsumableArray2[\"default\"])(Array(numRowsToCalculate)).map(function () {\n    return Math.floor(Math.random() * (dataContainer.numRows() - 1));\n  }); // If we have less than 10 rows, lets measure all of them\n\n  if (dataContainer.numRows() <= numRowsToCalculate) {\n    rowsToSample = Array.from(Array(dataContainer.numRows()).keys());\n  }\n  var rowWidth = Math.max.apply(Math, (0, _toConsumableArray2[\"default\"])(rowsToSample.map(function (rowIdx) {\n    return Math.ceil(context.measureText((0, _utils.parseFieldValue)(dataContainer.valueAt(rowIdx, colIdx), type)).width) + cellPadding;\n  }))); // header cell only has left padding\n\n  var headerWidth = Math.ceil(context.measureText(column).width) + cellPadding / 2 + optionsButton;\n  var minRowWidth = minCellSize + cellPadding;\n  var minHeaderWidth = minCellSize + cellPadding / 2 + optionsButton;\n  var clampedRowWidth = clamp(minRowWidth, maxCellSize, rowWidth);\n  var clampedHeaderWidth = clamp(minHeaderWidth, maxHeaderSize, headerWidth); // cleanup\n\n  textCanvas.parentElement.removeChild(textCanvas);\n  return {\n    row: clampedRowWidth,\n    header: clampedHeaderWidth\n  };\n}\nfunction clamp(min, max, value) {\n  return Math.max(Math.min(max, value), min);\n}\nfunction getColumnOrder() {\n  var pinnedColumns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var unpinnedColumns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return [].concat((0, _toConsumableArray2[\"default\"])(pinnedColumns), (0, _toConsumableArray2[\"default\"])(unpinnedColumns));\n}\nfunction getMinCellSize(cellSizeCache) {\n  return Object.keys(cellSizeCache).reduce(function (accu, col) {\n    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, col, cellSizeCache[col].row));\n  }, {});\n}\nfunction getSizeSum(sizeCache, key) {\n  return Object.keys(sizeCache).reduce(function (acc, val) {\n    return acc + (key ? sizeCache[val][key] : sizeCache[val]);\n  }, 0);\n}\n/**\n * Expand cell to fit both row and header, if there is still room left,\n * expand last cell to fit the entire width of the container\n * @param {CellSizeCache} cellSizeCache\n * @param {string[]} columnOrder\n * @param {number} containerWidth\n * @param {number} roomToFill\n */\n\nfunction expandCellSize(cellSizeCache, columnOrder, containerWidth, roomToFill) {\n  var remaining = roomToFill;\n  var expandedCellSize = columnOrder.reduce(function (accu, col) {\n    var size = cellSizeCache[col].row;\n    if (cellSizeCache[col].row < cellSizeCache[col].header && remaining > 0) {\n      // if we are cutting off the header, expand to fit it\n      size = cellSizeCache[col].header - cellSizeCache[col].row < remaining ? cellSizeCache[col].header : cellSizeCache[col].row + remaining;\n      remaining -= size - cellSizeCache[col].row;\n    }\n    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, col, size));\n  }, {});\n  var ghost = null;\n  if (remaining > 0 && remaining < MIN_GHOST_CELL_SIZE) {\n    // expand last cell\n    var lastCell = columnOrder[columnOrder.length - 1];\n    expandedCellSize[lastCell] += remaining;\n  } else if (remaining >= MIN_GHOST_CELL_SIZE) {\n    // if too much left add a ghost cell\n    ghost = remaining;\n  }\n  return {\n    cellSizeCache: expandedCellSize,\n    ghost: ghost\n  };\n}\n/**\n * Adjust cell size based on container width\n * @param {number} containerWidth\n * @param {CellSizeCache} cellSizeCache\n * @param {string[]} pinnedColumns\n * @param {string[]} unpinnedColumns\n */\n\nfunction adjustCellsToContainer(containerWidth, cellSizeCache, pinnedColumns, unpinnedColumns) {\n  var minRowSum = getSizeSum(cellSizeCache, 'row');\n  if (minRowSum >= containerWidth) {\n    // we apply the min Width to all cells\n    return {\n      cellSizeCache: getMinCellSize(cellSizeCache)\n    };\n  } // if we have some room to expand\n\n  var columnOrder = getColumnOrder(pinnedColumns, unpinnedColumns);\n  return expandCellSize(cellSizeCache, columnOrder, containerWidth, containerWidth - minRowSum);\n}","map":{"version":3,"names":["_interopRequireDefault","require","value","exports","renderedSize","adjustCellsToContainer","_defineProperty2","_toConsumableArray2","_document","_utils","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","MIN_GHOST_CELL_SIZE","MIN_CELL_SIZE","minCellSize","_ref","_ref$text","text","dataContainer","_ref$type","type","colIdx","_ref$numRowsToCalcula","numRowsToCalculate","_ref$fontSize","fontSize","_ref$font","font","_ref$cellPadding","cellPadding","_ref$maxCellSize","maxCellSize","_ref$maxHeaderSize","maxHeaderSize","_ref$minCellSize","_ref$optionsButton","optionsButton","row","header","textCanvas","createElement","body","appendChild","context","getContext","join","rowsToSample","Array","map","Math","floor","random","numRows","from","ceil","measureText","parseFieldValue","valueAt","rowIdx","width","headerWidth","column","minRowWidth","clampedRowWidth","clamp","rowWidth","clampedHeaderWidth","minHeaderWidth","parentElement","removeChild","min","max","getColumnOrder","pinnedColumns","undefined","unpinnedColumns","concat","cellSizeCache","reduce","accu","col","getSizeSum","sizeCache","acc","val","expandCellSize","columnOrder","containerWidth","roomToFill","remaining","expandedCellSize","size","ghost","lastCell"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/components/src/common/data-table/cell-size.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport document from 'global/document';\nimport {DataContainerInterface, parseFieldValue} from '@kepler.gl/utils';\n\nconst MIN_GHOST_CELL_SIZE: number = 200;\nconst MIN_CELL_SIZE = 45;\n\ntype RenderSizeParam = {\n  text: {dataContainer: DataContainerInterface; column: string};\n  type?: string;\n  colIdx: number;\n  numRowsToCalculate?: number;\n  fontSize?: number;\n  font?: string;\n  cellPadding?: number;\n  maxCellSize?: number;\n  maxHeaderSize?: number;\n  minCellSize?: number;\n  optionsButton?: number;\n};\n\nexport type CellSizeCache = {\n  [key: string]: {\n    row: number;\n    header: number;\n  };\n};\n\n/**\n * Measure rows and column content to determine min width for each column\n * @param {RenderSizeParam} param0\n */\nexport function renderedSize({\n  text: {dataContainer, column},\n  type = 'string',\n  colIdx,\n  numRowsToCalculate = 10,\n  fontSize = 12,\n  font = 'Lato',\n  cellPadding = 40,\n  maxCellSize = 500,\n  maxHeaderSize = 500,\n  minCellSize = MIN_CELL_SIZE,\n  optionsButton = 30\n}: RenderSizeParam): {row: number; header: number} {\n  if (!document) {\n    return {\n      row: 0,\n      header: 0\n    };\n  }\n  const textCanvas = document.createElement('canvas');\n  document.body.appendChild(textCanvas);\n  const context = textCanvas.getContext('2d');\n  context.font = [fontSize, font].join('px ');\n\n  let rowsToSample = [...Array(numRowsToCalculate)].map(() =>\n    Math.floor(Math.random() * (dataContainer.numRows() - 1))\n  );\n\n  // If we have less than 10 rows, lets measure all of them\n  if (dataContainer.numRows() <= numRowsToCalculate) {\n    rowsToSample = Array.from(Array(dataContainer.numRows()).keys());\n  }\n  const rowWidth = Math.max(\n    ...rowsToSample.map(\n      rowIdx =>\n        Math.ceil(\n          context.measureText(parseFieldValue(dataContainer.valueAt(rowIdx, colIdx), type)).width\n        ) + cellPadding\n    )\n  );\n  // header cell only has left padding\n  const headerWidth =\n    Math.ceil(context.measureText(column).width) + cellPadding / 2 + optionsButton;\n\n  const minRowWidth = minCellSize + cellPadding;\n  const minHeaderWidth = minCellSize + cellPadding / 2 + optionsButton;\n\n  const clampedRowWidth = clamp(minRowWidth, maxCellSize, rowWidth);\n  const clampedHeaderWidth = clamp(minHeaderWidth, maxHeaderSize, headerWidth);\n\n  // cleanup\n  textCanvas.parentElement.removeChild(textCanvas);\n\n  return {\n    row: clampedRowWidth,\n    header: clampedHeaderWidth\n  };\n}\n\nfunction clamp(min, max, value) {\n  return Math.max(Math.min(max, value), min);\n}\n\nfunction getColumnOrder(pinnedColumns: string[] = [], unpinnedColumns: string[] = []) {\n  return [...pinnedColumns, ...unpinnedColumns];\n}\n\nfunction getMinCellSize(cellSizeCache: CellSizeCache) {\n  return Object.keys(cellSizeCache).reduce(\n    (accu, col) => ({\n      ...accu,\n      [col]: cellSizeCache[col].row\n    }),\n    {}\n  );\n}\n\nfunction getSizeSum(sizeCache, key) {\n  return Object.keys(sizeCache).reduce(\n    (acc, val) => acc + (key ? sizeCache[val][key] : sizeCache[val]),\n    0\n  );\n}\n\n/**\n * Expand cell to fit both row and header, if there is still room left,\n * expand last cell to fit the entire width of the container\n * @param {CellSizeCache} cellSizeCache\n * @param {string[]} columnOrder\n * @param {number} containerWidth\n * @param {number} roomToFill\n */\nfunction expandCellSize(\n  cellSizeCache: CellSizeCache,\n  columnOrder: string[],\n  containerWidth: number,\n  roomToFill: number\n): {\n  cellSizeCache: CellSizeCache;\n  ghost: number | null;\n} {\n  let remaining = roomToFill;\n\n  const expandedCellSize = columnOrder.reduce((accu, col) => {\n    let size = cellSizeCache[col].row;\n    if (cellSizeCache[col].row < cellSizeCache[col].header && remaining > 0) {\n      // if we are cutting off the header, expand to fit it\n      size =\n        cellSizeCache[col].header - cellSizeCache[col].row < remaining\n          ? cellSizeCache[col].header\n          : cellSizeCache[col].row + remaining;\n      remaining -= size - cellSizeCache[col].row;\n    }\n\n    return {\n      ...accu,\n      [col]: size\n    };\n  }, {});\n\n  let ghost: number | null = null;\n  if (remaining > 0 && remaining < MIN_GHOST_CELL_SIZE) {\n    // expand last cell\n    const lastCell = columnOrder[columnOrder.length - 1];\n    expandedCellSize[lastCell] += remaining;\n  } else if (remaining >= MIN_GHOST_CELL_SIZE) {\n    // if too much left add a ghost cell\n    ghost = remaining;\n  }\n\n  return {\n    cellSizeCache: expandedCellSize,\n    ghost\n  };\n}\n\n/**\n * Adjust cell size based on container width\n * @param {number} containerWidth\n * @param {CellSizeCache} cellSizeCache\n * @param {string[]} pinnedColumns\n * @param {string[]} unpinnedColumns\n */\nexport function adjustCellsToContainer(\n  containerWidth: number,\n  cellSizeCache: CellSizeCache,\n  pinnedColumns: string[],\n  unpinnedColumns: string[]\n): {\n  cellSizeCache: CellSizeCache;\n  ghost?: number | null;\n} {\n  const minRowSum = getSizeSum(cellSizeCache, 'row');\n  if (minRowSum >= containerWidth) {\n    // we apply the min Width to all cells\n    return {cellSizeCache: getMinCellSize(cellSizeCache)};\n  }\n\n  // if we have some room to expand\n  const columnOrder = getColumnOrder(pinnedColumns, unpinnedColumns);\n  return expandCellSize(cellSizeCache, columnOrder, containerWidth, containerWidth - minRowSum);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}