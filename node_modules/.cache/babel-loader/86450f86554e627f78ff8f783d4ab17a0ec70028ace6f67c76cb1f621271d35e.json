{"ast":null,"code":"var ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array';\nexport function getGLTypeFromTypedArray(arrayOrType) {\n  var type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n  switch (type) {\n    case Float32Array:\n      return 5126;\n    case Uint16Array:\n      return 5123;\n    case Uint32Array:\n      return 5125;\n    case Uint8Array:\n      return 5121;\n    case Uint8ClampedArray:\n      return 5121;\n    case Int8Array:\n      return 5120;\n    case Int16Array:\n      return 5122;\n    case Int32Array:\n      return 5124;\n    default:\n      throw new Error(ERR_TYPE_DEDUCTION);\n  }\n}\nexport function getTypedArrayFromGLType(glType) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref3$clamped = _ref3.clamped,\n    clamped = _ref3$clamped === void 0 ? true : _ref3$clamped;\n  switch (glType) {\n    case 5126:\n      return Float32Array;\n    case 5123:\n    case 33635:\n    case 32819:\n    case 32820:\n      return Uint16Array;\n    case 5125:\n      return Uint32Array;\n    case 5121:\n      return clamped ? Uint8ClampedArray : Uint8Array;\n    case 5120:\n      return Int8Array;\n    case 5122:\n      return Int16Array;\n    case 5124:\n      return Int32Array;\n    default:\n      throw new Error('Failed to deduce typed array type from GL constant');\n  }\n}\nexport function flipRows(_ref) {\n  var data = _ref.data,\n    width = _ref.width,\n    height = _ref.height,\n    _ref$bytesPerPixel = _ref.bytesPerPixel,\n    bytesPerPixel = _ref$bytesPerPixel === void 0 ? 4 : _ref$bytesPerPixel,\n    temp = _ref.temp;\n  var bytesPerRow = width * bytesPerPixel;\n  temp = temp || new Uint8Array(bytesPerRow);\n  for (var y = 0; y < height / 2; ++y) {\n    var topOffset = y * bytesPerRow;\n    var bottomOffset = (height - y - 1) * bytesPerRow;\n    temp.set(data.subarray(topOffset, topOffset + bytesPerRow));\n    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);\n    data.set(temp, bottomOffset);\n  }\n}\nexport function scalePixels(_ref2) {\n  var data = _ref2.data,\n    width = _ref2.width,\n    height = _ref2.height;\n  var newWidth = Math.round(width / 2);\n  var newHeight = Math.round(height / 2);\n  var newData = new Uint8Array(newWidth * newHeight * 4);\n  for (var y = 0; y < newHeight; y++) {\n    for (var x = 0; x < newWidth; x++) {\n      for (var c = 0; c < 4; c++) {\n        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];\n      }\n    }\n  }\n  return {\n    data: newData,\n    width: newWidth,\n    height: newHeight\n  };\n}","map":{"version":3,"names":["ERR_TYPE_DEDUCTION","getGLTypeFromTypedArray","arrayOrType","type","ArrayBuffer","isView","constructor","Float32Array","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","Int8Array","Int16Array","Int32Array","Error","getTypedArrayFromGLType","glType","_ref3","arguments","length","undefined","_ref3$clamped","clamped","flipRows","_ref","data","width","height","_ref$bytesPerPixel","bytesPerPixel","temp","bytesPerRow","y","topOffset","bottomOffset","set","subarray","copyWithin","scalePixels","_ref2","newWidth","Math","round","newHeight","newData","x","c"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@luma.gl/webgl/src/webgl-utils/typed-array-utils.js"],"sourcesContent":["import GL from '@luma.gl/constants';\n\nconst ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array';\n\n// Converts TYPED ARRAYS to corresponding GL constant\n// Used to auto deduce gl parameter types\nexport function getGLTypeFromTypedArray(arrayOrType) {\n  // If typed array, look up constructor\n  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n  switch (type) {\n    case Float32Array:\n      return GL.FLOAT;\n    case Uint16Array:\n      return GL.UNSIGNED_SHORT;\n    case Uint32Array:\n      return GL.UNSIGNED_INT;\n    case Uint8Array:\n      return GL.UNSIGNED_BYTE;\n    case Uint8ClampedArray:\n      return GL.UNSIGNED_BYTE;\n    case Int8Array:\n      return GL.BYTE;\n    case Int16Array:\n      return GL.SHORT;\n    case Int32Array:\n      return GL.INT;\n    default:\n      throw new Error(ERR_TYPE_DEDUCTION);\n  }\n}\n\n// Converts GL constant to corresponding TYPED ARRAY\n// Used to auto deduce gl parameter types\n\n/* eslint-disable complexity */\nexport function getTypedArrayFromGLType(glType, {clamped = true} = {}) {\n  // Sorted in some order of likelihood to reduce amount of comparisons\n  switch (glType) {\n    case GL.FLOAT:\n      return Float32Array;\n    case GL.UNSIGNED_SHORT:\n    case GL.UNSIGNED_SHORT_5_6_5:\n    case GL.UNSIGNED_SHORT_4_4_4_4:\n    case GL.UNSIGNED_SHORT_5_5_5_1:\n      return Uint16Array;\n    case GL.UNSIGNED_INT:\n      return Uint32Array;\n    case GL.UNSIGNED_BYTE:\n      return clamped ? Uint8ClampedArray : Uint8Array;\n    case GL.BYTE:\n      return Int8Array;\n    case GL.SHORT:\n      return Int16Array;\n    case GL.INT:\n      return Int32Array;\n    default:\n      throw new Error('Failed to deduce typed array type from GL constant');\n  }\n}\n/* eslint-enable complexity */\n\n// Flip rows (can be used on arrays returned from `Framebuffer.readPixels`)\n// https://stackoverflow.com/questions/41969562/\n// how-can-i-flip-the-result-of-webglrenderingcontext-readpixels\nexport function flipRows({data, width, height, bytesPerPixel = 4, temp}) {\n  const bytesPerRow = width * bytesPerPixel;\n\n  // make a temp buffer to hold one row\n  temp = temp || new Uint8Array(bytesPerRow);\n  for (let y = 0; y < height / 2; ++y) {\n    const topOffset = y * bytesPerRow;\n    const bottomOffset = (height - y - 1) * bytesPerRow;\n    // make copy of a row on the top half\n    temp.set(data.subarray(topOffset, topOffset + bytesPerRow));\n    // copy a row from the bottom half to the top\n    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);\n    // copy the copy of the top half row to the bottom half\n    data.set(temp, bottomOffset);\n  }\n}\n\nexport function scalePixels({data, width, height}) {\n  const newWidth = Math.round(width / 2);\n  const newHeight = Math.round(height / 2);\n  const newData = new Uint8Array(newWidth * newHeight * 4);\n  for (let y = 0; y < newHeight; y++) {\n    for (let x = 0; x < newWidth; x++) {\n      for (let c = 0; c < 4; c++) {\n        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];\n      }\n    }\n  }\n  return {data: newData, width: newWidth, height: newHeight};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}