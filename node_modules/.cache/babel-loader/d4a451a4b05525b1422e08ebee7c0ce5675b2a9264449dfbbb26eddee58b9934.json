{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDefaultFilter = getDefaultFilter;\nexports.shouldApplyFilter = shouldApplyFilter;\nexports.validatePolygonFilter = validatePolygonFilter;\nexports.validateFilter = validateFilter;\nexports.validateFilterWithData = validateFilterWithData;\nexports.getFilterProps = getFilterProps;\nexports.getFilterFunction = getFilterFunction;\nexports.updateFilterDataId = updateFilterDataId;\nexports.filterDataByFilterTypes = filterDataByFilterTypes;\nexports.getFilterRecord = getFilterRecord;\nexports.diffFilters = diffFilters;\nexports.adjustValueToFilterDomain = adjustValueToFilterDomain;\nexports.getNumericFieldDomain = getNumericFieldDomain;\nexports.getNumericStepSize = getNumericStepSize;\nexports.getTimestampFieldDomain = getTimestampFieldDomain;\nexports.histogramConstruct = histogramConstruct;\nexports.getHistogram = getHistogram;\nexports.formatNumberByStep = formatNumberByStep;\nexports.isInRange = isInRange;\nexports.isInPolygon = isInPolygon;\nexports.getTimeWidgetTitleFormatter = getTimeWidgetTitleFormatter;\nexports.isFilterValidToSave = isFilterValidToSave;\nexports.isValidFilterValue = isValidFilterValue;\nexports.getColumnFilterProps = getColumnFilterProps;\nexports.getDefaultFilterPlotType = getDefaultFilterPlotType;\nexports.applyFiltersToDatasets = applyFiltersToDatasets;\nexports.applyFilterFieldName = applyFilterFieldName;\nexports.mergeFilterDomainStep = mergeFilterDomainStep;\nexports.generatePolygonFilter = generatePolygonFilter;\nexports.filterDatasetCPU = filterDatasetCPU;\nexports.validateFiltersUpdateDatasets = validateFiltersUpdateDatasets;\nexports.getFilterPlot = getFilterPlot;\nexports.getIntervalBins = getIntervalBins;\nexports.isValidTimeDomain = isValidTimeDomain;\nexports.getTimeWidgetHintFormatter = getTimeWidgetHintFormatter;\nexports.getFilterIdInFeature = exports.featureToFilterValue = exports.getPolygonFilterFunctor = exports.LAYER_FILTERS = exports.FILTER_ID_LENGTH = exports.DEFAULT_FILTER_STRUCTURE = exports.FILTER_COMPONENTS = exports.LIMITED_FILTER_EFFECT_PROPS = exports.FILTER_UPDATER_PROPS = exports.enlargedHistogramBins = exports.histogramBins = exports.TimestampStepMap = exports.durationYear = exports.durationWeek = exports.durationDay = exports.durationHour = exports.durationMinute = exports.durationSecond = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _d3Array = require(\"d3-array\");\nvar _keymirror = _interopRequireDefault(require(\"keymirror\"));\nvar _console = _interopRequireDefault(require(\"global/console\"));\nvar _lodash = _interopRequireDefault(require(\"lodash.get\"));\nvar _lodash2 = _interopRequireDefault(require(\"lodash.isequal\"));\nvar _booleanWithin = _interopRequireDefault(require(\"@turf/boolean-within\"));\nvar _helpers = require(\"@turf/helpers\");\nvar _decimal = require(\"decimal.js\");\nvar _constants = require(\"@kepler.gl/constants\");\nvar ScaleUtils = _interopRequireWildcard(require(\"./data-scale-utils\"));\nvar _h3Js = require(\"h3-js\");\nvar _utils = require(\"./utils\");\nvar _dataUtils = require(\"./data-utils\");\nvar _h3Utils = require(\"./h3-utils\");\nvar _FILTER_TYPES$timeRan, _FILTER_TYPES$range, _SupportedPlotType, _FILTER_COMPONENTS;\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar durationSecond = 1000;\nexports.durationSecond = durationSecond;\nvar durationMinute = durationSecond * 60;\nexports.durationMinute = durationMinute;\nvar durationHour = durationMinute * 60;\nexports.durationHour = durationHour;\nvar durationDay = durationHour * 24;\nexports.durationDay = durationDay;\nvar durationWeek = durationDay * 7;\nexports.durationWeek = durationWeek;\nvar durationYear = durationDay * 365;\nexports.durationYear = durationYear;\nvar TimestampStepMap = [{\n  max: 1,\n  step: 0.05\n}, {\n  max: 10,\n  step: 0.1\n}, {\n  max: 100,\n  step: 1\n}, {\n  max: 500,\n  step: 5\n}, {\n  max: 1000,\n  step: 10\n}, {\n  max: 5000,\n  step: 50\n}, {\n  max: Number.POSITIVE_INFINITY,\n  step: 1000\n}];\nexports.TimestampStepMap = TimestampStepMap;\nvar histogramBins = 30;\nexports.histogramBins = histogramBins;\nvar enlargedHistogramBins = 100;\nexports.enlargedHistogramBins = enlargedHistogramBins;\nvar FILTER_UPDATER_PROPS = (0, _keymirror[\"default\"])({\n  dataId: null,\n  name: null,\n  layerId: null\n});\nexports.FILTER_UPDATER_PROPS = FILTER_UPDATER_PROPS;\nvar LIMITED_FILTER_EFFECT_PROPS = (0, _keymirror[\"default\"])((0, _defineProperty2[\"default\"])({}, FILTER_UPDATER_PROPS.name, null));\n/**\n * Max number of filter value buffers that deck.gl provides\n */\n\nexports.LIMITED_FILTER_EFFECT_PROPS = LIMITED_FILTER_EFFECT_PROPS;\nvar SupportedPlotType = (_SupportedPlotType = {}, (0, _defineProperty2[\"default\"])(_SupportedPlotType, _constants.FILTER_TYPES.timeRange, (_FILTER_TYPES$timeRan = {\n  \"default\": 'histogram'\n}, (0, _defineProperty2[\"default\"])(_FILTER_TYPES$timeRan, _constants.ALL_FIELD_TYPES.integer, 'lineChart'), (0, _defineProperty2[\"default\"])(_FILTER_TYPES$timeRan, _constants.ALL_FIELD_TYPES.real, 'lineChart'), _FILTER_TYPES$timeRan)), (0, _defineProperty2[\"default\"])(_SupportedPlotType, _constants.FILTER_TYPES.range, (_FILTER_TYPES$range = {\n  \"default\": 'histogram'\n}, (0, _defineProperty2[\"default\"])(_FILTER_TYPES$range, _constants.ALL_FIELD_TYPES.integer, 'lineChart'), (0, _defineProperty2[\"default\"])(_FILTER_TYPES$range, _constants.ALL_FIELD_TYPES.real, 'lineChart'), _FILTER_TYPES$range)), _SupportedPlotType);\nvar FILTER_COMPONENTS = (_FILTER_COMPONENTS = {}, (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _constants.FILTER_TYPES.select, 'SingleSelectFilter'), (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _constants.FILTER_TYPES.multiSelect, 'MultiSelectFilter'), (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _constants.FILTER_TYPES.timeRange, 'TimeRangeFilter'), (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _constants.FILTER_TYPES.range, 'RangeFilter'), (0, _defineProperty2[\"default\"])(_FILTER_COMPONENTS, _constants.FILTER_TYPES.polygon, 'PolygonFilter'), _FILTER_COMPONENTS);\nexports.FILTER_COMPONENTS = FILTER_COMPONENTS;\nvar DEFAULT_FILTER_STRUCTURE = {\n  dataId: [],\n  // [string]\n  freeze: false,\n  id: null,\n  // time range filter specific\n  fixedDomain: false,\n  enlarged: false,\n  isAnimating: false,\n  animationWindow: _constants.ANIMATION_WINDOW.free,\n  speed: 1,\n  // field specific\n  name: [],\n  // string\n  type: null,\n  fieldIdx: [],\n  // [integer]\n  domain: null,\n  value: null,\n  // plot\n  plotType: _constants.PLOT_TYPES.histogram,\n  yAxis: null,\n  interval: null,\n  // mode\n  gpu: false\n};\nexports.DEFAULT_FILTER_STRUCTURE = DEFAULT_FILTER_STRUCTURE;\nvar FILTER_ID_LENGTH = 4;\nexports.FILTER_ID_LENGTH = FILTER_ID_LENGTH;\nvar LAYER_FILTERS = [_constants.FILTER_TYPES.polygon];\n/**\n * Generates a filter with a dataset id as dataId\n */\n\nexports.LAYER_FILTERS = LAYER_FILTERS;\nfunction getDefaultFilter(dataId) {\n  return _objectSpread(_objectSpread({}, DEFAULT_FILTER_STRUCTURE), {}, {\n    // store it as dataId and it could be one or many\n    dataId: (0, _utils.toArray)(dataId),\n    id: (0, _utils.generateHashId)(FILTER_ID_LENGTH)\n  });\n}\n/**\n * Check if a filter is valid based on the given dataId\n * @param  filter to validate\n * @param  datasetId id to validate filter against\n * @return true if a filter is valid, false otherwise\n */\n\nfunction shouldApplyFilter(filter, datasetId) {\n  var dataIds = (0, _utils.toArray)(filter.dataId);\n  return dataIds.includes(datasetId) && filter.value !== null;\n}\n\n/**\n * Validates and modifies polygon filter structure\n * @param dataset\n * @param filter\n * @param layers\n * @return - {filter, dataset}\n */\nfunction validatePolygonFilter(dataset, filter, layers) {\n  var failed = {\n    dataset: dataset,\n    filter: null\n  };\n  var value = filter.value,\n    layerId = filter.layerId,\n    type = filter.type,\n    dataId = filter.dataId;\n  if (!layerId || !isValidFilterValue(type, value)) {\n    return failed;\n  }\n  var isValidDataset = dataId.includes(dataset.id);\n  if (!isValidDataset) {\n    return failed;\n  }\n  var layer = layers.find(function (l) {\n    return layerId.includes(l.id);\n  });\n  if (!layer) {\n    return failed;\n  }\n  return {\n    filter: _objectSpread(_objectSpread({}, filter), {}, {\n      freeze: true,\n      fieldIdx: []\n    }),\n    dataset: dataset\n  };\n}\n/**\n * Custom filter validators\n */\n\nvar filterValidators = (0, _defineProperty2[\"default\"])({}, _constants.FILTER_TYPES.polygon, validatePolygonFilter);\n/**\n * Default validate filter function\n * @param dataset\n * @param filter\n * @return - {filter, dataset}\n */\n\nfunction validateFilter(dataset, filter) {\n  // match filter.dataId\n  var failed = {\n    dataset: dataset,\n    filter: null\n  };\n  var filterDataId = (0, _utils.toArray)(filter.dataId);\n  var filterDatasetIndex = filterDataId.indexOf(dataset.id);\n  if (filterDatasetIndex < 0 || !(0, _utils.toArray)(filter.name)[filterDatasetIndex]) {\n    // the current filter is not mapped against the current dataset\n    return failed;\n  }\n  var initializeFilter = _objectSpread(_objectSpread(_objectSpread({}, getDefaultFilter(filter.dataId)), filter), {}, {\n    dataId: filterDataId,\n    name: (0, _utils.toArray)(filter.name)\n  });\n  var fieldName = initializeFilter.name[filterDatasetIndex];\n  var _applyFilterFieldName = applyFilterFieldName(initializeFilter, dataset, fieldName, filterDatasetIndex, {\n      mergeDomain: true\n    }),\n    updatedFilter = _applyFilterFieldName.filter,\n    updatedDataset = _applyFilterFieldName.dataset;\n  if (!updatedFilter) {\n    return failed;\n  }\n  updatedFilter.value = adjustValueToFilterDomain(filter.value, updatedFilter);\n  updatedFilter.enlarged = typeof filter.enlarged === 'boolean' ? filter.enlarged : updatedFilter.enlarged;\n  if (updatedFilter.value === null) {\n    // cannot adjust saved value to filter\n    return failed;\n  }\n  return {\n    filter: validateFilterYAxis(updatedFilter, updatedDataset),\n    dataset: updatedDataset\n  };\n}\n/**\n * Validate saved filter config with new data,\n * calculate domain and fieldIdx based new fields and data\n *\n * @param dataset\n * @param filter - filter to be validate\n * @param layers - layers\n * @return validated filter\n */\n\nfunction validateFilterWithData(dataset, filter, layers) {\n  return filter.type && filterValidators.hasOwnProperty(filter.type) ? filterValidators[filter.type](dataset, filter, layers) : validateFilter(dataset, filter);\n}\n/**\n * Validate YAxis\n * @param filter\n * @param dataset\n * @return {*}\n */\n\nfunction validateFilterYAxis(filter, dataset) {\n  // TODO: validate yAxis against other datasets\n  var fields = dataset.fields;\n  var _filter = filter,\n    yAxis = _filter.yAxis; // TODO: validate yAxis against other datasets\n\n  if (yAxis) {\n    var matchedAxis = fields.find(function (_ref) {\n      var name = _ref.name,\n        type = _ref.type;\n      return name === yAxis.name && type === yAxis.type;\n    });\n    filter = matchedAxis ? _objectSpread(_objectSpread({}, filter), {}, {\n      yAxis: matchedAxis\n    }, getFilterPlot(_objectSpread(_objectSpread({}, filter), {}, {\n      yAxis: matchedAxis\n    }), dataset)) : filter;\n  }\n  return filter;\n}\n/**\n * Get default filter prop based on field type\n *\n * @param field\n * @param fieldDomain\n * @returns default filter\n */\n\nfunction getFilterProps(field, fieldDomain) {\n  var filterProps = _objectSpread(_objectSpread({}, fieldDomain), {}, {\n    fieldType: field.type\n  });\n  switch (field.type) {\n    case _constants.ALL_FIELD_TYPES.real:\n    case _constants.ALL_FIELD_TYPES.integer:\n      return _objectSpread(_objectSpread({}, filterProps), {}, {\n        value: fieldDomain.domain,\n        type: _constants.FILTER_TYPES.range,\n        // @ts-expect-error\n        typeOptions: [_constants.FILTER_TYPES.range],\n        gpu: true\n      });\n    case _constants.ALL_FIELD_TYPES[\"boolean\"]:\n      // @ts-expect-error\n      return _objectSpread(_objectSpread({}, filterProps), {}, {\n        type: _constants.FILTER_TYPES.select,\n        value: true,\n        gpu: false\n      });\n    case _constants.ALL_FIELD_TYPES.string:\n    case _constants.ALL_FIELD_TYPES.date:\n      // @ts-expect-error\n      return _objectSpread(_objectSpread({}, filterProps), {}, {\n        type: _constants.FILTER_TYPES.multiSelect,\n        value: [],\n        gpu: false\n      });\n    case _constants.ALL_FIELD_TYPES.timestamp:\n      // @ts-expect-error\n      return _objectSpread(_objectSpread({}, filterProps), {}, {\n        type: _constants.FILTER_TYPES.timeRange,\n        enlarged: true,\n        fixedDomain: true,\n        value: filterProps.domain,\n        gpu: true\n      });\n    default:\n      // @ts-expect-error\n      return {};\n  }\n}\nvar getPolygonFilterFunctor = function getPolygonFilterFunctor(layer, filter, dataContainer) {\n  var getPosition = layer.getPositionAccessor(dataContainer);\n  switch (layer.type) {\n    case _constants.LAYER_TYPES.point:\n    case _constants.LAYER_TYPES.icon:\n      return function (data) {\n        var pos = getPosition(data);\n        return pos.every(Number.isFinite) && isInPolygon(pos, filter.value);\n      };\n    case _constants.LAYER_TYPES.arc:\n    case _constants.LAYER_TYPES.line:\n      return function (data) {\n        var pos = getPosition(data);\n        return pos.every(Number.isFinite) && [[pos[0], pos[1]], [pos[3], pos[4]]].every(function (point) {\n          return isInPolygon(point, filter.value);\n        });\n      };\n    case _constants.LAYER_TYPES.hexagonId:\n      if (layer.dataToFeature && layer.dataToFeature.centroids) {\n        return function (data) {\n          // null or getCentroid({id})\n          var centroid = layer.dataToFeature.centroids[data.index];\n          return centroid && isInPolygon(centroid, filter.value);\n        };\n      }\n      return function (data) {\n        var id = getPosition(data);\n        if (!(0, _h3Js.h3IsValid)(id)) {\n          return false;\n        }\n        var pos = (0, _h3Utils.getCentroid)({\n          id: id\n        });\n        return pos.every(Number.isFinite) && isInPolygon(pos, filter.value);\n      };\n    default:\n      return function () {\n        return true;\n      };\n  }\n};\n/**\n * @param param An object that represents a row record.\n * @param param.index Index of the row in data container.\n * @returns Returns true to keep the element, or false otherwise.\n */\n\nexports.getPolygonFilterFunctor = getPolygonFilterFunctor;\n\n/**\n * @param field dataset Field\n * @param dataId Dataset id\n * @param filter Filter object\n * @param layers list of layers to filter upon\n * @param dataContainer Data container\n * @return filterFunction\n */\n\n/* eslint-disable complexity */\nfunction getFilterFunction(field, dataId, filter, layers, dataContainer) {\n  // field could be null in polygon filter\n  var valueAccessor = field ? field.valueAccessor : function (data) {\n    return null;\n  };\n  var defaultFunc = function defaultFunc(d) {\n    return true;\n  };\n  switch (filter.type) {\n    case _constants.FILTER_TYPES.range:\n      return function (data) {\n        return isInRange(valueAccessor(data), filter.value);\n      };\n    case _constants.FILTER_TYPES.multiSelect:\n      return function (data) {\n        return filter.value.includes(valueAccessor(data));\n      };\n    case _constants.FILTER_TYPES.select:\n      return function (data) {\n        return valueAccessor(data) === filter.value;\n      };\n    case _constants.FILTER_TYPES.timeRange:\n      if (!field) {\n        return defaultFunc;\n      }\n      var mappedValue = (0, _lodash[\"default\"])(field, ['filterProps', 'mappedValue']);\n      var accessor = Array.isArray(mappedValue) ? function (data) {\n        return mappedValue[data.index];\n      } : function (data) {\n        return (0, _dataUtils.timeToUnixMilli)(valueAccessor(data), field.format);\n      };\n      return function (data) {\n        return isInRange(accessor(data), filter.value);\n      };\n    case _constants.FILTER_TYPES.polygon:\n      if (!layers || !layers.length || !filter.layerId) {\n        return defaultFunc;\n      }\n      var layerFilterFunctions = filter.layerId.map(function (id) {\n        return layers.find(function (l) {\n          return l.id === id;\n        });\n      }).filter(function (l) {\n        return l && l.config.dataId === dataId;\n      }).map(function (layer) {\n        return getPolygonFilterFunctor(layer, filter, dataContainer);\n      });\n      return function (data) {\n        return layerFilterFunctions.every(function (filterFunc) {\n          return filterFunc(data);\n        });\n      };\n    default:\n      return defaultFunc;\n  }\n}\nfunction updateFilterDataId(dataId) {\n  return getDefaultFilter(dataId);\n}\nfunction filterDataByFilterTypes(_ref2, dataContainer) {\n  var dynamicDomainFilters = _ref2.dynamicDomainFilters,\n    cpuFilters = _ref2.cpuFilters,\n    filterFuncs = _ref2.filterFuncs;\n  var filteredIndexForDomain = [];\n  var filteredIndex = [];\n  var filterContext = {\n    index: -1,\n    dataContainer: dataContainer\n  };\n  var filterFuncCaller = function filterFuncCaller(filter) {\n    return filterFuncs[filter.id](filterContext);\n  };\n  var numRows = dataContainer.numRows();\n  for (var i = 0; i < numRows; ++i) {\n    filterContext.index = i;\n    var matchForDomain = dynamicDomainFilters && dynamicDomainFilters.every(filterFuncCaller);\n    if (matchForDomain) {\n      filteredIndexForDomain.push(filterContext.index);\n    }\n    var matchForRender = cpuFilters && cpuFilters.every(filterFuncCaller);\n    if (matchForRender) {\n      filteredIndex.push(filterContext.index);\n    }\n  }\n  return _objectSpread(_objectSpread({}, dynamicDomainFilters ? {\n    filteredIndexForDomain: filteredIndexForDomain\n  } : {}), cpuFilters ? {\n    filteredIndex: filteredIndex\n  } : {});\n}\n/**\n * Get a record of filters based on domain type and gpu / cpu\n */\n\nfunction getFilterRecord(dataId, filters) {\n  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var filterRecord = {\n    dynamicDomain: [],\n    fixedDomain: [],\n    cpu: [],\n    gpu: []\n  };\n  filters.forEach(function (f) {\n    if (isValidFilterValue(f.type, f.value) && (0, _utils.toArray)(f.dataId).includes(dataId)) {\n      (f.fixedDomain || opt.ignoreDomain ? filterRecord.fixedDomain : filterRecord.dynamicDomain).push(f);\n      (f.gpu && !opt.cpuOnly ? filterRecord.gpu : filterRecord.cpu).push(f);\n    }\n  });\n  return filterRecord;\n}\n/**\n * Compare filter records to get what has changed\n */\n\nfunction diffFilters(filterRecord) {\n  var oldFilterRecord = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var filterChanged = {};\n  Object.entries(filterRecord).forEach(function (_ref3) {\n    var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n      record = _ref4[0],\n      items = _ref4[1];\n    items.forEach(function (filter) {\n      var oldFilter = (oldFilterRecord[record] || []).find(function (f) {\n        return f.id === filter.id;\n      });\n      if (!oldFilter) {\n        // added\n        filterChanged = (0, _utils.set)([record, filter.id], 'added', filterChanged);\n      } else {\n        // check  what has changed\n        ['name', 'value', 'dataId'].forEach(function (prop) {\n          if (filter[prop] !== oldFilter[prop]) {\n            filterChanged = (0, _utils.set)([record, filter.id], \"\".concat(prop, \"_changed\"), filterChanged);\n          }\n        });\n      }\n    });\n    (oldFilterRecord[record] || []).forEach(function (oldFilter) {\n      // deleted\n      if (!items.find(function (f) {\n        return f.id === oldFilter.id;\n      })) {\n        filterChanged = (0, _utils.set)([record, oldFilter.id], 'deleted', filterChanged);\n      }\n    });\n  });\n  return _objectSpread(_objectSpread({}, {\n    dynamicDomain: null,\n    fixedDomain: null,\n    cpu: null,\n    gpu: null\n  }), filterChanged);\n}\n/**\n * Call by parsing filters from URL\n * Check if value of filter within filter domain, if not adjust it to match\n * filter domain\n *\n * @returns value - adjusted value to match filter or null to remove filter\n */\n// eslint-disable-next-line complexity\n\nfunction adjustValueToFilterDomain(value, _ref5) {\n  var domain = _ref5.domain,\n    type = _ref5.type;\n  if (!type) {\n    return false;\n  } // if the current filter is a polygon it will not have any domain\n  // all other filter types require domain\n\n  if (type !== _constants.FILTER_TYPES.polygon && !domain) {\n    return false;\n  }\n  switch (type) {\n    case _constants.FILTER_TYPES.range:\n    case _constants.FILTER_TYPES.timeRange:\n      if (!Array.isArray(value) || value.length !== 2) {\n        return domain.map(function (d) {\n          return d;\n        });\n      }\n      return value.map(function (d, i) {\n        return (0, _dataUtils.notNullorUndefined)(d) && isInRange(d, domain) ? d : domain[i];\n      });\n    case _constants.FILTER_TYPES.multiSelect:\n      if (!Array.isArray(value)) {\n        return [];\n      }\n      var filteredValue = value.filter(function (d) {\n        return domain.includes(d);\n      });\n      return filteredValue.length ? filteredValue : [];\n    case _constants.FILTER_TYPES.select:\n      return domain.includes(value) ? value : true;\n    case _constants.FILTER_TYPES.polygon:\n      return value;\n    default:\n      return null;\n  }\n}\n/* eslint-enable complexity */\n\n/**\n * Calculate numeric domain and suitable step\n */\n\nfunction getNumericFieldDomain(dataContainer, valueAccessor) {\n  var domain = [0, 1];\n  var step = 0.1;\n  var mappedValue = dataContainer.mapIndex(valueAccessor);\n  if (dataContainer.numRows() > 1) {\n    domain = ScaleUtils.getLinearDomain(mappedValue);\n    var diff = domain[1] - domain[0]; // in case equal domain, [96, 96], which will break quantize scale\n\n    if (!diff) {\n      domain[1] = domain[0] + 1;\n    }\n    step = getNumericStepSize(diff) || step;\n    domain[0] = formatNumberByStep(domain[0], step, 'floor');\n    domain[1] = formatNumberByStep(domain[1], step, 'ceil');\n  }\n  var _getHistogram = getHistogram(domain, mappedValue),\n    histogram = _getHistogram.histogram,\n    enlargedHistogram = _getHistogram.enlargedHistogram;\n  return {\n    domain: domain,\n    step: step,\n    histogram: histogram,\n    enlargedHistogram: enlargedHistogram\n  };\n}\n/**\n * Calculate step size for range and timerange filter\n */\n\nfunction getNumericStepSize(diff) {\n  diff = Math.abs(diff);\n  if (diff > 100) {\n    return 1;\n  } else if (diff > 3) {\n    return 0.01;\n  } else if (diff > 1) {\n    return 0.001;\n  } // Try to get at least 1000 steps - and keep the step size below that of\n  // the (diff > 1) case.\n\n  var x = diff / 1000; // Find the exponent and truncate to 10 to the power of that exponent\n\n  var exponentialForm = x.toExponential();\n  var exponent = parseFloat(exponentialForm.split('e')[1]); // Getting ready for node 12\n  // this is why we need decimal.js\n  // Math.pow(10, -5) = 0.000009999999999999999\n  // the above result shows in browser and node 10\n  // node 12 behaves correctly\n\n  return new _decimal.Decimal(10).pow(exponent).toNumber();\n}\n/**\n * Calculate timestamp domain and suitable step\n */\n\nfunction getTimestampFieldDomain(dataContainer, valueAccessor) {\n  // to avoid converting string format time to epoch\n  // every time we compare we store a value mapped to int in filter domain\n  var mappedValue = dataContainer.mapIndex(valueAccessor);\n  var domain = ScaleUtils.getLinearDomain(mappedValue);\n  var defaultTimeFormat = getTimeWidgetTitleFormatter(domain);\n  var step = 0.01;\n  var diff = domain[1] - domain[0];\n  var entry = TimestampStepMap.find(function (f) {\n    return f.max >= diff;\n  });\n  if (entry) {\n    step = entry.step;\n  }\n  var _getHistogram2 = getHistogram(domain, mappedValue),\n    histogram = _getHistogram2.histogram,\n    enlargedHistogram = _getHistogram2.enlargedHistogram;\n  return {\n    domain: domain,\n    step: step,\n    mappedValue: mappedValue,\n    histogram: histogram,\n    enlargedHistogram: enlargedHistogram,\n    defaultTimeFormat: defaultTimeFormat\n  };\n}\nfunction histogramConstruct(domain, mappedValue, bins) {\n  return (0, _d3Array.histogram)().thresholds((0, _d3Array.ticks)(domain[0], domain[1], bins)).domain(domain)(mappedValue).map(function (bin) {\n    return {\n      count: bin.length,\n      bin: bin,\n      x0: bin.x0,\n      x1: bin.x1\n    };\n  });\n}\n/**\n * Calculate histogram from domain and array of values\n */\n\nfunction getHistogram(domain, mappedValue) {\n  var histogram = histogramConstruct(domain, mappedValue, histogramBins);\n  var enlargedHistogram = histogramConstruct(domain, mappedValue, enlargedHistogramBins);\n  return {\n    histogram: histogram,\n    enlargedHistogram: enlargedHistogram\n  };\n}\n/**\n * round number based on step\n *\n * @param {Number} val\n * @param {Number} step\n * @param {string} bound\n * @returns {Number} rounded number\n */\n\nfunction formatNumberByStep(val, step, bound) {\n  if (bound === 'floor') {\n    return Math.floor(val * (1 / step)) / (1 / step);\n  }\n  return Math.ceil(val * (1 / step)) / (1 / step);\n}\nfunction isInRange(val, domain) {\n  if (!Array.isArray(domain)) {\n    return false;\n  }\n  return val >= domain[0] && val <= domain[1];\n}\n/**\n * Determines whether a point is within the provided polygon\n *\n * @param point as input search [lat, lng]\n * @param polygon Points must be within these (Multi)Polygon(s)\n * @return {boolean}\n */\n\nfunction isInPolygon(point, polygon) {\n  return (0, _booleanWithin[\"default\"])((0, _helpers.point)(point), polygon);\n}\nfunction getTimeWidgetTitleFormatter(domain) {\n  if (!isValidTimeDomain(domain)) {\n    return null;\n  }\n  var diff = domain[1] - domain[0]; // Local aware formats\n  // https://momentjs.com/docs/#/parsing/string-format\n\n  return diff > durationYear ? 'L' : diff > durationDay ? 'L LT' : 'L LTS';\n}\n/**\n * Sanity check on filters to prepare for save\n * @type {typeof import('./filter-utils').isFilterValidToSave}\n */\n\nfunction isFilterValidToSave(filter) {\n  return (filter === null || filter === void 0 ? void 0 : filter.type) && Array.isArray(filter === null || filter === void 0 ? void 0 : filter.name) && ((filter === null || filter === void 0 ? void 0 : filter.name.length) || (filter === null || filter === void 0 ? void 0 : filter.layerId.length)) && isValidFilterValue(filter === null || filter === void 0 ? void 0 : filter.type, filter === null || filter === void 0 ? void 0 : filter.value);\n}\n/**\n * Sanity check on filters to prepare for save\n * @type {typeof import('./filter-utils').isValidFilterValue}\n */\n\n/* eslint-disable complexity */\n\nfunction isValidFilterValue(type, value) {\n  if (!type) {\n    return false;\n  }\n  switch (type) {\n    case _constants.FILTER_TYPES.select:\n      return value === true || value === false;\n    case _constants.FILTER_TYPES.range:\n    case _constants.FILTER_TYPES.timeRange:\n      return Array.isArray(value) && value.every(function (v) {\n        return v !== null && !isNaN(v);\n      });\n    case _constants.FILTER_TYPES.multiSelect:\n      return Array.isArray(value) && Boolean(value.length);\n    case _constants.FILTER_TYPES.input:\n      return Boolean(value.length);\n    case _constants.FILTER_TYPES.polygon:\n      var coordinates = (0, _lodash[\"default\"])(value, ['geometry', 'coordinates']);\n      return Boolean(value && value.id && coordinates);\n    default:\n      return true;\n  }\n}\nfunction getColumnFilterProps(filter, dataset) {\n  if (filter.plotType === _constants.PLOT_TYPES.histogram || !filter.yAxis) {\n    // histogram should be calculated when create filter\n    return {};\n  }\n  var _filter$mappedValue = filter.mappedValue,\n    mappedValue = _filter$mappedValue === void 0 ? [] : _filter$mappedValue;\n  var yAxis = filter.yAxis;\n  var fieldIdx = dataset.getColumnFieldIdx(yAxis.name);\n  if (fieldIdx < 0) {\n    _console[\"default\"].warn(\"yAxis \".concat(yAxis.name, \" does not exist in dataset\"));\n    return {\n      lineChart: {},\n      yAxis: yAxis\n    };\n  } // return lineChart\n\n  var series = dataset.dataContainer.map(function (row, rowIndex) {\n    return {\n      x: mappedValue[rowIndex],\n      y: row.valueAt(fieldIdx)\n    };\n  }, true).filter(function (_ref6) {\n    var x = _ref6.x,\n      y = _ref6.y;\n    return Number.isFinite(x) && Number.isFinite(y);\n  }).sort(function (a, b) {\n    return (0, _d3Array.ascending)(a.x, b.x);\n  });\n  var yDomain = (0, _d3Array.extent)(series, function (d) {\n    return d.y;\n  });\n  var xDomain = [series[0].x, series[series.length - 1].x];\n  return {\n    lineChart: {\n      series: series,\n      yDomain: yDomain,\n      xDomain: xDomain\n    },\n    yAxis: yAxis\n  };\n}\nfunction getDefaultFilterPlotType(filter) {\n  var filterPlotTypes = filter.type && SupportedPlotType[filter.type];\n  if (!filterPlotTypes) {\n    return null;\n  }\n  if (!filter.yAxis) {\n    return filterPlotTypes[\"default\"];\n  }\n  return filterPlotTypes[filter.yAxis.type] || null;\n}\n/**\n *\n * @param datasetIds list of dataset ids to be filtered\n * @param datasets all datasets\n * @param filters all filters to be applied to datasets\n * @return datasets - new updated datasets\n */\n\nfunction applyFiltersToDatasets(datasetIds, datasets, filters, layers) {\n  var dataIds = (0, _utils.toArray)(datasetIds);\n  return dataIds.reduce(function (acc, dataId) {\n    var layersToFilter = (layers || []).filter(function (l) {\n      return l.config.dataId === dataId;\n    });\n    var appliedFilters = filters.filter(function (d) {\n      return shouldApplyFilter(d, dataId);\n    });\n    var table = datasets[dataId];\n    return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, dataId, table.filterTable(appliedFilters, layersToFilter, {})));\n  }, datasets);\n}\n/**\n * Applies a new field name value to fielter and update both filter and dataset\n * @param filter - to be applied the new field name on\n * @param dataset - dataset the field belongs to\n * @param fieldName - field.name\n * @param filterDatasetIndex - field.name\n * @param option\n * @return - {filter, datasets}\n */\n\nfunction applyFilterFieldName(filter, dataset, fieldName) {\n  var filterDatasetIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var option = arguments.length > 4 ? arguments[4] : undefined;\n  // using filterDatasetIndex we can filter only the specified dataset\n  var mergeDomain = option && option.hasOwnProperty('mergeDomain') ? option.mergeDomain : false;\n  var fieldIndex = dataset.getColumnFieldIdx(fieldName); // if no field with same name is found, move to the next datasets\n\n  if (fieldIndex === -1) {\n    // throw new Error(`fieldIndex not found. Dataset must contain a property with name: ${fieldName}`);\n    return {\n      filter: null,\n      dataset: dataset\n    };\n  } // TODO: validate field type\n\n  var filterProps = dataset.getColumnFilterProps(fieldName);\n  var newFilter = _objectSpread(_objectSpread({}, mergeDomain ? mergeFilterDomainStep(filter, filterProps) : _objectSpread(_objectSpread({}, filter), filterProps)), {}, {\n    name: Object.assign((0, _toConsumableArray2[\"default\"])((0, _utils.toArray)(filter.name)), (0, _defineProperty2[\"default\"])({}, filterDatasetIndex, fieldName)),\n    fieldIdx: Object.assign((0, _toConsumableArray2[\"default\"])((0, _utils.toArray)(filter.fieldIdx)), (0, _defineProperty2[\"default\"])({}, filterDatasetIndex, fieldIndex)),\n    // TODO, since we allow to add multiple fields to a filter we can no longer freeze the filter\n    freeze: true\n  });\n  return {\n    filter: newFilter,\n    dataset: dataset\n  };\n}\n/**\n * Merge one filter with other filter prop domain\n */\n\n/* eslint-disable complexity */\n\nfunction mergeFilterDomainStep(filter, filterProps) {\n  if (!filter) {\n    return null;\n  }\n  if (!filterProps) {\n    return filter;\n  }\n  if (filter.fieldType && filter.fieldType !== filterProps.fieldType || !filterProps.domain) {\n    return filter;\n  }\n  var combinedDomain = !filter.domain ? filterProps.domain : [].concat((0, _toConsumableArray2[\"default\"])(filter.domain || []), (0, _toConsumableArray2[\"default\"])(filterProps.domain || [])).sort(function (a, b) {\n    return a - b;\n  });\n  var newFilter = _objectSpread(_objectSpread(_objectSpread({}, filter), filterProps), {}, {\n    domain: [combinedDomain[0], combinedDomain[combinedDomain.length - 1]]\n  });\n  switch (filterProps.fieldType) {\n    case _constants.ALL_FIELD_TYPES.string:\n    case _constants.ALL_FIELD_TYPES.date:\n      return _objectSpread(_objectSpread({}, newFilter), {}, {\n        domain: (0, _dataUtils.unique)(combinedDomain).sort()\n      });\n    case _constants.ALL_FIELD_TYPES.timestamp:\n      var step = filter.step < filterProps.step ? filter.step : filterProps.step;\n      return _objectSpread(_objectSpread({}, newFilter), {}, {\n        step: step\n      });\n    case _constants.ALL_FIELD_TYPES.real:\n    case _constants.ALL_FIELD_TYPES.integer:\n    default:\n      return newFilter;\n  }\n}\n/* eslint-enable complexity */\n\n/**\n * Generates polygon filter\n */\n\nvar featureToFilterValue = function featureToFilterValue(feature, filterId, properties) {\n  return _objectSpread(_objectSpread({}, feature), {}, {\n    id: feature.id,\n    properties: _objectSpread(_objectSpread(_objectSpread({}, feature.properties), properties), {}, {\n      filterId: filterId\n    })\n  });\n};\nexports.featureToFilterValue = featureToFilterValue;\nvar getFilterIdInFeature = function getFilterIdInFeature(f) {\n  return (0, _lodash[\"default\"])(f, ['properties', 'filterId']);\n};\n/**\n * Generates polygon filter\n */\n\nexports.getFilterIdInFeature = getFilterIdInFeature;\nfunction generatePolygonFilter(layers, feature) {\n  var dataId = layers.map(function (l) {\n    return l.config.dataId;\n  }).filter(_dataUtils.notNullorUndefined);\n  var layerId = layers.map(function (l) {\n    return l.id;\n  });\n  var name = layers.map(function (l) {\n    return l.config.label;\n  });\n  var filter = getDefaultFilter(dataId);\n  return _objectSpread(_objectSpread({}, filter), {}, {\n    fixedDomain: true,\n    type: _constants.FILTER_TYPES.polygon,\n    name: name,\n    layerId: layerId,\n    value: featureToFilterValue(feature, filter.id, {\n      isVisible: true\n    })\n  });\n}\n/**\n * Run filter entirely on CPU\n */\n\nfunction filterDatasetCPU(state, dataId) {\n  var datasetFilters = state.filters.filter(function (f) {\n    return f.dataId.includes(dataId);\n  });\n  var dataset = state.datasets[dataId];\n  if (!dataset) {\n    return state;\n  }\n  var cpuFilteredDataset = dataset.filterTableCPU(datasetFilters, state.layers);\n  return (0, _utils.set)(['datasets', dataId], cpuFilteredDataset, state);\n}\n/**\n * Validate parsed filters with datasets and add filterProps to field\n */\n\nfunction validateFiltersUpdateDatasets(state) {\n  var filtersToValidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  // TODO Better Typings here\n  var validated = [];\n  var failed = [];\n  var datasets = state.datasets;\n  var updatedDatasets = datasets; // merge filters\n\n  filtersToValidate.forEach(function (filter) {\n    // we can only look for datasets define in the filter dataId\n    var datasetIds = (0, _utils.toArray)(filter.dataId); // we can merge a filter only if all datasets in filter.dataId are loaded\n\n    if (datasetIds.every(function (d) {\n      return datasets[d];\n    })) {\n      // all datasetIds in filter must be present the state datasets\n      var _datasetIds$reduce = datasetIds.reduce(function (acc, datasetId) {\n          var dataset = updatedDatasets[datasetId];\n          var layers = state.layers.filter(function (l) {\n            return l.config.dataId === dataset.id;\n          });\n          var _validateFilterWithDa = validateFilterWithData(acc.augmentedDatasets[datasetId] || dataset, filter, layers),\n            updatedFilter = _validateFilterWithDa.filter,\n            updatedDataset = _validateFilterWithDa.dataset;\n          if (updatedFilter) {\n            return _objectSpread(_objectSpread({}, acc), {}, {\n              // merge filter props\n              filter: acc.filter ? _objectSpread(_objectSpread({}, acc.filter), mergeFilterDomainStep(acc, updatedFilter)) : updatedFilter,\n              applyToDatasets: [].concat((0, _toConsumableArray2[\"default\"])(acc.applyToDatasets), [datasetId]),\n              augmentedDatasets: _objectSpread(_objectSpread({}, acc.augmentedDatasets), {}, (0, _defineProperty2[\"default\"])({}, datasetId, updatedDataset))\n            });\n          }\n          return acc;\n        }, {\n          filter: null,\n          applyToDatasets: [],\n          augmentedDatasets: {}\n        }),\n        validatedFilter = _datasetIds$reduce.filter,\n        applyToDatasets = _datasetIds$reduce.applyToDatasets,\n        augmentedDatasets = _datasetIds$reduce.augmentedDatasets;\n      if (validatedFilter && (0, _lodash2[\"default\"])(datasetIds, applyToDatasets)) {\n        validated.push(validatedFilter);\n        updatedDatasets = _objectSpread(_objectSpread({}, updatedDatasets), augmentedDatasets);\n      }\n    } else {\n      failed.push(filter);\n    }\n  });\n  return {\n    validated: validated,\n    failed: failed,\n    updatedDatasets: updatedDatasets\n  };\n}\nfunction getFilterPlot(filter, dataset) {\n  if (filter.plotType === _constants.PLOT_TYPES.histogram || !filter.yAxis) {\n    // histogram should be calculated when create filter\n    return {};\n  }\n  var _filter$mappedValue2 = filter.mappedValue,\n    mappedValue = _filter$mappedValue2 === void 0 ? [] : _filter$mappedValue2;\n  var yAxis = filter.yAxis;\n  var fieldIdx = dataset.getColumnFieldIdx(yAxis.name);\n  if (fieldIdx < 0) {\n    _console[\"default\"].warn(\"yAxis \".concat(yAxis.name, \" does not exist in dataset\"));\n    return {\n      lineChart: {},\n      yAxis: yAxis\n    };\n  } // return lineChart\n\n  var series = dataset.dataContainer.map(function (row, rowIndex) {\n    return {\n      x: mappedValue[rowIndex],\n      y: row.valueAt(fieldIdx)\n    };\n  }, true).filter(function (_ref7) {\n    var x = _ref7.x,\n      y = _ref7.y;\n    return Number.isFinite(x) && Number.isFinite(y);\n  }).sort(function (a, b) {\n    return (0, _d3Array.ascending)(a.x, b.x);\n  });\n  var yDomain = (0, _d3Array.extent)(series, function (d) {\n    return d.y;\n  });\n  var xDomain = [series[0].x, series[series.length - 1].x];\n  return {\n    lineChart: {\n      series: series,\n      yDomain: yDomain,\n      xDomain: xDomain\n    },\n    yAxis: yAxis\n  };\n}\n/**\n * Retrieve interval bins for time filter\n */\n\nfunction getIntervalBins(filter) {\n  var _filter$plotType;\n  var bins = filter.bins;\n  var interval = (_filter$plotType = filter.plotType) === null || _filter$plotType === void 0 ? void 0 : _filter$plotType.interval;\n  if (!interval || !bins || Object.keys(bins).length === 0) {\n    return null;\n  }\n  var values = Object.values(bins);\n  return values[0] ? values[0][interval] : null;\n}\nfunction isValidTimeDomain(domain) {\n  return Array.isArray(domain) && domain.every(Number.isFinite);\n}\nfunction getTimeWidgetHintFormatter(domain) {\n  if (!isValidTimeDomain(domain)) {\n    return undefined;\n  }\n  var diff = domain[1] - domain[0];\n  return diff > durationWeek ? 'L' : diff > durationDay ? 'L LT' : diff > durationHour ? 'LT' : 'LTS';\n}","map":{"version":3,"names":["exports","getColumnFilterProps","applyFiltersToDatasets","mergeFilterDomainStep","filterDatasetCPU","getFilterPlot","isValidTimeDomain","getFilterIdInFeature","featureToFilterValue","getPolygonFilterFunctor","LAYER_FILTERS","FILTER_ID_LENGTH","DEFAULT_FILTER_STRUCTURE","FILTER_COMPONENTS","LIMITED_FILTER_EFFECT_PROPS","FILTER_UPDATER_PROPS","enlargedHistogramBins","histogramBins","TimestampStepMap","durationYear","durationWeek","durationDay","durationHour","durationMinute","durationSecond","_toConsumableArray2","_interopRequireDefault","require","_slicedToArray2","_defineProperty2","_d3Array","_keymirror","_console","_lodash","_decimal","_constants","ScaleUtils","_interopRequireWildcard","_h3Js","_utils","_dataUtils","_h3Utils","_FILTER_TYPES$timeRan","_FILTER_TYPES$range","_SupportedPlotType","_FILTER_COMPONENTS","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","max","step","Number","POSITIVE_INFINITY","dataId","name","layerId","SupportedPlotType","FILTER_TYPES","timeRange","ALL_FIELD_TYPES","integer","real","range","select","multiSelect","polygon","freeze","id","enlarged","animationWindow","ANIMATION_WINDOW","free","speed","domain","value","plotType","PLOT_TYPES","histogram","yAxis","interval","gpu","getDefaultFilter","toArray","generateHashId","shouldApplyFilter","datasetId","dataIds","includes","validatePolygonFilter","layer","dataset","layers","failed","isValidFilterValue","type","isValidDataset","l","fieldIdx","filterValidators","filterDatasetIndex","filterDataId","indexOf","initializeFilter","fieldName","_applyFilterFieldName","applyFilterFieldName","mergeDomain","updatedFilter","updatedDataset","adjustValueToFilterDomain","validateFilterYAxis","validateFilterWithData","hasOwnProperty","validateFilter","fields","_filter","matchedAxis","find","_ref","getFilterProps","field","fieldDomain","filterProps","fieldType","string","date","timestamp","fixedDomain","hexagonId","dataContainer","getPosition","getPositionAccessor","LAYER_TYPES","point","icon","data","pos","line","isInPolygon","centroid","dataToFeature","centroids","index","h3IsValid","every","isFinite","valueAccessor","defaultFunc","d","isInRange","mappedValue","accessor","Array","isArray","timeToUnixMilli","format","layerFilterFunctions","map","config","filterFunc","dynamicDomainFilters","_ref2","cpuFilters","filterFuncs","filteredIndex","filterContext","numRows","matchForDomain","filterFuncCaller","matchForRender","filteredIndexForDomain","opt","undefined","filterRecord","dynamicDomain","cpu","f","ignoreDomain","cpuOnly","diffFilters","oldFilterRecord","filterChanged","entries","_ref3","_ref4","record","items","oldFilter","set","prop","concat","_ref5","notNullorUndefined","filteredValue","getNumericFieldDomain","enlargedHistogram","mapIndex","getLinearDomain","diff","formatNumberByStep","_getHistogram","getHistogram","getNumericStepSize","x","exponentialForm","toExponential","exponent","parseFloat","split","Decimal","pow","toNumber","getTimestampFieldDomain","defaultTimeFormat","getTimeWidgetTitleFormatter","entry","_getHistogram2","histogramConstruct","bins","thresholds","ticks","bin","count","x0","x1","val","bound","Math","ceil","_booleanWithin","_helpers","isFilterValidToSave","v","isNaN","Boolean","input","coordinates","_filter$mappedValue","getColumnFieldIdx","warn","lineChart","series","row","rowIndex","y","valueAt","_ref6","sort","a","b","ascending","xDomain","yDomain","filterPlotTypes","datasetIds","datasets","filters","appliedFilters","table","option","fieldIndex","newFilter","assign","combinedDomain","feature","properties","filterId","generatePolygonFilter","label","isVisible","state","datasetFilters","cpuFilteredDataset","filterTableCPU","validateFiltersUpdateDatasets","validated","updatedDatasets","filtersToValidate","_datasetIds$reduce","reduce","acc","_validateFilterWithDa","augmentedDatasets","applyToDatasets","validatedFilter","_filter$mappedValue2","_ref7","getIntervalBins","_filter$plotType"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/utils/src/filter-utils.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {ascending, extent, histogram as d3Histogram, ticks} from 'd3-array';\nimport keyMirror from 'keymirror';\nimport Console from 'global/console';\nimport get from 'lodash.get';\nimport isEqual from 'lodash.isequal';\n\nimport booleanWithin from '@turf/boolean-within';\nimport {point as turfPoint} from '@turf/helpers';\nimport {Decimal} from 'decimal.js';\nimport {\n  ALL_FIELD_TYPES,\n  FILTER_TYPES,\n  ANIMATION_WINDOW,\n  PLOT_TYPES,\n  LAYER_TYPES\n} from '@kepler.gl/constants';\nimport * as ScaleUtils from './data-scale-utils';\nimport {h3IsValid} from 'h3-js';\n\nimport {\n  Millisecond,\n  Entries,\n  Field,\n  ParsedFilter,\n  Filter,\n  FilterBase,\n  PolygonFilter,\n  FieldDomain,\n  TimeRangeFieldDomain,\n  HistogramBin,\n  Feature,\n  FeatureValue,\n  LineChart,\n  TimeRangeFilter,\n  RangeFieldDomain,\n  FilterDatasetOpt,\n  FilterRecord\n} from '@kepler.gl/types';\n\nimport {DataContainerInterface} from './data-container-interface';\nimport {generateHashId, set, toArray} from './utils';\nimport {notNullorUndefined, timeToUnixMilli, unique} from './data-utils';\nimport {getCentroid} from './h3-utils';\n\nexport const durationSecond = 1000;\nexport const durationMinute = durationSecond * 60;\nexport const durationHour = durationMinute * 60;\nexport const durationDay = durationHour * 24;\nexport const durationWeek = durationDay * 7;\nexport const durationYear = durationDay * 365;\n\nexport type FilterResult = {\n  filteredIndexForDomain?: number[];\n  filteredIndex?: number[];\n};\n\nexport type FilterChanged = {\n  // eslint-disable-next-line no-unused-vars\n  [key in keyof FilterRecord]: {\n    [key: string]: 'added' | 'deleted' | 'name_changed' | 'value_changed' | 'dataId_changed';\n  } | null;\n};\n\nexport type dataValueAccessor = (data: {index: number}) => number | null;\n\nexport const TimestampStepMap = [\n  {max: 1, step: 0.05},\n  {max: 10, step: 0.1},\n  {max: 100, step: 1},\n  {max: 500, step: 5},\n  {max: 1000, step: 10},\n  {max: 5000, step: 50},\n  {max: Number.POSITIVE_INFINITY, step: 1000}\n];\n\nexport const histogramBins = 30;\nexport const enlargedHistogramBins = 100;\n\nexport const FILTER_UPDATER_PROPS = keyMirror({\n  dataId: null,\n  name: null,\n  layerId: null\n});\n\nexport const LIMITED_FILTER_EFFECT_PROPS = keyMirror({\n  [FILTER_UPDATER_PROPS.name]: null\n});\n/**\n * Max number of filter value buffers that deck.gl provides\n */\n\nconst SupportedPlotType = {\n  [FILTER_TYPES.timeRange]: {\n    default: 'histogram',\n    [ALL_FIELD_TYPES.integer]: 'lineChart',\n    [ALL_FIELD_TYPES.real]: 'lineChart'\n  },\n  [FILTER_TYPES.range]: {\n    default: 'histogram',\n    [ALL_FIELD_TYPES.integer]: 'lineChart',\n    [ALL_FIELD_TYPES.real]: 'lineChart'\n  }\n};\n\nexport const FILTER_COMPONENTS = {\n  [FILTER_TYPES.select]: 'SingleSelectFilter',\n  [FILTER_TYPES.multiSelect]: 'MultiSelectFilter',\n  [FILTER_TYPES.timeRange]: 'TimeRangeFilter',\n  [FILTER_TYPES.range]: 'RangeFilter',\n  [FILTER_TYPES.polygon]: 'PolygonFilter'\n};\n\nexport const DEFAULT_FILTER_STRUCTURE = {\n  dataId: [], // [string]\n  freeze: false,\n  id: null,\n\n  // time range filter specific\n  fixedDomain: false,\n  enlarged: false,\n  isAnimating: false,\n  animationWindow: ANIMATION_WINDOW.free,\n  speed: 1,\n\n  // field specific\n  name: [], // string\n  type: null,\n  fieldIdx: [], // [integer]\n  domain: null,\n  value: null,\n\n  // plot\n  plotType: PLOT_TYPES.histogram,\n  yAxis: null,\n  interval: null,\n\n  // mode\n  gpu: false\n};\n\nexport const FILTER_ID_LENGTH = 4;\n\nexport const LAYER_FILTERS = [FILTER_TYPES.polygon];\n\n/**\n * Generates a filter with a dataset id as dataId\n */\nexport function getDefaultFilter(dataId: string | null | string[]): FilterBase<LineChart> {\n  return {\n    ...DEFAULT_FILTER_STRUCTURE,\n    // store it as dataId and it could be one or many\n    dataId: toArray(dataId),\n    id: generateHashId(FILTER_ID_LENGTH)\n  };\n}\n\n/**\n * Check if a filter is valid based on the given dataId\n * @param  filter to validate\n * @param  datasetId id to validate filter against\n * @return true if a filter is valid, false otherwise\n */\nexport function shouldApplyFilter(filter: Filter, datasetId: string): boolean {\n  const dataIds = toArray(filter.dataId);\n  return dataIds.includes(datasetId) && filter.value !== null;\n}\n\ninterface KeplerTableModel<K, L> {\n  id: string;\n  getColumnFieldIdx(columnName: string): number;\n  filterTable(filters: Filter[], layers: L[], opt?: FilterDatasetOpt): K;\n  getColumnFilterProps(columnName: string): Field['filterProps'] | null | undefined;\n  dataContainer: DataContainerInterface;\n  filterTableCPU(filters: Filter[], layers: L[]): K;\n}\n\n/**\n * Validates and modifies polygon filter structure\n * @param dataset\n * @param filter\n * @param layers\n * @return - {filter, dataset}\n */\nexport function validatePolygonFilter<K extends KeplerTableModel<K, L>, L extends {id: string}>(\n  dataset: K,\n  filter: PolygonFilter,\n  layers: L[]\n): {filter: PolygonFilter | null; dataset: K} {\n  const failed = {dataset, filter: null};\n  const {value, layerId, type, dataId} = filter;\n\n  if (!layerId || !isValidFilterValue(type, value)) {\n    return failed;\n  }\n\n  const isValidDataset = dataId.includes(dataset.id);\n\n  if (!isValidDataset) {\n    return failed;\n  }\n\n  const layer = layers.find(l => layerId.includes(l.id));\n\n  if (!layer) {\n    return failed;\n  }\n\n  return {\n    filter: {\n      ...filter,\n      freeze: true,\n      fieldIdx: []\n    },\n    dataset\n  };\n}\n\n/**\n * Custom filter validators\n */\nconst filterValidators = {\n  [FILTER_TYPES.polygon]: validatePolygonFilter\n};\n\n/**\n * Default validate filter function\n * @param dataset\n * @param filter\n * @return - {filter, dataset}\n */\nexport function validateFilter<K extends KeplerTableModel<K, L>, L>(\n  dataset: K,\n  filter: ParsedFilter\n): {filter: Filter | null; dataset: K} {\n  // match filter.dataId\n  const failed = {dataset, filter: null};\n  const filterDataId = toArray(filter.dataId);\n\n  const filterDatasetIndex = filterDataId.indexOf(dataset.id);\n  if (filterDatasetIndex < 0 || !toArray(filter.name)[filterDatasetIndex]) {\n    // the current filter is not mapped against the current dataset\n    return failed;\n  }\n\n  const initializeFilter: Filter = {\n    // @ts-expect-error\n    ...getDefaultFilter(filter.dataId),\n    ...filter,\n    dataId: filterDataId,\n    name: toArray(filter.name)\n  };\n\n  const fieldName = initializeFilter.name[filterDatasetIndex];\n  const {filter: updatedFilter, dataset: updatedDataset} = applyFilterFieldName(\n    initializeFilter,\n    dataset,\n    fieldName,\n    filterDatasetIndex,\n    {mergeDomain: true}\n  );\n\n  if (!updatedFilter) {\n    return failed;\n  }\n\n  updatedFilter.value = adjustValueToFilterDomain(filter.value, updatedFilter);\n  updatedFilter.enlarged =\n    typeof filter.enlarged === 'boolean' ? filter.enlarged : updatedFilter.enlarged;\n\n  if (updatedFilter.value === null) {\n    // cannot adjust saved value to filter\n    return failed;\n  }\n\n  return {\n    filter: validateFilterYAxis(updatedFilter, updatedDataset),\n    dataset: updatedDataset\n  };\n}\n\n/**\n * Validate saved filter config with new data,\n * calculate domain and fieldIdx based new fields and data\n *\n * @param dataset\n * @param filter - filter to be validate\n * @param layers - layers\n * @return validated filter\n */\nexport function validateFilterWithData<K extends KeplerTableModel<K, L>, L>(\n  dataset: K,\n  filter: ParsedFilter,\n  layers: L[]\n): {filter: Filter; dataset: K} {\n  return filter.type && filterValidators.hasOwnProperty(filter.type)\n    ? filterValidators[filter.type](dataset, filter, layers)\n    : validateFilter(dataset, filter);\n}\n\n/**\n * Validate YAxis\n * @param filter\n * @param dataset\n * @return {*}\n */\nfunction validateFilterYAxis(filter, dataset) {\n  // TODO: validate yAxis against other datasets\n\n  const {fields} = dataset;\n  const {yAxis} = filter;\n  // TODO: validate yAxis against other datasets\n  if (yAxis) {\n    const matchedAxis = fields.find(({name, type}) => name === yAxis.name && type === yAxis.type);\n\n    filter = matchedAxis\n      ? {\n          ...filter,\n          yAxis: matchedAxis,\n          ...getFilterPlot({...filter, yAxis: matchedAxis}, dataset)\n        }\n      : filter;\n  }\n\n  return filter;\n}\n\n/**\n * Get default filter prop based on field type\n *\n * @param field\n * @param fieldDomain\n * @returns default filter\n */\nexport function getFilterProps(\n  field: Field,\n  fieldDomain: FieldDomain\n): Partial<Filter> & {fieldType: string} {\n  const filterProps = {\n    ...fieldDomain,\n    fieldType: field.type\n  };\n\n  switch (field.type) {\n    case ALL_FIELD_TYPES.real:\n    case ALL_FIELD_TYPES.integer:\n      return {\n        ...filterProps,\n        value: fieldDomain.domain,\n        type: FILTER_TYPES.range,\n        // @ts-expect-error\n        typeOptions: [FILTER_TYPES.range],\n        gpu: true\n      };\n\n    case ALL_FIELD_TYPES.boolean:\n      // @ts-expect-error\n      return {\n        ...filterProps,\n        type: FILTER_TYPES.select,\n        value: true,\n        gpu: false\n      };\n\n    case ALL_FIELD_TYPES.string:\n    case ALL_FIELD_TYPES.date:\n      // @ts-expect-error\n      return {\n        ...filterProps,\n        type: FILTER_TYPES.multiSelect,\n        value: [],\n        gpu: false\n      };\n\n    case ALL_FIELD_TYPES.timestamp:\n      // @ts-expect-error\n      return {\n        ...filterProps,\n        type: FILTER_TYPES.timeRange,\n        enlarged: true,\n        fixedDomain: true,\n        value: filterProps.domain,\n        gpu: true\n      };\n\n    default:\n      // @ts-expect-error\n      return {};\n  }\n}\n\nexport const getPolygonFilterFunctor = (layer, filter, dataContainer) => {\n  const getPosition = layer.getPositionAccessor(dataContainer);\n\n  switch (layer.type) {\n    case LAYER_TYPES.point:\n    case LAYER_TYPES.icon:\n      return data => {\n        const pos = getPosition(data);\n        return pos.every(Number.isFinite) && isInPolygon(pos, filter.value);\n      };\n    case LAYER_TYPES.arc:\n    case LAYER_TYPES.line:\n      return data => {\n        const pos = getPosition(data);\n        return (\n          pos.every(Number.isFinite) &&\n          [\n            [pos[0], pos[1]],\n            [pos[3], pos[4]]\n          ].every(point => isInPolygon(point, filter.value))\n        );\n      };\n    case LAYER_TYPES.hexagonId:\n      if (layer.dataToFeature && layer.dataToFeature.centroids) {\n        return data => {\n          // null or getCentroid({id})\n          const centroid = layer.dataToFeature.centroids[data.index];\n          return centroid && isInPolygon(centroid, filter.value);\n        };\n      }\n      return data => {\n        const id = getPosition(data);\n        if (!h3IsValid(id)) {\n          return false;\n        }\n        const pos = getCentroid({id});\n        return pos.every(Number.isFinite) && isInPolygon(pos, filter.value);\n      };\n    default:\n      return () => true;\n  }\n};\n\n/**\n * @param param An object that represents a row record.\n * @param param.index Index of the row in data container.\n * @returns Returns true to keep the element, or false otherwise.\n */\ntype filterFunction = (data: {index: number}) => boolean;\n/**\n * @param field dataset Field\n * @param dataId Dataset id\n * @param filter Filter object\n * @param layers list of layers to filter upon\n * @param dataContainer Data container\n * @return filterFunction\n */\n/* eslint-disable complexity */\nexport function getFilterFunction<L extends {config: {dataId: string | null}; id: string}>(\n  field: Field | null,\n  dataId: string,\n  filter: Filter,\n  layers: L[],\n  dataContainer: DataContainerInterface\n): filterFunction {\n  // field could be null in polygon filter\n  const valueAccessor = field ? field.valueAccessor : data => null;\n  const defaultFunc = d => true;\n\n  switch (filter.type) {\n    case FILTER_TYPES.range:\n      return data => isInRange(valueAccessor(data), filter.value);\n    case FILTER_TYPES.multiSelect:\n      return data => filter.value.includes(valueAccessor(data));\n    case FILTER_TYPES.select:\n      return data => valueAccessor(data) === filter.value;\n    case FILTER_TYPES.timeRange:\n      if (!field) {\n        return defaultFunc;\n      }\n      const mappedValue = get(field, ['filterProps', 'mappedValue']);\n      const accessor = Array.isArray(mappedValue)\n        ? data => mappedValue[data.index]\n        : data => timeToUnixMilli(valueAccessor(data), field.format);\n      return data => isInRange(accessor(data), filter.value);\n    case FILTER_TYPES.polygon:\n      if (!layers || !layers.length || !filter.layerId) {\n        return defaultFunc;\n      }\n      const layerFilterFunctions = filter.layerId\n        .map(id => layers.find(l => l.id === id))\n        .filter(l => l && l.config.dataId === dataId)\n        .map(layer => getPolygonFilterFunctor(layer, filter, dataContainer));\n\n      return data => layerFilterFunctions.every(filterFunc => filterFunc(data));\n    default:\n      return defaultFunc;\n  }\n}\n\nexport function updateFilterDataId(dataId: string): FilterBase<LineChart> {\n  return getDefaultFilter(dataId);\n}\n\nexport function filterDataByFilterTypes(\n  {\n    dynamicDomainFilters,\n    cpuFilters,\n    filterFuncs\n  }: {\n    dynamicDomainFilters: Filter[] | null;\n    cpuFilters: Filter[] | null;\n    filterFuncs: {\n      [key: string]: filterFunction;\n    };\n  },\n  dataContainer: DataContainerInterface\n): FilterResult {\n  const filteredIndexForDomain: number[] = [];\n  const filteredIndex: number[] = [];\n\n  const filterContext = {index: -1, dataContainer};\n  const filterFuncCaller = (filter: Filter) => filterFuncs[filter.id](filterContext);\n\n  const numRows = dataContainer.numRows();\n  for (let i = 0; i < numRows; ++i) {\n    filterContext.index = i;\n\n    const matchForDomain = dynamicDomainFilters && dynamicDomainFilters.every(filterFuncCaller);\n    if (matchForDomain) {\n      filteredIndexForDomain.push(filterContext.index);\n    }\n\n    const matchForRender = cpuFilters && cpuFilters.every(filterFuncCaller);\n    if (matchForRender) {\n      filteredIndex.push(filterContext.index);\n    }\n  }\n\n  return {\n    ...(dynamicDomainFilters ? {filteredIndexForDomain} : {}),\n    ...(cpuFilters ? {filteredIndex} : {})\n  };\n}\n\n/**\n * Get a record of filters based on domain type and gpu / cpu\n */\nexport function getFilterRecord(\n  dataId: string,\n  filters: Filter[],\n  opt: FilterDatasetOpt = {}\n): FilterRecord {\n  const filterRecord: FilterRecord = {\n    dynamicDomain: [],\n    fixedDomain: [],\n    cpu: [],\n    gpu: []\n  };\n\n  filters.forEach(f => {\n    if (isValidFilterValue(f.type, f.value) && toArray(f.dataId).includes(dataId)) {\n      (f.fixedDomain || opt.ignoreDomain\n        ? filterRecord.fixedDomain\n        : filterRecord.dynamicDomain\n      ).push(f);\n\n      (f.gpu && !opt.cpuOnly ? filterRecord.gpu : filterRecord.cpu).push(f);\n    }\n  });\n\n  return filterRecord;\n}\n\n/**\n * Compare filter records to get what has changed\n */\nexport function diffFilters(\n  filterRecord: FilterRecord,\n  oldFilterRecord: FilterRecord | {} = {}\n): FilterChanged {\n  let filterChanged: Partial<FilterChanged> = {};\n\n  (Object.entries(filterRecord) as Entries<FilterRecord>).forEach(([record, items]) => {\n    items.forEach(filter => {\n      const oldFilter: Filter = (oldFilterRecord[record] || []).find(\n        (f: Filter) => f.id === filter.id\n      );\n\n      if (!oldFilter) {\n        // added\n        filterChanged = set([record, filter.id], 'added', filterChanged);\n      } else {\n        // check  what has changed\n        ['name', 'value', 'dataId'].forEach(prop => {\n          if (filter[prop] !== oldFilter[prop]) {\n            filterChanged = set([record, filter.id], `${prop}_changed`, filterChanged);\n          }\n        });\n      }\n    });\n\n    (oldFilterRecord[record] || []).forEach((oldFilter: Filter) => {\n      // deleted\n      if (!items.find(f => f.id === oldFilter.id)) {\n        filterChanged = set([record, oldFilter.id], 'deleted', filterChanged);\n      }\n    });\n  });\n\n  return {...{dynamicDomain: null, fixedDomain: null, cpu: null, gpu: null}, ...filterChanged};\n}\n/**\n * Call by parsing filters from URL\n * Check if value of filter within filter domain, if not adjust it to match\n * filter domain\n *\n * @returns value - adjusted value to match filter or null to remove filter\n */\n// eslint-disable-next-line complexity\nexport function adjustValueToFilterDomain(value: Filter['value'], {domain, type}) {\n  if (!type) {\n    return false;\n  }\n  // if the current filter is a polygon it will not have any domain\n  // all other filter types require domain\n  if (type !== FILTER_TYPES.polygon && !domain) {\n    return false;\n  }\n\n  switch (type) {\n    case FILTER_TYPES.range:\n    case FILTER_TYPES.timeRange:\n      if (!Array.isArray(value) || value.length !== 2) {\n        return domain.map(d => d);\n      }\n\n      return value.map((d, i) => (notNullorUndefined(d) && isInRange(d, domain) ? d : domain[i]));\n\n    case FILTER_TYPES.multiSelect:\n      if (!Array.isArray(value)) {\n        return [];\n      }\n      const filteredValue = value.filter(d => domain.includes(d));\n      return filteredValue.length ? filteredValue : [];\n\n    case FILTER_TYPES.select:\n      return domain.includes(value) ? value : true;\n    case FILTER_TYPES.polygon:\n      return value;\n\n    default:\n      return null;\n  }\n}\n/* eslint-enable complexity */\n\n/**\n * Calculate numeric domain and suitable step\n */\nexport function getNumericFieldDomain(\n  dataContainer: DataContainerInterface,\n  valueAccessor: dataValueAccessor\n): RangeFieldDomain {\n  let domain: [number, number] = [0, 1];\n  let step = 0.1;\n\n  const mappedValue = dataContainer.mapIndex(valueAccessor);\n\n  if (dataContainer.numRows() > 1) {\n    domain = ScaleUtils.getLinearDomain(mappedValue);\n    const diff = domain[1] - domain[0];\n\n    // in case equal domain, [96, 96], which will break quantize scale\n    if (!diff) {\n      domain[1] = domain[0] + 1;\n    }\n\n    step = getNumericStepSize(diff) || step;\n    domain[0] = formatNumberByStep(domain[0], step, 'floor');\n    domain[1] = formatNumberByStep(domain[1], step, 'ceil');\n  }\n\n  const {histogram, enlargedHistogram} = getHistogram(domain, mappedValue);\n\n  return {domain, step, histogram, enlargedHistogram};\n}\n\n/**\n * Calculate step size for range and timerange filter\n */\nexport function getNumericStepSize(diff: number): number {\n  diff = Math.abs(diff);\n\n  if (diff > 100) {\n    return 1;\n  } else if (diff > 3) {\n    return 0.01;\n  } else if (diff > 1) {\n    return 0.001;\n  }\n  // Try to get at least 1000 steps - and keep the step size below that of\n  // the (diff > 1) case.\n  const x = diff / 1000;\n  // Find the exponent and truncate to 10 to the power of that exponent\n\n  const exponentialForm = x.toExponential();\n  const exponent = parseFloat(exponentialForm.split('e')[1]);\n\n  // Getting ready for node 12\n  // this is why we need decimal.js\n  // Math.pow(10, -5) = 0.000009999999999999999\n  // the above result shows in browser and node 10\n  // node 12 behaves correctly\n  return new Decimal(10).pow(exponent).toNumber();\n}\n\n/**\n * Calculate timestamp domain and suitable step\n */\nexport function getTimestampFieldDomain(\n  dataContainer: DataContainerInterface,\n  valueAccessor: dataValueAccessor\n): TimeRangeFieldDomain {\n  // to avoid converting string format time to epoch\n  // every time we compare we store a value mapped to int in filter domain\n\n  const mappedValue = dataContainer.mapIndex(valueAccessor);\n  const domain = ScaleUtils.getLinearDomain(mappedValue);\n  const defaultTimeFormat = getTimeWidgetTitleFormatter(domain);\n\n  let step = 0.01;\n\n  const diff = domain[1] - domain[0];\n  const entry = TimestampStepMap.find(f => f.max >= diff);\n  if (entry) {\n    step = entry.step;\n  }\n\n  const {histogram, enlargedHistogram} = getHistogram(domain, mappedValue);\n\n  return {\n    domain,\n    step,\n    mappedValue,\n    histogram,\n    enlargedHistogram,\n    defaultTimeFormat\n  };\n}\n\nexport function histogramConstruct(\n  domain: [number, number],\n  mappedValue: (Millisecond | number)[],\n  bins: number\n): HistogramBin[] {\n  return d3Histogram()\n    .thresholds(ticks(domain[0], domain[1], bins))\n    .domain(domain)(mappedValue)\n    .map(bin => ({\n      count: bin.length,\n      bin,\n      x0: bin.x0,\n      x1: bin.x1\n    }));\n}\n/**\n * Calculate histogram from domain and array of values\n */\nexport function getHistogram(\n  domain: [number, number],\n  mappedValue: (Millisecond | number)[]\n): {histogram: HistogramBin[]; enlargedHistogram: HistogramBin[]} {\n  const histogram = histogramConstruct(domain, mappedValue, histogramBins);\n  const enlargedHistogram = histogramConstruct(domain, mappedValue, enlargedHistogramBins);\n\n  return {histogram, enlargedHistogram};\n}\n\n/**\n * round number based on step\n *\n * @param {Number} val\n * @param {Number} step\n * @param {string} bound\n * @returns {Number} rounded number\n */\nexport function formatNumberByStep(val: number, step: number, bound: 'floor' | 'ceil'): number {\n  if (bound === 'floor') {\n    return Math.floor(val * (1 / step)) / (1 / step);\n  }\n\n  return Math.ceil(val * (1 / step)) / (1 / step);\n}\n\nexport function isInRange(val: any, domain: number[]): boolean {\n  if (!Array.isArray(domain)) {\n    return false;\n  }\n\n  return val >= domain[0] && val <= domain[1];\n}\n\n/**\n * Determines whether a point is within the provided polygon\n *\n * @param point as input search [lat, lng]\n * @param polygon Points must be within these (Multi)Polygon(s)\n * @return {boolean}\n */\nexport function isInPolygon(point: number[], polygon: any): boolean {\n  return booleanWithin(turfPoint(point), polygon);\n}\nexport function getTimeWidgetTitleFormatter(domain: [number, number]): string | null {\n  if (!isValidTimeDomain(domain)) {\n    return null;\n  }\n\n  const diff = domain[1] - domain[0];\n\n  // Local aware formats\n  // https://momentjs.com/docs/#/parsing/string-format\n  return diff > durationYear ? 'L' : diff > durationDay ? 'L LT' : 'L LTS';\n}\n\n/**\n * Sanity check on filters to prepare for save\n * @type {typeof import('./filter-utils').isFilterValidToSave}\n */\nexport function isFilterValidToSave(filter: any): boolean {\n  return (\n    filter?.type &&\n    Array.isArray(filter?.name) &&\n    (filter?.name.length || filter?.layerId.length) &&\n    isValidFilterValue(filter?.type, filter?.value)\n  );\n}\n\n/**\n * Sanity check on filters to prepare for save\n * @type {typeof import('./filter-utils').isValidFilterValue}\n */\n/* eslint-disable complexity */\nexport function isValidFilterValue(type: string | null, value: any): boolean {\n  if (!type) {\n    return false;\n  }\n  switch (type) {\n    case FILTER_TYPES.select:\n      return value === true || value === false;\n\n    case FILTER_TYPES.range:\n    case FILTER_TYPES.timeRange:\n      return Array.isArray(value) && value.every(v => v !== null && !isNaN(v));\n\n    case FILTER_TYPES.multiSelect:\n      return Array.isArray(value) && Boolean(value.length);\n\n    case FILTER_TYPES.input:\n      return Boolean(value.length);\n\n    case FILTER_TYPES.polygon:\n      const coordinates = get(value, ['geometry', 'coordinates']);\n      return Boolean(value && value.id && coordinates);\n\n    default:\n      return true;\n  }\n}\n\nexport function getColumnFilterProps<K extends KeplerTableModel<K, L>, L>(\n  filter: Filter,\n  dataset: K\n): {lineChart: LineChart; yAxs: Field} | {} {\n  if (filter.plotType === PLOT_TYPES.histogram || !filter.yAxis) {\n    // histogram should be calculated when create filter\n    return {};\n  }\n\n  const {mappedValue = []} = filter;\n  const {yAxis} = filter;\n  const fieldIdx = dataset.getColumnFieldIdx(yAxis.name);\n  if (fieldIdx < 0) {\n    Console.warn(`yAxis ${yAxis.name} does not exist in dataset`);\n    return {lineChart: {}, yAxis};\n  }\n\n  // return lineChart\n  const series = dataset.dataContainer\n    .map(\n      (row, rowIndex) => ({\n        x: mappedValue[rowIndex],\n        y: row.valueAt(fieldIdx)\n      }),\n      true\n    )\n    .filter(({x, y}) => Number.isFinite(x) && Number.isFinite(y))\n    .sort((a, b) => ascending(a.x, b.x));\n\n  const yDomain = extent(series, d => d.y);\n  const xDomain = [series[0].x, series[series.length - 1].x];\n\n  return {lineChart: {series, yDomain, xDomain}, yAxis};\n}\n\nexport function getDefaultFilterPlotType(filter: Filter): string | null {\n  const filterPlotTypes: typeof SupportedPlotType[keyof typeof SupportedPlotType] | null =\n    filter.type && SupportedPlotType[filter.type];\n  if (!filterPlotTypes) {\n    return null;\n  }\n\n  if (!filter.yAxis) {\n    return filterPlotTypes.default;\n  }\n\n  return filterPlotTypes[filter.yAxis.type] || null;\n}\n\n/**\n *\n * @param datasetIds list of dataset ids to be filtered\n * @param datasets all datasets\n * @param filters all filters to be applied to datasets\n * @return datasets - new updated datasets\n */\nexport function applyFiltersToDatasets<\n  K extends KeplerTableModel<K, L>,\n  L extends {config: {dataId: string | null}}\n>(\n  datasetIds: string[],\n  datasets: {[id: string]: K},\n  filters: Filter[],\n  layers?: L[]\n): {[id: string]: K} {\n  const dataIds = toArray(datasetIds);\n  return dataIds.reduce((acc, dataId) => {\n    const layersToFilter = (layers || []).filter(l => l.config.dataId === dataId);\n    const appliedFilters = filters.filter(d => shouldApplyFilter(d, dataId));\n    const table = datasets[dataId];\n\n    return {\n      ...acc,\n      [dataId]: table.filterTable(appliedFilters, layersToFilter, {})\n    };\n  }, datasets);\n}\n\n/**\n * Applies a new field name value to fielter and update both filter and dataset\n * @param filter - to be applied the new field name on\n * @param dataset - dataset the field belongs to\n * @param fieldName - field.name\n * @param filterDatasetIndex - field.name\n * @param option\n * @return - {filter, datasets}\n */\nexport function applyFilterFieldName<K extends KeplerTableModel<K, L>, L>(\n  filter: Filter,\n  dataset: K,\n  fieldName: string,\n  filterDatasetIndex = 0,\n  option?: {mergeDomain: boolean}\n): {\n  filter: Filter | null;\n  dataset: K;\n} {\n  // using filterDatasetIndex we can filter only the specified dataset\n  const mergeDomain = option && option.hasOwnProperty('mergeDomain') ? option.mergeDomain : false;\n\n  const fieldIndex = dataset.getColumnFieldIdx(fieldName);\n  // if no field with same name is found, move to the next datasets\n  if (fieldIndex === -1) {\n    // throw new Error(`fieldIndex not found. Dataset must contain a property with name: ${fieldName}`);\n    return {filter: null, dataset};\n  }\n\n  // TODO: validate field type\n  const filterProps = dataset.getColumnFilterProps(fieldName);\n\n  const newFilter = {\n    ...(mergeDomain ? mergeFilterDomainStep(filter, filterProps) : {...filter, ...filterProps}),\n    name: Object.assign([...toArray(filter.name)], {[filterDatasetIndex]: fieldName}),\n    fieldIdx: Object.assign([...toArray(filter.fieldIdx)], {\n      [filterDatasetIndex]: fieldIndex\n    }),\n    // TODO, since we allow to add multiple fields to a filter we can no longer freeze the filter\n    freeze: true\n  };\n\n  return {\n    filter: newFilter,\n    dataset\n  };\n}\n\n/**\n * Merge one filter with other filter prop domain\n */\n/* eslint-disable complexity */\nexport function mergeFilterDomainStep(\n  filter: Filter,\n  filterProps?: Partial<Filter>\n): (Filter & {step?: number}) | null {\n  if (!filter) {\n    return null;\n  }\n\n  if (!filterProps) {\n    return filter;\n  }\n\n  if ((filter.fieldType && filter.fieldType !== filterProps.fieldType) || !filterProps.domain) {\n    return filter;\n  }\n\n  const combinedDomain = !filter.domain\n    ? filterProps.domain\n    : [...(filter.domain || []), ...(filterProps.domain || [])].sort((a, b) => a - b);\n\n  const newFilter = {\n    ...filter,\n    ...filterProps,\n    domain: [combinedDomain[0], combinedDomain[combinedDomain.length - 1]]\n  };\n\n  switch (filterProps.fieldType) {\n    case ALL_FIELD_TYPES.string:\n    case ALL_FIELD_TYPES.date:\n      return {\n        ...newFilter,\n        domain: unique(combinedDomain).sort()\n      };\n\n    case ALL_FIELD_TYPES.timestamp:\n      const step =\n        (filter as TimeRangeFilter).step < (filterProps as TimeRangeFieldDomain).step\n          ? (filter as TimeRangeFilter).step\n          : (filterProps as TimeRangeFieldDomain).step;\n\n      return {\n        ...newFilter,\n        step\n      };\n    case ALL_FIELD_TYPES.real:\n    case ALL_FIELD_TYPES.integer:\n    default:\n      return newFilter;\n  }\n}\n/* eslint-enable complexity */\n\n/**\n * Generates polygon filter\n */\nexport const featureToFilterValue = (\n  feature: Feature,\n  filterId: string,\n  properties?: {}\n): FeatureValue => ({\n  ...feature,\n  id: feature.id,\n  properties: {\n    ...feature.properties,\n    ...properties,\n    filterId\n  }\n});\n\nexport const getFilterIdInFeature = (f: FeatureValue): string => get(f, ['properties', 'filterId']);\n\n/**\n * Generates polygon filter\n */\nexport function generatePolygonFilter<\n  L extends {config: {dataId: string | null; label: string}; id: string}\n>(layers: L[], feature: Feature): PolygonFilter {\n  const dataId = layers.map(l => l.config.dataId).filter(notNullorUndefined);\n  const layerId = layers.map(l => l.id);\n  const name = layers.map(l => l.config.label);\n  const filter = getDefaultFilter(dataId);\n  return {\n    ...filter,\n    fixedDomain: true,\n    type: FILTER_TYPES.polygon,\n    name,\n    layerId,\n    value: featureToFilterValue(feature, filter.id, {isVisible: true})\n  };\n}\n\n/**\n * Run filter entirely on CPU\n */\ninterface StateType<K extends KeplerTableModel<K, L>, L> {\n  layers: L[];\n  filters: Filter[];\n  datasets: {[id: string]: K};\n}\n\nexport function filterDatasetCPU<T extends StateType<K, L>, K extends KeplerTableModel<K, L>, L>(\n  state: T,\n  dataId: string\n): T {\n  const datasetFilters = state.filters.filter(f => f.dataId.includes(dataId));\n  const dataset = state.datasets[dataId];\n\n  if (!dataset) {\n    return state;\n  }\n\n  const cpuFilteredDataset = dataset.filterTableCPU(datasetFilters, state.layers);\n\n  return set(['datasets', dataId], cpuFilteredDataset, state);\n}\n\n/**\n * Validate parsed filters with datasets and add filterProps to field\n */\nexport function validateFiltersUpdateDatasets<\n  S extends {datasets: {[id: string]: K}; layers: L[]},\n  K extends KeplerTableModel<K, L>,\n  L extends {config: {dataId: string | null; label: string}; id: string}\n>(\n  state: S,\n  filtersToValidate: ParsedFilter[] = []\n): {\n  validated: Filter[];\n  failed: Filter[];\n  updatedDatasets: S['datasets'];\n} {\n  // TODO Better Typings here\n  const validated: any[] = [];\n  const failed: any[] = [];\n  const {datasets} = state;\n  let updatedDatasets = datasets;\n\n  // merge filters\n  filtersToValidate.forEach(filter => {\n    // we can only look for datasets define in the filter dataId\n    const datasetIds = toArray(filter.dataId);\n\n    // we can merge a filter only if all datasets in filter.dataId are loaded\n    if (datasetIds.every(d => datasets[d])) {\n      // all datasetIds in filter must be present the state datasets\n      const {filter: validatedFilter, applyToDatasets, augmentedDatasets} = datasetIds.reduce(\n        (acc, datasetId) => {\n          const dataset = updatedDatasets[datasetId];\n          const layers = state.layers.filter(l => l.config.dataId === dataset.id);\n          const {filter: updatedFilter, dataset: updatedDataset} = validateFilterWithData(\n            acc.augmentedDatasets[datasetId] || dataset,\n            filter,\n            layers\n          );\n\n          if (updatedFilter) {\n            return {\n              ...acc,\n              // merge filter props\n              filter: acc.filter\n                ? {\n                    ...acc.filter,\n                    ...mergeFilterDomainStep(acc, updatedFilter)\n                  }\n                : updatedFilter,\n\n              applyToDatasets: [...acc.applyToDatasets, datasetId],\n\n              augmentedDatasets: {\n                ...acc.augmentedDatasets,\n                [datasetId]: updatedDataset\n              }\n            };\n          }\n\n          return acc;\n        },\n        {\n          filter: null,\n          applyToDatasets: [],\n          augmentedDatasets: {}\n        }\n      );\n\n      if (validatedFilter && isEqual(datasetIds, applyToDatasets)) {\n        validated.push(validatedFilter);\n        updatedDatasets = {\n          ...updatedDatasets,\n          ...augmentedDatasets\n        };\n      }\n    } else {\n      failed.push(filter);\n    }\n  });\n\n  return {validated, failed, updatedDatasets};\n}\n\nexport function getFilterPlot<K extends KeplerTableModel<K, L>, L>(\n  filter: Filter,\n  dataset: K\n): {lineChart: LineChart; yAxs: Field} | {} {\n  if (filter.plotType === PLOT_TYPES.histogram || !filter.yAxis) {\n    // histogram should be calculated when create filter\n    return {};\n  }\n\n  const {mappedValue = []} = filter;\n  const {yAxis} = filter;\n  const fieldIdx = dataset.getColumnFieldIdx(yAxis.name);\n  if (fieldIdx < 0) {\n    Console.warn(`yAxis ${yAxis.name} does not exist in dataset`);\n    return {lineChart: {}, yAxis};\n  }\n\n  // return lineChart\n  const series = dataset.dataContainer\n    .map(\n      (row, rowIndex) => ({\n        x: mappedValue[rowIndex],\n        y: row.valueAt(fieldIdx)\n      }),\n      true\n    )\n    .filter(({x, y}) => Number.isFinite(x) && Number.isFinite(y))\n    .sort((a, b) => ascending(a.x, b.x));\n\n  const yDomain = extent(series, d => d.y);\n  const xDomain = [series[0].x, series[series.length - 1].x];\n\n  return {lineChart: {series, yDomain, xDomain}, yAxis};\n}\n\n/**\n * Retrieve interval bins for time filter\n */\nexport function getIntervalBins(filter: TimeRangeFilter) {\n  const {bins} = filter;\n  const interval = filter.plotType?.interval;\n  if (!interval || !bins || Object.keys(bins).length === 0) {\n    return null;\n  }\n  const values = Object.values(bins);\n  return values[0] ? values[0][interval] : null;\n}\n\nexport function isValidTimeDomain(domain) {\n  return Array.isArray(domain) && domain.every(Number.isFinite);\n}\n\nexport function getTimeWidgetHintFormatter(domain: [number, number]): string | undefined {\n  if (!isValidTimeDomain(domain)) {\n    return undefined;\n  }\n\n  const diff = domain[1] - domain[0];\n  return diff > durationWeek\n    ? 'L'\n    : diff > durationDay\n    ? 'L LT'\n    : diff > durationHour\n    ? 'LT'\n    : 'LTS';\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBAA,OAAA,CAAAC,oBAAA,GAAAA,oBAAA;;AACAD,OAAA,CAAAE,sBAAA,GAAAA,sBAAA;;AACAF,OAAA,CAAAG,qBAAA,GAAAA,qBAAA;;AACAH,OAAA,CAAAI,gBAAA,GAAAA,gBAAA;;AACAJ,OAAA,CAAAK,aAAA,GAAAA,aAAA;;AAEAL,OAAA,CAAAM,iBAAA,GAAAA,iBAAA;;AACAN,OAAA,CAAAO,oBAAA,GAAAP,OAAA,CAAAQ,oBAAA,GAAAR,OAAA,CAAAS,uBAAA,GAAAT,OAAA,CAAAU,aAAA,GAAAV,OAAA,CAAAW,gBAAA,GAAAX,OAAA,CAAAY,wBAAA,GAAAZ,OAAA,CAAAa,iBAAA,GAAAb,OAAA,CAAAc,2BAAA,GAAAd,OAAA,CAAAe,oBAAA,GAAAf,OAAA,CAAAgB,qBAAA,GAAAhB,OAAA,CAAAiB,aAAA,GAAAjB,OAAA,CAAAkB,gBAAA,GAAAlB,OAAA,CAAAmB,YAAA,GAAAnB,OAAA,CAAAoB,YAAA,GAAApB,OAAA,CAAAqB,WAAA,GAAArB,OAAA,CAAAsB,YAAA,GAAAtB,OAAA,CAAAuB,cAAA,GAAAvB,OAAA,CAAAwB,cAAA;AACA,IAAAC,mBAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,eAAA,GAAAF,sBAAA,CAAAC,OAAA;AAOA,IAAAE,gBAAA,GAAAH,sBAAA,CAAAC,OAAA;AACA,IAAAG,QAAA,GAAAH,OAAA;AAuBA,IAAAI,UAAA,GAAAL,sBAAA,CAAAC,OAAA;AACA,IAAAK,QAAA,GAAAN,sBAAA,CAAAC,OAAA;AACA,IAAAM,OAAA,GAAAP,sBAAA,CAAAC,OAAA;;;;AAEO,IAAMO,QAAA,GAAAP,OAAiB,aAAvB;AACA,IAAMQ,UAAA,GAAAR,OAAiB,uBAAvB;AACA,IAAMS,UAAA,GAAYC,uBAAlB,CAAAV,OAAA;AACA,IAAMW,KAAA,GAAAX,OAAc;AACpB,IAAMY,MAAA,GAAAZ,OAAe,UAAW;AAChC,IAAMa,UAAA,GAAYb,OAAG,eAArB;AAgBA,IAAMc,QAAA,GAAAd,OAAgB,CAAG,YAC9B;AAAS,IAAAe,qBAAM,EAAAC,mBAAA,EAAAC,kBAAA,EAAAC,kBAAA;AACd,SAADC,QAAAC,MAAA,EAAAC,cAAA;EAAA,IAAAC,IAAA,GAAAC,MAAA,CAAAD,IAAA,CAAAF,MAAA;EAAA,IAAAG,MAAA,CAAAC,qBAAA;IAAA,IAAAC,OAAA,GAAAF,MAAA,CAAAC,qBAAA,CAAAJ,MAAA;IAAA,IAAAC,cAAA,EAAAI,OAAA,GAAAA,OAAA,CAAAC,MAAA,WAAAC,GAAA;MAAA,OAAAJ,MAAA,CAAAK,wBAAA,CAAAR,MAAA,EAAAO,GAAA,EAAAE,UAAA;IAAA;IAAAP,IAAA,CAAAQ,IAAA,CAAAC,KAAA,CAAAT,IAAA,EAAAG,OAAA;EAAA;EAAA,OAAAH,IAAA;AAAA;AAAA,SACAU,cAAAC,MAAA;EAAA,SAAAC,CAAA,MAAAA,CAAA,GAAAC,SAAA,CAAAC,MAAA,EAAAF,CAAA;IAAA,IAAAG,MAAA,GAAAF,SAAA,CAAAD,CAAA,YAAAC,SAAA,CAAAD,CAAA;IAAA,IAAAA,CAAA;MAAAf,OAAA,CAAAI,MAAA,CAAAc,MAAA,SAAAC,OAAA,WAAAC,GAAA;QAAA,IAAArC,gBAAA,aAAA+B,MAAA,EAAAM,GAAA,EAAAF,MAAA,CAAAE,GAAA;MAAA;IAAA,WAAAhB,MAAA,CAAAiB,yBAAA;MAAAjB,MAAA,CAAAkB,gBAAA,CAAAR,MAAA,EAAAV,MAAA,CAAAiB,yBAAA,CAAAH,MAAA;IAAA;MAAAlB,OAAA,CAAAI,MAAA,CAAAc,MAAA,GAAAC,OAAA,WAAAC,GAAA;QAAAhB,MAAA,CAAAmB,cAAA,CAAAT,MAAA,EAAAM,GAAA,EAAAhB,MAAA,CAAAK,wBAAA,CAAAS,MAAA,EAAAE,GAAA;MAAA;IAAA;EAAA;EAAA,OAAAN,MAAA;AAAA;AAAW,IAAApC,cAAM;AAAjBxB,OACA,CAAAwB,cAAA,GAAAA,cAAA;AAAC,IAAAD,cAAD,GAAAC,cAAA;AAAWxB,OAAI,CAAEuB,cAAA,GAAAA,cAAA;AAAjB,IACAD,YAAA,GAAAC,cAAA;AAACvB,OAAK,CAAAsB,YAAN,GAAAA,YAAA;AAAY,IAAAD,WAAM,GAAAC,YAAA;AAAlBtB,OACA,CAAAqB,WAAA,GAAAA,WAAA;AAAC,IAAAD,YAAD,GAAAC,WAAA;AAAYrB,OAAI,CAAEoB,YAAA,GAAAA,YAAA;AAAlB,IACAD,YAAA,GAAAE,WAAA;AAACrB,OAAK,CAAAmB,YAAO,GAAAA,YAAb;AAAgC,IAAAD,gBAAM;EAPjCoD,GAAA;;AAUA;;EACAC,IAAM;;EAEND,GAAM;EACXC,IAAA,EAAM;AACN;EACAD,GAAA,KAAO;EAHFC,IAAA;;EAMAD,GAAM;EAGbC,IAAA;AACA;EACAD,GAAA;;;EAEAA,GAAM,EAAAE,MAAA,CAAAC,iBAAiB;EAEnBF,IAAA;AAFmB;AAOnBvE,OAAA,CAAAkB,gBAAS,GAAAA,gBAAA;AAPU,IAAAD,aAAA;AAahBjB,OAAM,CAAAiB,aAAiB,GAAAA,aAAA;;AAQvBjB,OAAM,CAAAgB,qBAAwB,GAAGA,qBAAA;AACtC,IAAAD,oBADsC,OAAAgB,UAAA;EAC1B2C,MAAA;EACZC,IAAA,EAAM,IAAE;EACRC,OAAI,EAHkC;AAKtC;AACA5E,OAAA,CAAAe,oBANsC,GAAAA,oBAAA;AAOtC,IAAAD,2BAPsC,OAAAiB,UAAA,iBAAAF,gBAAA,iBAAAd,oBAAA,CAAA4D,IAAA;AAQtC;AACA;AACA;;AAGA3E,OAAI,CAAEc,2BAbgC,GAAAA,2BAAA;AAa5B,IAAA+D,iBAAA,IAAAjC,kBAAA,WAAAf,gBAAA,aAAAe,kBAAA,EAAAT,UAAA,CAAA2C,YAAA,CAAAC,SAAA,GAAArC,qBAAA;EACV,SAAM,EAdgC;AAetC,OAAAb,gBAfsC,aAAAa,qBAAA,EAAAP,UAAA,CAAA6C,eAAA,CAAAC,OAAA,oBAAApD,gBAAA,aAAAa,qBAAA,EAAAP,UAAA,CAAA6C,eAAA,CAAAE,IAAA,gBAAAxC,qBAAA,QAAAb,gBAAA,aAAAe,kBAAA,EAAAT,UAAA,CAAA2C,YAAA,CAAAK,KAAA,GAAAxC,mBAAA;EAexB;AACd,OAAAd,gBAhBsC,aAAAc,mBAAA,EAAAR,UAAA,CAAA6C,eAAA,CAAAC,OAAA,oBAAApD,gBAAA,aAAAc,mBAAA,EAAAR,UAAA,CAAA6C,eAAA,CAAAE,IAAA,gBAAAvC,mBAAA,IAAAC,kBAAA;AAiBtC,IAAA/B,iBAjBsC,IAAAgC,kBAAA,WAAAhB,gBAAA,aAAAgB,kBAAA,EAAAV,UAAA,CAAA2C,YAAA,CAAAM,MAAA,6BAAAvD,gBAAA,aAAAgB,kBAAA,EAAAV,UAAA,CAAA2C,YAAA,CAAAO,WAAA,4BAAAxD,gBAAA,aAAAgB,kBAAA,EAAAV,UAAA,CAAA2C,YAAA,CAAAC,SAAA,0BAAAlD,gBAAA,aAAAgB,kBAAA,EAAAV,UAAA,CAAA2C,YAAA,CAAAK,KAAA,sBAAAtD,gBAAA,aAAAgB,kBAAA,EAAAV,UAAA,CAAA2C,YAAA,CAAAQ,OAAA,oBAAAzC,kBAAA;AAmBtC7C,OAAA,CAAAa,iBAAA,GAAAA,iBAAA;AACA,IAAAD,wBAAU;EACV8D,MAAK,EAAE;EACP;EAEAa,MAAA;EACAC,EAAA,EAAG,IAAE;EAzBA;;EA4BAC,QAAM;;EAENC,eAAmB,EAAAvD,UAAI,CAAAwD,gBAAa,CAAAC,IAAA;EAE3CC,KAAA;EACA;EACAlB,IAAA;;;;EACO;EACLmB,MAAA;EAEEC,KAAA;EACA;EACAC,QAAI,EAAA7D,UAAA,CAAA8D,UAAA,CAAAC,SAAe;EAJrBC,KAAA;EAMDC,QAAA;EAED;EACAC,GAAA;AACA;AACArG,OAAA,CAAAY,wBAAA,GAAAA,wBAAA;AACA,IAAAD,gBAAA;AACAX,OAAA,CAAAW,gBAAA,GAAAA,gBAAA;;;AACO;AACL;;AAEDX,OAAA,CAAAU,aAAA,GAAAA,aAAA;AAWD,SAAA4F,iBAAA5B,MAAA;EACA,OAAAf,aAAA,CAAAA,aAAA,KAAA/C,wBAAA;IACA;IACA8D,MAAA,MAAAnC,MAAA,CAAAgE,OAAA,EAAA7B,MAAA;IACAc,EAAA,MAAAjD,MAAA,CAAAiE,cAAA,EAAA7F,gBAAA;EACA;AACA;AACO;AAKL;AAAgB;AAAS;AAAV;AAD6B;;AAAA,SAEf8F,kBAAApD,MAFe,EAAAqD,SAAA;;EAI5C,OAAKC,OAAD,CAAAC,QAAa,CAAAF,SAAA,KAAmBrD,MAAM,CAAA0C,KAAQ;AAChD;;;AAGF;;AAEA;AACE;AACD;;AAED,SAAMc,qBAAoBC,CAAAC,OAAC,EAAA1D,MAAA,EAAA2D,MAAA;EAAA,IAAAC,MAAI;IAA/BF,OAAA,EAAAA,OAAA;;EAEA;EACE,IAAAhB,KAAO,GAAA1C,MAAP,CAAA0C,KAAA;IACDnB,OAAA,GAAAvB,MAAA,CAAAuB,OAAA;;IAEDF,MAAO,GAAArB,MAAA,CAAAqB,MAAA;EAGH,KAAAE,OAAQ,IAFJ,CAAAsC,kBAAA,CAAAC,IAAA,EAAApB,KAAA;IAGJ,OAAAkB,MAAU;EAHN;EADD,IAAPG,cAAA,GAAA1C,MAAA,CAAAkC,QAAA,CAAAG,OAAA,CAAAvB,EAAA;EAUF,KAAA4B,cAAA;IACA,OAAAH,MAAA;EACA;;IACM,OAAArC,OAAA,CAAAgC,QAAgB,CAAAS,CAAA,CAAA7B,EAAA;EAItB;EAEA,KAAAsB,KAAA;IACA,OAAAG,MAAA;EACA;;IAEO5D,MAAS,EAAAM,aACd,CAAAA,aADK,EAGgC,GAAAN,MAAA;MACrCkC,MAAA;MACM+B,QAAM,EAAG;IAAC;IAASP,OAAM,EAAEA;EAAlB,CAAf;AACA;AAEA;;AACA;;AAGC,IAAAQ,gBAAA,OAAA1F,gBAAA,iBAAAM,UAAA,CAAA2C,YAAA,CAAAQ,OAAA,EAAAuB,qBAAA;;AAED;AAIE;AACA;AAL4B;;;;EAXO;EAyBlC,IAAAI,MAAA,GAAW;IAzBuBF,OAAA,EAAAA,OAAA;IAAA1D,MAoBtB;EApBsB;;EA4BrC,IAAImE,kBAAgB,GAAAC,YAAA,CAAAC,OAAA,CAAAX,OAAA,CAAAvB,EAAA;EAEnB,IAAAgC,kBAAA,aAAAjF,MAAA,CAAAgE,OAAA,EAAAlD,MAAA,CAAAsB,IAAA,EAAA6C,kBAAA;;IAED,OAAAP,MAAc;EACd;EAGA,IAAIU,gBAAc,GAAdhE,aAA8B,CAAAA,aAAA,CAAAA,aAAA,KAAA2C,gBAAA,CAAAjD,MAAA,CAAAqB,MAAA,IAAArB,MAAA;IAChCqB,MAAA,EAAA+C,YAAA;IACA9C,IAAA,GAAO,GAAApC,MAAP,CAAAgE,OAAA,EAAAlD,MAAA,CAAAsB,IAAA;EACD;EAED,IAAAiD,SAAO,GAAAD,gBAAA,CAAAhD,IAAA,CAAA6C,kBAAA;EAEL,IAAAK,qBAAS,GAAAC,oBAAA,CAAAH,gBAAA,EAAAZ,OAAA,EAAAa,SAAA,EAAAJ,kBAAA;MAFXO,WAAA;IAID;IAEDC,aAAA,GAAAH,qBAAA,CAAAxE,MAAA;IACA4E,cAAA,GAAAJ,qBAAA,CAAAd,OAAA;EAEA,KAAAiB,aAAA;IACA,OAAAf,MAAA;EACA;EAEAe,aAAA,CAAAjC,KAAA,GAAAmC,yBAAA,CAAA7E,MAAA,CAAA0C,KAAA,EAAAiC,aAAA;EACAA,aAAA,CAAAvC,QAAA,UAAApC,MAAA,CAAAoC,QAAA,iBAAApC,MAAA,CAAAoC,QAAA,GAAAuC,aAAA,CAAAvC,QAAA;;IACO;IAKL,OAAOwB,MAAO;EAGf;EAGD;IACA5D,MAAA,EAAA8E,mBAAA,CAAAH,aAAA,EAAAC,cAAA;IACAlB,OAAA,EAAAkB;EACA;AACA;;;AACA;AACE;AAD4C;AAAA;AAAA;;AAM5C;;AACkC,SAAAG,uBAAArB,OAAA,EAAA1D,MAAA,EAAA2D,MAAA;EAAA,OAAA3D,MAAkB,CAAA8D,IAAI,IAAKI,gBAAkB,CAAAc,cAA7C,CAAAhF,MAAA,CAAA8D,IAAA,IAAAI,gBAAA,CAAAlE,MAAA,CAAA8D,IAAA,EAAAJ,OAAA,EAAA1D,MAAA,EAAA2D,MAAA,IAAAsB,cAAA,CAAAvB,OAAA,EAAA1D,MAAA;AAAA;AAEhC;AAGM;AAHc;AAIe;AAAb;AAGvB;;AAGF,SAAA8E,oBAAA9E,MAAA,EAAA0D,OAAA;EAED;EACA,IAAAwB,MAAA,GAAAxB,OAAA,CAAAwB,MAAA;EACA,IAAAC,OAAA,GAAAnF,MAAA;IACA8C,KAAA,GAAAqC,OAAA,CAAArC,KAAA;;EAEA,IAAAA,KAAA;IACA,IAAAsC,WAAA,GAAAF,MAAA,CAAAG,IAAA,WAAAC,IAAA;;;MACO,OAAShE,IAAA,KAAAwB,KACd,CAAAxB,IACA,IAAAwC,IAAA,KACuChB,KAAA,CAAAgB,IAAA;IACvC,EAAM;IAEJ9D,MAAA,GAASoF,WAAQ,GAAA9E,aAAA,CAAAA,aAAA,KAAAN,MAAA;MAFnB8C,KAAA,EAAAsC;;MAKAtC,KAAQ,EAAAsC;IACN,IAAA1B,OAAK,KAAA1D,MAAA;EACL;EAGI,OAAAA,MAAO;AACP;AACA;AACA;AACA;AANF;;AASF;AACE;;AAIE,SAAAuF,cAHF7C,CAAA8C,KAAA,EAAAC,WAAA;EAIE,IAAAC,WAAK,GAAApF,aAAA,CAAAA,aAAA,KAAAmF,WAAA;IAJPE,SAAA,EAAAH,KAAA,CAAA1B;;EAQF,QAAK0B,KAAA,CAAA1B,IAAA;IACH,KAAAhF,UAAA,CAAA6C,eAAA,CAAAE,IAAA;IACA,KAAA/C,UAAA,CAAA6C,eAAA,CAAAC,OAAA;MAEE,OAAItB,aAAE,CAAAA,aAAa,KAAAoF,WAFrB;QAGEhD,KAAK,EAAE+C,WAHT,CAAAhD,MAAA;QAIEqB,IAAG,EAAEhF,UAAA,CAAA2C,YAAA,CAAAK,KAAA;QAJP;;QAOFkB,GAAK;MACH;IAGE,KAAAlE,UAAM,CAAA6C,eAAA,UAAa;MACnB;MACA,OAAArB,aAJF,CAAAA,aAAA,KAAAoF,WAAA;QAKE5B,IAAA,EAAKhF,UAAE,CAAA2C,YALT,CAAAM,MAAA;QAMEW,KAAK;QANPM,GAAA;;IAUA,KAAAlE,UAAA,CAAA6C,eAAA,CAAAiE,MAAA;IACA,KAAA9G,UAAA,CAAA6C,eAAA,CAAAkE,IAAA;MA5CJ;MA8CD,OAAAvF,aAAA,CAAAA,aAAA,KAAAoF,WAAA;;QAEYhD,KAAA;QACLM,GAAA;;IAGJ,KAAKlE,UAAA,CAAA6C,eAAY,CAAAmE,SAAjB;MACA;MACE,OAAOxF,aAAA,CAAIA,aAAI,KAAAoF,WAAA;QACb5B,IAAM,EAAAhF,UAAM,CAAA2C,YAAZ,CAAAC,SAAA;QACAU,QAAO,EAAG,IAAC;QAFb2D,WAAA;;QAIF/C,GAAK;MACL;IAEI;MACA;MAKe;EAAA;AAEhB;AACH,IAAA5F,uBAAK,YAAYA,uBAAjB4I,CAAAvC,KAAA,EAAAzD,MAAA,EAAAiG,aAAA;EACE,IAAAC,WAAU,GAAAzC,KAAA,CAAA0C,mBAAuB,CAAAF,aAAc;EAE3C,QAAAxC,KAAA,CAAAK,IAAA;IACA,KAAAhF,UAAM,CAAAsH,WAAiB,CAAAC,KAAA;IACvB,KAAAvH,UAAO,CAAAsH,WAAY,CAAAE,IAAA;MACpB,OAJD,UAAAC,IAAA;QAKD,IAAAC,GAAA,GAAAN,WAAA,CAAAK,IAAA;;MACD;;IAEE,KAAAzH,UAAK,CAAAsH,WAAA,CAAAK,IAAA;MACH,iBAAAF,IAAA;QACD,IAAAC,GAAA,GAAAN,WAAA,CAAAK,IAAA;;UACD,OAASG,WAAG,CAAAL,KAAA,EAAArG,MAAA,CAAA0C,KAAY;QAAC;MAAD;IAEzB,KAPD5D,UAAA,CAAAsH,WAAA,CAAAJ,SAAA;;QAQF,iBAAAO,IAAA;UACE;UAAO,IAAAI,QAAA,GAAAlD,KAAA,CAAAmD,aAAA,CAAAC,SAAA,CAAAN,IAAA,CAAAO,KAAA;UAAP,OAAAH,QAAA,IAAAD,WAAA,CAAAC,QAAA,EAAA3G,MAAA,CAAA0C,KAAA;QApCJ;MAHK;MA4CP,iBAAA6D,IAAA;QACA,IAAApE,EAAA,GAAA+D,WAAA,CAAAK,IAAA;QAEA,SAAAtH,KAAA,CAAA8H,SAAA,EAAA5E,EAAA;;;;UAEAA,EAAA,EAAAA;QACA;QACA,OAAAqE,GAAA,CAAAQ,KAAA,CAAA7F,MAAA,CAAA8F,QAAA,KAAAP,WAAA,CAAAF,GAAA,EAAAxG,MAAA,CAAA0C,KAAA;MACA;IAEA;MACA;QACA;;;AAEO;AAOL;AACA;AAAwD;AAAA;;;AACnC/F,OAArB,CAAAS,uBAAA,GAAAA,uBAAA;;AAEA;AACE;AACE;AAAW;AAAA;;AACb;AACE;;AAAW;;EACb;EACE,IAAA8J,aAAO,GAAA1B,KAAI,GAAAA,KAAA,CAAA0B,aAAA,aAAAX,IAAA;IAAA,WAAI;EAAJ;EACb,IAAAY,WAAK,YAAAA,WAAaA,CAAAC,CAAlB;IACE,OAAK;EACH;;IAEF,KAAAtI,UAAM,CAAA2C,YAAc,CAAAK,KAAA;MACpB,OAAM,UAAWyE,IAAM;QACf,OAAIc,SAAA,CAAAH,aAAJ,CAAAX,IAAA,GAAAvG,MAAA,CAAA0C,KAAA;MAAA,CADS;IAET,KAFR5D,UAAA,CAAA2C,YAAA,CAAAO,WAAA;MAGA,OAAO,UAAAuE,IAAI;QAAA,OAAIvG,MAAA,CAAA0C,KAAU,CAAAa,QAAS,CAAA2D,aAAc,CAAAX,IAArC;MAAA,CAAX;IACF,KAAKzH,UAAA,CAAA2C,YAAA,CAAaM,MAAA;MAChB,OAAK,UAAWwE,IAAA,EAAO;QACrB,OAAOW,aAAP,CAAAX,IAAA,MAAAvG,MAAA,CAAA0C,KAAA;MACD;IACD,KAAA5D,UAAM,CAAA2C,YAAoB,CAAGC,SAAO;MAC3B,KAAA8D,KAAI;QAAa,OAAA2B,WAAa;MAAb;MACf,IAAAG,WAAU,GAAC,IAAF1I,OAAA,UAAoB,CAA7B,EAAA4G,KAAA;MAAA,IACR+B,QAAI,GAAAC,KAAA,CAAAC,OAAK,CAAAH,WAAA,cAAAf,IAAA;QAAA,OAAIe,WAAA,CAAAf,IAAA,CAAAO,KAAA,CAAuB;MAA3B,CAHiB,GAA7B,UAAAP,IAAA;QAKA,OAAO,IAAApH,UAAI,CAAAuI,eAAA,EAAAR,aAAA,CAAAX,IAAA,GAAAf,KAAA,CAAAmC,MAAA;MAAA;MAAyC,iBAAIpB,IAAU,EAAC;QAAf,OAAzCc,SAAA,CAAAE,QAAA,CAAAhB,IAAA,GAAAvG,MAAA,CAAA0C,KAAA;MAAA,CAAX;IACF,KAAA5D,UAAA,CAAA2C,YAAA,CAAAQ,OAAA;MACE,KAAA0B,MAAO,KAAAA,MAAP,CAAAjD,MAAA,KAAAV,MAAA,CAAAuB,OAAA;QA3BJ,OAAA4F,WAAA;MA6BD;MAEM,IAASS,oBAAmB,GAAA5H,MAAuC,CAAAuB,OAAA,CAAAsG,GAAA,WAAA1F,EAAA;QACxE,OAAOwB,MAAA,CAAA0B,IAAiB,WAAxBrB,CAAA;UACD,OAAAA,CAAA,CAAA7B,EAAA,KAAAA,EAAA;;MAEM,GAASnC,MAAA,WAAAgE,CAAA;QAEZ,OAAAA,CAAA,IAAAA,CAAA,CAAA8D,MAWY,CAAAzG,MAXZ,KAAAA,MAAA;MACA,GAAAwG,GAAA,WAUYpE,KAVZ;QACA,OAAArG,uBASY,CAAAqG,KAAA,EAAAzD,MAAA,EAAAiG,aAAA;MACR;MACA,iBAA0BM,IAAhC;QAEM,OAAAqB,oBAAgB,CAAAZ,KAAA,WAAAe,UAAA;UAAM,OAANA,UAAA,CAAAxB,IAAA;QAAY;MAAlC;IACA;MAAyB,OAAoBY,WAAY;EAAA;;;EAGzD,OAAKlE,gBAAe,CAAA5B,MAAS,CAAE;AAC7B;;EAGA,IAAA2G,oBAAoB,GAAAC,KAAA,CAAAD,oBAAA;IAClBE,UAAA,GAAAD,KAAA,CAAAC,UAA4B;IAC7BC,WAAA,GAAAF,KAAA,CAAAE,WAAA;;EAED,IAAAC,aAAM,GAAc;;IACpBtB,KAAI;IACFb,aAAA,EAAaA;EACd;;IAGH,OAAAkC,WAAA,CAAAnI,MAAA,CAAAmC,EAAA,EAAAkG,aACM;EAAwB;EACV,IAAAC,OAAA,GAAArC,aAAA,CAAAqC,OAAA;EAErB,SAAA9H,CAAA,MAAAA,CAAA,GAAA8H,OAAA,IAAA9H,CAAA;IAED6H,aAAA,CAAAvB,KAAA,GAAAtG,CAAA;IACA,IAAA+H,cAAA,GAAAP,oBAAA,IAAAA,oBAAA,CAAAhB,KAAA,CAAAwB,gBAAA;;;IAEO;IAKL,IAAMC,cAA6B,GAAAP,UAAA,IAAAA,UAAA,CAAAlB,KAAA,CAAAwB,gBAAA;IAEjC,IAAAC,cAFiC;MAGjCL,aAHiC,CAAAhI,IAAA,CAAAiI,aAAA,CAAAvB,KAAA;IAIjC;EAJiC;EAQjC,OAAIxG,aAAA,CAAAA,aAA4B,CAAC,IAAA0H,oBAAU;IACzCU,sBAAkB,EAAIA;EAKtB,KAAC,CAAC,CAAC,EAAAR,UAAY;IAChBE,aAAA,EAAAA;EACF,CATD;AAWA;AACD;AAED;AACA;;;EAEO,IAAAO,GAAS,GAAAlI,SACd,CAAAC,MAAA,QAEeD,SAAA,QAAAmI,SAAA,GAAAnI,SAAA;EAAA,IADfoI,YAAA,GACe;IACfC,aAAI,EAAqC;IAExC/C,WAAO,EAAQ;IAAqEgD,GAAA;IAAA/F,GAAA,EAAnB;EAAmB;;IACnF,IAAAa,kBAAc,CAAAmF,CAAA,CAAAlF,IAAA,EAAMkF,CAAI,CAAAtG,KAAA,SAAAxD,MAAA,CAAAgE,OAAA,EAAA8F,CAAA,CAAA3H,MAAA,EAAAkC,QAAA,CAAAlC,MAAA;MACtB,CAAA2H,CAAA,CAAAjD,WAAuB,IAAI4C,GAAA,CAAAM,YAAgB,GAAAJ,YAAe,CAAA9C,WACxD,GAAA8C,YAAA,CAAAC,aAAA,EAAA1I,IAAA,CAAA4I,CAAA;MAAA,CAAAA,CAAA,CAAAhG,GAAA,IAAgB,CAAC2F,GAAF,CAAAO,OAAS,GAAOL,YAA/B,CAAA7F,GAAA,GAAA6F,YAAA,CAAAE,GAAA,EAAA3I,IAAA,CAAA4I,CAAA;IAAA;;EAGF,OAAAH,YAAA;AACE;AACA;AACD;AACC;;AAGI,SAAAM,YAAAN,YAAgB;EACjB,IAAAO,eAAA,GAAA3I,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAmI,SAAA,GAAAnI,SAAA;EACF,IAAA4I,aAJD;EAKDxJ,MAAA,CAAAyJ,OAAA,CAAAT,YAAA,EAAAjI,OAAA,WAAA2I,KAAA;IACF,IAhBDC,KAAA,OAAAjL,eAAA,aAAAgL,KAAA;MAkBCE,MAAA,GAAAD,KAAgB;MACfE,KAAA,GAAAF,KAAA;IACiBE,KAAA,CAAA9I,OAAM,WAAOZ,MAAU,EAAvB;MAAA,IAA4B2J,SAAA,IAAAP,eAAA,CAAAK,MAAA,SAAApE,IAAA,WAAA2D,CAAA;QAC3C,OAAAA,CAAA,CAAA7G,EAAA,KAAgBnC,MAAA,CAAAmC,EAAA;MACjB;MAvBL,KAAAwH,SAAA;QA2BA;QAAYN,aAAe,GAAhB,IAAAnK,MAAA,CAAA0K,GAAA,GAAAH,MAAA,EAAAzJ,MAAA,CAAAmC,EAAA,YAAAkH,aAAA;MAAsB;QAAsB;QAAW,CAAE,2BAAAzI,OAAA,WAAAiJ,IAAA;UAAU,IAAA7J,MAA9E,CAAA6J,IAAA,MAAAF,SAAA,CAAAE,IAAA;YACDR,aAAA,OAAAnK,MAAA,CAAA0K,GAAA,GAAAH,MAAA,EAAAzJ,MAAA,CAAAmC,EAAA,MAAA2H,MAAA,CAAAD,IAAA,eAAAR,aAAA;UACD;QACA;MACA;IACA;IACA,CAAAD,eAAA,CAAAK,MAAA,SAAA7I,OAAA,WAAA+I,SAAA;MACA;MACA,KAAAD,KAAA,CAAArE,IAAA,WAAA2D,CAAA;QACA,OAAAA,CAAA,CAAA7G,EAAA,KAAAwH,SAAA,CAAAxH,EAAA;;;MACO;IAA2E,EAAf;EAAe;;IAChF2G,aAAW;IACT/C,WAAO,EAAP;IAEFgD,GAAA;IACA/F,GAAA;;;AACA;AACE;AACD;;AAED;AACE;AACA;AACE;;AACqB,SAAZ6B,yBAAPA,CAAAnC,KAAA,EAAAqH,KAAA;EACD,IAAAtH,MAAA,GAAAsH,KAAA,CAAAtH,MAAA;;EAEgB,KAAAqB,IAAA;IAAA,OAAjB;;EAEF;;EAGG,IAAAA,IAAA,KAAAhF,UAAA,CAAA2C,YAAA,CAAAQ,OAAA,KAAAQ,MAAA;;EACD;EAAoC,QAApCqB,IAAA;IACA,KAAAhF,UAAO,CAAA2C,YAAc,CAAdK,KAAuB;;MAEhC,IAAK,CAAA0F,KAAA,CAAAC,OAAA,CAAA/E,KAAA,KAAaA,KAAlB,CAAAhC,MAAA;QACE,OAAO+B,MAAO,CAAAoF,GAAA,WAAPT,CAAA,EAAyB;;QAClC,CAAK;MACH;MAEF,OAAA1E,KAAA,CAAAmF,GAAA,WAAAT,CAAA,EAAA5G,CAAA;QACE,OAAO,EAAP,EAAArB,UAAA,CAAA6K,kBAAA,EAAA5C,CAAA,KAAAC,SAAA,CAAAD,CAAA,EAAA3E,MAAA,IAAA2E,CAAA,GAAA3E,MAAA,CAAAjC,CAAA;MAtBJ;IAyBF,KAAA1B,UAAA,CAAA2C,YAAA,CAAAO,WAAA;;QAEA;MACA;;;MAEO;MAID,OAAwBiI,aAA5B,CAAAvJ,MAAA,GAAAuJ,aAAA;IAGA,KAAMnL,UAAW,CAAG2C,YAAA,CAAaM,MAAC;;IAGhC,KAAAjD,UAAS,CAAA2C,YAAW,CAAAQ,OAAgB;MACpC,OAAUS,KAAG;IAGb;MACE,OAAO,IAAP;EAAY;;AAGd;;AAEA;AACD;;;AAlBiB,SAoBAwH,qBApBAC,CAAAlE,aAoBA,EAAAiB,aApBA;;EAsBlB,IAAAhG,IAAO;EAAC,IAAAoG,WAAA,GAADrB,aAAA,CAAAmE,QAAA,CAAAlD,aAAA;EAAe,IAAAjB,aAAA,CAAAqC,OAAf;IAA0B7F,MAAA,GAAA1D,UAAA,CAAAsL,eAAA,CAAA/C,WAAA;IAAjC,IAAAgD,IAAA,GAAA7H,MAAA,MAAAA,MAAA;;IAGF,KAAA6H,IAAA;MACA7H,MAAA,MAAAA,MAAA;IACA;;IACOA,MAAS,MAAA8H,kBAAyC,CAAA9H,MAAA,KAAAvB,IAAA;IACvDuB,MAAO,GAAI,GAAC8H,kBAAZ,CAAA9H,MAAA,KAAAvB,IAAA;;EAGE,IAAAsJ,aAAA,GAAAC,YAAA,CAAAhI,MAAA,EAAA6E,WAAA;IADFzE,SAEW,GAAI2H,aAAM,CAAA3H,SAAA;IACnBsH,iBAAA,GAAAK,aAAA,CAAAL,iBAAA;EAEA;IAEF1H,MAAA,EAAAA,MAAA;IACAvB,IAAA,EAAAA,IAAA;;;EACA;;AAGA;AACA;AAGA;;AAGA,SAAAwJ,mBAAAJ,IAAA;;EAED,IAAAA,IAAA;IAED;EACA,WAAAA,IAAA;IACA;;;EACO;EAIL;;EAIA,IAAMK,CAAA,GAAAL,IAAM,GAAG;;EAGf,IAAIM,eAAJ,GAAAD,CAAA,CAAAE,aAAA;EAEA,IAAMC,QAAO,GAAAC,UAAY,CAAAH,eAAzB,CAAAI,KAAA;EACA;EAAqC;EAAA;;;EAEnC,OAAI,IAAGnM,QAAP,CAAAoM,OAAA,KAAAC,GAAA,CAAAJ,QAAA,EAAAK,QAAA;AACD;;AAdqB;AAAA;;AAkBtB,SAAOC,wBAAAnF,aAAA,EAAAiB,aAAA;EACL;EACA;EACA,IAAAI,WAAA,GAAArB,aAHK,CAAAmE,QAAA,CAAAlD,aAAA;EAIL,IAAAzE,MAAA,GAAA1D,UAJK,CAAAsL,eAAA,CAAA/C,WAAA;EAKL,IAAA+D,iBAAA,GAAAC,2BALK,CAAA7I,MAAA;EAML,IAAAvB,IAAA;EANK,IAAPoJ,IAAA,GAAA7H,MAAA,MAAAA,MAAA;EAQD,IAAA8I,KAAA,GAAA1N,gBAAA,CAAAwH,IAAA,WAAA2D,CAAA;;EAEM;EAQK,IAAAuC,KAAK;IACXrK,IAAA,GAAKqK,KAAK,CAACrK,IAAA;EACX;EAEA,IAAAsK,cAAQ,GAAAf,YAAA,CAAAhI,MAAA,EAAA6E,WAAA;IAJFzE,SAAA,GAAA2I,cAAA,CAAA3I,SAAA;IAHVsH,iBAAA,GAAAqB,cAAA,CAAArB,iBAAA;EAUF;IACA1H,MAAA,EAAAA,MAAA;IACAvB,IAAA,EAAAA,IAAA;;;IACOiJ,iBAAA,EACLA,iBACA;IAEAkB,iBAAkB,EAAAA;EAClB;AAEA;AAAmB,SAAAI,mBAAAhJ,MAAA,EAAA6E,WAAA,EAAAoE,IAAA;EAAZ,OAAP,IAAAjN,QAAA,CAAAoE,SAAA,IAAA8I,UAAA,KAAAlN,QAAA,CAAAmN,KAAA,EAAAnJ,MAAA,KAAAA,MAAA,KAAAiJ,IAAA,GAAAjJ,MAAA,CAAAA,MAAA,EAAA6E,WAAA,EAAAO,GAAA,WAAAgE,GAAA;IACD;MAEDC,KAAA,EAAAD,GAAA,CAAAnL,MAAA;MACAmL,GAAA,EAAAA,GAAA;MACAE,EAAA,EAAAF,GAAA,CAAAE,EAAA;MACAC,EAAA,EAAAH,GAAA,CAAAG;IACA;EACA;AACA;AACA;;;;AAGI,SAAAvB,YAAOA,CAAWhI,MAAG,EAAI6E,WAAlB,EAAgC;EACxC,IAAAzE,SAAA,GAAA4I,kBAAA,CAAAhJ,MAAA,EAAA6E,WAAA,EAAA1J,aAAA;;EAED,OAAO;IACRiF,SAAA,EAAAA,SAAA;;EAEM;AACL;AACE;AACD;;AAED;AACD;AAED;AACA;AACA;;AAGA,SAAA0H,mBAAA0B,GAAA,EAAA/K,IAAA,EAAAgL,KAAA;EACA,IAAAA,KAAA;;;EAEE,OAAOC,IAAA,CAAAC,IAAA,CAAAH,GAAA,QAAA/K,IAAA,MAAc,IAAAA,IAAA;AACtB;AACM,SAASmG,UAAA4E,GAAA,EAAAxJ,MAAA;EACd,IAAI,CAAC+E,KAAA,CAAAC,OAAA,CAAAhF,MAAkB;IACrB,OAAO,KAAP;EACD;EAED,OAAMwJ,GAAI,IAAGxJ,MAAA,GAAY,IAAAwJ,GAAO,IAEhCxJ,MAAA;AACA;;AACA;AACD;AAED;AACA;AACA;AACA;;AACO,SAASiE,YAAAL,KAAA,EAATpE,OAAA,EAAmD;EACxD,OACE,IAAAoK,cAAA,UAAM,OAAAC,QAAN,CAAAjG,KAAA,EAAAA,KAAQ,GAAApE,OACR;AAIH;AAGD,SAAAqJ,4BAAA7I,MAAA;EACA,KAAAxF,iBAAA,CAAAwF,MAAA;IACA;;;;;EAGE,OAAK6H,IAAM,GAAAxM,YAAA,SAAAwM,IAAA,GAAAtM,WAAA;AACT;AACD;;AACD;AACE;;AAGA,SAAKuO,oBAAAvM,MAAa;EAClB,OAAK,CAAAA,MAAA,aAAAA,MAAa,UAAlB,aAAAA,MAAA,CAAA8D,IAAA,KAAA0D,KAAA,CAAAC,OAAA,CAAAzH,MAAA,aAAAA,MAAA,uBAAAA,MAAA,CAAAsB,IAAA,OAAAtB,MAAA,aAAAA,MAAA,uBAAAA,MAAA,CAAAsB,IAAA,CAAAZ,MAAA,MAAAV,MAAA,aAAAA,MAAA,uBAAAA,MAAA,CAAAuB,OAAA,CAAAb,MAAA,MAAAmD,kBAAA,CAAA7D,MAAA,aAAAA,MAAA,uBAAAA,MAAA,CAAA8D,IAAA,EAAA9D,MAAA,aAAAA,MAAA,uBAAAA,MAAA,CAAA0C,KAAA;AACE;AAA4C;AAAA;;AAE9C;;;;;EAMA,KAAAoB,IAAK;IACH,OAAM;EACN;EAEF,QAAAA,IAAA;IACE,KAAAhF,UAAA,CAAA2C,YAAA,CAAAM,MAAA;MAnBJ,OAAAW,KAAA,aAAAA,KAAA;;IAuBK,KAAS5D,UAAA,CAAA2C,YACd,CAAAC,SACA;MAEI,OAAO8F,KAAA,CAAAC,OAAa,CAAA/E,KAAA,KAAAA,KAAA,CAAAsE,KAAW,WAA/BwF,CAAA,EAA6C;QAC/C,OAAAA,CAAA,cAAAC,KAAA,CAAAD,CAAA;MACA;;MAHwC,OAAAhF,KAAA,CAAAC,OAAA,CAAA/E,KAMf,KAApBgK,OAAA,CAAAhK,KANmC,CAAAhC,MAAA;IAAA,KAOnC5B,UAAS,CAP0B2C,YAAA,CAAAkL,KAAA;MAQpC,OAAAD,OAAW,CAAAhK,KAAQ,CAAAhC,MAAA;IACzB,KAAI5B,UAAJ,CAAkB2C,YAAA,CAAAQ,OAAA;MAChB,IAAA2K,WAAA,GAAQ,IAARhO,OAAA,UAAsB,GAAA8D,KAAM,EAA5B;;IACQ;MAAe;EAAA;AACxB;;EAGD,IAAM1C,MAAM,CAAA2C,QAAG,KAAQ7D,UAAR,CACZ8D,UACC,CAAAC,SAAM,KAAA7C,MAAN,CAAA8C,KAAA;IAAA;IACE,OAAG;EACH;EAFF,IAIA+J,mBAEM,GAAA7M,MAAA,CAAAsH,WAAA;IAAAA,WAAA,GAAAuF,mBAAA,mBAAAA,mBAAA;EAAA,IAAA/J,KAAA,GAAA9C,MAAA,CAAA8C,KAAA;EAAA,IAAAmB,QAAY,GAAMP,OAAC,CAAAoJ,iBAAsB,CAAAhK,KAAP,CAAgBxB,IAAlD;EACF,IAAA2C,QAAU;IATlBtF,QAAA,YAAAoO,IAAA,UAAAjD,MAAA,CAAAhH,KAAA,CAAAxB,IAAA;IAWgC,OAAI;MAApC0L,SAAA;MACMlK,KAAA,EAAOA;IAEb;EAAQ;;EAA6B,IAAAmK,MAAA,GAAAvJ,OAAA,CAAAuC,aAAA,CAAA4B,GAAA,WAAAqF,GAAA,EAAAC,QAAA;IAAlB,OAAZ;MAAwCxC,CAAA,EAAKrD,WAAL,CAAA6F,QAAA;MAA/CC,CAAA,EAAAF,GAAA,CAAAG,OAAA,CAAApJ,QAAA;IACD;;IAEM,IAAA0G,CAAS,GAAA2C,KAAA,CAAA3C,CAAA;MACRyC,CAAA,GAAAE,KAAA,CAAAF,CAAA;;EAEN,GAAAG,IAAK,WAAAC,CAAA,EAALC,CAAsB;IACpB,OAAO,IAAPhP,QAAA,CAAAiP,SAAA,EAAAF,CAAA,CAAA7C,CAAA,EAAA8C,CAAA,CAAA9C,CAAA;EACD;;IAED,OAAKvD,CAAA,CAAMgG,CAAC;EACV;EACD,IAAAO,OAAA,IAAAV,MAAA,IAAAtC,CAAA,EAAAsC,MAAA,CAAAA,MAAA,CAAAvM,MAAA,MAAAiK,CAAA;;IAEDqC,SAAO;MACRC,MAAA,EAAAA,MAAA;MAEDW,OAAA,EAAAA,OAAA;MACAD,OAAA,EAAAA;IACA;IACA7K,KAAA,EAAAA;EACA;AACA;;;EAWE,IAAM,CAAA+K,eAAU;IAChB,OAAO;EACL;EAA8C,IAA9C,CAAA7N,MAAA,CAAA8C,KAAA;IACA,OAAM+K,eAAiB,UAAQ;EAAQ;EACvC,OAAMA,eAAgB,CAAC7N,MAAD,CAAtB8C,KAAA,CAAAgB,IAAA;AAEA;AAID;AACF;AAED;AACA;AACA;AACA;AACA;;AAGA,SAAAjH,uBAAAiR,UAAA,EAAAC,QAAA,EAAAC,OAAA,EAAArK,MAAA;EACA,IAAAL,OAAA,OAAApE,MAAA,CAAAgE,OAAA,EAAA4K,UAAA;;;MACO,OAAS9J,CAAA,CAAA8D,MAAA,CAAAzG,MAAA,KACdA,MACA;IAOA,EALA;IAKA,IAJA4M,cAIA,GAAAD,OAAA,CAAAhO,MAAA,WAAAoH,CAAA;MACA,OAAAhE,iBAAA,CAAAgE,CAAA,EAAA/F,MAAA;IACA,EAAM;IAEN,IAAM6M,KAAA,GAAUH,QAAG,CAAA1M,MAAQ;;EAE3B,GAAA0M,QAAI;AACF;AACA;AAAQ;AAAc;AAAf;AACR;;;AAGD;;;AAKE,SAAAtJ,oBAAUR,CAAAjE,MAAA,EAAA0D,OAAA,EAAAa,SAAA;EAGV,IAAAJ,kBAAA,GAAA1D,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAmI,SAAA,GAAAnI,SAAA;EACA,IAAA0N,MAAQ,GAAA1N,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAmI,SAAA;EAPK;;EAUf,IAAAwF,UAAO,GAAA1K,OAAA,CAAAoJ,iBAAA,CAAAvI,SAAA;;EAEL,IAAA6J,UAAA;IAFF;IAID;MAEDpO,MAAA;MACA0D,OAAA,EAAAA;IACA;;;;EAME,IAAI2K,SAAS,GAAA/N,aAAA,CAAAA,aAAA,KAAAoE,WAAA,GAAA5H,qBAAA,CAAAkD,MAAA,EAAA0F,WAAA,IAAApF,aAAA,CAAAA,aAAA,KAAAN,MAAA,GAAA0F,WAAA;IACXpE,IAAA,EAAAzB,MAAA,CAAAyO,MAAA,KAAAlQ,mBAAA,iBAAAc,MAAA,CAAAgE,OAAA,EAAAlD,MAAA,CAAAsB,IAAA,QAAA9C,gBAAA,iBAAA2F,kBAAA,EAAAI,SAAA;IACDN,QAAA,EAAApE,MAAA,CAAAyO,MAAA,KAAAlQ,mBAAA,iBAAAc,MAAA,CAAAgE,OAAA,EAAAlD,MAAA,CAAAiE,QAAA,QAAAzF,gBAAA,iBAAA2F,kBAAA,EAAAiK,UAAA;;IAEDlM,MAAK;EACH;;IAGFlC,MAAK,EAAMqO,SAAC;IACV3K,OAAO,EAAAA;EACR;;AAED;AAEmE;AAAA;;AAEnE;;;EAMA,KAAA1D,MAAQ;IACN,OAAK;EACL;EAGI,KAAA0F,WAAQ;IAFV,OAAA1F,MAAA;;EAMA,IAAAA,MAAM,CAAA2F,SACH,IAA2B3F,MAAQ,CAAA2F,SAAD,KAAnCD,WACgC,CAAAC,SAC3B,KAAAD,WAHP,CAAAjD,MAAA;IAKA,OAAAzC,MAAA;EAEE;;IAEJ,OAAKwN,CAAA,GAAAC,CAAA;EACL;EAEE,IAAAY,SAAO,GAAA/N,aAAP,CAAAA,aAAA,CAAAA,aAAA,KAAAN,MAAA,GAAA0F,WAAA;IArBJjD,MAAA,GAAA8L,cAAA,KAAAA,cAAA,CAAAA,cAAA,CAAA7N,MAAA;EAuBD;;IAGD,KAAA5B,UAAA,CAAA6C,eAAA,CAAAiE,MAAA;IACA,KAAA9G,UAAA,CAAA6C,eAAA,CAAAkE,IAAA;MACA,OAAAvF,aAAA,CAAAA,aAAA,KAAA+N,SAAA;;;IACoC,KAAAvP,UAAA,CAAA6C,eAAA,CAAAmE,SAK/B;MACD,IAAE5E,IAAA,GAAQlB,MANsB,CAAAkB,IAAA,GAAAwE,WAAA,CAAAxE,IAAA,GAAAlB,MAAA,CAAAkB,IAAA,GAAAwE,WAAA,CAAAxE,IAAA;MAOlC,OAAAZ,aAAU,CAAAA,aAAA,KAAA+N,SAAA;QAGRnN,IAAA,EAAQA;MAHA;IAPL,KAAApC,UAAA,CAAA6C,eAAA,CAAAE,IAAA;;;;;AAc6B;AAAA;;AAGpC;AACA;;;;EACO,OAASvB,aAAA,CAAAA,aAEd,CAFK,EAEQ,EAAAkO,OAAiC;IAC9CrM,EAAM,EAAAqM,OAAS,CAAArM,EAAA;IAAYsM,UAAM,EAAAnO,aAAN,CAAAA,aAAA,CAAAA,aAAA,KAAAkO,OAAA,CAAAC,UAAA,GAAAA,UAAA;MAAqBC,QAAO,EAAAA;IACvD;EAA4B;AAAA;AACH/R,OAAA,CAAAQ,oBAAA,GAAAA,oBAAA;AACzB,IAAAD,oBAAe,YAAiBA,oBAAhCmE,CAAA2H,CAAA;EACA,WAAApK,OAAA,aAAAoK,CAAA;AAEE;AACA;AACA;AACA;;AACgDrM,OAArB,CAAAO,oBAAA,GAAAA,oBAAA;AAE9B,SAAAyR,sBAAAhL,MAAA,EAAA6K,OAAA;EAED,IAAAnN,MAAA,GAAAsC,MAAA,CAAAkE,GAAA,WAAA7D,CAAA;IACA,OAAAA,CAAA,CAAA8D,MAAA,CAAAzG,MAAA;EACA,GAAArB,MAAA,CAAAb,UAAA,CAAA6K,kBAAA;;;EAOO;EAIL,IAAM1I,IAAA,GAAAqC,MAAA,CAAckE,GAAG,WAAM7D,CAAA,EAAQ;IAAQ,OAAIA,CAAC,CAAC8D,MAAF,CAAS8G,KAAA;EAAb,CAAtB,CAAvB;EACA,IAAM5O,MAAA,GAAOiD,gBAAkB,CAAA5B,MAA/B;;IAEA0E,WAAA,EAAc;IACZjC,IAAA,EAAAhF,UAAA,CAAA2C,YAAA,CAAAQ,OAAA;IACDX,IAAA,EAAAA,IAAA;;IAEDoB,KAAM,EAAAvF,oBAAqB,CAAAqR,OAAQ,EAAAxO,MAAA,CAAAmC,EAAe;MAElD0M,SAAO;IACR;EAED;AACA;AACA;;;;AAaE,SAAA9R,iBAAA+R,KAAA,EAAAzN,MAAA;EACA,IAAM0N,cAAN,GAAAD,KAAA,CAAAd,OAAA,CAAAhO,MAAA,WAAAgJ,CAAA;IACA,OAAMA,CAAa,CAAA3H,MAAnB,CAAAkC,QAAA,CAAAlC,MAAA;EAHA;EAKA,IAAIqC,OAAA,GAAAoL,KAAe,CAAAf,QAAG,CAAA1M,MAEtB;EACA,KAAAqC,OAAA;IACE,OAAAoL,KAAA;EACA;EAGA,IAAAE,kBAAI,GAAiBtL,OAAA,CAAAuL,cAAC,CAAAF,cAAA,EAAAD,KAAA,CAAAnL,MAAA;EAAA,WAAIzE,MAAA,CAAA0K,GAAQ,EAAZ,aAAAvI,MAAA,GAAA2N,kBAAA,EAAAF,KAAA;AAAA;AACpB;AADsC;AAIlC;;AACoC,SAArBI,6BAAfA,CAAAJ,KAAA;;EAFkB;EAAA,IAAAK,SAGH;EAHG,IAAAvL,MAGqB;;EAMvC,IAAAwL,eAAI,GAAArB,QAAe;;EAGfsB,iBAAA,CAAAzO,OAAA,WAAAZ,MAAA;IACA;IAOA,IAAA8N,UAAA,OAAA5O,MAAe,CAAAgE,OAAA,EAAAlD,MAAA,CAAAqB,MAAA;;IAVjB,IAAAyM,UAAA,CAAA9G,KAAA,WAAAI,CAAA;MAiBD,OAAA2G,QAAA,CAAA3G,CAAA;;MAED;MACD,IACDkI,kBAAA,GAAAxB,UAAA,CAAAyB,MAAA,WAAAC,GAAA,EAAAnM,SAAA;UACE,IAAAK,OAAQ,GADV0L,eAAA,CAAA/L,SAAA;UAEE,IAAAM,MAAA,GAAAmL,KAAiB,CAFnBnL,MAAA,CAAA3D,MAAA,WAAAgE,CAAA;YAGE,OAAAA,CAAA,CAAA8D,MAAiB,CAAAzG,MAAE,KAAAqC,OAAA,CAAAvB,EAAA;UArCe;UAAA,IAENsN,qBAFM,GAAA1K,sBAEN,CAAAyK,GAFM,CAAAE,iBAAA,CAAArM,SAAA,KAAAK,OAAA,EAAA1D,MAAA,EAAA2D,MAAA;YAEWgB,aAAA,GAFX8K,qBAEW,CAAAzP,MAAA;;UAwC/C,IAAA2E,aAAe;YACf,OAAArE,aAAe,CAAAA,aAAA,KAAAkP,GAAA,OACV;cAGN;cACIxP,MAAA,EAAAwP,GAAA,CAAAxP,MAAA,GAAAM,aAAA,CAAAA,aAAA,KAAAkP,GAAA,CAAAxP,MAAA,GAAAlD,qBAAA,CAAA0S,GAAA,EAAA7K,aAAA,KAAAA,aAAA;cACCgL,eAAN,KAAA7F,MAAA,KAAA1L,mBAAA,aAAAoR,GAAA,CAAAG,eAAA,IAAAtM,SAAA;cACDqM,iBAAA,EAAApP,aAAA,CAAAA,aAAA,KAAAkP,GAAA,CAAAE,iBAAA,WAAAlR,gBAAA,iBAAA6E,SAAA,EAAAuB,cAAA;YAvDH;UA0DA;UAAmB,OAAA4K,GAAZ;QAAoB;UAA3BxP,MAAA;UACD2P,eAAA;;QAEM;QAIDC,eAAA,GAAoBN,kBAAA,CAAAtP,MAAW;QACjC2P,eAAA,GAAAL,kBAAA,CAAAK,eAAA;QACAD,iBAAA,GAAAJ,kBAAA,CAAAI,iBAAA;;QAHwCP,SAAA,CAAA/O,IAAA,CAAAwP,eAMnC;QAAAR,eANmC,GAAA9O,aAAA,CAAAA,aAAA,CAMrB,EANqB,EAAA8O,eAAA,GAAAM,iBAAA;MAOnC;IACP,OAAM;;IACN;EACE;;IACAP,SAAO,EAAAA,SAAA;IAACvL,MAAA,EAAAA,MAAW;IAAIwL,eAAA,EAAAA;EAAhB;AACR;;EAGD,IAAMpP,MAAM,CAAA2C,QAAG,KAAQ7D,UAAR,CACZ8D,UACC,CAAAC,SAAM,KAAA7C,MAAN,CAAA8C,KAAA;IAAA;IACE,OAAG;EACH;EAFF,IAIA+M,oBAEM,GAAA7P,MAAA,CAAAsH,WAAA;IAAAA,WAAA,GAAAuI,oBAAA,mBAAAA,oBAAA;EAAA,IAAA/M,KAAA,GAAA9C,MAAA,CAAA8C,KAAA;EAAA,IAAAmB,QAAY,GAAMP,OAAC,CAAAoJ,iBAAsB,CAAAhK,KAAP,CAAgBxB,IAAlD;EACF,IAAA2C,QAAU;IATlBtF,QAAA,YAAAoO,IAAA,UAAAjD,MAAA,CAAAhH,KAAA,CAAAxB,IAAA;IAWgC,OAAI;MAApC0L,SAAA;MACMlK,KAAA,EAAOA;IAEb;EAAQ;;EAA6B,IAAAmK,MAAA,GAAAvJ,OAAA,CAAAuC,aAAA,CAAA4B,GAAA,WAAAqF,GAAA,EAAAC,QAAA;IAAlB,OAAZ;MAAwCxC,CAAA,EAAKrD,WAAL,CAAA6F,QAAA;MAA/CC,CAAA,EAAAF,GAAA,CAAAG,OAAA,CAAApJ,QAAA;IACD;EAED,SAAAjE,MAAA,WAAA8P,KAAA;IACA,IAAAnF,CAAA,GAAAmF,KAAA,CAAAnF,CAAA;MACAyC,CAAA,GAAA0C,KAAA,CAAA1C,CAAA;;;IACO,OAAS,IAAA3O,QAAA,CAATiP,SAAkD,EAAAF,CAAA,CAAA7C,CAAA,EAAA8C,CAAA,CAAA9C,CAAA;EAAA;;IAAA,OAAAvD,CAAA,CACxCgG,CAAA;EACf;;EACA,OAAK;IACHJ,SAAO,EAAP;MACDC,MAAA,EAAAA,MAAA;;MACKU,OAAM,EAAGA;IACf;IACD7K,KAAA,EAAAA;;AAEM;AACL;AACD;;;AAIG,SAAAiN,gBAAA/P,MAAA;EACD,IAAAgQ,gBAAA;EAED,IAAMtE,IAAI,GAAG1L,MAAM,CAAC0L,IAAP;EACb,IAAA3I,QAAW,GAAG,CAAAiN,gBAAP,GAEHhQ,MAAI,CAAG2C,QAAA,MACP,QADAqN,gBAEO,KAAP,KACA,CADA,GAEA,KANJ,IAAAA,gBAAA,CAAAjN,QAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}