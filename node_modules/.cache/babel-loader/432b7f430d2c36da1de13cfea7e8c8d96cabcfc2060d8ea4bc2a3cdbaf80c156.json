{"ast":null,"code":"import { Matrix3, _MathUtils } from '@math.gl/core';\nvar scratchMatrix = new Matrix3();\nvar scratchUnitary = new Matrix3();\nvar scratchDiagonal = new Matrix3();\nvar jMatrix = new Matrix3();\nvar jMatrixTranspose = new Matrix3();\nexport default function computeEigenDecomposition(matrix) {\n  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var EIGEN_TOLERANCE = _MathUtils.EPSILON20;\n  var EIGEN_MAX_SWEEPS = 10;\n  var count = 0;\n  var sweep = 0;\n  var unitaryMatrix = scratchUnitary;\n  var diagonalMatrix = scratchDiagonal;\n  unitaryMatrix.identity();\n  diagonalMatrix.copy(matrix);\n  var epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n    shurDecomposition(diagonalMatrix, jMatrix);\n    jMatrixTranspose.copy(jMatrix).transpose();\n    diagonalMatrix.multiplyRight(jMatrix);\n    diagonalMatrix.multiplyLeft(jMatrixTranspose);\n    unitaryMatrix.multiplyRight(jMatrix);\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n  result.unitary = unitaryMatrix.toTarget(result.unitary);\n  result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n  return result;\n}\nfunction computeFrobeniusNorm(matrix) {\n  var norm = 0.0;\n  for (var i = 0; i < 9; ++i) {\n    var temp = matrix[i];\n    norm += temp * temp;\n  }\n  return Math.sqrt(norm);\n}\nvar rowVal = [1, 0, 0];\nvar colVal = [2, 2, 1];\nfunction offDiagonalFrobeniusNorm(matrix) {\n  var norm = 0.0;\n  for (var i = 0; i < 3; ++i) {\n    var temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n  return Math.sqrt(norm);\n}\nfunction shurDecomposition(matrix, result) {\n  var tolerance = _MathUtils.EPSILON15;\n  var maxDiagonal = 0.0;\n  var rotAxis = 1;\n  for (var i = 0; i < 3; ++i) {\n    var temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n  var p = rowVal[rotAxis];\n  var q = colVal[rotAxis];\n  var c = 1.0;\n  var s = 0.0;\n  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n    var qq = matrix[scratchMatrix.getElementIndex(q, q)];\n    var pp = matrix[scratchMatrix.getElementIndex(p, p)];\n    var qp = matrix[scratchMatrix.getElementIndex(q, p)];\n    var tau = (qq - pp) / 2.0 / qp;\n    var t;\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n  Matrix3.IDENTITY.to(result);\n  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n  result[scratchMatrix.getElementIndex(q, p)] = s;\n  result[scratchMatrix.getElementIndex(p, q)] = -s;\n  return result;\n}","map":{"version":3,"names":["Matrix3","_MathUtils","scratchMatrix","scratchUnitary","scratchDiagonal","jMatrix","jMatrixTranspose","computeEigenDecomposition","matrix","result","arguments","length","undefined","EIGEN_TOLERANCE","EPSILON20","EIGEN_MAX_SWEEPS","count","sweep","unitaryMatrix","diagonalMatrix","identity","copy","epsilon","computeFrobeniusNorm","offDiagonalFrobeniusNorm","shurDecomposition","transpose","multiplyRight","multiplyLeft","unitary","toTarget","diagonal","norm","i","temp","Math","sqrt","rowVal","colVal","getElementIndex","tolerance","EPSILON15","maxDiagonal","rotAxis","abs","p","q","c","s","qq","pp","qp","tau","t","IDENTITY","to"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@math.gl/culling/src/lib/algorithms/compute-eigen-decomposition.ts"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Matrix3, _MathUtils} from '@math.gl/core';\n\nconst scratchMatrix = new Matrix3();\nconst scratchUnitary = new Matrix3();\nconst scratchDiagonal = new Matrix3();\n\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n\nexport type EigenDecomposition = {\n  unitary: Matrix3;\n  diagonal: Matrix3;\n};\n\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n *\n * - Returns a diagonal matrix and unitary matrix such that:\n * `matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)`\n * - The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * - This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n * section 8.4.3 The Classical Jacobi Algorithm\n *\n * @param matrix The 3x3 matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param result Optional object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * const a = //... symmetric matrix\n * const result = {\n *   unitary : new Matrix3(),\n *   diagonal : new Matrix3()\n * };\n * computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Matrix3.transpose(result.unitary, new Matrix3());\n * const b = Matrix3.multiply(result.unitary, result.diagonal, new Matrix3());\n * Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = result.diagonal.getColumn(0, new Vector3()).x;  // first eigenvalue\n * const v = result.unitary.getColumn(0, new Vector3());          // first eigenvector\n * const c = v.multiplyByScalar(lambda);                          // equal to v.transformByMatrix3(a)\n */\nexport default function computeEigenDecomposition(\n  matrix: number[],\n  // @ts-expect-error accept empty object type\n  result: EigenDecomposition = {}\n): EigenDecomposition {\n  const EIGEN_TOLERANCE = _MathUtils.EPSILON20;\n  const EIGEN_MAX_SWEEPS = 10;\n\n  let count = 0;\n  let sweep = 0;\n\n  const unitaryMatrix = scratchUnitary;\n  const diagonalMatrix = scratchDiagonal;\n\n  unitaryMatrix.identity();\n  diagonalMatrix.copy(matrix);\n\n  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n\n  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n    shurDecomposition(diagonalMatrix, jMatrix);\n\n    jMatrixTranspose.copy(jMatrix).transpose();\n\n    diagonalMatrix.multiplyRight(jMatrix);\n    diagonalMatrix.multiplyLeft(jMatrixTranspose);\n    unitaryMatrix.multiplyRight(jMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  result.unitary = unitaryMatrix.toTarget(result.unitary);\n  result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n\n  return result;\n}\n\nfunction computeFrobeniusNorm(matrix: Matrix3): number {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n\n// Computes the \"off-diagonal\" Frobenius norm.\n// Assumes matrix is symmetric.\nfunction offDiagonalFrobeniusNorm(matrix: Matrix3): number {\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n\n// The routine takes a matrix, which is assumed to be symmetric, and\n// finds the largest off-diagonal term, and then creates\n// a matrix (result) which can be used to help reduce it\n//\n// This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n// section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n//\n// eslint-disable-next-line max-statements\nfunction shurDecomposition(matrix: Matrix3, result: Matrix3): Matrix3 {\n  const tolerance = _MathUtils.EPSILON15;\n\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n\n  let c = 1.0;\n  let s = 0.0;\n\n  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[scratchMatrix.getElementIndex(q, q)];\n    const pp = matrix[scratchMatrix.getElementIndex(p, p)];\n    const qp = matrix[scratchMatrix.getElementIndex(q, p)];\n\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  // Copy into result\n  Matrix3.IDENTITY.to(result);\n  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n  result[scratchMatrix.getElementIndex(q, p)] = s;\n  result[scratchMatrix.getElementIndex(p, q)] = -s;\n\n  return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}