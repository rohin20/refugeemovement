{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport ScreenPass from '../passes/screen-pass';\nimport { normalizeShaderModule } from '@luma.gl/core';\nvar PostProcessEffect = /*#__PURE__*/function () {\n  function PostProcessEffect(module) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, PostProcessEffect);\n    _defineProperty(this, \"id\", void 0);\n    _defineProperty(this, \"props\", void 0);\n    _defineProperty(this, \"module\", void 0);\n    _defineProperty(this, \"passes\", void 0);\n    this.id = \"\".concat(module.name, \"-pass\");\n    this.props = props;\n    normalizeShaderModule(module);\n    this.module = module;\n  }\n  _createClass(PostProcessEffect, [{\n    key: \"preRender\",\n    value: function preRender() {}\n  }, {\n    key: \"postRender\",\n    value: function postRender(gl, params) {\n      var passes = this.passes || createPasses(gl, this.module, this.id, this.props);\n      this.passes = passes;\n      var target = params.target;\n      var inputBuffer = params.inputBuffer;\n      var outputBuffer = params.swapBuffer;\n      for (var index = 0; index < this.passes.length; index++) {\n        if (target && index === this.passes.length - 1) {\n          outputBuffer = target;\n        }\n        this.passes[index].render({\n          inputBuffer: inputBuffer,\n          outputBuffer: outputBuffer\n        });\n        var switchBuffer = outputBuffer;\n        outputBuffer = inputBuffer;\n        inputBuffer = switchBuffer;\n      }\n      return inputBuffer;\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      if (this.passes) {\n        var _iterator = _createForOfIteratorHelper(this.passes),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var pass = _step.value;\n            pass.delete();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this.passes = undefined;\n      }\n    }\n  }]);\n  return PostProcessEffect;\n}();\nexport { PostProcessEffect as default };\nfunction createPasses(gl, module, id, moduleSettings) {\n  if (!module.passes) {\n    var fs = getFragmentShaderForRenderPass(module);\n    var pass = new ScreenPass(gl, {\n      id: id,\n      module: module,\n      fs: fs,\n      moduleSettings: moduleSettings\n    });\n    return [pass];\n  }\n  return module.passes.map(function (pass, index) {\n    var fs = getFragmentShaderForRenderPass(module, pass);\n    var idn = \"\".concat(id, \"-\").concat(index);\n    return new ScreenPass(gl, {\n      id: idn,\n      module: module,\n      fs: fs,\n      moduleSettings: moduleSettings\n    });\n  });\n}\nvar FILTER_FS_TEMPLATE = function FILTER_FS_TEMPLATE(func) {\n  return \"uniform sampler2D texture;\\nuniform vec2 texSize;\\n\\nvarying vec2 position;\\nvarying vec2 coordinate;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec2 texCoord = coordinate;\\n\\n  gl_FragColor = texture2D(texture, texCoord);\\n  gl_FragColor = \".concat(func, \"(gl_FragColor, texSize, texCoord);\\n}\\n\");\n};\nvar SAMPLER_FS_TEMPLATE = function SAMPLER_FS_TEMPLATE(func) {\n  return \"uniform sampler2D texture;\\nuniform vec2 texSize;\\n\\nvarying vec2 position;\\nvarying vec2 coordinate;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec2 texCoord = coordinate;\\n\\n  gl_FragColor = \".concat(func, \"(texture, texSize, texCoord);\\n}\\n\");\n};\nfunction getFragmentShaderForRenderPass(module) {\n  var pass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : module;\n  if (pass.filter) {\n    var func = typeof pass.filter === 'string' ? pass.filter : \"\".concat(module.name, \"_filterColor\");\n    return FILTER_FS_TEMPLATE(func);\n  }\n  if (pass.sampler) {\n    var _func = typeof pass.sampler === 'string' ? pass.sampler : \"\".concat(module.name, \"_sampleColor\");\n    return SAMPLER_FS_TEMPLATE(_func);\n  }\n  return null;\n}","map":{"version":3,"names":["ScreenPass","normalizeShaderModule","PostProcessEffect","module","props","arguments","length","undefined","_classCallCheck","_defineProperty","id","concat","name","_createClass","key","value","preRender","postRender","gl","params","passes","createPasses","target","inputBuffer","outputBuffer","swapBuffer","index","render","switchBuffer","cleanup","_iterator","_createForOfIteratorHelper","_step","s","n","done","pass","delete","err","e","f","default","moduleSettings","fs","getFragmentShaderForRenderPass","map","idn","FILTER_FS_TEMPLATE","func","SAMPLER_FS_TEMPLATE","filter","sampler"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/core/src/effects/post-process-effect.ts"],"sourcesContent":["import ScreenPass from '../passes/screen-pass';\nimport {normalizeShaderModule} from '@luma.gl/core';\n\nimport type {Effect, PostRenderOptions} from '../lib/effect';\nimport type {Framebuffer} from '@luma.gl/webgl';\nimport type {ShaderModule} from '../types/types';\n\nexport default class PostProcessEffect implements Effect {\n  id: string;\n  props: any;\n  module: ShaderModule;\n  passes?: ScreenPass[];\n\n  constructor(module: ShaderModule, props: any = {}) {\n    this.id = `${module.name}-pass`;\n    this.props = props;\n    normalizeShaderModule(module);\n    this.module = module;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  preRender(): void {}\n\n  postRender(gl: WebGLRenderingContext, params: PostRenderOptions): Framebuffer {\n    const passes = this.passes || createPasses(gl, this.module, this.id, this.props);\n    this.passes = passes;\n\n    const {target} = params;\n    let inputBuffer = params.inputBuffer;\n    let outputBuffer = params.swapBuffer;\n\n    for (let index = 0; index < this.passes.length; index++) {\n      if (target && index === this.passes.length - 1) {\n        outputBuffer = target;\n      }\n      this.passes[index].render({inputBuffer, outputBuffer});\n      const switchBuffer = outputBuffer;\n      outputBuffer = inputBuffer;\n      inputBuffer = switchBuffer;\n    }\n    return inputBuffer;\n  }\n\n  cleanup(): void {\n    if (this.passes) {\n      for (const pass of this.passes) {\n        pass.delete();\n      }\n      this.passes = undefined;\n    }\n  }\n}\n\nfunction createPasses(\n  gl: WebGLRenderingContext,\n  module: ShaderModule,\n  id: string,\n  moduleSettings: any\n): ScreenPass[] {\n  if (!module.passes) {\n    const fs = getFragmentShaderForRenderPass(module);\n    const pass = new ScreenPass(gl, {\n      id,\n      module,\n      fs,\n      moduleSettings\n    });\n    return [pass];\n  }\n\n  return module.passes.map((pass, index) => {\n    const fs = getFragmentShaderForRenderPass(module, pass);\n    const idn = `${id}-${index}`;\n\n    return new ScreenPass(gl, {\n      id: idn,\n      module,\n      fs,\n      moduleSettings\n    });\n  });\n}\n\nconst FILTER_FS_TEMPLATE = func => `\\\nuniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = texture2D(texture, texCoord);\n  gl_FragColor = ${func}(gl_FragColor, texSize, texCoord);\n}\n`;\n\nconst SAMPLER_FS_TEMPLATE = func => `\\\nuniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = ${func}(texture, texSize, texCoord);\n}\n`;\n\nfunction getFragmentShaderForRenderPass(module, pass = module) {\n  if (pass.filter) {\n    const func = typeof pass.filter === 'string' ? pass.filter : `${module.name}_filterColor`;\n    return FILTER_FS_TEMPLATE(func);\n  }\n\n  if (pass.sampler) {\n    const func = typeof pass.sampler === 'string' ? pass.sampler : `${module.name}_sampleColor`;\n    return SAMPLER_FS_TEMPLATE(func);\n  }\n\n  // console.error(`${module.name} no fragment shader generated`);\n  return null;\n}\n"],"mappings":";;;;AAAA,OAAOA,UAAP,MAAuB,uBAAvB;AACA,SAAQC,qBAAR,QAAoC,eAApC;AAAA,IAMqBC,iBAAN;EAMb,SAAAA,kBAAYC,MAAD,EAAwC;IAAA,IAAjBC,KAAU,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAApC;IAAAG,eAAA,OAAAN,iBAAA;IAAwCO,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IACjD,KAAKC,EAAL,MAAAC,MAAA,CAAaR,MAAM,CAACS,IAApB;IACA,KAAKR,KAAL,GAAaA,KAAb;IACAH,qBAAqB,CAACE,MAAD,CAArB;IACA,KAAKA,MAAL,GAAcA,MAAd;EACD;EAAAU,YAAA,CAAAX,iBAAA;IAAAY,GAAA;IAAAC,KAAA,EAGD,SAAAC,UAAA,EAAkB,CAAE;EAAA;IAAAF,GAAA;IAAAC,KAAA,EAEpB,SAAAE,WAAWC,EAAD,EAA4BC,MAA5B,EAAoE;MAC5E,IAAMC,MAAM,GAAG,KAAKA,MAAL,IAAeC,YAAY,CAACH,EAAD,EAAK,KAAKf,MAAV,EAAkB,KAAKO,EAAvB,EAA2B,KAAKN,KAAhC,CAA1C;MACA,KAAKgB,MAAL,GAAcA,MAAd;MAEA,IAAOE,MAAA,GAAUH,MAAjB,CAAOG,MAAA;MACP,IAAIC,WAAW,GAAGJ,MAAM,CAACI,WAAzB;MACA,IAAIC,YAAY,GAAGL,MAAM,CAACM,UAA1B;MAEA,KAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG,KAAKN,MAAL,CAAYd,MAAxC,EAAgDoB,KAAK,EAArD,EAAyD;QACvD,IAAIJ,MAAM,IAAII,KAAK,KAAK,KAAKN,MAAL,CAAYd,MAAZ,GAAqB,CAA7C,EAAgD;UAC9CkB,YAAY,GAAGF,MAAf;QACD;QACD,KAAKF,MAAL,CAAYM,KAAZ,EAAmBC,MAAnB,CAA0B;UAACJ,WAAD,EAACA,WAAD;UAAcC,YAAA,EAAAA;QAAd,CAA1B;QACA,IAAMI,YAAY,GAAGJ,YAArB;QACAA,YAAY,GAAGD,WAAf;QACAA,WAAW,GAAGK,YAAd;MACD;MACD,OAAOL,WAAP;IACD;EAAA;IAAAT,GAAA;IAAAC,KAAA,EAED,SAAAc,QAAA,EAAgB;MACd,IAAI,KAAKT,MAAT,EAAiB;QAAA,IAAAU,SAAA,GAAAC,0BAAA,CACI,KAAKX,MAAxB;UAAAY,KAAA;QAAA;UAAA,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAgC;YAAA,IAArBC,IAAX,GAAAJ,KAAA,CAAAjB,KAAA;YACEqB,IAAI,CAACC,MAAL;UACD;QAAA,SAAAC,GAAA;UAAAR,SAAA,CAAAS,CAAA,CAAAD,GAAA;QAAA;UAAAR,SAAA,CAAAU,CAAA;QAAA;QACD,KAAKpB,MAAL,GAAcb,SAAd;MACD;IACF;EAAA;EAAA,OAAAL,iBAAA;AAAA;AAAA,SA3CkBA,iBAAN,IAAAuC,OAAA;AA8Cf,SAASpB,YAATA,CACEH,EADF,EAEEf,MAFF,EAGEO,EAHF,EAIEgC,cAJF,EAKgB;EACd,IAAI,CAACvC,MAAM,CAACiB,MAAZ,EAAoB;IAClB,IAAMuB,EAAE,GAAGC,8BAA8B,CAACzC,MAAD,CAAzC;IACA,IAAMiC,IAAI,GAAG,IAAIpC,UAAJ,CAAekB,EAAf,EAAmB;MAC9BR,EAD8B,EAC9BA,EAD8B;MAE9BP,MAF8B,EAE9BA,MAF8B;MAG9BwC,EAH8B,EAG9BA,EAH8B;MAI9BD,cAAA,EAAAA;IAJ8B,CAAnB,CAAb;IAMA,OAAO,CAACN,IAAD,CAAP;EACD;EAED,OAAOjC,MAAM,CAACiB,MAAP,CAAcyB,GAAd,CAAkB,UAACT,IAAD,EAAOV,KAAP,EAAiB;IACxC,IAAMiB,EAAE,GAAGC,8BAA8B,CAACzC,MAAD,EAASiC,IAAT,CAAzC;IACA,IAAMU,GAAG,MAAAnC,MAAA,CAAMD,EAAN,OAAAC,MAAA,CAAYe,KAAZ,CAAT;IAEA,OAAO,IAAI1B,UAAJ,CAAekB,EAAf,EAAmB;MACxBR,EAAE,EAAEoC,GADoB;MAExB3C,MAFwB,EAExBA,MAFwB;MAGxBwC,EAHwB,EAGxBA,EAHwB;MAIxBD,cAAA,EAAAA;IAJwB,CAAnB,CAAP;EAMD,CAVM,CAAP;AAWD;AAED,IAAMK,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAGC,IAAI;EAAA,sPAAArC,MAAA,CAYZqC,IAZY,4CAA/B;AAAA;AAgBA,IAAMC,mBAAmB,GAAG,SAAtBA,mBAAmBA,CAAGD,IAAI;EAAA,sMAAArC,MAAA,CAWbqC,IAXa,uCAAhC;AAAA;AAeA,SAASJ,8BAATA,CAAwCzC,MAAxC,EAA+D;EAAA,IAAfiC,IAAI,GAAA/B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGF,MAAvD;EACE,IAAIiC,IAAI,CAACc,MAAT,EAAiB;IACf,IAAMF,IAAI,GAAG,OAAOZ,IAAI,CAACc,MAAZ,KAAuB,QAAvB,GAAkCd,IAAI,CAACc,MAAvC,MAAAvC,MAAA,CAAmDR,MAAM,CAACS,IAA1D,iBAAb;IACA,OAAOmC,kBAAkB,CAACC,IAAD,CAAzB;EACD;EAED,IAAIZ,IAAI,CAACe,OAAT,EAAkB;IAChB,IAAMH,KAAI,GAAG,OAAOZ,IAAI,CAACe,OAAZ,KAAwB,QAAxB,GAAmCf,IAAI,CAACe,OAAxC,MAAAxC,MAAA,CAAqDR,MAAM,CAACS,IAA5D,iBAAb;IACA,OAAOqC,mBAAmB,CAACD,KAAD,CAA1B;EACD;EAGD,OAAO,IAAP;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}