{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { createIterable, getAccessorFromBuffer } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\nimport { Buffer } from '@luma.gl/webgl';\nvar Tesselator = /*#__PURE__*/function () {\n  function Tesselator(opts) {\n    _classCallCheck(this, Tesselator);\n    _defineProperty(this, \"opts\", void 0);\n    _defineProperty(this, \"typedArrayManager\", void 0);\n    _defineProperty(this, \"indexStarts\", [0]);\n    _defineProperty(this, \"vertexStarts\", [0]);\n    _defineProperty(this, \"vertexCount\", 0);\n    _defineProperty(this, \"instanceCount\", 0);\n    _defineProperty(this, \"attributes\", void 0);\n    _defineProperty(this, \"_attributeDefs\", void 0);\n    _defineProperty(this, \"data\", void 0);\n    _defineProperty(this, \"getGeometry\", void 0);\n    _defineProperty(this, \"geometryBuffer\", void 0);\n    _defineProperty(this, \"buffers\", void 0);\n    _defineProperty(this, \"positionSize\", void 0);\n    _defineProperty(this, \"normalize\", void 0);\n    var _opts$attributes = opts.attributes,\n      attributes = _opts$attributes === void 0 ? {} : _opts$attributes;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n  }\n  _createClass(Tesselator, [{\n    key: \"updateGeometry\",\n    value: function updateGeometry(opts) {\n      Object.assign(this.opts, opts);\n      var _this$opts = this.opts,\n        data = _this$opts.data,\n        _this$opts$buffers = _this$opts.buffers,\n        buffers = _this$opts$buffers === void 0 ? {} : _this$opts$buffers,\n        getGeometry = _this$opts.getGeometry,\n        geometryBuffer = _this$opts.geometryBuffer,\n        positionFormat = _this$opts.positionFormat,\n        dataChanged = _this$opts.dataChanged,\n        _this$opts$normalize = _this$opts.normalize,\n        normalize = _this$opts$normalize === void 0 ? true : _this$opts$normalize;\n      this.data = data;\n      this.getGeometry = getGeometry;\n      this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n      this.buffers = buffers;\n      this.normalize = normalize;\n      if (geometryBuffer) {\n        assert(data.startIndices);\n        this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n        if (!normalize) {\n          buffers.positions = geometryBuffer;\n        }\n      }\n      this.geometryBuffer = buffers.positions;\n      if (Array.isArray(dataChanged)) {\n        var _iterator = _createForOfIteratorHelper(dataChanged),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var dataRange = _step.value;\n            this._rebuildGeometry(dataRange);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        this._rebuildGeometry();\n      }\n    }\n  }, {\n    key: \"updatePartialGeometry\",\n    value: function updatePartialGeometry(_ref) {\n      var startRow = _ref.startRow,\n        endRow = _ref.endRow;\n      this._rebuildGeometry({\n        startRow: startRow,\n        endRow: endRow\n      });\n    }\n  }, {\n    key: \"getGeometryFromBuffer\",\n    value: function getGeometryFromBuffer(geometryBuffer) {\n      var value = geometryBuffer.value || geometryBuffer;\n      if (!ArrayBuffer.isView(value)) {\n        return null;\n      }\n      return getAccessorFromBuffer(value, {\n        size: this.positionSize,\n        offset: geometryBuffer.offset,\n        stride: geometryBuffer.stride,\n        startIndices: this.data.startIndices\n      });\n    }\n  }, {\n    key: \"_allocate\",\n    value: function _allocate(instanceCount, copy) {\n      var attributes = this.attributes,\n        buffers = this.buffers,\n        _attributeDefs = this._attributeDefs,\n        typedArrayManager = this.typedArrayManager;\n      for (var name in _attributeDefs) {\n        if (name in buffers) {\n          typedArrayManager.release(attributes[name]);\n          attributes[name] = null;\n        } else {\n          var def = _attributeDefs[name];\n          def.copy = copy;\n          attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n        }\n      }\n    }\n  }, {\n    key: \"_forEachGeometry\",\n    value: function _forEachGeometry(visitor, startRow, endRow) {\n      var data = this.data,\n        getGeometry = this.getGeometry;\n      var _createIterable = createIterable(data, startRow, endRow),\n        iterable = _createIterable.iterable,\n        objectInfo = _createIterable.objectInfo;\n      var _iterator2 = _createForOfIteratorHelper(iterable),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var object = _step2.value;\n          objectInfo.index++;\n          var geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n          visitor(geometry, objectInfo.index);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"_rebuildGeometry\",\n    value: function _rebuildGeometry(dataRange) {\n      var _this = this;\n      if (!this.data) {\n        return;\n      }\n      var indexStarts = this.indexStarts,\n        vertexStarts = this.vertexStarts,\n        instanceCount = this.instanceCount;\n      var data = this.data,\n        geometryBuffer = this.geometryBuffer;\n      var _ref2 = dataRange || {},\n        _ref2$startRow = _ref2.startRow,\n        startRow = _ref2$startRow === void 0 ? 0 : _ref2$startRow,\n        _ref2$endRow = _ref2.endRow,\n        endRow = _ref2$endRow === void 0 ? Infinity : _ref2$endRow;\n      var normalizedData = {};\n      if (!dataRange) {\n        indexStarts = [0];\n        vertexStarts = [0];\n      }\n      if (this.normalize || !geometryBuffer) {\n        this._forEachGeometry(function (geometry, dataIndex) {\n          var normalizedGeometry = geometry && _this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = normalizedGeometry;\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? _this.getGeometrySize(normalizedGeometry) : 0);\n        }, startRow, endRow);\n        instanceCount = vertexStarts[vertexStarts.length - 1];\n      } else {\n        vertexStarts = data.startIndices;\n        instanceCount = vertexStarts[data.length] || 0;\n        if (ArrayBuffer.isView(geometryBuffer)) {\n          instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n        } else if (geometryBuffer instanceof Buffer) {\n          var byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n          instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n        } else if (geometryBuffer.buffer) {\n          var _byteStride = geometryBuffer.stride || this.positionSize * 4;\n          instanceCount = instanceCount || geometryBuffer.buffer.byteLength / _byteStride;\n        } else if (geometryBuffer.value) {\n          var bufferValue = geometryBuffer.value;\n          var elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n          instanceCount = instanceCount || bufferValue.length / elementStride;\n        }\n      }\n      this._allocate(instanceCount, Boolean(dataRange));\n      this.indexStarts = indexStarts;\n      this.vertexStarts = vertexStarts;\n      this.instanceCount = instanceCount;\n      var context = {};\n      this._forEachGeometry(function (geometry, dataIndex) {\n        var normalizedGeometry = normalizedData[dataIndex] || geometry;\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        var vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        _this.updateGeometryAttributes(normalizedGeometry, context);\n      }, startRow, endRow);\n      this.vertexCount = indexStarts[indexStarts.length - 1];\n    }\n  }]);\n  return Tesselator;\n}();\nexport { Tesselator as default };","map":{"version":3,"names":["createIterable","getAccessorFromBuffer","defaultTypedArrayManager","assert","Buffer","Tesselator","opts","_classCallCheck","_defineProperty","_opts$attributes","attributes","typedArrayManager","_attributeDefs","updateGeometry","_createClass","key","value","Object","assign","_this$opts","data","_this$opts$buffers","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","_this$opts$normalize","normalize","positionSize","size","startIndices","getGeometryFromBuffer","positions","Array","isArray","_iterator","_createForOfIteratorHelper","_step","s","n","done","dataRange","_rebuildGeometry","err","e","f","updatePartialGeometry","_ref","startRow","endRow","ArrayBuffer","isView","offset","stride","_allocate","instanceCount","copy","name","release","def","allocate","_forEachGeometry","visitor","_createIterable","iterable","objectInfo","_iterator2","_step2","object","index","geometry","_this","indexStarts","vertexStarts","_ref2","_ref2$startRow","_ref2$endRow","Infinity","normalizedData","dataIndex","normalizedGeometry","normalizeGeometry","getGeometrySize","length","byteStride","accessor","byteLength","buffer","bufferValue","elementStride","BYTES_PER_ELEMENT","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","updateGeometryAttributes","vertexCount","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/core/src/utils/tesselator.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/webgl';\n\nimport type {BinaryAttribute} from '../lib/attribute/attribute';\nimport type {TypedArray} from '../types/types';\nimport type {AccessorFunction} from '../types/layer-props';\nimport type {TypedArrayManager} from './typed-array-manager';\n\ntype ExternalBuffer = TypedArray | Buffer | BinaryAttribute;\n\ntype TesselatorOptions<GeometryT, ExtraOptionsT> = ExtraOptionsT & {\n  attributes?: Record<string, any>;\n  getGeometry?: AccessorFunction<any, GeometryT>;\n  data?: any;\n  buffers?: Record<string, ExternalBuffer>;\n  geometryBuffer?: ExternalBuffer;\n  positionFormat?: 'XY' | 'XYZ';\n  dataChanged?: {startRow: number; endRow?: number}[] | string | false;\n  normalize?: boolean;\n};\n\nexport type GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\nexport default abstract class Tesselator<GeometryT, NormalizedGeometryT, ExtraOptionsT> {\n  opts: TesselatorOptions<GeometryT, ExtraOptionsT>;\n  typedArrayManager: TypedArrayManager;\n  indexStarts: number[] = [0];\n  vertexStarts: number[] = [0];\n  vertexCount: number = 0;\n  instanceCount: number = 0;\n  attributes: Record<string, TypedArray | null>;\n\n  protected _attributeDefs: any;\n  protected data: any;\n  protected getGeometry?: AccessorFunction<any, GeometryT> | null;\n  protected geometryBuffer?: ExternalBuffer;\n  protected buffers!: Record<string, ExternalBuffer>;\n  protected positionSize!: number;\n  protected normalize!: boolean;\n\n  constructor(opts: TesselatorOptions<GeometryT, ExtraOptionsT>) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n  }\n\n  /* Public methods */\n  updateGeometry(opts: TesselatorOptions<GeometryT, ExtraOptionsT>): void {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged as {startRow: number; endRow?: number}[]) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}: {startRow: number; endRow: number}): void {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  // Subclass interface\n\n  /** Convert geometry to a uniform shape */\n  protected abstract normalizeGeometry(geometry: GeometryT): NormalizedGeometryT;\n\n  /** Update the positions buffer of a single geometry */\n  protected abstract updateGeometryAttributes(\n    geometry: NormalizedGeometryT | null,\n    context: GeometryUpdateContext\n  );\n\n  /** Get the number of vertices in a geometry */\n  protected abstract getGeometrySize(geometry: NormalizedGeometryT): number;\n\n  protected getGeometryFromBuffer(\n    geometryBuffer: ExternalBuffer\n  ): AccessorFunction<any, GeometryT> | null {\n    const value = (geometryBuffer as BinaryAttribute).value || geometryBuffer;\n    if (!ArrayBuffer.isView(value)) {\n      // Cannot read binary geometries\n      return null;\n    }\n\n    // @ts-ignore (2322) NumericArray not assignable to GeometryT\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: (geometryBuffer as BinaryAttribute).offset,\n      stride: (geometryBuffer as BinaryAttribute).stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  private _allocate(instanceCount: number, copy: boolean): void {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  private _forEachGeometry(\n    visitor: (geometry: GeometryT | null, index: number) => void,\n    startRow: number,\n    endRow: number\n  ): void {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  private _rebuildGeometry(dataRange?: {startRow: number; endRow?: number}): void {\n    if (!this.data) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData: Record<number, NormalizedGeometryT | null> = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry: GeometryT | null, dataIndex: number) => {\n          const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = normalizedGeometry;\n          vertexStarts[dataIndex + 1] =\n            vertexStarts[dataIndex] +\n            (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        // @ts-expect-error (2339) accessor is not typed\n        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride =\n          // @ts-ignore (2339) if stride is not specified, will fall through to positionSize\n          geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    // @ts-ignore (2739) context will be populated in the loop\n    const context: GeometryUpdateContext = {};\n\n    this._forEachGeometry(\n      (geometry: GeometryT | null, dataIndex: number) => {\n        const normalizedGeometry =\n          normalizedData[dataIndex] ||\n          // @ts-expect-error (2352) GeometryT cannot be casted to NormalizedGeometryT. We are assuming the user passed already normalized data if opts.normalize is set to false.\n          (geometry as NormalizedGeometryT);\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(normalizedGeometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}