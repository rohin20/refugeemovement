{"ast":null,"code":"import _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { AsyncQueue, TableBatchBuilder, convertToArrayRow, convertToObjectRow } from '@loaders.gl/schema';\nimport Papa from './papaparse/papaparse';\nimport AsyncIteratorStreamer from './papaparse/async-iterator-streamer';\nvar VERSION = typeof \"3.3.1\" !== 'undefined' ? \"3.3.1\" : 'latest';\nvar DEFAULT_CSV_LOADER_OPTIONS = {\n  csv: {\n    shape: 'object-row-table',\n    optimizeMemoryUsage: false,\n    header: 'auto',\n    columnPrefix: 'column',\n    quoteChar: '\"',\n    escapeChar: '\"',\n    dynamicTyping: true,\n    comments: false,\n    skipEmptyLines: true,\n    delimitersToGuess: [',', '\\t', '|', ';']\n  }\n};\nexport var CSVLoader = {\n  id: 'csv',\n  module: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv', 'tsv', 'dsv'],\n  mimeTypes: ['text/csv', 'text/tab-separated-values', 'text/dsv'],\n  category: 'table',\n  parse: function () {\n    var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(arrayBuffer, options) {\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", parseCSV(new TextDecoder().decode(arrayBuffer), options));\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    function parse(_x, _x2) {\n      return _parse.apply(this, arguments);\n    }\n    return parse;\n  }(),\n  parseText: function parseText(text, options) {\n    return parseCSV(text, options);\n  },\n  parseInBatches: parseCSVInBatches,\n  options: DEFAULT_CSV_LOADER_OPTIONS\n};\nfunction parseCSV(_x3, _x4) {\n  return _parseCSV.apply(this, arguments);\n}\nfunction _parseCSV() {\n  _parseCSV = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(csvText, options) {\n    var csvOptions, firstRow, header, parseWithHeader, papaparseConfig, result, rows, headerRow;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          csvOptions = _objectSpread(_objectSpread({}, DEFAULT_CSV_LOADER_OPTIONS.csv), options === null || options === void 0 ? void 0 : options.csv);\n          firstRow = readFirstRow(csvText);\n          header = csvOptions.header === 'auto' ? isHeaderRow(firstRow) : Boolean(csvOptions.header);\n          parseWithHeader = header;\n          papaparseConfig = _objectSpread(_objectSpread({}, csvOptions), {}, {\n            header: parseWithHeader,\n            download: false,\n            transformHeader: parseWithHeader ? duplicateColumnTransformer() : undefined,\n            error: function error(e) {\n              throw new Error(e);\n            }\n          });\n          result = Papa.parse(csvText, papaparseConfig);\n          rows = result.data;\n          headerRow = result.meta.fields || generateHeader(csvOptions.columnPrefix, firstRow.length);\n          _context2.t0 = csvOptions.shape;\n          _context2.next = _context2.t0 === 'object-row-table' ? 11 : _context2.t0 === 'array-row-table' ? 13 : 15;\n          break;\n        case 11:\n          rows = rows.map(function (row) {\n            return Array.isArray(row) ? convertToObjectRow(row, headerRow) : row;\n          });\n          return _context2.abrupt(\"break\", 15);\n        case 13:\n          rows = rows.map(function (row) {\n            return Array.isArray(row) ? row : convertToArrayRow(row, headerRow);\n          });\n          return _context2.abrupt(\"break\", 15);\n        case 15:\n          return _context2.abrupt(\"return\", rows);\n        case 16:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _parseCSV.apply(this, arguments);\n}\nfunction parseCSVInBatches(asyncIterator, options) {\n  var _options;\n  options = _objectSpread({}, options);\n  if (options.batchSize === 'auto') {\n    options.batchSize = 4000;\n  }\n  var csvOptions = _objectSpread(_objectSpread({}, DEFAULT_CSV_LOADER_OPTIONS.csv), (_options = options) === null || _options === void 0 ? void 0 : _options.csv);\n  var asyncQueue = new AsyncQueue();\n  var isFirstRow = true;\n  var headerRow = null;\n  var tableBatchBuilder = null;\n  var schema = null;\n  var config = _objectSpread(_objectSpread({}, csvOptions), {}, {\n    header: false,\n    download: false,\n    chunkSize: 1024 * 1024 * 5,\n    skipEmptyLines: false,\n    step: function step(results) {\n      var row = results.data;\n      if (csvOptions.skipEmptyLines) {\n        var collapsedRow = row.flat().join('').trim();\n        if (collapsedRow === '') {\n          return;\n        }\n      }\n      var bytesUsed = results.meta.cursor;\n      if (isFirstRow && !headerRow) {\n        var header = csvOptions.header === 'auto' ? isHeaderRow(row) : Boolean(csvOptions.header);\n        if (header) {\n          headerRow = row.map(duplicateColumnTransformer());\n          return;\n        }\n      }\n      if (isFirstRow) {\n        isFirstRow = false;\n        if (!headerRow) {\n          headerRow = generateHeader(csvOptions.columnPrefix, row.length);\n        }\n        schema = deduceSchema(row, headerRow);\n      }\n      if (csvOptions.optimizeMemoryUsage) {\n        row = JSON.parse(JSON.stringify(row));\n      }\n      tableBatchBuilder = tableBatchBuilder || new TableBatchBuilder(schema, _objectSpread({\n        shape: csvOptions.shape || 'array-row-table'\n      }, options));\n      try {\n        tableBatchBuilder.addRow(row);\n        var batch = tableBatchBuilder && tableBatchBuilder.getFullBatch({\n          bytesUsed: bytesUsed\n        });\n        if (batch) {\n          asyncQueue.enqueue(batch);\n        }\n      } catch (error) {\n        asyncQueue.enqueue(error);\n      }\n    },\n    complete: function complete(results) {\n      try {\n        var bytesUsed = results.meta.cursor;\n        var batch = tableBatchBuilder && tableBatchBuilder.getFinalBatch({\n          bytesUsed: bytesUsed\n        });\n        if (batch) {\n          asyncQueue.enqueue(batch);\n        }\n      } catch (error) {\n        asyncQueue.enqueue(error);\n      }\n      asyncQueue.close();\n    }\n  });\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n  return asyncQueue;\n}\nfunction isHeaderRow(row) {\n  return row && row.every(function (value) {\n    return typeof value === 'string';\n  });\n}\nfunction readFirstRow(csvText) {\n  var result = Papa.parse(csvText, {\n    download: false,\n    dynamicTyping: true,\n    preview: 1\n  });\n  return result.data[0];\n}\nfunction duplicateColumnTransformer() {\n  var observedColumns = new Set();\n  return function (col) {\n    var colName = col;\n    var counter = 1;\n    while (observedColumns.has(colName)) {\n      colName = \"\".concat(col, \".\").concat(counter);\n      counter++;\n    }\n    observedColumns.add(colName);\n    return colName;\n  };\n}\nfunction generateHeader(columnPrefix) {\n  var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var headers = [];\n  for (var i = 0; i < count; i++) {\n    headers.push(\"\".concat(columnPrefix).concat(i + 1));\n  }\n  return headers;\n}\nfunction deduceSchema(row, headerRow) {\n  var schema = headerRow ? {} : [];\n  for (var i = 0; i < row.length; i++) {\n    var columnName = headerRow && headerRow[i] || i;\n    var value = row[i];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        schema[columnName] = {\n          name: String(columnName),\n          index: i,\n          type: Float32Array\n        };\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {\n          name: String(columnName),\n          index: i,\n          type: Array\n        };\n    }\n  }\n  return schema;\n}\nexport var _typecheckCSVLoader = CSVLoader;","map":{"version":3,"names":["AsyncQueue","TableBatchBuilder","convertToArrayRow","convertToObjectRow","Papa","AsyncIteratorStreamer","VERSION","DEFAULT_CSV_LOADER_OPTIONS","csv","shape","optimizeMemoryUsage","header","columnPrefix","quoteChar","escapeChar","dynamicTyping","comments","skipEmptyLines","delimitersToGuess","CSVLoader","id","module","name","version","extensions","mimeTypes","category","parse","_parse","_asyncToGenerator","_regeneratorRuntime","mark","_callee","arrayBuffer","options","wrap","_callee$","_context","prev","next","abrupt","parseCSV","TextDecoder","decode","stop","_x","_x2","apply","arguments","parseText","text","parseInBatches","parseCSVInBatches","_x3","_x4","_parseCSV","_callee2","csvText","csvOptions","firstRow","parseWithHeader","papaparseConfig","result","rows","headerRow","_callee2$","_context2","_objectSpread","readFirstRow","isHeaderRow","Boolean","download","transformHeader","duplicateColumnTransformer","undefined","error","e","Error","data","meta","fields","generateHeader","length","t0","map","row","Array","isArray","asyncIterator","_options","batchSize","asyncQueue","isFirstRow","tableBatchBuilder","schema","config","chunkSize","step","results","collapsedRow","flat","join","trim","bytesUsed","cursor","deduceSchema","JSON","stringify","addRow","batch","getFullBatch","enqueue","complete","getFinalBatch","close","every","value","preview","observedColumns","Set","col","colName","counter","has","concat","add","count","headers","i","push","columnName","String","index","type","Float32Array","_typecheckCSVLoader"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/processors/node_modules/@loaders.gl/csv/src/csv-loader.ts"],"sourcesContent":["import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {Batch} from '@loaders.gl/schema';\ntype Schema = any;\n\nimport {\n  AsyncQueue,\n  TableBatchBuilder,\n  convertToArrayRow,\n  convertToObjectRow\n} from '@loaders.gl/schema';\nimport Papa from './papaparse/papaparse';\nimport AsyncIteratorStreamer from './papaparse/async-iterator-streamer';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport type CSVLoaderOptions = LoaderOptions & {\n  csv?: {\n    // loaders.gl options\n    shape?: 'array-row-table' | 'object-row-table' | 'columnar-table';\n    /** optimizes memory usage but increases parsing time. */\n    optimizeMemoryUsage?: boolean;\n    columnPrefix?: string;\n    header?: 'auto';\n\n    // CSV options (papaparse)\n    // delimiter: auto\n    // newline: auto\n    quoteChar?: string;\n    escapeChar?: string;\n    // Convert numbers and boolean values in rows from strings\n    dynamicTyping?: boolean;\n    comments?: boolean;\n    skipEmptyLines?: boolean | 'greedy';\n    // transform: null?\n    delimitersToGuess?: string[];\n    // fastMode: auto\n  };\n};\n\nconst DEFAULT_CSV_LOADER_OPTIONS = {\n  csv: {\n    shape: 'object-row-table',\n    optimizeMemoryUsage: false,\n    // CSV options\n    header: 'auto',\n    columnPrefix: 'column',\n    // delimiter: auto\n    // newline: auto\n    quoteChar: '\"',\n    escapeChar: '\"',\n    dynamicTyping: true,\n    comments: false,\n    skipEmptyLines: true,\n    // transform: null?\n    delimitersToGuess: [',', '\\t', '|', ';']\n    // fastMode: auto\n  }\n};\n\nexport const CSVLoader = {\n  id: 'csv',\n  module: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv', 'tsv', 'dsv'],\n  mimeTypes: ['text/csv', 'text/tab-separated-values', 'text/dsv'],\n  category: 'table',\n  parse: async (arrayBuffer: ArrayBuffer, options?: CSVLoaderOptions) =>\n    parseCSV(new TextDecoder().decode(arrayBuffer), options),\n  parseText: (text: string, options?: CSVLoaderOptions) => parseCSV(text, options),\n  parseInBatches: parseCSVInBatches,\n  // @ts-ignore\n  // testText: null,\n  options: DEFAULT_CSV_LOADER_OPTIONS as CSVLoaderOptions\n};\n\nasync function parseCSV(csvText: string, options?: CSVLoaderOptions) {\n  // Apps can call the parse method directly, we so apply default options here\n  const csvOptions = {...DEFAULT_CSV_LOADER_OPTIONS.csv, ...options?.csv};\n\n  const firstRow = readFirstRow(csvText);\n  const header: boolean =\n    csvOptions.header === 'auto' ? isHeaderRow(firstRow) : Boolean(csvOptions.header);\n\n  const parseWithHeader = header;\n\n  const papaparseConfig = {\n    // dynamicTyping: true,\n    ...csvOptions,\n    header: parseWithHeader,\n    download: false, // We handle loading, no need for papaparse to do it for us\n    transformHeader: parseWithHeader ? duplicateColumnTransformer() : undefined,\n    error: (e) => {\n      throw new Error(e);\n    }\n  };\n\n  const result = Papa.parse(csvText, papaparseConfig);\n  let {data: rows} = result;\n\n  const headerRow = result.meta.fields || generateHeader(csvOptions.columnPrefix, firstRow.length);\n\n  switch (csvOptions.shape) {\n    case 'object-row-table':\n      rows = rows.map((row) => (Array.isArray(row) ? convertToObjectRow(row, headerRow) : row));\n      break;\n    case 'array-row-table':\n      rows = rows.map((row) => (Array.isArray(row) ? row : convertToArrayRow(row, headerRow)));\n      break;\n    default:\n  }\n\n  /*\n  if (!header && shape === 'object-row-table') {\n    // If the dataset has no header, transform the array result into an object shape with an\n    // autogenerated header\n    return result.data.map((row) =>\n      row.reduce((acc, value, i) => {\n        acc[headerRow[i]] = value;\n        return acc;\n      }, {})\n    );\n  }\n  */\n  return rows;\n}\n\n// TODO - support batch size 0 = no batching/single batch?\nfunction parseCSVInBatches(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options?: CSVLoaderOptions\n): AsyncIterable<Batch> {\n  // Papaparse does not support standard batch size handling\n  // TODO - investigate papaparse chunks mode\n  options = {...options};\n  if (options.batchSize === 'auto') {\n    options.batchSize = 4000;\n  }\n\n  // Apps can call the parse method directly, we so apply default options here\n  const csvOptions = {...DEFAULT_CSV_LOADER_OPTIONS.csv, ...options?.csv};\n\n  const asyncQueue = new AsyncQueue<Batch>();\n\n  let isFirstRow: boolean = true;\n  let headerRow: string[] | null = null;\n  let tableBatchBuilder: TableBatchBuilder | null = null;\n  let schema: Schema | null = null;\n\n  const config = {\n    // dynamicTyping: true, // Convert numbers and boolean values in rows from strings,\n    ...csvOptions,\n    header: false, // Unfortunately, header detection is not automatic and does not infer shapes\n    download: false, // We handle loading, no need for papaparse to do it for us\n    // chunkSize is set to 5MB explicitly (same as Papaparse default) due to a bug where the\n    // streaming parser gets stuck if skipEmptyLines and a step callback are both supplied.\n    // See https://github.com/mholt/PapaParse/issues/465\n    chunkSize: 1024 * 1024 * 5,\n    // skipEmptyLines is set to a boolean value if supplied. Greedy is set to true\n    // skipEmptyLines is handled manually given two bugs where the streaming parser gets stuck if\n    // both of the skipEmptyLines and step callback options are provided:\n    // - true doesn't work unless chunkSize is set: https://github.com/mholt/PapaParse/issues/465\n    // - greedy doesn't work: https://github.com/mholt/PapaParse/issues/825\n    skipEmptyLines: false,\n\n    // step is called on every row\n    // eslint-disable-next-line complexity\n    step(results) {\n      let row = results.data;\n\n      if (csvOptions.skipEmptyLines) {\n        // Manually reject lines that are empty\n        const collapsedRow = row.flat().join('').trim();\n        if (collapsedRow === '') {\n          return;\n        }\n      }\n      const bytesUsed = results.meta.cursor;\n\n      // Check if we need to save a header row\n      if (isFirstRow && !headerRow) {\n        // Auto detects or can be forced with csvOptions.header\n        const header = csvOptions.header === 'auto' ? isHeaderRow(row) : Boolean(csvOptions.header);\n        if (header) {\n          headerRow = row.map(duplicateColumnTransformer());\n          return;\n        }\n      }\n\n      // If first data row, we can deduce the schema\n      if (isFirstRow) {\n        isFirstRow = false;\n        if (!headerRow) {\n          headerRow = generateHeader(csvOptions.columnPrefix, row.length);\n        }\n        schema = deduceSchema(row, headerRow);\n      }\n\n      if (csvOptions.optimizeMemoryUsage) {\n        // A workaround to allocate new strings and don't retain pointers to original strings.\n        // https://bugs.chromium.org/p/v8/issues/detail?id=2869\n        row = JSON.parse(JSON.stringify(row));\n      }\n\n      // Add the row\n      tableBatchBuilder =\n        tableBatchBuilder ||\n        new TableBatchBuilder(schema, {\n          // @ts-expect-error\n          shape: csvOptions.shape || 'array-row-table',\n          ...options\n        });\n\n      try {\n        tableBatchBuilder.addRow(row);\n        // If a batch has been completed, emit it\n        const batch = tableBatchBuilder && tableBatchBuilder.getFullBatch({bytesUsed});\n        if (batch) {\n          asyncQueue.enqueue(batch);\n        }\n      } catch (error) {\n        asyncQueue.enqueue(error as Error);\n      }\n    },\n\n    // complete is called when all rows have been read\n    complete(results) {\n      try {\n        const bytesUsed = results.meta.cursor;\n        // Ensure any final (partial) batch gets emitted\n        const batch = tableBatchBuilder && tableBatchBuilder.getFinalBatch({bytesUsed});\n        if (batch) {\n          asyncQueue.enqueue(batch);\n        }\n      } catch (error) {\n        asyncQueue.enqueue(error as Error);\n      }\n\n      asyncQueue.close();\n    }\n  };\n\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n\n  // TODO - Does it matter if we return asyncIterable or asyncIterator\n  // return asyncQueue[Symbol.asyncIterator]();\n  return asyncQueue;\n}\n\n/**\n * Checks if a certain row is a header row\n * @param row the row to check\n * @returns true if the row looks like a header\n */\nfunction isHeaderRow(row: string[]): boolean {\n  return row && row.every((value) => typeof value === 'string');\n}\n\n/**\n * Reads, parses, and returns the first row of a CSV text\n * @param csvText the csv text to parse\n * @returns the first row\n */\nfunction readFirstRow(csvText: string): any[] {\n  const result = Papa.parse(csvText, {\n    download: false,\n    dynamicTyping: true,\n    preview: 1\n  });\n  return result.data[0];\n}\n\n/**\n * Creates a transformer that renames duplicate columns. This is needed as Papaparse doesn't handle\n * duplicate header columns and would use the latest occurrence by default.\n * See the header option in https://www.papaparse.com/docs#config\n * @returns a transform function that returns sanitized names for duplicate fields\n */\nfunction duplicateColumnTransformer() {\n  const observedColumns = new Set();\n  return (col) => {\n    let colName = col;\n    let counter = 1;\n    while (observedColumns.has(colName)) {\n      colName = `${col}.${counter}`;\n      counter++;\n    }\n    observedColumns.add(colName);\n    return colName;\n  };\n}\n\n/**\n * Generates the header of a CSV given a prefix and a column count\n * @param columnPrefix the columnPrefix to use\n * @param count the count of column names to generate\n * @returns an array of column names\n */\nfunction generateHeader(columnPrefix: string, count: number = 0): string[] {\n  const headers: string[] = [];\n  for (let i = 0; i < count; i++) {\n    headers.push(`${columnPrefix}${i + 1}`);\n  }\n  return headers;\n}\n\nfunction deduceSchema(row, headerRow) {\n  const schema = headerRow ? {} : [];\n  for (let i = 0; i < row.length; i++) {\n    const columnName = (headerRow && headerRow[i]) || i;\n    const value = row[i];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n  }\n  return schema;\n}\n\nexport const _typecheckCSVLoader: LoaderWithParser = CSVLoader;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}