{"ast":null,"code":"import { Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64, Float32, Float64, Bool, Utf8, TimestampMillisecond, Null } from '../types/arrow-like/type';\nimport Schema from './schema';\nimport Field from './field';\nvar TYPED_ARRAY_TO_TYPE = {\n  Int8Array: new Int8(),\n  Int16Array: new Int16(),\n  Int32Array: new Int32(),\n  Uint8Array: new Uint8(),\n  Uint8ClampedArray: new Uint8(),\n  Uint16Array: new Uint16(),\n  Uint32Array: new Uint32(),\n  Float32Array: new Float32(),\n  Float64Array: new Float64()\n};\nif (typeof BigInt64Array !== 'undefined') {\n  TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n  TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n}\nfunction getTypeFromColumnArray(columnArray) {\n  var ArrayType = columnArray.constructor && columnArray.constructor.name;\n  var type = TYPED_ARRAY_TO_TYPE[ArrayType];\n  if (type) {\n    return {\n      type: type,\n      nullable: false,\n      metadata: null\n    };\n  }\n  var metadata = null;\n  if (columnArray.length > 0) {\n    var value = columnArray[0];\n    type = deduceTypeFromValue(value);\n    if (type) {\n      metadata = new Map([['type', type.toString()]]);\n    }\n  }\n  return {\n    type: new Null(),\n    nullable: true,\n    metadata: metadata\n  };\n}\nexport function deduceTableSchema(table) {\n  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var deducedSchema = Array.isArray(table) ? deduceSchemaForRowTable(table) : deduceSchemaForColumnarTable(table);\n  return Object.assign(deducedSchema, schema);\n}\nfunction deduceSchemaForColumnarTable(columnarTable) {\n  var fields = [];\n  for (var columnName in columnarTable) {\n    var columnArray = columnarTable[columnName];\n    var _getTypeFromColumnArr = getTypeFromColumnArray(columnArray),\n      type = _getTypeFromColumnArr.type,\n      nullable = _getTypeFromColumnArr.nullable,\n      metadata = _getTypeFromColumnArr.metadata;\n    fields.push(new Field(columnName, type, nullable, metadata || new Map()));\n  }\n  return new Schema(fields);\n}\nfunction deduceSchemaForRowTable(rowTable) {\n  var fields = [];\n  if (rowTable.length) {\n    var row = rowTable[0];\n    if (Array.isArray(row)) {\n      for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {\n        var value = row[columnIndex];\n        var name = String(columnIndex);\n        var type = deduceTypeFromValue(value);\n        var nullable = true;\n        var metadata = new Map([['type', type.toString()]]);\n        fields.push(new Field(name, new Null(), nullable, metadata));\n      }\n    } else {\n      for (var columnName in row) {\n        var _value = row[columnName];\n        var _type = deduceTypeFromValue(_value);\n        var _nullable = true;\n        var _metadata = new Map([['type', _type.toString()]]);\n        fields.push(new Field(columnName, new Null(), _nullable, _metadata));\n      }\n    }\n  }\n  return new Schema(fields);\n}\nfunction deduceTypeFromValue(value) {\n  if (value === true || value === false) {\n    return new Bool();\n  }\n  if (value instanceof Date) {\n    return new TimestampMillisecond();\n  }\n  if (value instanceof Number) {\n    return new Float32();\n  }\n  if (typeof value === 'string') {\n    return new Utf8();\n  }\n  return new Null();\n}","map":{"version":3,"names":["Int8","Int16","Int32","Int64","Uint8","Uint16","Uint32","Uint64","Float32","Float64","Bool","Utf8","TimestampMillisecond","Null","Schema","Field","TYPED_ARRAY_TO_TYPE","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","getTypeFromColumnArray","columnArray","ArrayType","constructor","name","type","nullable","metadata","length","value","deduceTypeFromValue","Map","toString","deduceTableSchema","table","schema","arguments","undefined","deducedSchema","Array","isArray","deduceSchemaForRowTable","deduceSchemaForColumnarTable","Object","assign","columnarTable","fields","columnName","_getTypeFromColumnArr","push","rowTable","row","columnIndex","String","_value","_type","_nullable","_metadata","Date","Number"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/tables/src/lib/schema/schema-utils.js"],"sourcesContent":["// SCHEMA SUPPORT - AUTODEDUCTION\nimport {\n  // Int,\n  Int8,\n  Int16,\n  Int32,\n  Int64,\n  Uint8,\n  Uint16,\n  Uint32,\n  Uint64,\n  // Float,\n  // Float16,\n  Float32,\n  Float64,\n  Bool,\n  Utf8,\n  TimestampMillisecond,\n  Null\n} from '../types/arrow-like/type';\nimport Schema from './schema';\nimport Field from './field';\n\nconst TYPED_ARRAY_TO_TYPE = {\n  Int8Array: new Int8(),\n  Int16Array: new Int16(),\n  Int32Array: new Int32(),\n  Uint8Array: new Uint8(),\n  Uint8ClampedArray: new Uint8(),\n  Uint16Array: new Uint16(),\n  Uint32Array: new Uint32(),\n  Float32Array: new Float32(),\n  Float64Array: new Float64()\n};\n\nif (typeof BigInt64Array !== 'undefined') {\n  TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n  TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n}\n\n// Type deduction\n\n/**\n * Type deduction from columnar array\n *\n * Notes:\n * - If the column is a typed array we are able to make a fairly precise type deduction\n * - However we can't tell if it is intervals, dates, fixed size lists etc.\n * - Nullable typed arrays are only supported if backing table is Arrow\n *\n * @param {*} columnArray\n * @returns type, nullable, metadata - (Arrow-like) type information\n */\nfunction getTypeFromColumnArray(columnArray) {\n  const ArrayType = columnArray.constructor && columnArray.constructor.name;\n  let type = TYPED_ARRAY_TO_TYPE[ArrayType];\n  if (type) {\n    return {type, nullable: false, metadata: null};\n  }\n\n  let metadata = null;\n  if (columnArray.length > 0) {\n    const value = columnArray[0];\n    type = deduceTypeFromValue(value);\n    if (type) {\n      metadata = new Map([['type', type.toString()]]);\n    }\n  }\n\n  // We use fields of Arrow-Type Null to indicate that we represent additional, non binary columns\n  return {type: new Null(), nullable: true, metadata};\n}\n\nexport function deduceTableSchema(table, schema = null) {\n  const deducedSchema = Array.isArray(table)\n    ? deduceSchemaForRowTable(table)\n    : deduceSchemaForColumnarTable(table);\n  // Deduced schema will fill in missing info from partial options.schema, if provided\n  return Object.assign(deducedSchema, schema);\n}\n\nfunction deduceSchemaForColumnarTable(columnarTable) {\n  const fields = [];\n  for (const columnName in columnarTable) {\n    const columnArray = columnarTable[columnName];\n    const {type, nullable, metadata} = getTypeFromColumnArray(columnArray);\n    fields.push(new Field(columnName, type, nullable, metadata || new Map()));\n  }\n  return new Schema(fields);\n}\n\nfunction deduceSchemaForRowTable(rowTable) {\n  const fields = [];\n  if (rowTable.length) {\n    const row = rowTable[0];\n    // Note - handle rows in both array and object format\n    if (Array.isArray(row)) {\n      // row: [value1, value2, ...]\n      for (let columnIndex = 0; columnIndex < row.length; ++columnIndex) {\n        const value = row[columnIndex];\n        const name = String(columnIndex);\n        const type = deduceTypeFromValue(value);\n        const nullable = true;\n        const metadata = new Map([['type', type.toString()]]);\n        fields.push(new Field(name, new Null(), nullable, metadata));\n      }\n    } else {\n      for (const columnName in row) {\n        // row: {columnName1: value1, columnName2: value2, ...}\n        // TODO - Could look at additional rows if nulls in first row\n        const value = row[columnName];\n        const type = deduceTypeFromValue(value);\n        const nullable = true;\n        const metadata = new Map([['type', type.toString()]]);\n        fields.push(new Field(columnName, new Null(), nullable, metadata));\n      }\n    }\n  }\n  return new Schema(fields);\n}\n\nfunction deduceTypeFromValue(value) {\n  if (value === true || value === false) {\n    return new Bool();\n  }\n  if (value instanceof Date) {\n    return new TimestampMillisecond();\n  }\n  if (value instanceof Number) {\n    return new Float32();\n  }\n  if (typeof value === 'string') {\n    return new Utf8();\n  }\n  // TODO JS columns (arrays and object valued) are currently null\n  return new Null();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}