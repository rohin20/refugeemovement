{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSavedMapsErrorUpdater = exports.getSavedMapsSuccessUpdater = exports.getSavedMapsUpdater = exports.setCloudProviderUpdater = exports.resetProviderStatusUpdater = exports.loadCloudMapErrorUpdater = exports.loadCloudMapSuccessUpdater = exports.loadCloudMapUpdater = exports.exportFileErrorUpdater = exports.postSaveLoadSuccessUpdater = exports.exportFileSuccessUpdater = exports.exportFileToCloudUpdater = exports.INITIAL_PROVIDER_STATE = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _tasks = require(\"react-palm/tasks\");\nvar _console = _interopRequireDefault(require(\"global/console\"));\nvar _utils = require(\"@kepler.gl/utils\");\nvar _tasks2 = require(\"@kepler.gl/tasks\");\nvar _actions = require(\"@kepler.gl/actions\");\nvar _constants = require(\"@kepler.gl/constants\");\nvar _cloudProviders = require(\"@kepler.gl/cloud-providers\");\nvar _processors = require(\"@kepler.gl/processors\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar INITIAL_PROVIDER_STATE = {\n  isProviderLoading: false,\n  isCloudMapLoading: false,\n  providerError: null,\n  currentProvider: null,\n  successInfo: {},\n  mapSaved: null,\n  visualizations: []\n};\nexports.INITIAL_PROVIDER_STATE = INITIAL_PROVIDER_STATE;\nfunction createActionTask(action, payload) {\n  if (typeof action === 'function') {\n    return (0, _tasks2.ACTION_TASK)().map(function (_) {\n      return action(payload);\n    });\n  }\n  return null;\n}\nfunction _validateProvider(provider, method) {\n  if (!provider) {\n    _console[\"default\"].error(\"provider is not defined\");\n    return false;\n  }\n  if (typeof provider[method] !== 'function') {\n    _console[\"default\"].error(\"\".concat(method, \" is not a function of Cloud provider: \").concat(provider.name));\n    return false;\n  }\n  return true;\n}\nfunction createGlobalNotificationTasks(_ref) {\n  var type = _ref.type,\n    message = _ref.message,\n    _ref$delayClose = _ref.delayClose,\n    delayClose = _ref$delayClose === void 0 ? true : _ref$delayClose;\n  var id = (0, _utils.generateHashId)();\n  var successNote = {\n    id: id,\n    type: _constants.DEFAULT_NOTIFICATION_TYPES[type || ''] || _constants.DEFAULT_NOTIFICATION_TYPES.success,\n    topic: _constants.DEFAULT_NOTIFICATION_TOPICS.global,\n    message: message\n  };\n  var task = (0, _tasks2.ACTION_TASK)().map(function (_) {\n    return (0, _actions.addNotification)(successNote);\n  });\n  return delayClose ? [task, (0, _tasks2.DELAY_TASK)(3000).map(function (_) {\n    return (0, _actions.removeNotification)(id);\n  })] : [task];\n}\n/**\n * This method will export the current kepler config file to the chosen cloud proder\n * add returns a share URL\n *\n */\n\nvar exportFileToCloudUpdater = function exportFileToCloudUpdater(state, action) {\n  var _action$payload = action.payload,\n    mapData = _action$payload.mapData,\n    provider = _action$payload.provider,\n    _action$payload$optio = _action$payload.options,\n    options = _action$payload$optio === void 0 ? {} : _action$payload$optio,\n    onSuccess = _action$payload.onSuccess,\n    onError = _action$payload.onError,\n    closeModal = _action$payload.closeModal;\n  if (!_validateProvider(provider, 'uploadMap')) {\n    return state;\n  }\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: true,\n    currentProvider: provider.name\n  }); // payload called by provider.uploadMap\n\n  var payload = {\n    mapData: mapData,\n    options: options\n  };\n  var uploadFileTask = (0, _tasks2.EXPORT_FILE_TO_CLOUD_TASK)({\n    provider: provider,\n    payload: payload\n  }).bimap(\n  // success\n  function (response) {\n    return (0, _actions.exportFileSuccess)({\n      response: response,\n      provider: provider,\n      options: options,\n      onSuccess: onSuccess,\n      closeModal: closeModal\n    });\n  },\n  // error\n  function (error) {\n    return (0, _actions.exportFileError)({\n      error: error,\n      provider: provider,\n      options: options,\n      onError: onError\n    });\n  });\n  return (0, _tasks.withTask)(newState, uploadFileTask);\n};\nexports.exportFileToCloudUpdater = exportFileToCloudUpdater;\nvar exportFileSuccessUpdater = function exportFileSuccessUpdater(state, action) {\n  var _action$payload2 = action.payload,\n    response = _action$payload2.response,\n    provider = _action$payload2.provider,\n    _action$payload2$opti = _action$payload2.options,\n    options = _action$payload2$opti === void 0 ? {} : _action$payload2$opti,\n    onSuccess = _action$payload2.onSuccess,\n    closeModal = _action$payload2.closeModal;\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: false,\n    // TODO: do we always have to store this?\n    successInfo: response\n  }, !options.isPublic ? {\n    mapSaved: provider.name\n  } : {});\n  var tasks = [createActionTask(onSuccess, {\n    response: response,\n    provider: provider,\n    options: options\n  }), closeModal && (0, _tasks2.ACTION_TASK)().map(function (_) {\n    return (0, _actions.postSaveLoadSuccess)(\"Map saved to \".concat(state.currentProvider, \"!\"));\n  })].filter(function (d) {\n    return d;\n  });\n  return tasks.length ? (0, _tasks.withTask)(newState, tasks) : newState;\n};\n/**\n * Close modal on success and display notification\n */\n\nexports.exportFileSuccessUpdater = exportFileSuccessUpdater;\nvar postSaveLoadSuccessUpdater = function postSaveLoadSuccessUpdater(state, action) {\n  var message = action.payload || \"Saved / Load to \".concat(state.currentProvider, \" Success\");\n  var tasks = [(0, _tasks2.ACTION_TASK)().map(function (_) {\n    return (0, _actions.toggleModal)(null);\n  }), (0, _tasks2.ACTION_TASK)().map(function (_) {\n    return (0, _actions.resetProviderStatus)();\n  })].concat((0, _toConsumableArray2[\"default\"])(createGlobalNotificationTasks({\n    message: message\n  })));\n  return (0, _tasks.withTask)(state, tasks);\n};\nexports.postSaveLoadSuccessUpdater = postSaveLoadSuccessUpdater;\nvar exportFileErrorUpdater = function exportFileErrorUpdater(state, action) {\n  var _action$payload3 = action.payload,\n    error = _action$payload3.error,\n    provider = _action$payload3.provider,\n    onError = _action$payload3.onError;\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: false\n  });\n  if (isFileConflict(error)) {\n    newState.mapSaved = provider.name;\n    return (0, _tasks.withTask)(newState, [(0, _tasks2.ACTION_TASK)().map(function (_) {\n      return (0, _actions.toggleModal)(_constants.OVERWRITE_MAP_ID);\n    })]);\n  }\n  newState.providerError = (0, _utils.getError)(error);\n  var task = createActionTask(onError, {\n    error: error,\n    provider: provider\n  });\n  return task ? (0, _tasks.withTask)(newState, task) : newState;\n};\nexports.exportFileErrorUpdater = exportFileErrorUpdater;\nvar loadCloudMapUpdater = function loadCloudMapUpdater(state, action) {\n  var _action$payload4 = action.payload,\n    loadParams = _action$payload4.loadParams,\n    provider = _action$payload4.provider,\n    onSuccess = _action$payload4.onSuccess,\n    onError = _action$payload4.onError;\n  if (!loadParams) {\n    _console[\"default\"].warn('load map error: loadParams is undefined');\n    return state;\n  }\n  if (!_validateProvider(provider, 'downloadMap')) {\n    return state;\n  }\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: true,\n    isCloudMapLoading: true\n  }); // payload called by provider.downloadMap\n\n  var uploadFileTask = (0, _tasks2.LOAD_CLOUD_MAP_TASK)({\n    provider: provider,\n    payload: loadParams\n  }).bimap(\n  // success\n  // @ts-expect-error\n  function (response) {\n    return (0, _actions.loadCloudMapSuccess)({\n      response: response,\n      loadParams: loadParams,\n      provider: provider,\n      onSuccess: onSuccess,\n      onError: onError\n    });\n  },\n  // error\n  // @ts-expect-error\n  function (error) {\n    return (0, _actions.loadCloudMapError)({\n      error: error,\n      provider: provider,\n      onError: onError\n    });\n  });\n  return (0, _tasks.withTask)(newState, uploadFileTask);\n};\nexports.loadCloudMapUpdater = loadCloudMapUpdater;\nfunction isFileConflict(error) {\n  return error && error.message === _cloudProviders.FILE_CONFLICT_MSG;\n}\nfunction checkLoadMapResponseError(response) {\n  if (!response || !(0, _utils.isPlainObject)(response)) {\n    return new Error('Load map response is empty');\n  }\n  if (!(0, _utils.isPlainObject)(response.map)) {\n    return new Error(\"Load map response should be an object property \\\"map\\\"\");\n  }\n  if (!response.map.datasets || !response.map.config) {\n    return new Error(\"Load map response.map should be an object with property datasets or config\");\n  }\n  return null;\n}\nfunction getDatasetHandler(format) {\n  var defaultHandler = _processors.DATASET_HANDLERS[_constants.DATASET_FORMATS.csv];\n  if (!format) {\n    _console[\"default\"].warn('format is not provided in load map response, will use csv by default');\n    return defaultHandler;\n  }\n  if (!_processors.DATASET_HANDLERS[format]) {\n    var supportedFormat = Object.keys(_constants.DATASET_FORMATS).map(function (k) {\n      return \"'\".concat(k, \"'\");\n    }).join(', ');\n    _console[\"default\"].warn(\"unknown format \".concat(format, \". Please use one of \").concat(supportedFormat, \", will use csv by default\"));\n    return defaultHandler;\n  }\n  return _processors.DATASET_HANDLERS[format];\n}\nfunction parseLoadMapResponse(response, loadParams, provider) {\n  var map = response.map,\n    format = response.format;\n  var processorMethod = getDatasetHandler(format);\n  var parsedDatasets = (0, _utils.toArray)(map.datasets).map(function (ds, i) {\n    if (format === _constants.DATASET_FORMATS.keplergl) {\n      // no need to obtain id, directly pass them in\n      return processorMethod(ds);\n    }\n    var info = ds && ds.info || {\n      id: (0, _utils.generateHashId)(6)\n    };\n    var data = processorMethod(ds.data || ds);\n    return {\n      info: info,\n      data: data\n    };\n  });\n  var info = _objectSpread(_objectSpread({}, map.info), {}, {\n    provider: provider.name,\n    loadParams: loadParams\n  });\n  return _objectSpread({\n    datasets: parsedDatasets,\n    info: info\n  }, map.config ? {\n    config: map.config\n  } : {});\n}\nvar loadCloudMapSuccessUpdater = function loadCloudMapSuccessUpdater(state, action) {\n  var _action$payload5 = action.payload,\n    response = _action$payload5.response,\n    loadParams = _action$payload5.loadParams,\n    provider = _action$payload5.provider,\n    onSuccess = _action$payload5.onSuccess,\n    onError = _action$payload5.onError;\n  var formatError = checkLoadMapResponseError(response);\n  if (formatError) {\n    // if response format is not correct\n    return exportFileErrorUpdater(state, {\n      payload: {\n        error: formatError,\n        provider: provider,\n        onError: onError\n      }\n    });\n  }\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    mapSaved: provider.name,\n    currentProvider: provider.name,\n    isCloudMapLoading: false,\n    isProviderLoading: false\n  });\n  var payload = parseLoadMapResponse(response, loadParams, provider);\n  var tasks = [(0, _tasks2.ACTION_TASK)().map(function (_) {\n    return (0, _actions.addDataToMap)(payload);\n  }), createActionTask(onSuccess, {\n    response: response,\n    loadParams: loadParams,\n    provider: provider\n  }), (0, _tasks2.ACTION_TASK)().map(function (_) {\n    return (0, _actions.postSaveLoadSuccess)(\"Map from \".concat(provider.name, \" loaded\"));\n  })].filter(function (d) {\n    return d;\n  });\n  return tasks.length ? (0, _tasks.withTask)(newState, tasks) : newState;\n};\nexports.loadCloudMapSuccessUpdater = loadCloudMapSuccessUpdater;\nvar loadCloudMapErrorUpdater = function loadCloudMapErrorUpdater(state, action) {\n  var message = (0, _utils.getError)(action.payload.error) || \"Error loading saved map\";\n  _console[\"default\"].warn(message);\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: false,\n    isCloudMapLoading: false,\n    providerError: null\n  });\n  return (0, _tasks.withTask)(newState, createGlobalNotificationTasks({\n    type: 'error',\n    message: message,\n    delayClose: false\n  }));\n};\nexports.loadCloudMapErrorUpdater = loadCloudMapErrorUpdater;\nvar resetProviderStatusUpdater = function resetProviderStatusUpdater(state) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: false,\n    providerError: null,\n    isCloudMapLoading: false,\n    successInfo: {}\n  });\n};\n/**\n * Set current cloudProvider\n */\n\nexports.resetProviderStatusUpdater = resetProviderStatusUpdater;\nvar setCloudProviderUpdater = function setCloudProviderUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: false,\n    providerError: null,\n    successInfo: {},\n    currentProvider: action.payload\n  });\n};\nexports.setCloudProviderUpdater = setCloudProviderUpdater;\nvar getSavedMapsUpdater = function getSavedMapsUpdater(state, action) {\n  var provider = action.payload;\n  if (!_validateProvider(provider, 'listMaps')) {\n    return state;\n  }\n  var getSavedMapsTask = (0, _tasks2.GET_SAVED_MAPS_TASK)(provider).bimap(\n  // success\n  function (visualizations) {\n    return (0, _actions.getSavedMapsSuccess)({\n      visualizations: visualizations,\n      provider: provider\n    });\n  },\n  // error\n  function (error) {\n    return (0, _actions.getSavedMapsError)({\n      error: error,\n      provider: provider\n    });\n  });\n  return (0, _tasks.withTask)(_objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: true\n  }), getSavedMapsTask);\n};\nexports.getSavedMapsUpdater = getSavedMapsUpdater;\nvar getSavedMapsSuccessUpdater = function getSavedMapsSuccessUpdater(state, action) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    isProviderLoading: false,\n    visualizations: action.payload.visualizations\n  });\n};\nexports.getSavedMapsSuccessUpdater = getSavedMapsSuccessUpdater;\nvar getSavedMapsErrorUpdater = function getSavedMapsErrorUpdater(state, action) {\n  var message = (0, _utils.getError)(action.payload.error) || \"Error getting saved maps from \".concat(state.currentProvider);\n  _console[\"default\"].warn(action.payload.error);\n  var newState = _objectSpread(_objectSpread({}, state), {}, {\n    currentProvider: null,\n    isProviderLoading: false\n  });\n  return (0, _tasks.withTask)(newState, createGlobalNotificationTasks({\n    type: 'error',\n    message: message,\n    delayClose: false\n  }));\n};\nexports.getSavedMapsErrorUpdater = getSavedMapsErrorUpdater;","map":{"version":3,"names":["value","exports","getSavedMapsErrorUpdater","getSavedMapsSuccessUpdater","getSavedMapsUpdater","setCloudProviderUpdater","resetProviderStatusUpdater","loadCloudMapErrorUpdater","loadCloudMapSuccessUpdater","loadCloudMapUpdater","exportFileErrorUpdater","postSaveLoadSuccessUpdater","exportFileSuccessUpdater","exportFileToCloudUpdater","INITIAL_PROVIDER_STATE","_tasks","require","_console","_interopRequireDefault","_utils","_tasks2","_actions","_cloudProviders","_processors","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty2","getOwnPropertyDescriptors","defineProperties","defineProperty","isProviderLoading","isCloudMapLoading","providerError","successInfo","mapSaved","createActionTask","action","payload","_validateProvider","delayClose","provider","method","error","concat","name","createGlobalNotificationTasks","_ref","type","message","_ref$delayClose","successNote","id","_constants","DEFAULT_NOTIFICATION_TYPES","success","topic","DEFAULT_NOTIFICATION_TOPICS","global","task","ACTION_TASK","map","_","addNotification","removeNotification","state","_action$payload","mapData","_action$payload$optio","options","onSuccess","onError","closeModal","newState","currentProvider","uploadFileTask","EXPORT_FILE_TO_CLOUD_TASK","response","withTask","_action$payload2","_action$payload2$opti","tasks","postSaveLoadSuccess","d","resetProviderStatus","_toConsumableArray2","_action$payload3","isFileConflict","getError","_action$payload4","loadParams","warn","LOAD_CLOUD_MAP_TASK","bimap","loadCloudMapError","FILE_CONFLICT_MSG","checkLoadMapResponseError","Console","Error","isPlainObject","getDatasetHandler","format","defaultHandler","DATASET_HANDLERS","supportedFormat","DATASET_FORMATS","k","join","parseLoadMapResponse","info","processorMethod","keplergl","ds","generateHashId","data","datasets","parsedDatasets","config","_action$payload5","formatError","addDataToMap","getSavedMapsTask","GET_SAVED_MAPS_TASK","visualizations","getSavedMapsSuccess"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/reducers/src/provider-state-updaters.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {withTask} from 'react-palm/tasks';\nimport Console from 'global/console';\nimport {generateHashId, getError, isPlainObject, toArray} from '@kepler.gl/utils';\nimport {\n  EXPORT_FILE_TO_CLOUD_TASK,\n  ACTION_TASK,\n  DELAY_TASK,\n  LOAD_CLOUD_MAP_TASK,\n  GET_SAVED_MAPS_TASK\n} from '@kepler.gl/tasks';\nimport {\n  exportFileSuccess,\n  exportFileError,\n  postSaveLoadSuccess,\n  loadCloudMapSuccess,\n  getSavedMapsSuccess,\n  getSavedMapsError,\n  loadCloudMapError,\n  resetProviderStatus,\n  removeNotification,\n  toggleModal,\n  addNotification,\n  addDataToMap,\n  ProviderActions\n} from '@kepler.gl/actions';\nimport {\n  DEFAULT_NOTIFICATION_TYPES,\n  DEFAULT_NOTIFICATION_TOPICS,\n  DATASET_FORMATS,\n  OVERWRITE_MAP_ID\n} from '@kepler.gl/constants';\nimport {ExportFileToCloudPayload} from '@kepler.gl/types';\n\nimport {FILE_CONFLICT_MSG, MapListItem} from '@kepler.gl/cloud-providers';\nimport {DATASET_HANDLERS} from '@kepler.gl/processors';\n\ntype ActionPayload<P> = {\n  type?: string;\n  payload: P;\n};\n\nexport type ProviderState = {\n  isProviderLoading: boolean;\n  isCloudMapLoading: boolean;\n  providerError: any;\n  currentProvider: string | null;\n  successInfo: any;\n  mapSaved: null | string;\n  initialState?: any;\n  visualizations: MapListItem[];\n};\n\nexport const INITIAL_PROVIDER_STATE: ProviderState = {\n  isProviderLoading: false,\n  isCloudMapLoading: false,\n  providerError: null,\n  currentProvider: null,\n  successInfo: {},\n  mapSaved: null,\n  visualizations: []\n};\n\nfunction createActionTask(action, payload) {\n  if (typeof action === 'function') {\n    return ACTION_TASK().map(_ => action(payload));\n  }\n\n  return null;\n}\n\nfunction _validateProvider(provider, method) {\n  if (!provider) {\n    Console.error(`provider is not defined`);\n    return false;\n  }\n\n  if (typeof provider[method] !== 'function') {\n    Console.error(`${method} is not a function of Cloud provider: ${provider.name}`);\n    return false;\n  }\n\n  return true;\n}\n\nfunction createGlobalNotificationTasks({\n  type,\n  message,\n  delayClose = true\n}: {\n  type?: string;\n  message: string;\n  delayClose?: boolean;\n}) {\n  const id = generateHashId();\n  const successNote = {\n    id,\n    type: DEFAULT_NOTIFICATION_TYPES[type || ''] || DEFAULT_NOTIFICATION_TYPES.success,\n    topic: DEFAULT_NOTIFICATION_TOPICS.global,\n    message\n  };\n  const task = ACTION_TASK().map(_ => addNotification(successNote));\n  return delayClose ? [task, DELAY_TASK(3000).map(_ => removeNotification(id))] : [task];\n}\n\n/**\n * This method will export the current kepler config file to the chosen cloud proder\n * add returns a share URL\n *\n */\nexport const exportFileToCloudUpdater = (\n  state: ProviderState,\n  action: ActionPayload<ExportFileToCloudPayload>\n): ProviderState => {\n  const {mapData, provider, options = {}, onSuccess, onError, closeModal} = action.payload;\n\n  if (!_validateProvider(provider, 'uploadMap')) {\n    return state;\n  }\n\n  const newState = {\n    ...state,\n    isProviderLoading: true,\n    currentProvider: provider.name\n  };\n\n  // payload called by provider.uploadMap\n  const payload = {\n    mapData,\n    options\n  };\n  const uploadFileTask = EXPORT_FILE_TO_CLOUD_TASK({provider, payload}).bimap(\n    // success\n    response => exportFileSuccess({response, provider, options, onSuccess, closeModal}),\n    // error\n    error => exportFileError({error, provider, options, onError})\n  );\n\n  return withTask(newState, uploadFileTask);\n};\n\nexport const exportFileSuccessUpdater = (\n  state: ProviderState,\n  action: ActionPayload<ProviderActions.ExportFileSuccessPayload>\n): ProviderState => {\n  const {response, provider, options = {}, onSuccess, closeModal} = action.payload;\n\n  const newState = {\n    ...state,\n    isProviderLoading: false,\n    // TODO: do we always have to store this?\n    successInfo: response,\n    ...(!options.isPublic\n      ? {\n          mapSaved: provider.name\n        }\n      : {})\n  };\n\n  const tasks = [\n    createActionTask(onSuccess, {response, provider, options}),\n    closeModal &&\n      ACTION_TASK().map(_ => postSaveLoadSuccess(`Map saved to ${state.currentProvider}!`))\n  ].filter(d => d);\n\n  return tasks.length ? withTask(newState, tasks) : newState;\n};\n\n/**\n * Close modal on success and display notification\n */\nexport const postSaveLoadSuccessUpdater = (\n  state: ProviderState,\n  action: ActionPayload<ProviderActions.PostSaveLoadSuccessPayload>\n): ProviderState => {\n  const message = action.payload || `Saved / Load to ${state.currentProvider} Success`;\n\n  const tasks = [\n    ACTION_TASK().map(_ => toggleModal(null)),\n    ACTION_TASK().map(_ => resetProviderStatus()),\n    ...createGlobalNotificationTasks({message})\n  ];\n\n  return withTask(state, tasks);\n};\n\nexport const exportFileErrorUpdater = (\n  state: ProviderState,\n  action: ActionPayload<ProviderActions.ExportFileErrorPayload>\n): ProviderState => {\n  const {error, provider, onError} = action.payload;\n\n  const newState = {\n    ...state,\n    isProviderLoading: false\n  };\n\n  if (isFileConflict(error)) {\n    newState.mapSaved = provider.name;\n    return withTask(newState, [ACTION_TASK().map(_ => toggleModal(OVERWRITE_MAP_ID))]);\n  }\n\n  newState.providerError = getError(error);\n  const task = createActionTask(onError, {error, provider});\n\n  return task ? withTask(newState, task) : newState;\n};\n\nexport const loadCloudMapUpdater = (\n  state: ProviderState,\n  action: ActionPayload<ProviderActions.LoadCloudMapPayload>\n): ProviderState => {\n  const {loadParams, provider, onSuccess, onError} = action.payload;\n  if (!loadParams) {\n    Console.warn('load map error: loadParams is undefined');\n    return state;\n  }\n  if (!_validateProvider(provider, 'downloadMap')) {\n    return state;\n  }\n\n  const newState = {\n    ...state,\n    isProviderLoading: true,\n    isCloudMapLoading: true\n  };\n\n  // payload called by provider.downloadMap\n  const uploadFileTask = LOAD_CLOUD_MAP_TASK({provider, payload: loadParams}).bimap(\n    // success\n    // @ts-expect-error\n    response => loadCloudMapSuccess({response, loadParams, provider, onSuccess, onError}),\n    // error\n    // @ts-expect-error\n    error => loadCloudMapError({error, provider, onError})\n  );\n\n  return withTask(newState, uploadFileTask);\n};\n\nfunction isFileConflict(error) {\n  return error && error.message === FILE_CONFLICT_MSG;\n}\n\nfunction checkLoadMapResponseError(response) {\n  if (!response || !isPlainObject(response)) {\n    return new Error('Load map response is empty');\n  }\n  if (!isPlainObject(response.map)) {\n    return new Error(`Load map response should be an object property \"map\"`);\n  }\n  if (!response.map.datasets || !response.map.config) {\n    return new Error(`Load map response.map should be an object with property datasets or config`);\n  }\n\n  return null;\n}\n\nfunction getDatasetHandler(format) {\n  const defaultHandler = DATASET_HANDLERS[DATASET_FORMATS.csv];\n  if (!format) {\n    Console.warn('format is not provided in load map response, will use csv by default');\n    return defaultHandler;\n  }\n\n  if (!DATASET_HANDLERS[format]) {\n    const supportedFormat = Object.keys(DATASET_FORMATS)\n      .map(k => `'${k}'`)\n      .join(', ');\n    Console.warn(\n      `unknown format ${format}. Please use one of ${supportedFormat}, will use csv by default`\n    );\n    return defaultHandler;\n  }\n\n  return DATASET_HANDLERS[format];\n}\n\nfunction parseLoadMapResponse(response, loadParams, provider) {\n  const {map, format} = response;\n  const processorMethod = getDatasetHandler(format);\n\n  const parsedDatasets = toArray(map.datasets).map((ds, i) => {\n    if (format === DATASET_FORMATS.keplergl) {\n      // no need to obtain id, directly pass them in\n      return processorMethod(ds);\n    }\n    const info = (ds && ds.info) || {id: generateHashId(6)};\n    const data = processorMethod(ds.data || ds);\n    return {info, data};\n  });\n\n  const info = {\n    ...map.info,\n    provider: provider.name,\n    loadParams\n  };\n  return {\n    datasets: parsedDatasets,\n    info,\n    ...(map.config ? {config: map.config} : {})\n  };\n}\n\nexport const loadCloudMapSuccessUpdater = (\n  state: ProviderState,\n  action: ActionPayload<ProviderActions.LoadCloudMapSuccessPayload>\n): ProviderState => {\n  const {response, loadParams, provider, onSuccess, onError} = action.payload;\n\n  const formatError = checkLoadMapResponseError(response);\n  if (formatError) {\n    // if response format is not correct\n    return exportFileErrorUpdater(state, {\n      payload: {error: formatError, provider, onError}\n    });\n  }\n\n  const newState = {\n    ...state,\n    mapSaved: provider.name,\n    currentProvider: provider.name,\n    isCloudMapLoading: false,\n    isProviderLoading: false\n  };\n\n  const payload = parseLoadMapResponse(response, loadParams, provider);\n\n  const tasks = [\n    ACTION_TASK().map(_ => addDataToMap(payload)),\n    createActionTask(onSuccess, {response, loadParams, provider}),\n    ACTION_TASK().map(_ => postSaveLoadSuccess(`Map from ${provider.name} loaded`))\n  ].filter(d => d);\n\n  return tasks.length ? withTask(newState, tasks) : newState;\n};\n\nexport const loadCloudMapErrorUpdater = (\n  state: ProviderState,\n  action: ActionPayload<ProviderActions.LoadCloudMapErrorPayload>\n): ProviderState => {\n  const message = getError(action.payload.error) || `Error loading saved map`;\n\n  Console.warn(message);\n\n  const newState = {\n    ...state,\n    isProviderLoading: false,\n    isCloudMapLoading: false,\n    providerError: null\n  };\n\n  return withTask(\n    newState,\n    createGlobalNotificationTasks({type: 'error', message, delayClose: false})\n  );\n};\n\nexport const resetProviderStatusUpdater = (state: ProviderState): ProviderState => ({\n  ...state,\n  isProviderLoading: false,\n  providerError: null,\n  isCloudMapLoading: false,\n  successInfo: {}\n});\n\n/**\n * Set current cloudProvider\n */\nexport const setCloudProviderUpdater = (\n  state: ProviderState,\n  action: ActionPayload<ProviderActions.SetCloudProviderPayload>\n): ProviderState => ({\n  ...state,\n  isProviderLoading: false,\n  providerError: null,\n  successInfo: {},\n  currentProvider: action.payload\n});\n\nexport const getSavedMapsUpdater = (\n  state: ProviderState,\n  action: ActionPayload<ProviderActions.GetSavedMapsPayload>\n): ProviderState => {\n  const provider = action.payload;\n  if (!_validateProvider(provider, 'listMaps')) {\n    return state;\n  }\n\n  const getSavedMapsTask = GET_SAVED_MAPS_TASK(provider).bimap(\n    // success\n    visualizations => getSavedMapsSuccess({visualizations, provider}),\n    // error\n    error => getSavedMapsError({error, provider})\n  );\n\n  return withTask(\n    {\n      ...state,\n      isProviderLoading: true\n    },\n    getSavedMapsTask\n  );\n};\n\nexport const getSavedMapsSuccessUpdater = (\n  state: ProviderState,\n  action: ActionPayload<ProviderActions.GetSavedMapsSuccessPayload>\n): ProviderState => ({\n  ...state,\n  isProviderLoading: false,\n  visualizations: action.payload.visualizations\n});\n\nexport const getSavedMapsErrorUpdater = (\n  state: ProviderState,\n  action: ActionPayload<ProviderActions.GetSavedMapsErrorPayload>\n): ProviderState => {\n  const message =\n    getError(action.payload.error) || `Error getting saved maps from ${state.currentProvider}`;\n\n  Console.warn(action.payload.error);\n\n  const newState = {\n    ...state,\n    currentProvider: null,\n    isProviderLoading: false\n  };\n\n  return withTask(\n    newState,\n    createGlobalNotificationTasks({type: 'error', message, delayClose: false})\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}