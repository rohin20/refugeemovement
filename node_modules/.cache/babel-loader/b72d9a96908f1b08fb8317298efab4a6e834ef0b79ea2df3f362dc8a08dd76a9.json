{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport assert from '../utils/assert';\nvar Schema = function () {\n  function Schema(fields) {\n    var metadata = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, Schema);\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n  _createClass(Schema, [{\n    key: \"compareTo\",\n    value: function compareTo(other) {\n      if (this.fields.metadata !== other.fields.metadata) {\n        return false;\n      }\n      if (this.fields.length !== other.fields.length) {\n        return false;\n      }\n      for (var i = 0; i < this.fields.length; ++i) {\n        if (!this.fields[i].compareTo(other.fields[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"select\",\n    value: function select() {\n      var nameMap = Object.create(null);\n      for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {\n        columnNames[_key] = arguments[_key];\n      }\n      for (var _i = 0, _columnNames = columnNames; _i < _columnNames.length; _i++) {\n        var name = _columnNames[_i];\n        nameMap[name] = true;\n      }\n      var selectedFields = columnNames.filter(function (field) {\n        return nameMap[field.name];\n      });\n      return new Schema(selectedFields, this.metadata);\n    }\n  }, {\n    key: \"selectAt\",\n    value: function selectAt() {\n      var _this = this;\n      for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        columnIndices[_key2] = arguments[_key2];\n      }\n      var selectedFields = columnIndices.map(function (index) {\n        return _this.fields[index];\n      }).filter(Boolean);\n      return new Schema(selectedFields, this.metadata);\n    }\n  }, {\n    key: \"assign\",\n    value: function assign(schemaOrFields) {\n      var metadata = this.metadata;\n      var fields = schemaOrFields;\n      if (schemaOrFields instanceof Schema) {\n        var otherSchema = schemaOrFields;\n        fields = otherSchema.fields;\n        metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n      }\n      var fieldMap = Object.create(null);\n      var _iterator = _createForOfIteratorHelper(this.fields),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var field = _step.value;\n          fieldMap[field.name] = field;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = _createForOfIteratorHelper(fields),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _field = _step2.value;\n          fieldMap[_field.name] = _field;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var mergedFields = Object.values(fieldMap);\n      return new Schema(mergedFields, metadata);\n    }\n  }]);\n  return Schema;\n}();\nexport { Schema as default };\nfunction checkNames(fields) {\n  var usedNames = {};\n  var _iterator3 = _createForOfIteratorHelper(fields),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var field = _step3.value;\n      if (usedNames[field.name]) {\n        console.warn('Schema: duplicated field name', field.name, field);\n      }\n      usedNames[field.name] = true;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\nfunction mergeMaps(m1, m2) {\n  return new Map([].concat(_toConsumableArray(m1 || new Map()), _toConsumableArray(m2 || new Map())));\n}","map":{"version":3,"names":["assert","Schema","fields","metadata","arguments","length","undefined","_classCallCheck","Array","isArray","checkNames","Map","other","i","compareTo","nameMap","Object","create","_len","columnNames","_key","_i","_columnNames","name","selectedFields","filter","field","_this","_len2","columnIndices","_key2","map","index","Boolean","schemaOrFields","otherSchema","mergeMaps","fieldMap","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","err","e","f","_iterator2","_step2","_field","mergedFields","values","usedNames","_iterator3","_step3","console","warn","m1","m2","concat","_toConsumableArray"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/tables/src/lib/schema/schema.js"],"sourcesContent":["import assert from '../utils/assert';\n\n// ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n// https://loaders.gl/arrowjs/docs/api-reference/schema\nexport default class Schema {\n  constructor(fields, metadata = null) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields\n  compareTo(other) {\n    if (this.fields.metadata !== other.fields.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames) {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = columnNames.filter(field => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices) {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map(index => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields) {\n    let metadata = this.metadata;\n\n    let fields = schemaOrFields;\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields) {\n  const usedNames = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps(m1, m2) {\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,MAAP,MAAmB,iBAAnB;IAIqBC,M;EACnB,SAAAA,OAAYC,MAAZ,EAAqC;IAAA,IAAjBC,QAAiB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAN,IAAM;IAAAG,eAAA,OAAAN,MAAA;IACnCD,MAAM,CAACQ,KAAK,CAACC,OAAN,CAAcP,MAAd,CAAD,CAAN;IACAQ,UAAU,CAACR,MAAD,CAAV;IAEA,KAAKA,MAAL,GAAcA,MAAd;IACA,KAAKC,QAAL,GAAgBA,QAAQ,IAAI,IAAIQ,GAAJ,EAA5B;EACD;;;8BAGSC,K,EAAO;MACf,IAAI,KAAKV,MAAL,CAAYC,QAAZ,KAAyBS,KAAK,CAACV,MAAN,CAAaC,QAA1C,EAAoD;QAClD,OAAO,KAAP;MACD;MACD,IAAI,KAAKD,MAAL,CAAYG,MAAZ,KAAuBO,KAAK,CAACV,MAAN,CAAaG,MAAxC,EAAgD;QAC9C,OAAO,KAAP;MACD;MACD,KAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKX,MAAL,CAAYG,MAAhC,EAAwC,EAAEQ,CAA1C,EAA6C;QAC3C,IAAI,CAAC,KAAKX,MAAL,CAAYW,CAAZ,EAAeC,SAAf,CAAyBF,KAAK,CAACV,MAAN,CAAaW,CAAb,CAAzB,CAAL,EAAgD;UAC9C,OAAO,KAAP;QACD;MACF;MACD,OAAO,IAAP;IACD;;;6BAEsB;MAErB,IAAME,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAhB;MAFqB,SAAAC,IAAA,GAAAd,SAAA,CAAAC,MAAA,EAAbc,WAAa,OAAAX,KAAA,CAAAU,IAAA,GAAAE,IAAA,MAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA;QAAbD,WAAa,CAAAC,IAAA,IAAAhB,SAAA,CAAAgB,IAAA;MAAA;MAGrB,SAAAC,EAAA,MAAAC,YAAA,GAAmBH,WAAnB,EAAAE,EAAA,GAAAC,YAAA,CAAAjB,MAAA,EAAAgB,EAAA,IAAgC;QAA3B,IAAME,IAAI,GAAAD,YAAA,CAAAD,EAAA,CAAV;QACHN,OAAO,CAACQ,IAAD,CAAP,GAAgB,IAAhB;MACD;MACD,IAAMC,cAAc,GAAGL,WAAW,CAACM,MAAZ,CAAmB,UAAAC,KAAK;QAAA,OAAIX,OAAO,CAACW,KAAK,CAACH,IAAP,CAAX;MAAA,CAAxB,CAAvB;MACA,OAAO,IAAItB,MAAJ,CAAWuB,cAAX,EAA2B,KAAKrB,QAAhC,CAAP;IACD;;;+BAE0B;MAAA,IAAAwB,KAAA;MAAA,SAAAC,KAAA,GAAAxB,SAAA,CAAAC,MAAA,EAAfwB,aAAe,OAAArB,KAAA,CAAAoB,KAAA,GAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;QAAfD,aAAe,CAAAC,KAAA,IAAA1B,SAAA,CAAA0B,KAAA;MAAA;MAEzB,IAAMN,cAAc,GAAGK,aAAa,CAACE,GAAd,CAAkB,UAAAC,KAAK;QAAA,OAAIL,KAAI,CAACzB,MAAL,CAAY8B,KAAZ,CAAJ;MAAA,CAAvB,EAA+CP,MAA/C,CAAsDQ,OAAtD,CAAvB;MACA,OAAO,IAAIhC,MAAJ,CAAWuB,cAAX,EAA2B,KAAKrB,QAAhC,CAAP;IACD;;;2BAEM+B,c,EAAgB;MACrB,IAAI/B,QAAQ,GAAG,KAAKA,QAApB;MAEA,IAAID,MAAM,GAAGgC,cAAb;MACA,IAAIA,cAAc,YAAYjC,MAA9B,EAAsC;QACpC,IAAMkC,WAAW,GAAGD,cAApB;QACAhC,MAAM,GAAGiC,WAAW,CAACjC,MAArB;QACAC,QAAQ,GAAGiC,SAAS,CAACA,SAAS,CAAC,IAAIzB,GAAJ,EAAD,EAAY,KAAKR,QAAjB,CAAV,EAAsCgC,WAAW,CAAChC,QAAlD,CAApB;MACD;MAGD,IAAMkC,QAAQ,GAAGrB,MAAM,CAACC,MAAP,CAAc,IAAd,CAAjB;MAXqB,IAAAqB,SAAA,GAAAC,0BAAA,CAaD,KAAKrC,MAbJ;QAAAsC,KAAA;MAAA;QAarB,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAiC;UAAA,IAAtBjB,KAAsB,GAAAc,KAAA,CAAAI,KAAA;UAC/BP,QAAQ,CAACX,KAAK,CAACH,IAAP,CAAR,GAAuBG,KAAvB;QACD;MAfoB,SAAAmB,GAAA;QAAAP,SAAA,CAAAQ,CAAA,CAAAD,GAAA;MAAA;QAAAP,SAAA,CAAAS,CAAA;MAAA;MAAA,IAAAC,UAAA,GAAAT,0BAAA,CAiBDrC,MAjBC;QAAA+C,MAAA;MAAA;QAiBrB,KAAAD,UAAA,CAAAP,CAAA,MAAAQ,MAAA,GAAAD,UAAA,CAAAN,CAAA,IAAAC,IAAA,GAA4B;UAAA,IAAjBO,MAAiB,GAAAD,MAAA,CAAAL,KAAA;UAC1BP,QAAQ,CAACa,MAAK,CAAC3B,IAAP,CAAR,GAAuB2B,MAAvB;QACD;MAnBoB,SAAAL,GAAA;QAAAG,UAAA,CAAAF,CAAA,CAAAD,GAAA;MAAA;QAAAG,UAAA,CAAAD,CAAA;MAAA;MAqBrB,IAAMI,YAAY,GAAGnC,MAAM,CAACoC,MAAP,CAAcf,QAAd,CAArB;MAEA,OAAO,IAAIpC,MAAJ,CAAWkD,YAAX,EAAyBhD,QAAzB,CAAP;IACD;;;;SAjEkBF,M;AAqErB,SAASS,UAATA,CAAoBR,MAApB,EAA4B;EAC1B,IAAMmD,SAAS,GAAG,EAAlB;EAD0B,IAAAC,UAAA,GAAAf,0BAAA,CAENrC,MAFM;IAAAqD,MAAA;EAAA;IAE1B,KAAAD,UAAA,CAAAb,CAAA,MAAAc,MAAA,GAAAD,UAAA,CAAAZ,CAAA,IAAAC,IAAA,GAA4B;MAAA,IAAjBjB,KAAiB,GAAA6B,MAAA,CAAAX,KAAA;MAC1B,IAAIS,SAAS,CAAC3B,KAAK,CAACH,IAAP,CAAb,EAA2B;QAEzBiC,OAAO,CAACC,IAAR,CAAa,+BAAb,EAA8C/B,KAAK,CAACH,IAApD,EAA0DG,KAA1D;MACD;MACD2B,SAAS,CAAC3B,KAAK,CAACH,IAAP,CAAT,GAAwB,IAAxB;IACD;EARyB,SAAAsB,GAAA;IAAAS,UAAA,CAAAR,CAAA,CAAAD,GAAA;EAAA;IAAAS,UAAA,CAAAP,CAAA;EAAA;AAS3B;AAED,SAASX,SAATA,CAAmBsB,EAAnB,EAAuBC,EAAvB,EAA2B;EACzB,OAAO,IAAIhD,GAAJ,IAAAiD,MAAA,CAAAC,kBAAA,CAAaH,EAAE,IAAI,IAAI/C,GAAJ,EAAnB,GAAAkD,kBAAA,CAAmCF,EAAE,IAAI,IAAIhD,GAAJ,EAAzC,GAAP;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}