{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.pointVisConfigs = exports.iconOptionalColumns = exports.iconRequiredColumns = exports.iconAccessor = exports.iconPosAccessor = exports.SVG_ICON_URL = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _window = _interopRequireDefault(require(\"global/window\"));\nvar _extensions = require(\"@deck.gl/extensions\");\nvar _constants = _interopRequireDefault(require(\"@luma.gl/constants\"));\nvar _deckglLayers = require(\"@kepler.gl/deckgl-layers\");\nvar _iconLayerIcon = _interopRequireDefault(require(\"./icon-layer-icon\"));\nvar _constants2 = require(\"@kepler.gl/constants\");\nvar _iconInfoModal = _interopRequireDefault(require(\"./icon-info-modal\"));\nvar _baseLayer = _interopRequireDefault(require(\"../base-layer\"));\nvar _layerUtils = require(\"../layer-utils\");\nvar _layerTextLabel = require(\"../layer-text-label\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar brushingExtension = new _extensions.BrushingExtension();\nvar SVG_ICON_URL = \"\".concat(_constants2.CLOUDFRONT, \"/icons/svg-icons.json\");\nexports.SVG_ICON_URL = SVG_ICON_URL;\nvar iconPosAccessor = function iconPosAccessor(_ref) {\n  var lat = _ref.lat,\n    lng = _ref.lng,\n    altitude = _ref.altitude;\n  return function (dc) {\n    return function (d) {\n      return [dc.valueAt(d.index, lng.fieldIdx), dc.valueAt(d.index, lat.fieldIdx), (altitude === null || altitude === void 0 ? void 0 : altitude.fieldIdx) > -1 ? dc.valueAt(d.index, altitude.fieldIdx) : 0];\n    };\n  };\n};\nexports.iconPosAccessor = iconPosAccessor;\nvar iconAccessor = function iconAccessor(_ref2) {\n  var icon = _ref2.icon;\n  return function (dc) {\n    return function (d) {\n      return dc.valueAt(d.index, icon.fieldIdx);\n    };\n  };\n};\nexports.iconAccessor = iconAccessor;\nvar iconRequiredColumns = ['lat', 'lng', 'icon'];\nexports.iconRequiredColumns = iconRequiredColumns;\nvar iconOptionalColumns = ['altitude'];\nexports.iconOptionalColumns = iconOptionalColumns;\nvar pointVisConfigs = {\n  radius: 'radius',\n  fixedRadius: 'fixedRadius',\n  opacity: 'opacity',\n  colorRange: 'colorRange',\n  radiusRange: 'radiusRange'\n};\nexports.pointVisConfigs = pointVisConfigs;\nfunction flatterIconPositions(icon) {\n  // had to flip y, since @luma modal has changed\n  return icon.mesh.cells.reduce(function (prev, cell) {\n    cell.forEach(function (p) {\n      prev.push.apply(prev, [icon.mesh.positions[p][0], -icon.mesh.positions[p][1], icon.mesh.positions[p][2]]);\n    });\n    return prev;\n  }, []);\n}\nvar IconLayer = /*#__PURE__*/function (_Layer) {\n  (0, _inherits2[\"default\"])(IconLayer, _Layer);\n  var _super = _createSuper(IconLayer);\n  function IconLayer() {\n    var _this;\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0, _classCallCheck2[\"default\"])(this, IconLayer);\n    _this = _super.call(this, props);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"getIconAccessor\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_layerInfoModal\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"iconGeometry\", void 0);\n    _this.registerVisConfig(pointVisConfigs);\n    _this.getPositionAccessor = function (dataContainer) {\n      return iconPosAccessor(_this.config.columns)(dataContainer);\n    };\n    _this.getIconAccessor = function (dataContainer) {\n      return iconAccessor(_this.config.columns)(dataContainer);\n    }; // prepare layer info modal\n\n    _this._layerInfoModal = (0, _iconInfoModal[\"default\"])();\n    _this.iconGeometry = props.iconGeometry || null;\n    _this.getSvgIcons();\n    return _this;\n  }\n  (0, _createClass2[\"default\"])(IconLayer, [{\n    key: \"type\",\n    get: function get() {\n      return 'icon';\n    }\n  }, {\n    key: \"requiredLayerColumns\",\n    get: function get() {\n      return iconRequiredColumns;\n    }\n  }, {\n    key: \"optionalColumns\",\n    get: function get() {\n      return iconOptionalColumns;\n    }\n  }, {\n    key: \"columnPairs\",\n    get: function get() {\n      return this.defaultPointColumnPairs;\n    }\n  }, {\n    key: \"layerIcon\",\n    get: function get() {\n      return _iconLayerIcon[\"default\"];\n    }\n  }, {\n    key: \"visualChannels\",\n    get: function get() {\n      return {\n        color: _objectSpread(_objectSpread({}, (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(IconLayer.prototype), \"visualChannels\", this).color), {}, {\n          accessor: 'getFillColor',\n          defaultValue: function defaultValue(config) {\n            return config.color;\n          }\n        }),\n        size: _objectSpread(_objectSpread({}, (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(IconLayer.prototype), \"visualChannels\", this).size), {}, {\n          property: 'radius',\n          range: 'radiusRange',\n          channelScaleType: 'radius',\n          accessor: 'getRadius',\n          defaultValue: 1\n        })\n      };\n    }\n  }, {\n    key: \"layerInfoModal\",\n    get: function get() {\n      return {\n        id: 'iconInfo',\n        template: this._layerInfoModal,\n        modalProps: {\n          title: 'modal.iconInfo.title'\n        }\n      };\n    }\n  }, {\n    key: \"getSvgIcons\",\n    value: function getSvgIcons() {\n      var _this2 = this;\n      var fetchConfig = {\n        method: 'GET',\n        mode: 'cors',\n        cache: 'no-cache'\n      };\n      if (_window[\"default\"].fetch) {\n        _window[\"default\"].fetch(SVG_ICON_URL, fetchConfig).then(function (response) {\n          return response.json();\n        }).then(function () {\n          var parsed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var _parsed$svgIcons = parsed.svgIcons,\n            svgIcons = _parsed$svgIcons === void 0 ? [] : _parsed$svgIcons;\n          _this2.iconGeometry = svgIcons.reduce(function (accu, curr) {\n            return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, curr.id, flatterIconPositions(curr)));\n          }, {});\n          _this2._layerInfoModal = (0, _iconInfoModal[\"default\"])(svgIcons);\n        });\n      }\n    }\n  }, {\n    key: \"calculateDataAttribute\",\n    value: function calculateDataAttribute(_ref3, getPosition) {\n      var dataContainer = _ref3.dataContainer,\n        filteredIndex = _ref3.filteredIndex;\n      var getIcon = this.getIconAccessor(dataContainer);\n      var data = [];\n      for (var i = 0; i < filteredIndex.length; i++) {\n        var index = filteredIndex[i];\n        var rowIndex = {\n          index: index\n        };\n        var pos = getPosition(rowIndex);\n        var icon = getIcon(rowIndex); // if doesn't have point lat or lng, do not add the point\n        // deck.gl can't handle position = null\n\n        if (pos.every(Number.isFinite) && typeof icon === 'string') {\n          data.push({\n            index: index,\n            icon: icon\n          });\n        }\n      }\n      return data;\n    }\n  }, {\n    key: \"formatLayerData\",\n    value: function formatLayerData(datasets, oldLayerData) {\n      if (this.config.dataId === null) {\n        return {};\n      }\n      var textLabel = this.config.textLabel;\n      var _datasets$this$config = datasets[this.config.dataId],\n        gpuFilter = _datasets$this$config.gpuFilter,\n        dataContainer = _datasets$this$config.dataContainer;\n      var getPosition = this.getPositionAccessor(dataContainer);\n      var _this$updateData = this.updateData(datasets, oldLayerData),\n        data = _this$updateData.data,\n        triggerChanged = _this$updateData.triggerChanged; // get all distinct characters in the text labels\n\n      var textLabels = (0, _layerTextLabel.formatTextLabelData)({\n        textLabel: textLabel,\n        triggerChanged: triggerChanged,\n        oldLayerData: oldLayerData,\n        data: data,\n        dataContainer: dataContainer\n      });\n      var accessors = this.getAttributeAccessors({\n        dataContainer: dataContainer\n      });\n      return _objectSpread({\n        data: data,\n        getPosition: getPosition,\n        getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(),\n        textLabels: textLabels\n      }, accessors);\n    }\n  }, {\n    key: \"updateLayerMeta\",\n    value: function updateLayerMeta(dataContainer, getPosition) {\n      var bounds = this.getPointsBounds(dataContainer, getPosition);\n      this.updateMeta({\n        bounds: bounds\n      });\n    }\n  }, {\n    key: \"renderLayer\",\n    value: function renderLayer(opts) {\n      var _this$config$columns$,\n        _this3 = this;\n      var data = opts.data,\n        gpuFilter = opts.gpuFilter,\n        objectHovered = opts.objectHovered,\n        mapState = opts.mapState,\n        interactionConfig = opts.interactionConfig;\n      var radiusScale = this.getRadiusScaleByZoom(mapState);\n      var layerProps = _objectSpread({\n        radiusScale: radiusScale\n      }, this.config.visConfig.fixedRadius ? {} : {\n        radiusMaxPixels: 500\n      });\n      var updateTriggers = _objectSpread({\n        getPosition: this.config.columns,\n        getFilterValue: gpuFilter.filterValueUpdateTriggers\n      }, this.getVisualChannelUpdateTriggers());\n      var defaultLayerProps = this.getDefaultDeckLayerProps(opts);\n      var brushingProps = this.getBrushingExtensionProps(interactionConfig);\n      var getPixelOffset = (0, _layerTextLabel.getTextOffsetByRadius)(radiusScale, data.getRadius, mapState);\n      var extensions = [].concat((0, _toConsumableArray2[\"default\"])(defaultLayerProps.extensions), [brushingExtension]); // shared Props between layer and label layer\n\n      var sharedProps = _objectSpread({\n        getFilterValue: data.getFilterValue,\n        extensions: extensions,\n        filterRange: defaultLayerProps.filterRange\n      }, brushingProps);\n      var labelLayers = (0, _toConsumableArray2[\"default\"])(this.renderTextLabelLayer({\n        getPosition: data.getPosition,\n        sharedProps: sharedProps,\n        getPixelOffset: getPixelOffset,\n        updateTriggers: updateTriggers\n      }, opts));\n      var hoveredObject = this.hasHoveredObject(objectHovered);\n      var parameters = {\n        // icons will be flat on the map when the altitude column is not used\n        depthTest: ((_this$config$columns$ = this.config.columns.altitude) === null || _this$config$columns$ === void 0 ? void 0 : _this$config$columns$.fieldIdx) > -1,\n        cullFace: _constants[\"default\"].FRONT\n      };\n      return !this.iconGeometry ? [] : [new _deckglLayers.SvgIconLayer(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaultLayerProps), brushingProps), layerProps), data), {}, {\n        parameters: parameters,\n        getIconGeometry: function getIconGeometry(id) {\n          var _this3$iconGeometry;\n          return (_this3$iconGeometry = _this3.iconGeometry) === null || _this3$iconGeometry === void 0 ? void 0 : _this3$iconGeometry[id];\n        },\n        // update triggers\n        updateTriggers: updateTriggers,\n        extensions: extensions\n      }))].concat((0, _toConsumableArray2[\"default\"])(hoveredObject ? [\n      // @ts-expect-error SvgIconLayerProps needs getIcon Field\n      new _deckglLayers.SvgIconLayer(_objectSpread(_objectSpread(_objectSpread({}, this.getDefaultHoverLayerProps()), layerProps), {}, {\n        data: [hoveredObject],\n        parameters: parameters,\n        getPosition: data.getPosition,\n        getRadius: data.getRadius,\n        getFillColor: this.config.highlightColor,\n        getIconGeometry: function getIconGeometry(id) {\n          var _this3$iconGeometry2;\n          return (_this3$iconGeometry2 = _this3.iconGeometry) === null || _this3$iconGeometry2 === void 0 ? void 0 : _this3$iconGeometry2[id];\n        }\n      }))] : []), (0, _toConsumableArray2[\"default\"])(labelLayers));\n    }\n  }], [{\n    key: \"findDefaultLayerProps\",\n    value: function findDefaultLayerProps(_ref4) {\n      var _ref4$fieldPairs = _ref4.fieldPairs,\n        fieldPairs = _ref4$fieldPairs === void 0 ? [] : _ref4$fieldPairs,\n        _ref4$fields = _ref4.fields,\n        fields = _ref4$fields === void 0 ? [] : _ref4$fields;\n      var notFound = {\n        props: []\n      };\n      if (!fieldPairs.length || !fields.length) {\n        return notFound;\n      }\n      var iconFields = fields.filter(function (_ref5) {\n        var name = _ref5.name;\n        return name.replace(/[_,.]+/g, ' ').trim().split(' ').some(function (seg) {\n          return _constants2.ICON_FIELDS.icon.some(function (t) {\n            return t.includes(seg);\n          });\n        });\n      });\n      if (!iconFields.length) {\n        return notFound;\n      } // create icon layers for first point pair\n\n      var ptPair = fieldPairs[0];\n      var columns = (0, _layerUtils.assignPointPairToLayerColumn)(ptPair, true);\n      var props = iconFields.map(function (iconField) {\n        return {\n          label: iconField.name.replace(/[_,.]+/g, ' ').trim(),\n          columns: _objectSpread(_objectSpread({}, columns), {}, {\n            icon: {\n              value: iconField.name,\n              fieldIdx: iconField.fieldIdx\n            }\n          }),\n          isVisible: true\n        };\n      });\n      return {\n        props: props\n      };\n    }\n  }]);\n  return IconLayer;\n}(_baseLayer[\"default\"]);\nexports[\"default\"] = IconLayer;","map":{"version":3,"names":["exports","pointVisConfigs","iconOptionalColumns","iconRequiredColumns","iconAccessor","iconPosAccessor","SVG_ICON_URL","_toConsumableArray2","_interopRequireDefault","require","_classCallCheck2","_createClass2","_assertThisInitialized2","_get2","_inherits2","_possibleConstructorReturn2","_getPrototypeOf2","_defineProperty2","_iconLayerIcon","_iconInfoModal","_baseLayer","_layerUtils","_layerTextLabel","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_isNativeReflectConstruct","icon","Reflect","construct","sham","Proxy","Boolean","prototype","valueOf","call","e","brushingExtension","_extensions","BrushingExtension","concat","_constants2","CLOUDFRONT","_ref","altitude","d","_ref2","dc","valueAt","index","fieldIdx","colorRange","radiusRange","flatterIconPositions","mesh","cells","reduce","prev","cell","forEach","p","IconLayer","_Layer","_super","_createSuper","_this","getPositionAccessor","dataContainer","config","columns","getIconAccessor","_layerInfoModal","iconGeometry","props","get","key","defaultPointColumnPairs","color","_objectSpread","accessor","defaultValue","channelScaleType","id","template","modalProps","title","value","getSvgIcons","_this2","cache","_window","fetch","response","json","then","parsed","arguments","length","undefined","_parsed$svgIcons","svgIcons","accu","curr","calculateDataAttribute","_ref3","getPosition","getIcon","data","filteredIndex","i","rowIndex","pos","every","Number","isFinite","formatLayerData","datasets","oldLayerData","dataId","textLabel","_datasets$this$config","gpuFilter","_this$updateData","updateData","textLabels","formatTextLabelData","triggerChanged","getAttributeAccessors","getFilterValue","filterValueAccessor","accessors","updateLayerMeta","bounds","getPointsBounds","updateMeta","renderLayer","opts","_this3","mapState","interactionConfig","radiusScale","getRadiusScaleByZoom","layerProps","visConfig","fixedRadius","radiusMaxPixels","updateTriggers","filterValueUpdateTriggers","getVisualChannelUpdateTriggers","defaultLayerProps","getDefaultDeckLayerProps","brushingProps","getBrushingExtensionProps","getPixelOffset","getTextOffsetByRadius","getRadius","extensions","sharedProps","filterRange","labelLayers","renderTextLabelLayer","hoveredObject","hasHoveredObject","objectHovered","parameters","depthTest","_this$config$columns$","cullFace","_constants","FRONT","_deckglLayers","SvgIconLayer","getIconGeometry","_this3$iconGeometry","getDefaultHoverLayerProps","getFillColor","highlightColor","_this3$iconGeometry2","findDefaultLayerProps","_ref4","fieldPairs","_ref4$fieldPairs","_ref4$fields","fields","notFound","iconFields","_ref5","name","replace","trim","split","some","seg","ICON_FIELDS","t","includes","ptPair"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/layers/src/icon-layer/icon-layer.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport window from 'global/window';\nimport {BrushingExtension} from '@deck.gl/extensions';\nimport GL from '@luma.gl/constants';\n\nimport {SvgIconLayer} from '@kepler.gl/deckgl-layers';\nimport IconLayerIcon from './icon-layer-icon';\nimport {ICON_FIELDS, CLOUDFRONT, ColorRange} from '@kepler.gl/constants';\nimport IconInfoModalFactory from './icon-info-modal';\nimport Layer, {LayerBaseConfig, LayerColumn} from '../base-layer';\nimport {assignPointPairToLayerColumn} from '../layer-utils';\nimport {getTextOffsetByRadius, formatTextLabelData} from '../layer-text-label';\nimport {default as KeplerTable} from '@kepler.gl/table';\nimport {DataContainerInterface} from '@kepler.gl/utils';\nimport {\n  VisConfigBoolean,\n  VisConfigColorRange,\n  VisConfigNumber,\n  VisConfigRange,\n  Merge\n} from '@kepler.gl/types';\n\nexport type IconLayerColumnsConfig = {\n  lat: LayerColumn;\n  lng: LayerColumn;\n  altitude: LayerColumn;\n  icon: LayerColumn;\n};\n\ntype IconGeometry = {} | null;\n\nexport type IconLayerVisConfigSettings = {\n  radius: VisConfigNumber;\n  fixedRadius: VisConfigBoolean;\n  opacity: VisConfigNumber;\n  colorRange: VisConfigColorRange;\n  radiusRange: VisConfigRange;\n};\n\nexport type IconLayerVisConfig = {\n  radius: number;\n  fixedRadius: boolean;\n  opacity: number;\n  colorRange: ColorRange;\n  radiusRange: [number, number];\n};\n\nexport type IconLayerConfig = Merge<\n  LayerBaseConfig,\n  {columns: IconLayerColumnsConfig; visConfig: IconLayerVisConfig}\n>;\n\nexport type IconLayerData = {index: number; icon: string};\n\nconst brushingExtension = new BrushingExtension();\n\nexport const SVG_ICON_URL = `${CLOUDFRONT}/icons/svg-icons.json`;\n\nexport const iconPosAccessor = ({lat, lng, altitude}: IconLayerColumnsConfig) => (\n  dc: DataContainerInterface\n) => d => [\n  dc.valueAt(d.index, lng.fieldIdx),\n  dc.valueAt(d.index, lat.fieldIdx),\n  altitude?.fieldIdx > -1 ? dc.valueAt(d.index, altitude.fieldIdx) : 0\n];\n\nexport const iconAccessor = ({icon}: IconLayerColumnsConfig) => (dc: DataContainerInterface) => d =>\n  dc.valueAt(d.index, icon.fieldIdx);\n\nexport const iconRequiredColumns: ['lat', 'lng', 'icon'] = ['lat', 'lng', 'icon'];\nexport const iconOptionalColumns: ['altitude'] = ['altitude'];\n\nexport const pointVisConfigs: {\n  radius: 'radius';\n  fixedRadius: 'fixedRadius';\n  opacity: 'opacity';\n  colorRange: 'colorRange';\n  radiusRange: 'radiusRange';\n} = {\n  radius: 'radius',\n  fixedRadius: 'fixedRadius',\n  opacity: 'opacity',\n  colorRange: 'colorRange',\n  radiusRange: 'radiusRange'\n};\n\nfunction flatterIconPositions(icon) {\n  // had to flip y, since @luma modal has changed\n  return icon.mesh.cells.reduce((prev, cell) => {\n    cell.forEach(p => {\n      prev.push(\n        ...[icon.mesh.positions[p][0], -icon.mesh.positions[p][1], icon.mesh.positions[p][2]]\n      );\n    });\n    return prev;\n  }, []);\n}\n\nexport default class IconLayer extends Layer {\n  getIconAccessor: (dataContainer: DataContainerInterface) => (d: any) => any;\n  _layerInfoModal: () => JSX.Element;\n  iconGeometry: IconGeometry;\n\n  declare visConfigSettings: IconLayerVisConfigSettings;\n  declare config: IconLayerConfig;\n\n  constructor(\n    props: {\n      id?: string;\n      iconGeometry?: IconGeometry;\n    } & Partial<LayerBaseConfig> = {}\n  ) {\n    super(props);\n\n    this.registerVisConfig(pointVisConfigs);\n    this.getPositionAccessor = (dataContainer: DataContainerInterface) =>\n      iconPosAccessor(this.config.columns)(dataContainer);\n    this.getIconAccessor = dataContainer => iconAccessor(this.config.columns)(dataContainer);\n\n    // prepare layer info modal\n    this._layerInfoModal = IconInfoModalFactory();\n    this.iconGeometry = props.iconGeometry || null;\n    this.getSvgIcons();\n  }\n\n  get type(): 'icon' {\n    return 'icon';\n  }\n\n  get requiredLayerColumns() {\n    return iconRequiredColumns;\n  }\n\n  get optionalColumns() {\n    return iconOptionalColumns;\n  }\n\n  get columnPairs() {\n    return this.defaultPointColumnPairs;\n  }\n\n  get layerIcon() {\n    return IconLayerIcon;\n  }\n\n  get visualChannels() {\n    return {\n      color: {\n        ...super.visualChannels.color,\n        accessor: 'getFillColor',\n        defaultValue: config => config.color\n      },\n      size: {\n        ...super.visualChannels.size,\n        property: 'radius',\n        range: 'radiusRange',\n        channelScaleType: 'radius',\n        accessor: 'getRadius',\n        defaultValue: 1\n      }\n    };\n  }\n\n  get layerInfoModal() {\n    return {\n      id: 'iconInfo',\n      template: this._layerInfoModal,\n      modalProps: {\n        title: 'modal.iconInfo.title'\n      }\n    };\n  }\n\n  getSvgIcons() {\n    const fetchConfig = {\n      method: 'GET',\n      mode: 'cors',\n      cache: 'no-cache'\n    };\n\n    if (window.fetch) {\n      window\n        .fetch(SVG_ICON_URL, fetchConfig)\n        .then(response => response.json())\n        .then((parsed: {svgIcons?: any[]} = {}) => {\n          const {svgIcons = []} = parsed;\n          this.iconGeometry = svgIcons.reduce(\n            (accu, curr) => ({\n              ...accu,\n              [curr.id]: flatterIconPositions(curr)\n            }),\n            {}\n          );\n\n          this._layerInfoModal = IconInfoModalFactory(svgIcons);\n        });\n    }\n  }\n\n  static findDefaultLayerProps({fieldPairs = [], fields = []}: KeplerTable) {\n    const notFound = {props: []};\n    if (!fieldPairs.length || !fields.length) {\n      return notFound;\n    }\n\n    const iconFields = fields.filter(({name}) =>\n      name\n        .replace(/[_,.]+/g, ' ')\n        .trim()\n        .split(' ')\n        .some(seg => ICON_FIELDS.icon.some(t => t.includes(seg)))\n    );\n\n    if (!iconFields.length) {\n      return notFound;\n    }\n\n    // create icon layers for first point pair\n    const ptPair = fieldPairs[0];\n    const columns = assignPointPairToLayerColumn(ptPair, true);\n\n    const props = iconFields.map(iconField => ({\n      label: iconField.name.replace(/[_,.]+/g, ' ').trim(),\n      columns: {\n        ...columns,\n        icon: {\n          value: iconField.name,\n          fieldIdx: iconField.fieldIdx\n        }\n      },\n      isVisible: true\n    }));\n\n    return {props};\n  }\n\n  calculateDataAttribute({dataContainer, filteredIndex}: KeplerTable, getPosition) {\n    const getIcon = this.getIconAccessor(dataContainer);\n    const data: IconLayerData[] = [];\n\n    for (let i = 0; i < filteredIndex.length; i++) {\n      const index = filteredIndex[i];\n      const rowIndex = {index};\n      const pos = getPosition(rowIndex);\n      const icon = getIcon(rowIndex);\n\n      // if doesn't have point lat or lng, do not add the point\n      // deck.gl can't handle position = null\n      if (pos.every(Number.isFinite) && typeof icon === 'string') {\n        data.push({\n          index,\n          icon\n        });\n      }\n    }\n\n    return data;\n  }\n\n  formatLayerData(datasets, oldLayerData) {\n    if (this.config.dataId === null) {\n      return {};\n    }\n    const {textLabel} = this.config;\n    const {gpuFilter, dataContainer} = datasets[this.config.dataId];\n\n    const getPosition = this.getPositionAccessor(dataContainer);\n\n    const {data, triggerChanged} = this.updateData(datasets, oldLayerData);\n\n    // get all distinct characters in the text labels\n    const textLabels = formatTextLabelData({\n      textLabel,\n      triggerChanged,\n      oldLayerData,\n      data,\n      dataContainer\n    });\n\n    const accessors = this.getAttributeAccessors({dataContainer});\n\n    return {\n      data,\n      getPosition,\n      getFilterValue: gpuFilter.filterValueAccessor(dataContainer)(),\n      textLabels,\n      ...accessors\n    };\n  }\n\n  updateLayerMeta(dataContainer, getPosition) {\n    const bounds = this.getPointsBounds(dataContainer, getPosition);\n    this.updateMeta({bounds});\n  }\n\n  renderLayer(opts) {\n    const {data, gpuFilter, objectHovered, mapState, interactionConfig} = opts;\n\n    const radiusScale = this.getRadiusScaleByZoom(mapState);\n\n    const layerProps = {\n      radiusScale,\n      ...(this.config.visConfig.fixedRadius ? {} : {radiusMaxPixels: 500})\n    };\n\n    const updateTriggers = {\n      getPosition: this.config.columns,\n      getFilterValue: gpuFilter.filterValueUpdateTriggers,\n      ...this.getVisualChannelUpdateTriggers()\n    };\n\n    const defaultLayerProps = this.getDefaultDeckLayerProps(opts);\n    const brushingProps = this.getBrushingExtensionProps(interactionConfig);\n    const getPixelOffset = getTextOffsetByRadius(radiusScale, data.getRadius, mapState);\n    const extensions = [...defaultLayerProps.extensions, brushingExtension];\n\n    // shared Props between layer and label layer\n    const sharedProps = {\n      getFilterValue: data.getFilterValue,\n      extensions,\n      filterRange: defaultLayerProps.filterRange,\n      ...brushingProps\n    };\n\n    const labelLayers = [\n      ...this.renderTextLabelLayer(\n        {\n          getPosition: data.getPosition,\n          sharedProps,\n          getPixelOffset,\n          updateTriggers\n        },\n        opts\n      )\n    ];\n    const hoveredObject = this.hasHoveredObject(objectHovered);\n\n    const parameters = {\n      // icons will be flat on the map when the altitude column is not used\n      depthTest: this.config.columns.altitude?.fieldIdx > -1,\n      cullFace: GL.FRONT\n    };\n\n    return !this.iconGeometry\n      ? []\n      : [\n          new SvgIconLayer({\n            ...defaultLayerProps,\n            ...brushingProps,\n            ...layerProps,\n            ...data,\n            parameters,\n            getIconGeometry: id => this.iconGeometry?.[id],\n\n            // update triggers\n            updateTriggers,\n            extensions\n          }),\n\n          ...(hoveredObject\n            ? [\n                // @ts-expect-error SvgIconLayerProps needs getIcon Field\n                new SvgIconLayer({\n                  ...this.getDefaultHoverLayerProps(),\n                  ...layerProps,\n                  data: [hoveredObject],\n                  parameters,\n                  getPosition: data.getPosition,\n                  getRadius: data.getRadius,\n                  getFillColor: this.config.highlightColor,\n                  getIconGeometry: id => this.iconGeometry?.[id]\n                })\n              ]\n            : []),\n\n          // text label layer\n          ...labelLayers\n        ];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}