{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unique = unique;\nexports.getLatLngBounds = getLatLngBounds;\nexports.clamp = clamp;\nexports.getSampleData = getSampleData;\nexports.timeToUnixMilli = timeToUnixMilli;\nexports.notNullorUndefined = notNullorUndefined;\nexports.isNumber = isNumber;\nexports.isPlainObject = isPlainObject;\nexports.hasOwnProperty = hasOwnProperty;\nexports.numberSort = numberSort;\nexports.getSortingFunction = getSortingFunction;\nexports.preciseRound = preciseRound;\nexports.getRoundingDecimalFromStep = getRoundingDecimalFromStep;\nexports.snapToMarks = snapToMarks;\nexports.normalizeSliderValue = normalizeSliderValue;\nexports.roundValToStep = roundValToStep;\nexports.getFormatter = getFormatter;\nexports.applyDefaultFormat = applyDefaultFormat;\nexports.getBooleanFormatter = getBooleanFormatter;\nexports.applyCustomFormat = applyCustomFormat;\nexports.datetimeFormatter = datetimeFormatter;\nexports.arrayMove = exports.parseFieldValue = exports.FIELD_DISPLAY_FORMAT = exports.defaultFormatter = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _assert = _interopRequireDefault(require(\"assert\"));\nvar _constants = require(\"@kepler.gl/constants\");\nvar _d3Format = require(\"d3-format\");\nvar _d3Array = require(\"d3-array\");\nvar _momentTimezone = _interopRequireDefault(require(\"moment-timezone\"));\nvar _FIELD_DISPLAY_FORMAT;\n\n/**\n * simple getting unique values of an array\n *\n * @param values\n * @returns unique values\n */\nfunction unique(values) {\n  var results = [];\n  var uniqueSet = new Set(values);\n  uniqueSet.forEach(function (v) {\n    if (notNullorUndefined(v)) {\n      results.push(v);\n    }\n  });\n  return results;\n}\nfunction getLatLngBounds(points, idx, limit) {\n  var lats = points.map(function (d) {\n    return Number(Array.isArray(d)) && d[idx];\n  }).filter(Number.isFinite).sort(numberSort);\n  if (!lats.length) {\n    return null;\n  } // clamp to limit\n\n  return [Math.max(lats[0], limit[0]), Math.min(lats[lats.length - 1], limit[1])];\n}\nfunction clamp(_ref) {\n  var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n    min = _ref2[0],\n    max = _ref2[1];\n  var val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return val <= min ? min : val >= max ? max : val;\n}\nfunction getSampleData(data) {\n  var sampleSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  var getValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (d) {\n    return d;\n  };\n  var sampleStep = Math.max(Math.floor(data.length / sampleSize), 1);\n  var output = [];\n  for (var i = 0; i < data.length; i += sampleStep) {\n    output.push(getValue(data[i]));\n  }\n  return output;\n}\n/**\n * Convert different time format to unix milliseconds\n */\n\nfunction timeToUnixMilli(value, format) {\n  if (notNullorUndefined(value)) {\n    if (typeof value === 'string') {\n      return _momentTimezone[\"default\"].utc(value, format).valueOf();\n    }\n    if (typeof value === 'number') {\n      return format === 'x' ? value * 1000 : value;\n    }\n    if (value instanceof Date) {\n      return value.valueOf();\n    }\n  }\n  return null;\n}\n/**\n * whether null or undefined\n */\n\nfunction notNullorUndefined(d) {\n  return d !== undefined && d !== null;\n}\n/**\n * Whether d is a number, this filtered out NaN as well\n */\n\nfunction isNumber(d) {\n  return Number.isFinite(d);\n}\n/**\n * whether is an object\n * @returns {boolean} - yes or no\n */\n\nfunction isPlainObject(obj) {\n  return obj === Object(obj) && typeof obj !== 'function' && !Array.isArray(obj);\n}\n/**\n * whether object has property\n * @param {string} prop\n * @returns {boolean} - yes or no\n */\n\nfunction hasOwnProperty(obj, prop) {\n  return obj.hasOwnProperty(prop);\n}\nfunction numberSort(a, b) {\n  return a - b;\n}\nfunction getSortingFunction(fieldType) {\n  switch (fieldType) {\n    case _constants.ALL_FIELD_TYPES.real:\n    case _constants.ALL_FIELD_TYPES.integer:\n    case _constants.ALL_FIELD_TYPES.timestamp:\n      return numberSort;\n    default:\n      return undefined;\n  }\n}\n/**\n * round number with exact number of decimals\n * return as a string\n */\n\nfunction preciseRound(num, decimals) {\n  var t = Math.pow(10, decimals);\n  return (Math.round(num * t + (decimals > 0 ? 1 : 0) * (Math.sign(num) * (10 / Math.pow(100, decimals)))) / t).toFixed(decimals);\n}\n/**\n * get number of decimals to round to for slider from step\n * @param step\n * @returns- number of decimal\n */\n\nfunction getRoundingDecimalFromStep(step) {\n  if (isNaN(step)) {\n    (0, _assert[\"default\"])('step is not a number');\n    (0, _assert[\"default\"])(step);\n  }\n  var splitZero = step.toString().split('.');\n  if (splitZero.length === 1) {\n    return 0;\n  }\n  return splitZero[1].length;\n}\n/**\n * Use in slider, given a number and an array of numbers, return the nears number from the array\n * @param value\n * @param marks\n */\n\nfunction snapToMarks(value, marks) {\n  // always use bin x0\n  var i = (0, _d3Array.bisectLeft)(marks, value);\n  if (i === 0) {\n    return marks[i];\n  } else if (i === marks.length) {\n    return marks[i - 1];\n  }\n  var idx = marks[i] - value < value - marks[i - 1] ? i : i - 1;\n  return marks[idx];\n}\n/**\n * If marks is provided, snap to marks, if not normalize to step\n * @param val\n * @param minValue\n * @param step\n * @param marks\n */\n\nfunction normalizeSliderValue(val, minValue, step, marks) {\n  if (marks && marks.length) {\n    return snapToMarks(val, marks);\n  }\n  return roundValToStep(minValue, step, val);\n}\n/**\n * round the value to step for the slider\n * @param minValue\n * @param step\n * @param val\n * @returns - rounded number\n */\n\nfunction roundValToStep(minValue, step, val) {\n  if (!isNumber(step) || !isNumber(minValue)) {\n    return val;\n  }\n  var decimal = getRoundingDecimalFromStep(step);\n  var steps = Math.floor((val - minValue) / step);\n  var remain = val - (steps * step + minValue); // has to round because javascript turns 0.1 into 0.9999999999999987\n\n  remain = Number(preciseRound(remain, 8));\n  var closest;\n  if (remain === 0) {\n    closest = val;\n  } else if (remain < step / 2) {\n    closest = steps * step + minValue;\n  } else {\n    closest = (steps + 1) * step + minValue;\n  } // precise round return a string rounded to the defined decimal\n\n  var rounded = preciseRound(closest, decimal);\n  return Number(rounded);\n}\n/**\n * Get the value format based on field and format options\n * Used in render tooltip value\n */\n\nvar defaultFormatter = function defaultFormatter(v) {\n  return notNullorUndefined(v) ? String(v) : '';\n};\nexports.defaultFormatter = defaultFormatter;\nvar FIELD_DISPLAY_FORMAT = (_FIELD_DISPLAY_FORMAT = {}, (0, _defineProperty2[\"default\"])(_FIELD_DISPLAY_FORMAT, _constants.ALL_FIELD_TYPES.string, defaultFormatter), (0, _defineProperty2[\"default\"])(_FIELD_DISPLAY_FORMAT, _constants.ALL_FIELD_TYPES.timestamp, defaultFormatter), (0, _defineProperty2[\"default\"])(_FIELD_DISPLAY_FORMAT, _constants.ALL_FIELD_TYPES.integer, defaultFormatter), (0, _defineProperty2[\"default\"])(_FIELD_DISPLAY_FORMAT, _constants.ALL_FIELD_TYPES.real, defaultFormatter), (0, _defineProperty2[\"default\"])(_FIELD_DISPLAY_FORMAT, _constants.ALL_FIELD_TYPES[\"boolean\"], defaultFormatter), (0, _defineProperty2[\"default\"])(_FIELD_DISPLAY_FORMAT, _constants.ALL_FIELD_TYPES.date, defaultFormatter), (0, _defineProperty2[\"default\"])(_FIELD_DISPLAY_FORMAT, _constants.ALL_FIELD_TYPES.geojson, function (d) {\n  return typeof d === 'string' ? d : isPlainObject(d) ? JSON.stringify(d) : Array.isArray(d) ? \"[\".concat(String(d), \"]\") : '';\n}), _FIELD_DISPLAY_FORMAT);\n/**\n * Parse field value and type and return a string representation\n */\n\nexports.FIELD_DISPLAY_FORMAT = FIELD_DISPLAY_FORMAT;\nvar parseFieldValue = function parseFieldValue(value, type) {\n  if (!notNullorUndefined(value)) {\n    return '';\n  }\n  return FIELD_DISPLAY_FORMAT[type] ? FIELD_DISPLAY_FORMAT[type](value) : String(value);\n};\nexports.parseFieldValue = parseFieldValue;\nvar arrayMoveMutate = function arrayMoveMutate(array, from, to) {\n  array.splice(to < 0 ? array.length + to : to, 0, array.splice(from, 1)[0]);\n};\n/**\n *\n * @param array\n * @param from\n * @param to\n */\n\nvar arrayMove = function arrayMove(array, from, to) {\n  array = array.slice();\n  arrayMoveMutate(array, from, to);\n  return array;\n};\n/**\n * Get the value format based on field and format options\n * Used in render tooltip value\n * @param format\n * @param field\n */\n\nexports.arrayMove = arrayMove;\nfunction getFormatter(format, field) {\n  if (!format) {\n    return defaultFormatter;\n  }\n  var tooltipFormat = Object.values(_constants.TOOLTIP_FORMATS).find(function (f) {\n    return f[_constants.TOOLTIP_KEY] === format;\n  });\n  if (tooltipFormat) {\n    return applyDefaultFormat(tooltipFormat);\n  } else if (typeof format === 'string' && field) {\n    return applyCustomFormat(format, field);\n  }\n  return defaultFormatter;\n}\nfunction applyDefaultFormat(tooltipFormat) {\n  if (!tooltipFormat || !tooltipFormat.format) {\n    return defaultFormatter;\n  }\n  switch (tooltipFormat.type) {\n    case _constants.TOOLTIP_FORMAT_TYPES.DECIMAL:\n      return (0, _d3Format.format)(tooltipFormat.format);\n    case _constants.TOOLTIP_FORMAT_TYPES.DATE:\n    case _constants.TOOLTIP_FORMAT_TYPES.DATE_TIME:\n      return datetimeFormatter(null)(tooltipFormat.format);\n    case _constants.TOOLTIP_FORMAT_TYPES.PERCENTAGE:\n      return function (v) {\n        return \"\".concat((0, _d3Format.format)(_constants.TOOLTIP_FORMATS.DECIMAL_DECIMAL_FIXED_2.format)(v), \"%\");\n      };\n    case _constants.TOOLTIP_FORMAT_TYPES.BOOLEAN:\n      return getBooleanFormatter(tooltipFormat.format);\n    default:\n      return defaultFormatter;\n  }\n}\nfunction getBooleanFormatter(format) {\n  switch (format) {\n    case '01':\n      return function (v) {\n        return v ? '1' : '0';\n      };\n    case 'yn':\n      return function (v) {\n        return v ? 'yes' : 'no';\n      };\n    default:\n      return defaultFormatter;\n  }\n} // Allow user to specify custom tooltip format via config\n\nfunction applyCustomFormat(format, field) {\n  switch (field.type) {\n    case _constants.ALL_FIELD_TYPES.real:\n    case _constants.ALL_FIELD_TYPES.integer:\n      return (0, _d3Format.format)(format);\n    case _constants.ALL_FIELD_TYPES.date:\n    case _constants.ALL_FIELD_TYPES.timestamp:\n      return datetimeFormatter(null)(format);\n    default:\n      return function (v) {\n        return v;\n      };\n  }\n}\n/**\n * Format epoch milliseconds with a format string\n * @type timezone\n */\n\nfunction datetimeFormatter(timezone) {\n  return timezone ? function (format) {\n    return function (ts) {\n      return _momentTimezone[\"default\"].utc(ts).tz(timezone).format(format);\n    };\n  } : function (format) {\n    return function (ts) {\n      return _momentTimezone[\"default\"].utc(ts).format(format);\n    };\n  };\n}","map":{"version":3,"names":["exports","isPlainObject","numberSort","preciseRound","snapToMarks","roundValToStep","applyCustomFormat","datetimeFormatter","arrayMove","parseFieldValue","FIELD_DISPLAY_FORMAT","defaultFormatter","_defineProperty2","_interopRequireDefault","require","_slicedToArray2","_assert","_constants","_d3Format","_d3Array","_FIELD_DISPLAY_FORMAT","results","uniqueSet","Set","values","notNullorUndefined","v","push","getLatLngBounds","points","idx","limit","Number","Array","isArray","d","filter","isFinite","sort","lats","length","Math","max","min","_ref2","_ref","val","arguments","undefined","getSampleData","data","sampleSize","getValue","sampleStep","floor","output","i","value","_momentTimezone","utc","format","valueOf","Date","isNumber","obj","Object","hasOwnProperty","prop","a","b","getSortingFunction","fieldType","ALL_FIELD_TYPES","real","integer","timestamp","num","decimals","t","pow","isNaN","step","splitZero","toString","split","bisectLeft","marks","minValue","decimal","getRoundingDecimalFromStep","steps","remain","closest","string","date","geojson","JSON","stringify","concat","String","type","arrayMoveMutate","array","from","to","splice","slice","getFormatter","field","tooltipFormat","TOOLTIP_FORMATS","find","f","TOOLTIP_FORMAT_TYPES","DECIMAL","DATE","DATE_TIME","PERCENTAGE","DECIMAL_DECIMAL_FIXED_2","BOOLEAN","getBooleanFormatter"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/utils/src/data-utils.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport assert from 'assert';\nimport {\n  ALL_FIELD_TYPES,\n  TOOLTIP_FORMATS,\n  TOOLTIP_FORMAT_TYPES,\n  TOOLTIP_KEY,\n  TooltipFormat\n} from '@kepler.gl/constants';\nimport {format as d3Format} from 'd3-format';\nimport {bisectLeft} from 'd3-array';\nimport moment from 'moment-timezone';\n\nimport {Millisecond, Field} from '@kepler.gl/types';\n\nexport type FieldFormatter = (value: any) => string;\n\n/**\n * simple getting unique values of an array\n *\n * @param values\n * @returns unique values\n */\nexport function unique<T>(values: T[]) {\n  const results: T[] = [];\n  const uniqueSet = new Set(values);\n  uniqueSet.forEach(v => {\n    if (notNullorUndefined(v)) {\n      results.push(v);\n    }\n  });\n  return results;\n}\n\nexport function getLatLngBounds(\n  points: number[][],\n  idx: number,\n  limit: [number, number]\n): [number, number] | null {\n  const lats = points\n    .map(d => Number(Array.isArray(d)) && d[idx])\n    .filter(Number.isFinite)\n    .sort(numberSort);\n\n  if (!lats.length) {\n    return null;\n  }\n\n  // clamp to limit\n  return [Math.max(lats[0], limit[0]), Math.min(lats[lats.length - 1], limit[1])];\n}\n\nexport function clamp([min, max]: [number, number], val: number = 0): number {\n  return val <= min ? min : val >= max ? max : val;\n}\n\nexport function getSampleData(data, sampleSize = 500, getValue = d => d) {\n  const sampleStep = Math.max(Math.floor(data.length / sampleSize), 1);\n  const output: any[] = [];\n  for (let i = 0; i < data.length; i += sampleStep) {\n    output.push(getValue(data[i]));\n  }\n\n  return output;\n}\n\n/**\n * Convert different time format to unix milliseconds\n */\nexport function timeToUnixMilli(value: string | number | Date, format: string): Millisecond | null {\n  if (notNullorUndefined(value)) {\n    if (typeof value === 'string') {\n      return moment.utc(value, format).valueOf();\n    }\n    if (typeof value === 'number') {\n      return format === 'x' ? value * 1000 : value;\n    }\n    if (value instanceof Date) {\n      return value.valueOf();\n    }\n  }\n  return null;\n}\n\n/**\n * whether null or undefined\n */\nexport function notNullorUndefined<T extends NonNullable<any>>(d: T | null | undefined): d is T {\n  return d !== undefined && d !== null;\n}\n\n/**\n * Whether d is a number, this filtered out NaN as well\n */\nexport function isNumber(d: any): boolean {\n  return Number.isFinite(d);\n}\n\n/**\n * whether is an object\n * @returns {boolean} - yes or no\n */\nexport function isPlainObject(obj: unknown): obj is Record<string, unknown> {\n  return obj === Object(obj) && typeof obj !== 'function' && !Array.isArray(obj);\n}\n\n/**\n * whether object has property\n * @param {string} prop\n * @returns {boolean} - yes or no\n */\nexport function hasOwnProperty<X extends {}, Y extends PropertyKey>(\n  obj: X,\n  prop: Y\n): obj is X & Record<Y, unknown> {\n  return obj.hasOwnProperty(prop);\n}\n\nexport function numberSort(a: number, b: number): number {\n  return a - b;\n}\n\nexport function getSortingFunction(fieldType: string): typeof numberSort | undefined {\n  switch (fieldType) {\n    case ALL_FIELD_TYPES.real:\n    case ALL_FIELD_TYPES.integer:\n    case ALL_FIELD_TYPES.timestamp:\n      return numberSort;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * round number with exact number of decimals\n * return as a string\n */\nexport function preciseRound(num: number, decimals: number): string {\n  const t = Math.pow(10, decimals);\n  return (\n    Math.round(\n      num * t + (decimals > 0 ? 1 : 0) * (Math.sign(num) * (10 / Math.pow(100, decimals)))\n    ) / t\n  ).toFixed(decimals);\n}\n\n/**\n * get number of decimals to round to for slider from step\n * @param step\n * @returns- number of decimal\n */\nexport function getRoundingDecimalFromStep(step: number): number {\n  if (isNaN(step)) {\n    assert('step is not a number');\n    assert(step);\n  }\n\n  const splitZero = step.toString().split('.');\n  if (splitZero.length === 1) {\n    return 0;\n  }\n  return splitZero[1].length;\n}\n\n/**\n * Use in slider, given a number and an array of numbers, return the nears number from the array\n * @param value\n * @param marks\n */\nexport function snapToMarks(value: number, marks: number[]): number {\n  // always use bin x0\n  const i = bisectLeft(marks, value);\n  if (i === 0) {\n    return marks[i];\n  } else if (i === marks.length) {\n    return marks[i - 1];\n  }\n  const idx = marks[i] - value < value - marks[i - 1] ? i : i - 1;\n  return marks[idx];\n}\n\n/**\n * If marks is provided, snap to marks, if not normalize to step\n * @param val\n * @param minValue\n * @param step\n * @param marks\n */\nexport function normalizeSliderValue(\n  val: number,\n  minValue: number,\n  step: number,\n  marks?: number[]\n): number {\n  if (marks && marks.length) {\n    return snapToMarks(val, marks);\n  }\n\n  return roundValToStep(minValue, step, val);\n}\n\n/**\n * round the value to step for the slider\n * @param minValue\n * @param step\n * @param val\n * @returns - rounded number\n */\nexport function roundValToStep(minValue: number, step: number, val: number): number {\n  if (!isNumber(step) || !isNumber(minValue)) {\n    return val;\n  }\n\n  const decimal = getRoundingDecimalFromStep(step);\n  const steps = Math.floor((val - minValue) / step);\n  let remain = val - (steps * step + minValue);\n\n  // has to round because javascript turns 0.1 into 0.9999999999999987\n  remain = Number(preciseRound(remain, 8));\n\n  let closest: number;\n  if (remain === 0) {\n    closest = val;\n  } else if (remain < step / 2) {\n    closest = steps * step + minValue;\n  } else {\n    closest = (steps + 1) * step + minValue;\n  }\n\n  // precise round return a string rounded to the defined decimal\n  const rounded = preciseRound(closest, decimal);\n\n  return Number(rounded);\n}\n\n/**\n * Get the value format based on field and format options\n * Used in render tooltip value\n */\nexport const defaultFormatter: FieldFormatter = v => (notNullorUndefined(v) ? String(v) : '');\n\nexport const FIELD_DISPLAY_FORMAT: {\n  [key: string]: FieldFormatter;\n} = {\n  [ALL_FIELD_TYPES.string]: defaultFormatter,\n  [ALL_FIELD_TYPES.timestamp]: defaultFormatter,\n  [ALL_FIELD_TYPES.integer]: defaultFormatter,\n  [ALL_FIELD_TYPES.real]: defaultFormatter,\n  [ALL_FIELD_TYPES.boolean]: defaultFormatter,\n  [ALL_FIELD_TYPES.date]: defaultFormatter,\n  [ALL_FIELD_TYPES.geojson]: d =>\n    typeof d === 'string'\n      ? d\n      : isPlainObject(d)\n      ? JSON.stringify(d)\n      : Array.isArray(d)\n      ? `[${String(d)}]`\n      : ''\n};\n\n/**\n * Parse field value and type and return a string representation\n */\nexport const parseFieldValue = (value: any, type: string): string => {\n  if (!notNullorUndefined(value)) {\n    return '';\n  }\n\n  return FIELD_DISPLAY_FORMAT[type] ? FIELD_DISPLAY_FORMAT[type](value) : String(value);\n};\n\nconst arrayMoveMutate = <T>(array: T[], from: number, to: number) => {\n  array.splice(to < 0 ? array.length + to : to, 0, array.splice(from, 1)[0]);\n};\n\n/**\n *\n * @param array\n * @param from\n * @param to\n */\nexport const arrayMove = <T>(array: T[], from: number, to: number) => {\n  array = array.slice();\n  arrayMoveMutate(array, from, to);\n  return array;\n};\n\n/**\n * Get the value format based on field and format options\n * Used in render tooltip value\n * @param format\n * @param field\n */\nexport function getFormatter(\n  format: string | Record<string, string>,\n  field?: Field\n): FieldFormatter {\n  if (!format) {\n    return defaultFormatter;\n  }\n  const tooltipFormat = Object.values(TOOLTIP_FORMATS).find(f => f[TOOLTIP_KEY] === format);\n\n  if (tooltipFormat) {\n    return applyDefaultFormat(tooltipFormat as TooltipFormat);\n  } else if (typeof format === 'string' && field) {\n    return applyCustomFormat(format, field);\n  }\n\n  return defaultFormatter;\n}\n\nexport function applyDefaultFormat(tooltipFormat: TooltipFormat): (v: any) => string {\n  if (!tooltipFormat || !tooltipFormat.format) {\n    return defaultFormatter;\n  }\n\n  switch (tooltipFormat.type) {\n    case TOOLTIP_FORMAT_TYPES.DECIMAL:\n      return d3Format(tooltipFormat.format);\n    case TOOLTIP_FORMAT_TYPES.DATE:\n    case TOOLTIP_FORMAT_TYPES.DATE_TIME:\n      return datetimeFormatter(null)(tooltipFormat.format);\n    case TOOLTIP_FORMAT_TYPES.PERCENTAGE:\n      return v => `${d3Format(TOOLTIP_FORMATS.DECIMAL_DECIMAL_FIXED_2.format)(v)}%`;\n    case TOOLTIP_FORMAT_TYPES.BOOLEAN:\n      return getBooleanFormatter(tooltipFormat.format);\n    default:\n      return defaultFormatter;\n  }\n}\n\nexport function getBooleanFormatter(format: string): FieldFormatter {\n  switch (format) {\n    case '01':\n      return (v: Boolean) => (v ? '1' : '0');\n    case 'yn':\n      return (v: Boolean) => (v ? 'yes' : 'no');\n    default:\n      return defaultFormatter;\n  }\n}\n// Allow user to specify custom tooltip format via config\nexport function applyCustomFormat(format, field): FieldFormatter {\n  switch (field.type) {\n    case ALL_FIELD_TYPES.real:\n    case ALL_FIELD_TYPES.integer:\n      return d3Format(format);\n    case ALL_FIELD_TYPES.date:\n    case ALL_FIELD_TYPES.timestamp:\n      return datetimeFormatter(null)(format);\n    default:\n      return v => v;\n  }\n}\n\n/**\n * Format epoch milliseconds with a format string\n * @type timezone\n */\nexport function datetimeFormatter(\n  timezone?: string | null\n): (format?: string) => (ts: number) => string {\n  return timezone\n    ? format => ts =>\n        moment\n          .utc(ts)\n          .tz(timezone)\n          .format(format)\n    : format => ts => moment.utc(ts).format(format);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}