{"ast":null,"code":"import _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar QUANTIZED_MESH_HEADER = new Map([['centerX', Float64Array.BYTES_PER_ELEMENT], ['centerY', Float64Array.BYTES_PER_ELEMENT], ['centerZ', Float64Array.BYTES_PER_ELEMENT], ['minHeight', Float32Array.BYTES_PER_ELEMENT], ['maxHeight', Float32Array.BYTES_PER_ELEMENT], ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]]);\nfunction decodeZigZag(value) {\n  return value >> 1 ^ -(value & 1);\n}\nfunction decodeHeader(dataView) {\n  var position = 0;\n  var header = {};\n  var _iterator = _createForOfIteratorHelper(QUANTIZED_MESH_HEADER),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        key = _step$value[0],\n        bytesCount = _step$value[1];\n      var getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n      header[key] = getter.call(dataView, position, true);\n      position += bytesCount;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    header: header,\n    headerEndPosition: position\n  };\n}\nfunction decodeVertexData(dataView, headerEndPosition) {\n  var position = headerEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = dataView.getUint32(position, true);\n  var vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  var elementArrayLength = vertexCount * bytesPerArrayElement;\n  var uArrayStartPosition = position;\n  var vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  var heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n  var u = 0;\n  var v = 0;\n  var height = 0;\n  for (var i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true));\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n  position += elementArrayLength * 3;\n  return {\n    vertexData: vertexData,\n    vertexDataEndPosition: position\n  };\n}\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex) {\n  var encoded = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var indices;\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n  if (!encoded) {\n    return indices;\n  }\n  var highest = 0;\n  for (var i = 0; i < indices.length; ++i) {\n    var code = indices[i];\n    indices[i] = highest - code;\n    if (code === 0) {\n      ++highest;\n    }\n  }\n  return indices;\n}\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  var position = vertexDataEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = vertexData.length / elementsPerVertex;\n  var bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - position % bytesPerIndex;\n  }\n  var triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var triangleIndicesCount = triangleCount * 3;\n  var triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);\n  position += triangleIndicesCount * bytesPerIndex;\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices: triangleIndices\n  };\n}\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  var position = triangleIndicesEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = vertexData.length / elementsPerVertex;\n  var bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n  var westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n  var southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);\n  position += southVertexCount * bytesPerIndex;\n  var eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n  var northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);\n  position += northVertexCount * bytesPerIndex;\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices: westIndices,\n    southIndices: southIndices,\n    eastIndices: eastIndices,\n    northIndices: northIndices\n  };\n}\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);\n}\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);\n}\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  var extensions = {};\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {\n      extensions: extensions,\n      extensionsEndPosition: indicesEndPosition\n    };\n  }\n  var position = indicesEndPosition;\n  while (position < dataView.byteLength) {\n    var extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n    var extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    var extensionView = new DataView(dataView.buffer, position, extensionLength);\n    switch (extensionId) {\n      case 1:\n        {\n          extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n          break;\n        }\n      case 2:\n        {\n          extensions.waterMask = decodeWaterMaskExtension(extensionView);\n          break;\n        }\n      default:\n        {}\n    }\n    position += extensionLength;\n  }\n  return {\n    extensions: extensions,\n    extensionsEndPosition: position\n  };\n}\nexport var DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\nvar DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\nexport default function decode(data, userOptions) {\n  var options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  var view = new DataView(data);\n  var _decodeHeader = decodeHeader(view),\n    header = _decodeHeader.header,\n    headerEndPosition = _decodeHeader.headerEndPosition;\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {\n      header: header\n    };\n  }\n  var _decodeVertexData = decodeVertexData(view, headerEndPosition),\n    vertexData = _decodeVertexData.vertexData,\n    vertexDataEndPosition = _decodeVertexData.vertexDataEndPosition;\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {\n      header: header,\n      vertexData: vertexData\n    };\n  }\n  var _decodeTriangleIndice = decodeTriangleIndices(view, vertexData, vertexDataEndPosition),\n    triangleIndices = _decodeTriangleIndice.triangleIndices,\n    triangleIndicesEndPosition = _decodeTriangleIndice.triangleIndicesEndPosition;\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {\n      header: header,\n      vertexData: vertexData,\n      triangleIndices: triangleIndices\n    };\n  }\n  var _decodeEdgeIndices = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition),\n    westIndices = _decodeEdgeIndices.westIndices,\n    southIndices = _decodeEdgeIndices.southIndices,\n    eastIndices = _decodeEdgeIndices.eastIndices,\n    northIndices = _decodeEdgeIndices.northIndices,\n    edgeIndicesEndPosition = _decodeEdgeIndices.edgeIndicesEndPosition;\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header: header,\n      vertexData: vertexData,\n      triangleIndices: triangleIndices,\n      westIndices: westIndices,\n      northIndices: northIndices,\n      eastIndices: eastIndices,\n      southIndices: southIndices\n    };\n  }\n  var _decodeExtensions = decodeExtensions(view, edgeIndicesEndPosition),\n    extensions = _decodeExtensions.extensions;\n  return {\n    header: header,\n    vertexData: vertexData,\n    triangleIndices: triangleIndices,\n    westIndices: westIndices,\n    northIndices: northIndices,\n    eastIndices: eastIndices,\n    southIndices: southIndices,\n    extensions: extensions\n  };\n}","map":{"version":3,"names":["QUANTIZED_MESH_HEADER","Map","Float64Array","BYTES_PER_ELEMENT","Float32Array","decodeZigZag","value","decodeHeader","dataView","position","header","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","key","bytesCount","getter","getFloat64","getFloat32","call","err","e","f","headerEndPosition","decodeVertexData","elementsPerVertex","vertexCount","getUint32","vertexData","Uint16Array","Uint32Array","bytesPerArrayElement","elementArrayLength","uArrayStartPosition","vArrayStartPosition","heightArrayStartPosition","u","v","height","i","getUint16","vertexDataEndPosition","decodeIndex","buffer","indicesCount","bytesPerIndex","encoded","arguments","length","undefined","indices","highest","code","decodeTriangleIndices","triangleCount","triangleIndicesCount","triangleIndices","triangleIndicesEndPosition","decodeEdgeIndices","westVertexCount","westIndices","southVertexCount","southIndices","eastVertexCount","eastIndices","northVertexCount","northIndices","edgeIndicesEndPosition","decodeVertexNormalsExtension","extensionDataView","Uint8Array","byteOffset","byteLength","decodeWaterMaskExtension","slice","decodeExtensions","indicesEndPosition","extensions","extensionsEndPosition","extensionId","getUint8","extensionLength","extensionView","DataView","vertexNormals","waterMask","DECODING_STEPS","vertices","edgeIndices","DEFAULT_OPTIONS","maxDecodingStep","decode","data","userOptions","options","Object","assign","view","_decodeHeader","_decodeVertexData","_decodeTriangleIndice","_decodeEdgeIndices","_decodeExtensions"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/terrain/src/lib/decode-quantized-mesh.ts"],"sourcesContent":["// Copyright (C) 2018-2019 HERE Europe B.V.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst QUANTIZED_MESH_HEADER = new Map([\n  ['centerX', Float64Array.BYTES_PER_ELEMENT],\n  ['centerY', Float64Array.BYTES_PER_ELEMENT],\n  ['centerZ', Float64Array.BYTES_PER_ELEMENT],\n\n  ['minHeight', Float32Array.BYTES_PER_ELEMENT],\n  ['maxHeight', Float32Array.BYTES_PER_ELEMENT],\n\n  ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT],\n\n  ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]\n]);\n\nfunction decodeZigZag(value) {\n  return (value >> 1) ^ -(value & 1);\n}\n\nfunction decodeHeader(dataView) {\n  let position = 0;\n  const header = {};\n\n  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {\n    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n\n    header[key] = getter.call(dataView, position, true);\n    position += bytesCount;\n  }\n\n  return {header, headerEndPosition: position};\n}\n\nfunction decodeVertexData(dataView, headerEndPosition) {\n  let position = headerEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = dataView.getUint32(position, true);\n  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  const elementArrayLength = vertexCount * bytesPerArrayElement;\n  const uArrayStartPosition = position;\n  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(\n      dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true)\n    );\n\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n\n  position += elementArrayLength * 3;\n\n  return {vertexData, vertexDataEndPosition: position};\n}\n\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {\n  let indices;\n\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n\n  if (!encoded) {\n    return indices;\n  }\n\n  let highest = 0;\n\n  for (let i = 0; i < indices.length; ++i) {\n    const code = indices[i];\n\n    indices[i] = highest - code;\n\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  return indices;\n}\n\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  let position = vertexDataEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - (position % bytesPerIndex);\n  }\n\n  const triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const triangleIndicesCount = triangleCount * 3;\n  const triangleIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    triangleIndicesCount,\n    bytesPerIndex\n  );\n  position += triangleIndicesCount * bytesPerIndex;\n\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices\n  };\n}\n\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  let position = triangleIndicesEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  const westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n\n  const southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const southIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    southVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += southVertexCount * bytesPerIndex;\n\n  const eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n\n  const northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const northIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    northVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += northVertexCount * bytesPerIndex;\n\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices\n  };\n}\n\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(\n    extensionDataView.buffer,\n    extensionDataView.byteOffset,\n    extensionDataView.byteLength\n  );\n}\n\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(\n    extensionDataView.byteOffset,\n    extensionDataView.byteOffset + extensionDataView.byteLength\n  );\n}\n\ntype Extensions = {\n  vertexNormals?: any;\n  waterMask?: any;\n};\n\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  const extensions: Extensions = {};\n\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {extensions, extensionsEndPosition: indicesEndPosition};\n  }\n\n  let position = indicesEndPosition;\n\n  while (position < dataView.byteLength) {\n    const extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n\n    const extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n\n    const extensionView = new DataView(dataView.buffer, position, extensionLength);\n\n    switch (extensionId) {\n      case 1: {\n        extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n\n        break;\n      }\n      case 2: {\n        extensions.waterMask = decodeWaterMaskExtension(extensionView);\n\n        break;\n      }\n      default: {\n        // console.warn(`Unknown extension with id ${extensionId}`)\n      }\n    }\n\n    position += extensionLength;\n  }\n\n  return {extensions, extensionsEndPosition: position};\n}\n\nexport const DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\n\nconst DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\n\nexport default function decode(data, userOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  const view = new DataView(data);\n  const {header, headerEndPosition} = decodeHeader(view);\n\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {header};\n  }\n\n  const {vertexData, vertexDataEndPosition} = decodeVertexData(view, headerEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {header, vertexData};\n  }\n\n  const {triangleIndices, triangleIndicesEndPosition} = decodeTriangleIndices(\n    view,\n    vertexData,\n    vertexDataEndPosition\n  );\n\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {header, vertexData, triangleIndices};\n  }\n\n  const {westIndices, southIndices, eastIndices, northIndices, edgeIndicesEndPosition} =\n    decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header,\n      vertexData,\n      triangleIndices,\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    };\n  }\n\n  const {extensions} = decodeExtensions(view, edgeIndicesEndPosition);\n\n  return {\n    header,\n    vertexData,\n    triangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices,\n    extensions\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}