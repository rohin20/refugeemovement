{"ast":null,"code":"import _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { Vector3 } from '@math.gl/core';\nimport { CullingVolume, Plane } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nvar scratchVector = new Vector3();\nvar scratchPosition = new Vector3();\nvar cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);\nexport function getFrameState(viewport, frameNumber) {\n  var cameraDirection = viewport.cameraDirection,\n    cameraUp = viewport.cameraUp,\n    height = viewport.height;\n  var metersPerUnit = viewport.distanceScales.metersPerUnit;\n  var viewportCenterCartesian = worldToCartesian(viewport, viewport.center);\n  var enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n  var cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  var cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());\n  var cameraDirectionCartesian = new Vector3(enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))).normalize();\n  var cameraUpCartesian = new Vector3(enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))).normalize();\n  commonSpacePlanesToWGS84(viewport);\n  var ViewportClass = viewport.constructor;\n  var longitude = viewport.longitude,\n    latitude = viewport.latitude,\n    width = viewport.width,\n    bearing = viewport.bearing,\n    zoom = viewport.zoom;\n  var topDownViewport = new ViewportClass({\n    longitude: longitude,\n    latitude: latitude,\n    height: height,\n    width: width,\n    bearing: bearing,\n    zoom: zoom,\n    pitch: 0\n  });\n  return {\n    camera: {\n      position: cameraPositionCartesian,\n      direction: cameraDirectionCartesian,\n      up: cameraUpCartesian\n    },\n    viewport: viewport,\n    topDownViewport: topDownViewport,\n    height: height,\n    cullingVolume: cullingVolume,\n    frameNumber: frameNumber,\n    sseDenominator: 1.15\n  };\n}\nexport function limitSelectedTiles(tiles, frameState, maximumTilesSelected) {\n  if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {\n    return [tiles, []];\n  }\n  var tuples = [];\n  var _frameState$viewport = frameState.viewport,\n    viewportLongitude = _frameState$viewport.longitude,\n    viewportLatitude = _frameState$viewport.latitude;\n  var _iterator = _createForOfIteratorHelper(tiles.entries()),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        index = _step$value[0],\n        tile = _step$value[1];\n      var _tile$header$mbs = _slicedToArray(tile.header.mbs, 2),\n        longitude = _tile$header$mbs[0],\n        latitude = _tile$header$mbs[1];\n      var deltaLon = Math.abs(viewportLongitude - longitude);\n      var deltaLat = Math.abs(viewportLatitude - latitude);\n      var distance = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);\n      tuples.push([index, distance]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var tuplesSorted = tuples.sort(function (a, b) {\n    return a[1] - b[1];\n  });\n  var selectedTiles = [];\n  for (var i = 0; i < maximumTilesSelected; i++) {\n    selectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n  var unselectedTiles = [];\n  for (var _i = maximumTilesSelected; _i < tuplesSorted.length; _i++) {\n    unselectedTiles.push(tiles[tuplesSorted[_i][0]]);\n  }\n  return [selectedTiles, unselectedTiles];\n}\nfunction commonSpacePlanesToWGS84(viewport) {\n  var frustumPlanes = viewport.getFrustumPlanes();\n  var nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);\n  var nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);\n  var cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition);\n  var i = 0;\n  cullingVolume.planes[i++].fromPointNormal(nearCenterCartesian, scratchVector.copy(nearCenterCartesian).subtract(cameraCartesian));\n  for (var dir in frustumPlanes) {\n    if (dir === 'near') {\n      continue;\n    }\n    var plane = frustumPlanes[dir];\n    var posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition);\n    var cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition);\n    cullingVolume.planes[i++].fromPointNormal(cartesianPos, scratchVector.copy(nearCenterCartesian).subtract(cartesianPos));\n  }\n}\nfunction closestPointOnPlane(plane, refPoint) {\n  var out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n  var distanceToRef = plane.normal.dot(refPoint);\n  out.copy(plane.normal).scale(plane.distance - distanceToRef).add(refPoint);\n  return out;\n}\nfunction worldToCartesian(viewport, point) {\n  var out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n  var cartographicPos = viewport.unprojectPosition(point);\n  return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);\n}","map":{"version":3,"names":["Vector3","CullingVolume","Plane","Ellipsoid","scratchVector","scratchPosition","cullingVolume","getFrameState","viewport","frameNumber","cameraDirection","cameraUp","height","metersPerUnit","distanceScales","viewportCenterCartesian","worldToCartesian","center","enuToFixedTransform","WGS84","eastNorthUpToFixedFrame","cameraPositionCartographic","unprojectPosition","cameraPosition","cameraPositionCartesian","cartographicToCartesian","cameraDirectionCartesian","transformAsVector","scale","normalize","cameraUpCartesian","commonSpacePlanesToWGS84","ViewportClass","constructor","longitude","latitude","width","bearing","zoom","topDownViewport","pitch","camera","position","direction","up","sseDenominator","limitSelectedTiles","tiles","frameState","maximumTilesSelected","length","tuples","_frameState$viewport","viewportLongitude","viewportLatitude","_iterator","_createForOfIteratorHelper","entries","_step","s","n","done","_step$value","_slicedToArray","value","index","tile","_tile$header$mbs","header","mbs","deltaLon","Math","abs","deltaLat","distance","sqrt","push","err","e","f","tuplesSorted","sort","a","b","selectedTiles","i","unselectedTiles","frustumPlanes","getFrustumPlanes","nearCenterCommon","closestPointOnPlane","near","nearCenterCartesian","cameraCartesian","planes","fromPointNormal","copy","subtract","dir","plane","posCommon","cartesianPos","refPoint","out","arguments","undefined","distanceToRef","normal","dot","add","point","cartographicPos"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/geo-layers/node_modules/@loaders.gl/tiles/src/tileset/helpers/frame-state.ts"],"sourcesContent":["import {Tile3D} from '@loaders.gl/tiles';\nimport {Vector3} from '@math.gl/core';\nimport {CullingVolume, Plane} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {GeospatialViewport, Viewport} from '../../types';\n\nexport type FrameState = {\n  camera: {\n    position: number[];\n    direction: number[];\n    up: number[];\n  };\n  viewport: GeospatialViewport;\n  topDownViewport: GeospatialViewport; // Use it to calculate projected radius for a tile\n  height: number;\n  cullingVolume: CullingVolume;\n  frameNumber: number; // TODO: This can be the same between updates, what number is unique for between updates?\n  sseDenominator: number; // Assumes fovy = 60 degrees\n};\n\nconst scratchVector = new Vector3();\nconst scratchPosition = new Vector3();\nconst cullingVolume = new CullingVolume([\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane()\n]);\n\n// Extracts a frame state appropriate for tile culling from a deck.gl viewport\n// TODO - this could likely be generalized and merged back into deck.gl for other culling scenarios\nexport function getFrameState(viewport: GeospatialViewport, frameNumber: number): FrameState {\n  // Traverse and and request. Update _selectedTiles so that we know what to render.\n  // Traverse and and request. Update _selectedTiles so that we know what to render.\n  const {cameraDirection, cameraUp, height} = viewport;\n  const {metersPerUnit} = viewport.distanceScales;\n\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() breaks on raw array, create a Vector.\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() takes a cartesian, is that intuitive?\n  const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);\n  const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(\n    cameraPositionCartographic,\n    new Vector3()\n  );\n\n  // These should still be normalized as the transform has scale 1 (goes from meters to meters)\n  const cameraDirectionCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))\n  ).normalize();\n  const cameraUpCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))\n  ).normalize();\n\n  commonSpacePlanesToWGS84(viewport);\n\n  const ViewportClass = viewport.constructor;\n  const {longitude, latitude, width, bearing, zoom} = viewport;\n  // @ts-ignore\n  const topDownViewport = new ViewportClass({\n    longitude,\n    latitude,\n    height,\n    width,\n    bearing,\n    zoom,\n    pitch: 0\n  });\n\n  // TODO: make a file/class for frameState and document what needs to be attached to this so that traversal can function\n  return {\n    camera: {\n      position: cameraPositionCartesian,\n      direction: cameraDirectionCartesian,\n      up: cameraUpCartesian\n    },\n    viewport,\n    topDownViewport,\n    height,\n    cullingVolume,\n    frameNumber, // TODO: This can be the same between updates, what number is unique for between updates?\n    sseDenominator: 1.15 // Assumes fovy = 60 degrees\n  };\n}\n\n/**\n * Limit `tiles` array length with `maximumTilesSelected` number.\n * The criteria for this filtering is distance of a tile center\n * to the `frameState.viewport`'s longitude and latitude\n * @param tiles - tiles array to filter\n * @param frameState - frameState to calculate distances\n * @param maximumTilesSelected - maximal amount of tiles in the output array\n * @returns new tiles array\n */\nexport function limitSelectedTiles(\n  tiles: Tile3D[],\n  frameState: FrameState,\n  maximumTilesSelected: number\n): [Tile3D[], Tile3D[]] {\n  if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {\n    return [tiles, []];\n  }\n  // Accumulate distances in couples array: [tileIndex: number, distanceToViewport: number]\n  const tuples: [number, number][] = [];\n  const {longitude: viewportLongitude, latitude: viewportLatitude} = frameState.viewport;\n  for (const [index, tile] of tiles.entries()) {\n    const [longitude, latitude] = tile.header.mbs;\n    const deltaLon = Math.abs(viewportLongitude - longitude);\n    const deltaLat = Math.abs(viewportLatitude - latitude);\n    const distance = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);\n    tuples.push([index, distance]);\n  }\n  const tuplesSorted = tuples.sort((a, b) => a[1] - b[1]);\n  const selectedTiles: Tile3D[] = [];\n  for (let i = 0; i < maximumTilesSelected; i++) {\n    selectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n  const unselectedTiles: Tile3D[] = [];\n  for (let i = maximumTilesSelected; i < tuplesSorted.length; i++) {\n    unselectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n\n  return [selectedTiles, unselectedTiles];\n}\n\nfunction commonSpacePlanesToWGS84(viewport) {\n  // Extract frustum planes based on current view.\n  const frustumPlanes = viewport.getFrustumPlanes();\n\n  // Get the near/far plane centers\n  const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);\n  const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);\n  const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition);\n\n  let i = 0;\n  cullingVolume.planes[i++].fromPointNormal(\n    nearCenterCartesian,\n    scratchVector.copy(nearCenterCartesian).subtract(cameraCartesian)\n  );\n\n  for (const dir in frustumPlanes) {\n    if (dir === 'near') {\n      continue; // eslint-disable-line no-continue\n    }\n    const plane = frustumPlanes[dir];\n    const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition);\n    const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition);\n\n    cullingVolume.planes[i++].fromPointNormal(\n      cartesianPos,\n      // Want the normal to point into the frustum since that's what culling expects\n      scratchVector.copy(nearCenterCartesian).subtract(cartesianPos)\n    );\n  }\n}\n\nfunction closestPointOnPlane(\n  plane: {distance: number; normal: Vector3},\n  refPoint: [number, number, number] | Vector3,\n  out: Vector3 = new Vector3()\n): Vector3 {\n  const distanceToRef = plane.normal.dot(refPoint);\n  out\n    .copy(plane.normal)\n    .scale(plane.distance - distanceToRef)\n    .add(refPoint);\n  return out;\n}\n\nfunction worldToCartesian(\n  viewport: Viewport,\n  point: number[] | Vector3,\n  out: Vector3 = new Vector3()\n): Vector3 {\n  const cartographicPos = viewport.unprojectPosition(point);\n  return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}