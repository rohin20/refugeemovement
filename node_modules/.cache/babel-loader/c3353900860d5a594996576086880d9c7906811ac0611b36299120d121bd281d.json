{"ast":null,"code":"import _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { padArray } from '../../utils/array-utils';\nvar DEFAULT_TRANSITION_SETTINGS = {\n  interpolation: {\n    duration: 0,\n    easing: function easing(t) {\n      return t;\n    }\n  },\n  spring: {\n    stiffness: 0.05,\n    damping: 0.5\n  }\n};\nexport function normalizeTransitionSettings(userSettings, layerSettings) {\n  if (!userSettings) {\n    return null;\n  }\n  if (Number.isFinite(userSettings)) {\n    userSettings = {\n      type: 'interpolation',\n      duration: userSettings\n    };\n  }\n  var type = userSettings.type || 'interpolation';\n  return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, DEFAULT_TRANSITION_SETTINGS[type]), layerSettings), userSettings), {}, {\n    type: type\n  });\n}\nexport function getSourceBufferAttribute(gl, attribute) {\n  var buffer = attribute.getBuffer();\n  if (buffer) {\n    return [buffer, {\n      divisor: 0,\n      size: attribute.size,\n      normalized: attribute.settings.normalized\n    }];\n  }\n  return attribute.value;\n}\nexport function getAttributeTypeFromSize(size) {\n  switch (size) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(\"No defined attribute type for size \\\"\".concat(size, \"\\\"\"));\n  }\n}\nexport function cycleBuffers(buffers) {\n  buffers.push(buffers.shift());\n}\nexport function getAttributeBufferLength(attribute, numInstances) {\n  var doublePrecision = attribute.doublePrecision,\n    settings = attribute.settings,\n    value = attribute.value,\n    size = attribute.size;\n  var multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;\n  return (settings.noAlloc ? value.length : numInstances * size) * multiplier;\n}\nexport function padBuffer(_ref) {\n  var buffer = _ref.buffer,\n    numInstances = _ref.numInstances,\n    attribute = _ref.attribute,\n    fromLength = _ref.fromLength,\n    fromStartIndices = _ref.fromStartIndices,\n    _ref$getData = _ref.getData,\n    getData = _ref$getData === void 0 ? function (x) {\n      return x;\n    } : _ref$getData;\n  var precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;\n  var size = attribute.size * precisionMultiplier;\n  var byteOffset = attribute.byteOffset;\n  var toStartIndices = attribute.startIndices;\n  var hasStartIndices = fromStartIndices && toStartIndices;\n  var toLength = getAttributeBufferLength(attribute, numInstances);\n  var isConstant = attribute.isConstant;\n  if (!hasStartIndices && fromLength >= toLength) {\n    return;\n  }\n  var toData = isConstant ? attribute.value : attribute.getBuffer().getData({\n    srcByteOffset: byteOffset\n  });\n  if (attribute.settings.normalized && !isConstant) {\n    var getter = getData;\n    getData = function getData(value, chunk) {\n      return attribute.normalizeConstant(getter(value, chunk));\n    };\n  }\n  var getMissingData = isConstant ? function (i, chunk) {\n    return getData(toData, chunk);\n  } : function (i, chunk) {\n    return getData(toData.subarray(i, i + size), chunk);\n  };\n  var source = buffer.getData({\n    length: fromLength\n  });\n  var data = new Float32Array(toLength);\n  padArray({\n    source: source,\n    target: data,\n    sourceStartIndices: fromStartIndices,\n    targetStartIndices: toStartIndices,\n    size: size,\n    getData: getMissingData\n  });\n  if (buffer.byteLength < data.byteLength + byteOffset) {\n    buffer.reallocate(data.byteLength + byteOffset);\n  }\n  buffer.subData({\n    data: data,\n    offset: byteOffset\n  });\n}","map":{"version":3,"names":["padArray","DEFAULT_TRANSITION_SETTINGS","interpolation","duration","easing","t","spring","stiffness","damping","normalizeTransitionSettings","userSettings","layerSettings","Number","isFinite","type","_objectSpread","getSourceBufferAttribute","gl","attribute","buffer","getBuffer","divisor","size","normalized","settings","value","getAttributeTypeFromSize","Error","concat","cycleBuffers","buffers","push","shift","getAttributeBufferLength","numInstances","doublePrecision","multiplier","Float64Array","noAlloc","length","padBuffer","_ref","fromLength","fromStartIndices","_ref$getData","getData","x","precisionMultiplier","byteOffset","toStartIndices","startIndices","hasStartIndices","toLength","isConstant","toData","srcByteOffset","getter","chunk","normalizeConstant","getMissingData","i","subarray","source","data","Float32Array","target","sourceStartIndices","targetStartIndices","byteLength","reallocate","subData","offset"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/core/src/lib/attribute/attribute-transition-utils.ts"],"sourcesContent":["import {padArray} from '../../utils/array-utils';\nimport {NumericArray} from '../../types/types';\nimport Attribute from './attribute';\nimport type {BufferAccessor} from './data-column';\nimport type {Buffer} from '@luma.gl/webgl';\n\nexport interface TransitionSettings {\n  type: string;\n  /** Callback to get the value that the entering vertices are transitioning from. */\n  enter?: (toValue: NumericArray, chunk?: NumericArray) => NumericArray;\n  /** Callback when the transition is started */\n  onStart?: () => void;\n  /** Callback when the transition is done */\n  onEnd?: () => void;\n  /** Callback when the transition is interrupted */\n  onInterrupt?: () => void;\n}\n\nexport type InterpolationTransitionSettings = TransitionSettings & {\n  type?: 'interpolation';\n  /** Duration of the transition animation, in milliseconds */\n  duration: number;\n  /** Easing function that maps a value from [0, 1] to [0, 1], see [http://easings.net/](http://easings.net/) */\n  easing?: (t: number) => number;\n};\n\nexport type SpringTransitionSettings = TransitionSettings & {\n  type: 'spring';\n  /** \"Tension\" factor for the spring */\n  stiffness: number;\n  /** \"Friction\" factor that counteracts the spring's acceleration */\n  damping: number;\n};\n\nconst DEFAULT_TRANSITION_SETTINGS = {\n  interpolation: {\n    duration: 0,\n    easing: t => t\n  },\n  spring: {\n    stiffness: 0.05,\n    damping: 0.5\n  }\n};\n\nexport function normalizeTransitionSettings(\n  userSettings: number | InterpolationTransitionSettings | SpringTransitionSettings,\n  layerSettings?: boolean | Partial<TransitionSettings>\n): TransitionSettings | null {\n  if (!userSettings) {\n    return null;\n  }\n  if (Number.isFinite(userSettings)) {\n    userSettings = {type: 'interpolation', duration: userSettings as number};\n  }\n  const type = (userSettings as TransitionSettings).type || 'interpolation';\n  return {\n    ...DEFAULT_TRANSITION_SETTINGS[type],\n    ...(layerSettings as TransitionSettings),\n    ...(userSettings as TransitionSettings),\n    type\n  };\n}\n\n// NOTE: NOT COPYING OVER OFFSET OR STRIDE HERE BECAUSE:\n// (1) WE DON'T SUPPORT INTERLEAVED BUFFERS FOR TRANSITIONS\n// (2) BUFFERS WITH OFFSETS ALWAYS CONTAIN VALUES OF THE SAME SIZE\n// (3) THE OPERATIONS IN THE SHADER ARE PER-COMPONENT (addition and scaling)\nexport function getSourceBufferAttribute(\n  gl: WebGLRenderingContext,\n  attribute: Attribute\n): [Buffer, BufferAccessor] | NumericArray {\n  // The Attribute we pass to Transform as a sourceBuffer must have {divisor: 0}\n  // so we create a copy of the attribute (with divisor=0) to use when running\n  // transform feedback\n  const buffer = attribute.getBuffer();\n  if (buffer) {\n    return [\n      buffer,\n      {\n        divisor: 0,\n        size: attribute.size,\n        normalized: attribute.settings.normalized\n      } as BufferAccessor\n    ];\n  }\n  // constant\n  // don't pass normalized here because the `value` from a normalized attribute is\n  // already normalized\n  return attribute.value as NumericArray;\n}\n\nexport function getAttributeTypeFromSize(size: number): string {\n  switch (size) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(`No defined attribute type for size \"${size}\"`);\n  }\n}\n\nexport function cycleBuffers(buffers: Buffer[]): void {\n  buffers.push(buffers.shift() as Buffer);\n}\n\nexport function getAttributeBufferLength(attribute: Attribute, numInstances: number): number {\n  const {doublePrecision, settings, value, size} = attribute;\n  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;\n  return (settings.noAlloc ? (value as NumericArray).length : numInstances * size) * multiplier;\n}\n\n// This helper is used when transitioning attributes from a set of values in one buffer layout\n// to a set of values in a different buffer layout. (Buffer layouts are used when attribute values\n// within a buffer should be grouped for drawElements, like the Polygon layer.) For example, a\n// buffer layout of [3, 4] might have data [A1, A2, A3, B1, B2, B3, B4]. If it needs to transition\n// to a buffer layout of [4, 2], it should produce a buffer, using the transition setting's `enter`\n// function, that looks like this: [A1, A2, A3, A4 (user `enter` fn), B1, B2, 0]. Note: the final\n// 0 in this buffer is because we never shrink buffers, only grow them, for performance reasons.\nexport function padBuffer({\n  buffer,\n  numInstances,\n  attribute,\n  fromLength,\n  fromStartIndices,\n  getData = x => x\n}: {\n  buffer: Buffer;\n  numInstances: number;\n  attribute: Attribute;\n  fromLength: number;\n  fromStartIndices?: NumericArray | null;\n  getData?: (toValue: NumericArray, chunk?: NumericArray) => NumericArray;\n}): void {\n  // TODO: move the precisionMultiplier logic to the attribute when retrieving\n  // its `size` and `elementOffset`?\n  const precisionMultiplier =\n    attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;\n  const size = attribute.size * precisionMultiplier;\n  const byteOffset = attribute.byteOffset;\n  const toStartIndices = attribute.startIndices;\n  const hasStartIndices = fromStartIndices && toStartIndices;\n  const toLength = getAttributeBufferLength(attribute, numInstances);\n  const isConstant = attribute.isConstant;\n\n  // check if buffer needs to be padded\n  if (!hasStartIndices && fromLength >= toLength) {\n    return;\n  }\n\n  const toData = isConstant\n    ? attribute.value\n    : (attribute.getBuffer() as Buffer).getData({srcByteOffset: byteOffset});\n  if (attribute.settings.normalized && !isConstant) {\n    const getter = getData;\n    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));\n  }\n\n  const getMissingData = isConstant\n    ? (i, chunk) => getData(toData, chunk)\n    : (i, chunk) => getData(toData.subarray(i, i + size), chunk);\n\n  const source = buffer.getData({length: fromLength});\n  const data = new Float32Array(toLength);\n  padArray({\n    source,\n    target: data,\n    sourceStartIndices: fromStartIndices,\n    targetStartIndices: toStartIndices,\n    size,\n    getData: getMissingData\n  });\n\n  // TODO: support offset in buffer.setData?\n  if (buffer.byteLength < data.byteLength + byteOffset) {\n    buffer.reallocate(data.byteLength + byteOffset);\n  }\n  buffer.subData({data, offset: byteOffset});\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}