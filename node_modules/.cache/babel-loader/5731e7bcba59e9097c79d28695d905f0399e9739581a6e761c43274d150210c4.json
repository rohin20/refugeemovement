{"ast":null,"code":"import _defineProperty from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { LineLayer, SolidPolygonLayer } from '@deck.gl/layers';\nimport { generateContours } from './contour-utils';\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport { getBoundingBox, getGridParams } from '../utils/grid-aggregation-utils';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nvar DEFAULT_COLOR = [255, 255, 255, 255];\nvar DEFAULT_STROKE_WIDTH = 1;\nvar DEFAULT_THRESHOLD = 1;\nvar defaultProps = {\n  cellSize: {\n    type: 'number',\n    min: 1,\n    max: 1000,\n    value: 1000\n  },\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM',\n  contours: [{\n    threshold: DEFAULT_THRESHOLD\n  }],\n  zOffset: 0.005\n};\nvar POSITION_ATTRIBUTE_NAME = 'positions';\nvar DIMENSIONS = {\n  data: {\n    props: ['cellSize']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\nvar ContourLayer = /*#__PURE__*/function (_GridAggregationLayer) {\n  _inherits(ContourLayer, _GridAggregationLayer);\n  var _super = _createSuper(ContourLayer);\n  function ContourLayer() {\n    _classCallCheck(this, ContourLayer);\n    return _super.apply(this, arguments);\n  }\n  _createClass(ContourLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _attributeManager$add;\n      _get(_getPrototypeOf(ContourLayer.prototype), \"initializeState\", this).call(this, {\n        dimensions: DIMENSIONS\n      });\n      this.setState({\n        contourData: {},\n        projectPoints: false,\n        weights: {\n          count: {\n            size: 1,\n            operation: AGGREGATION_OPERATION.SUM\n          }\n        }\n      });\n      var attributeManager = this.getAttributeManager();\n      attributeManager.add((_attributeManager$add = {}, _defineProperty(_attributeManager$add, POSITION_ATTRIBUTE_NAME, {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      }), _defineProperty(_attributeManager$add, \"count\", {\n        size: 3,\n        accessor: 'getWeight'\n      }), _attributeManager$add));\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts) {\n      _get(_getPrototypeOf(ContourLayer.prototype), \"updateState\", this).call(this, opts);\n      var contoursChanged = false;\n      var oldProps = opts.oldProps,\n        props = opts.props;\n      var aggregationDirty = this.state.aggregationDirty;\n      if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {\n        contoursChanged = true;\n        this._updateThresholdData(opts.props);\n      }\n      if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {\n        this._generateContours();\n      }\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this$state$contourDa = this.state.contourData,\n        contourSegments = _this$state$contourDa.contourSegments,\n        contourPolygons = _this$state$contourDa.contourPolygons;\n      var LinesSubLayerClass = this.getSubLayerClass('lines', LineLayer);\n      var BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n      var lineLayer = contourSegments && contourSegments.length > 0 && new LinesSubLayerClass(this.getSubLayerProps({\n        id: 'lines'\n      }), {\n        data: this.state.contourData.contourSegments,\n        getSourcePosition: function getSourcePosition(d) {\n          return d.start;\n        },\n        getTargetPosition: function getTargetPosition(d) {\n          return d.end;\n        },\n        getColor: function getColor(d) {\n          return d.contour.color || DEFAULT_COLOR;\n        },\n        getWidth: function getWidth(d) {\n          return d.contour.strokeWidth || DEFAULT_STROKE_WIDTH;\n        }\n      });\n      var bandsLayer = contourPolygons && contourPolygons.length > 0 && new BandsSubLayerClass(this.getSubLayerProps({\n        id: 'bands'\n      }), {\n        data: this.state.contourData.contourPolygons,\n        getPolygon: function getPolygon(d) {\n          return d.vertices;\n        },\n        getFillColor: function getFillColor(d) {\n          return d.contour.color || DEFAULT_COLOR;\n        }\n      });\n      return [lineLayer, bandsLayer];\n    }\n  }, {\n    key: \"updateAggregationState\",\n    value: function updateAggregationState(opts) {\n      var props = opts.props,\n        oldProps = opts.oldProps;\n      var cellSize = props.cellSize,\n        coordinateSystem = props.coordinateSystem;\n      var viewport = this.context.viewport;\n      var cellSizeChanged = oldProps.cellSize !== cellSize;\n      var gpuAggregation = props.gpuAggregation;\n      if (this.state.gpuAggregation !== props.gpuAggregation) {\n        if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n          log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n          gpuAggregation = false;\n        }\n      }\n      var gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n      this.setState({\n        gpuAggregation: gpuAggregation\n      });\n      var dimensions = this.state.dimensions;\n      var positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n      var data = dimensions.data,\n        weights = dimensions.weights;\n      var boundingBox = this.state.boundingBox;\n      if (positionsChanged) {\n        boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n        this.setState({\n          boundingBox: boundingBox\n        });\n      }\n      if (positionsChanged || cellSizeChanged) {\n        var _getGridParams = getGridParams(boundingBox, cellSize, viewport, coordinateSystem),\n          gridOffset = _getGridParams.gridOffset,\n          translation = _getGridParams.translation,\n          width = _getGridParams.width,\n          height = _getGridParams.height,\n          numCol = _getGridParams.numCol,\n          numRow = _getGridParams.numRow;\n        this.allocateResources(numRow, numCol);\n        this.setState({\n          gridOffset: gridOffset,\n          boundingBox: boundingBox,\n          translation: translation,\n          posOffset: translation.slice(),\n          gridOrigin: [-1 * translation[0], -1 * translation[1]],\n          width: width,\n          height: height,\n          numCol: numCol,\n          numRow: numRow\n        });\n      }\n      var aggregationDataDirty = positionsChanged || gpuAggregationChanged || this.isAggregationDirty(opts, {\n        dimension: data,\n        compareAll: gpuAggregation\n      });\n      var aggregationWeightsDirty = this.isAggregationDirty(opts, {\n        dimension: weights\n      });\n      if (aggregationWeightsDirty) {\n        this._updateAccessors(opts);\n      }\n      if (aggregationDataDirty || aggregationWeightsDirty) {\n        this._resetResults();\n      }\n      this.setState({\n        aggregationDataDirty: aggregationDataDirty,\n        aggregationWeightsDirty: aggregationWeightsDirty\n      });\n    }\n  }, {\n    key: \"_updateAccessors\",\n    value: function _updateAccessors(opts) {\n      var _opts$props = opts.props,\n        getWeight = _opts$props.getWeight,\n        aggregation = _opts$props.aggregation,\n        data = _opts$props.data;\n      var count = this.state.weights.count;\n      if (count) {\n        count.getWeight = getWeight;\n        count.operation = AGGREGATION_OPERATION[aggregation];\n      }\n      this.setState({\n        getValue: getValueFunc(aggregation, getWeight, {\n          data: data\n        })\n      });\n    }\n  }, {\n    key: \"_resetResults\",\n    value: function _resetResults() {\n      var count = this.state.weights.count;\n      if (count) {\n        count.aggregationData = null;\n      }\n    }\n  }, {\n    key: \"_generateContours\",\n    value: function _generateContours() {\n      var _this$state = this.state,\n        numCol = _this$state.numCol,\n        numRow = _this$state.numRow,\n        gridOrigin = _this$state.gridOrigin,\n        gridOffset = _this$state.gridOffset,\n        thresholdData = _this$state.thresholdData;\n      var count = this.state.weights.count;\n      var aggregationData = count.aggregationData;\n      if (!aggregationData) {\n        aggregationData = count.aggregationBuffer.getData();\n        count.aggregationData = aggregationData;\n      }\n      var _GPUGridAggregator$ge = GPUGridAggregator.getCellData({\n          countsData: aggregationData\n        }),\n        cellWeights = _GPUGridAggregator$ge.cellWeights;\n      var contourData = generateContours({\n        thresholdData: thresholdData,\n        cellWeights: cellWeights,\n        gridSize: [numCol, numRow],\n        gridOrigin: gridOrigin,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset]\n      });\n      this.setState({\n        contourData: contourData\n      });\n    }\n  }, {\n    key: \"_updateThresholdData\",\n    value: function _updateThresholdData(props) {\n      var contours = props.contours,\n        zOffset = props.zOffset;\n      var count = contours.length;\n      var thresholdData = new Array(count);\n      for (var i = 0; i < count; i++) {\n        var contour = contours[i];\n        thresholdData[i] = {\n          contour: contour,\n          zIndex: contour.zIndex || i,\n          zOffset: zOffset\n        };\n      }\n      this.setState({\n        thresholdData: thresholdData\n      });\n    }\n  }]);\n  return ContourLayer;\n}(GridAggregationLayer);\nexport { ContourLayer as default };\nContourLayer.layerName = 'ContourLayer';\nContourLayer.defaultProps = defaultProps;","map":{"version":3,"names":["LineLayer","SolidPolygonLayer","generateContours","log","GPUGridAggregator","AGGREGATION_OPERATION","getValueFunc","getBoundingBox","getGridParams","GridAggregationLayer","DEFAULT_COLOR","DEFAULT_STROKE_WIDTH","DEFAULT_THRESHOLD","defaultProps","cellSize","type","min","max","value","getPosition","x","position","getWeight","gpuAggregation","aggregation","contours","threshold","zOffset","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","props","weights","accessors","ContourLayer","_GridAggregationLayer","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","initializeState","_attributeManager$add","_get","_getPrototypeOf","prototype","call","dimensions","setState","contourData","projectPoints","count","size","operation","SUM","attributeManager","getAttributeManager","add","_defineProperty","accessor","fp64","use64bitPositions","updateState","opts","contoursChanged","oldProps","aggregationDirty","state","_updateThresholdData","getNumInstances","_generateContours","renderLayers","_this$state$contourDa","contourSegments","contourPolygons","LinesSubLayerClass","getSubLayerClass","BandsSubLayerClass","lineLayer","length","getSubLayerProps","id","getSourcePosition","d","start","getTargetPosition","end","getColor","contour","color","getWidth","strokeWidth","bandsLayer","getPolygon","vertices","getFillColor","updateAggregationState","coordinateSystem","viewport","context","cellSizeChanged","isSupported","gl","warn","gpuAggregationChanged","positionsChanged","isAttributeChanged","boundingBox","getAttributes","_getGridParams","gridOffset","translation","width","height","numCol","numRow","allocateResources","posOffset","slice","gridOrigin","aggregationDataDirty","isAggregationDirty","dimension","compareAll","aggregationWeightsDirty","_updateAccessors","_resetResults","_opts$props","getValue","aggregationData","_this$state","thresholdData","aggregationBuffer","getData","_GPUGridAggregator$ge","getCellData","countsData","cellWeights","gridSize","xOffset","yOffset","Array","i","zIndex","default","layerName"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/aggregation-layers/src/contour-layer/contour-layer.js"],"sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {LineLayer, SolidPolygonLayer} from '@deck.gl/layers';\nimport {generateContours} from './contour-utils';\nimport {log} from '@deck.gl/core';\n\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION, getValueFunc} from '../utils/aggregation-operation-utils';\nimport {getBoundingBox, getGridParams} from '../utils/grid-aggregation-utils';\nimport GridAggregationLayer from '../grid-aggregation-layer';\n\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\nconst DEFAULT_THRESHOLD = 1;\n\nconst defaultProps = {\n  // grid aggregation\n  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},\n  getPosition: {type: 'accessor', value: x => x.position},\n  getWeight: {type: 'accessor', value: 1},\n  gpuAggregation: true,\n  aggregation: 'SUM',\n\n  // contour lines\n  contours: [{threshold: DEFAULT_THRESHOLD}],\n\n  zOffset: 0.005\n};\n\nconst POSITION_ATTRIBUTE_NAME = 'positions';\n\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\nexport default class ContourLayer extends GridAggregationLayer {\n  initializeState() {\n    super.initializeState({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      contourData: {},\n      projectPoints: false,\n      weights: {\n        count: {\n          size: 1,\n          operation: AGGREGATION_OPERATION.SUM\n        }\n      }\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      count: {size: 3, accessor: 'getWeight'}\n    });\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n    let contoursChanged = false;\n    const {oldProps, props} = opts;\n    const {aggregationDirty} = this.state;\n\n    if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {\n      contoursChanged = true;\n      this._updateThresholdData(opts.props);\n    }\n\n    if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {\n      this._generateContours();\n    }\n  }\n\n  renderLayers() {\n    const {contourSegments, contourPolygons} = this.state.contourData;\n\n    const LinesSubLayerClass = this.getSubLayerClass('lines', LineLayer);\n    const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n\n    // Contour lines layer\n    const lineLayer =\n      contourSegments &&\n      contourSegments.length > 0 &&\n      new LinesSubLayerClass(\n        this.getSubLayerProps({\n          id: 'lines'\n        }),\n        {\n          data: this.state.contourData.contourSegments,\n          getSourcePosition: d => d.start,\n          getTargetPosition: d => d.end,\n          getColor: d => d.contour.color || DEFAULT_COLOR,\n          getWidth: d => d.contour.strokeWidth || DEFAULT_STROKE_WIDTH\n        }\n      );\n\n    // Contour bands layer\n    const bandsLayer =\n      contourPolygons &&\n      contourPolygons.length > 0 &&\n      new BandsSubLayerClass(\n        this.getSubLayerProps({\n          id: 'bands'\n        }),\n        {\n          data: this.state.contourData.contourPolygons,\n          getPolygon: d => d.vertices,\n          getFillColor: d => d.contour.color || DEFAULT_COLOR\n        }\n      );\n\n    return [lineLayer, bandsLayer];\n  }\n\n  // Aggregation Overrides\n\n  /* eslint-disable max-statements, complexity */\n  updateAggregationState(opts) {\n    const {props, oldProps} = opts;\n    const {cellSize, coordinateSystem} = props;\n    const {viewport} = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    let gpuAggregation = props.gpuAggregation;\n    if (this.state.gpuAggregation !== props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n\n    const {dimensions} = this.state;\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {data, weights} = dimensions;\n\n    let {boundingBox} = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({boundingBox});\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {gridOffset, translation, width, height, numCol, numRow} = getGridParams(\n        boundingBox,\n        cellSize,\n        viewport,\n        coordinateSystem\n      );\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        boundingBox,\n        translation,\n        posOffset: translation.slice(), // Used for CPU aggregation, to offset points\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty =\n      positionsChanged ||\n      gpuAggregationChanged ||\n      this.isAggregationDirty(opts, {\n        dimension: data,\n        compareAll: gpuAggregation // check for all (including extentions props) when using gpu aggregation\n      });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n  }\n  /* eslint-enable max-statements, complexity */\n\n  // Private (Aggregation)\n\n  _updateAccessors(opts) {\n    const {getWeight, aggregation, data} = opts.props;\n    const {count} = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({getValue: getValueFunc(aggregation, getWeight, {data})});\n  }\n\n  _resetResults() {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n\n  // Private (Contours)\n\n  _generateContours() {\n    const {numCol, numRow, gridOrigin, gridOffset, thresholdData} = this.state;\n    const {count} = this.state.weights;\n    let {aggregationData} = count;\n    if (!aggregationData) {\n      aggregationData = count.aggregationBuffer.getData();\n      count.aggregationData = aggregationData;\n    }\n\n    const {cellWeights} = GPUGridAggregator.getCellData({countsData: aggregationData});\n    const contourData = generateContours({\n      thresholdData,\n      cellWeights,\n      gridSize: [numCol, numRow],\n      gridOrigin,\n      cellSize: [gridOffset.xOffset, gridOffset.yOffset]\n    });\n\n    // contourData contains both iso-lines and iso-bands if requested.\n    this.setState({contourData});\n  }\n\n  _updateThresholdData(props) {\n    const {contours, zOffset} = props;\n    const count = contours.length;\n    const thresholdData = new Array(count);\n    for (let i = 0; i < count; i++) {\n      const contour = contours[i];\n      thresholdData[i] = {\n        contour,\n        zIndex: contour.zIndex || i,\n        zOffset\n      };\n    }\n    this.setState({thresholdData});\n  }\n}\n\nContourLayer.layerName = 'ContourLayer';\nContourLayer.defaultProps = defaultProps;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}