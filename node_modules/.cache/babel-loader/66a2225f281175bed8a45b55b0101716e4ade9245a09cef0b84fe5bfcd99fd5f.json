{"ast":null,"code":"import _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { flatGeojsonToBinary } from '@loaders.gl/gis';\nimport Protobuf from 'pbf';\nimport VectorTile from './mapbox-vector-tile/vector-tile';\nimport BinaryVectorTile from './binary-vector-tile/vector-tile';\nexport default function parseMVT(arrayBuffer, options) {\n  var _options$gis, _options$mvt;\n  var mvtOptions = normalizeOptions(options);\n  var shape = (options === null || options === void 0 ? void 0 : (_options$gis = options.gis) === null || _options$gis === void 0 ? void 0 : _options$gis.format) || (options === null || options === void 0 ? void 0 : (_options$mvt = options.mvt) === null || _options$mvt === void 0 ? void 0 : _options$mvt.shape);\n  switch (shape) {\n    case 'columnar-table':\n      return {\n        shape: 'columnar-table',\n        data: parseToBinary(arrayBuffer, mvtOptions)\n      };\n    case 'geojson-row-table':\n      {\n        var table = {\n          shape: 'geojson-row-table',\n          data: parseToGeojson(arrayBuffer, mvtOptions)\n        };\n        return table;\n      }\n    case 'geojson':\n      return parseToGeojson(arrayBuffer, mvtOptions);\n    case 'binary-geometry':\n      return parseToBinary(arrayBuffer, mvtOptions);\n    case 'binary':\n      return parseToBinary(arrayBuffer, mvtOptions);\n    default:\n      throw new Error(shape);\n  }\n}\nfunction parseToBinary(arrayBuffer, options) {\n  var _parseToFlatGeoJson = parseToFlatGeoJson(arrayBuffer, options),\n    _parseToFlatGeoJson2 = _slicedToArray(_parseToFlatGeoJson, 2),\n    flatGeoJsonFeatures = _parseToFlatGeoJson2[0],\n    geometryInfo = _parseToFlatGeoJson2[1];\n  var binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);\n  binaryData.byteLength = arrayBuffer.byteLength;\n  return binaryData;\n}\nfunction parseToFlatGeoJson(arrayBuffer, options) {\n  var features = [];\n  var geometryInfo = {\n    coordLength: 2,\n    pointPositionsCount: 0,\n    pointFeaturesCount: 0,\n    linePositionsCount: 0,\n    linePathsCount: 0,\n    lineFeaturesCount: 0,\n    polygonPositionsCount: 0,\n    polygonObjectsCount: 0,\n    polygonRingsCount: 0,\n    polygonFeaturesCount: 0\n  };\n  if (arrayBuffer.byteLength <= 0) {\n    return [features, geometryInfo];\n  }\n  var tile = new BinaryVectorTile(new Protobuf(arrayBuffer));\n  var selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n  selectedLayers.forEach(function (layerName) {\n    var vectorTileLayer = tile.layers[layerName];\n    if (!vectorTileLayer) {\n      return;\n    }\n    for (var i = 0; i < vectorTileLayer.length; i++) {\n      var vectorTileFeature = vectorTileLayer.feature(i, geometryInfo);\n      var decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);\n      features.push(decodedFeature);\n    }\n  });\n  return [features, geometryInfo];\n}\nfunction parseToGeojson(arrayBuffer, options) {\n  if (arrayBuffer.byteLength <= 0) {\n    return [];\n  }\n  var features = [];\n  var tile = new VectorTile(new Protobuf(arrayBuffer));\n  var selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n  selectedLayers.forEach(function (layerName) {\n    var vectorTileLayer = tile.layers[layerName];\n    if (!vectorTileLayer) {\n      return;\n    }\n    for (var i = 0; i < vectorTileLayer.length; i++) {\n      var vectorTileFeature = vectorTileLayer.feature(i);\n      var decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);\n      features.push(decodedFeature);\n    }\n  });\n  return features;\n}\nfunction normalizeOptions(options) {\n  var _options$mvt2;\n  if (!(options !== null && options !== void 0 && options.mvt)) {\n    throw new Error('mvt options required');\n  }\n  var wgs84Coordinates = ((_options$mvt2 = options.mvt) === null || _options$mvt2 === void 0 ? void 0 : _options$mvt2.coordinates) === 'wgs84';\n  var tileIndex = options.mvt.tileIndex;\n  var hasTileIndex = tileIndex && Number.isFinite(tileIndex.x) && Number.isFinite(tileIndex.y) && Number.isFinite(tileIndex.z);\n  if (wgs84Coordinates && !hasTileIndex) {\n    throw new Error('MVT Loader: WGS84 coordinates need tileIndex property');\n  }\n  return options.mvt;\n}\nfunction getDecodedFeature(feature, options, layerName) {\n  var decodedFeature = feature.toGeoJSON(options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinates);\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = layerName;\n  }\n  return decodedFeature;\n}\nfunction getDecodedFeatureBinary(feature, options, layerName) {\n  var decodedFeature = feature.toBinaryCoordinates(options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinatesBinary);\n  if (options.layerProperty && decodedFeature.properties) {\n    decodedFeature.properties[options.layerProperty] = layerName;\n  }\n  return decodedFeature;\n}\nfunction transformToLocalCoordinates(line, feature) {\n  var extent = feature.extent;\n  for (var i = 0; i < line.length; i++) {\n    var p = line[i];\n    p[0] /= extent;\n    p[1] /= extent;\n  }\n}\nfunction transformToLocalCoordinatesBinary(data, feature) {\n  var extent = feature.extent;\n  for (var i = 0, il = data.length; i < il; ++i) {\n    data[i] /= extent;\n  }\n}","map":{"version":3,"names":["flatGeojsonToBinary","Protobuf","VectorTile","BinaryVectorTile","parseMVT","arrayBuffer","options","_options$gis","_options$mvt","mvtOptions","normalizeOptions","shape","gis","format","mvt","data","parseToBinary","table","parseToGeojson","Error","_parseToFlatGeoJson","parseToFlatGeoJson","_parseToFlatGeoJson2","_slicedToArray","flatGeoJsonFeatures","geometryInfo","binaryData","byteLength","features","coordLength","pointPositionsCount","pointFeaturesCount","linePositionsCount","linePathsCount","lineFeaturesCount","polygonPositionsCount","polygonObjectsCount","polygonRingsCount","polygonFeaturesCount","tile","selectedLayers","Array","isArray","layers","Object","keys","forEach","layerName","vectorTileLayer","i","length","vectorTileFeature","feature","decodedFeature","getDecodedFeatureBinary","push","getDecodedFeature","_options$mvt2","wgs84Coordinates","coordinates","tileIndex","hasTileIndex","Number","isFinite","x","y","z","toGeoJSON","transformToLocalCoordinates","layerProperty","properties","toBinaryCoordinates","transformToLocalCoordinatesBinary","line","extent","p","il"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/mvt/src/lib/parse-mvt.ts"],"sourcesContent":["import {flatGeojsonToBinary} from '@loaders.gl/gis';\nimport type {\n  FlatFeature,\n  Feature,\n  GeojsonGeometryInfo,\n  BinaryFeatures,\n  GeoJSONRowTable\n} from '@loaders.gl/schema';\nimport Protobuf from 'pbf';\n\nimport type {MVTMapboxCoordinates, MVTOptions, MVTLoaderOptions} from '../lib/types';\n\nimport VectorTile from './mapbox-vector-tile/vector-tile';\nimport BinaryVectorTile from './binary-vector-tile/vector-tile';\nimport VectorTileFeatureBinary from './binary-vector-tile/vector-tile-feature';\nimport VectorTileFeatureMapBox from './mapbox-vector-tile/vector-tile-feature';\n\n/**\n * Parse MVT arrayBuffer and return GeoJSON.\n *\n * @param arrayBuffer A MVT arrayBuffer\n * @param options\n * @returns A GeoJSON geometry object or a binary representation\n */\nexport default function parseMVT(arrayBuffer: ArrayBuffer, options?: MVTLoaderOptions) {\n  const mvtOptions = normalizeOptions(options);\n\n  const shape = options?.gis?.format || options?.mvt?.shape;\n  switch (shape) {\n    case 'columnar-table': // binary + some JS arrays\n      return {shape: 'columnar-table', data: parseToBinary(arrayBuffer, mvtOptions)};\n    case 'geojson-row-table': {\n      const table: GeoJSONRowTable = {\n        shape: 'geojson-row-table',\n        data: parseToGeojson(arrayBuffer, mvtOptions)\n      };\n      return table;\n    }\n    case 'geojson':\n      return parseToGeojson(arrayBuffer, mvtOptions);\n    case 'binary-geometry':\n      return parseToBinary(arrayBuffer, mvtOptions);\n    case 'binary':\n      return parseToBinary(arrayBuffer, mvtOptions);\n    default:\n      throw new Error(shape);\n  }\n}\n\nfunction parseToBinary(arrayBuffer: ArrayBuffer, options: MVTOptions): BinaryFeatures {\n  const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);\n\n  const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);\n  // Add the original byteLength (as a reasonable approximation of the size of the binary data)\n  // TODO decide where to store extra fields like byteLength (header etc) and document\n  // @ts-ignore\n  binaryData.byteLength = arrayBuffer.byteLength;\n  return binaryData;\n}\n\nfunction parseToFlatGeoJson(\n  arrayBuffer: ArrayBuffer,\n  options: MVTOptions\n): [FlatFeature[], GeojsonGeometryInfo] {\n  const features: FlatFeature[] = [];\n  const geometryInfo: GeojsonGeometryInfo = {\n    coordLength: 2,\n    pointPositionsCount: 0,\n    pointFeaturesCount: 0,\n    linePositionsCount: 0,\n    linePathsCount: 0,\n    lineFeaturesCount: 0,\n    polygonPositionsCount: 0,\n    polygonObjectsCount: 0,\n    polygonRingsCount: 0,\n    polygonFeaturesCount: 0\n  };\n\n  if (arrayBuffer.byteLength <= 0) {\n    return [features, geometryInfo];\n  }\n\n  const tile = new BinaryVectorTile(new Protobuf(arrayBuffer));\n\n  const selectedLayers =\n    options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n\n  selectedLayers.forEach((layerName: string) => {\n    const vectorTileLayer = tile.layers[layerName];\n    if (!vectorTileLayer) {\n      return;\n    }\n\n    for (let i = 0; i < vectorTileLayer.length; i++) {\n      const vectorTileFeature = vectorTileLayer.feature(i, geometryInfo);\n      const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);\n      features.push(decodedFeature);\n    }\n  });\n\n  return [features, geometryInfo];\n}\n\nfunction parseToGeojson(arrayBuffer: ArrayBuffer, options: MVTOptions): Feature[] {\n  if (arrayBuffer.byteLength <= 0) {\n    return [];\n  }\n\n  const features: MVTMapboxCoordinates[] = [];\n  const tile = new VectorTile(new Protobuf(arrayBuffer));\n\n  const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n\n  selectedLayers.forEach((layerName: string) => {\n    const vectorTileLayer = tile.layers[layerName];\n    if (!vectorTileLayer) {\n      return;\n    }\n\n    for (let i = 0; i < vectorTileLayer.length; i++) {\n      const vectorTileFeature = vectorTileLayer.feature(i);\n      const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);\n      features.push(decodedFeature);\n    }\n  });\n\n  return features as Feature[];\n}\n\nfunction normalizeOptions(options?: MVTLoaderOptions): MVTOptions {\n  if (!options?.mvt) {\n    throw new Error('mvt options required');\n  }\n\n  // Validate\n  const wgs84Coordinates = options.mvt?.coordinates === 'wgs84';\n  const {tileIndex} = options.mvt;\n  const hasTileIndex =\n    tileIndex &&\n    Number.isFinite(tileIndex.x) &&\n    Number.isFinite(tileIndex.y) &&\n    Number.isFinite(tileIndex.z);\n\n  if (wgs84Coordinates && !hasTileIndex) {\n    throw new Error('MVT Loader: WGS84 coordinates need tileIndex property');\n  }\n\n  return options.mvt;\n}\n\n/**\n * @param feature\n * @param options\n * @returns decoded feature\n */\nfunction getDecodedFeature(\n  feature: VectorTileFeatureMapBox,\n  options: MVTOptions,\n  layerName: string\n): MVTMapboxCoordinates {\n  const decodedFeature = feature.toGeoJSON(\n    options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinates\n  );\n\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = layerName;\n  }\n\n  return decodedFeature;\n}\n\n/**\n * @param feature\n * @param options\n * @returns decoded binary feature\n */\nfunction getDecodedFeatureBinary(\n  feature: VectorTileFeatureBinary,\n  options: MVTOptions,\n  layerName: string\n): FlatFeature {\n  const decodedFeature = feature.toBinaryCoordinates(\n    options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinatesBinary\n  );\n\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty && decodedFeature.properties) {\n    decodedFeature.properties[options.layerProperty] = layerName;\n  }\n\n  return decodedFeature;\n}\n\n/**\n * @param line\n * @param feature\n */\nfunction transformToLocalCoordinates(line: number[], feature: {extent: any}): void {\n  // This function transforms local coordinates in a\n  // [0 - bufferSize, this.extent + bufferSize] range to a\n  // [0 - (bufferSize / this.extent), 1 + (bufferSize / this.extent)] range.\n  // The resulting extent would be 1.\n  const {extent} = feature;\n  for (let i = 0; i < line.length; i++) {\n    const p = line[i];\n    p[0] /= extent;\n    p[1] /= extent;\n  }\n}\n\nfunction transformToLocalCoordinatesBinary(data: number[], feature: {extent: any}) {\n  // For the binary code path, the feature data is just\n  // one big flat array, so we just divide each value\n  const {extent} = feature;\n  for (let i = 0, il = data.length; i < il; ++i) {\n    data[i] /= extent;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}