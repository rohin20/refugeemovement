{"ast":null,"code":"import _regeneratorRuntime from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncIterator from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport _awaitAsyncGenerator from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport { isBrowser, toArrayBuffer } from '@loaders.gl/loader-utils';\nexport function makeStreamIterator(stream, options) {\n  return isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);\n}\nfunction makeBrowserStreamIterator(_x, _x2) {\n  return _makeBrowserStreamIterator.apply(this, arguments);\n}\nfunction _makeBrowserStreamIterator() {\n  _makeBrowserStreamIterator = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(stream, options) {\n    var reader, nextBatchPromise, currentBatchPromise, _yield$_awaitAsyncGen, done, value;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          reader = stream.getReader();\n          _context.prev = 1;\n        case 2:\n          if (!true) {\n            _context.next = 16;\n            break;\n          }\n          currentBatchPromise = nextBatchPromise || reader.read();\n          if (options !== null && options !== void 0 && options._streamReadAhead) {\n            nextBatchPromise = reader.read();\n          }\n          _context.next = 7;\n          return _awaitAsyncGenerator(currentBatchPromise);\n        case 7:\n          _yield$_awaitAsyncGen = _context.sent;\n          done = _yield$_awaitAsyncGen.done;\n          value = _yield$_awaitAsyncGen.value;\n          if (!done) {\n            _context.next = 12;\n            break;\n          }\n          return _context.abrupt(\"return\");\n        case 12:\n          _context.next = 14;\n          return toArrayBuffer(value);\n        case 14:\n          _context.next = 2;\n          break;\n        case 16:\n          _context.next = 21;\n          break;\n        case 18:\n          _context.prev = 18;\n          _context.t0 = _context[\"catch\"](1);\n          reader.releaseLock();\n        case 21:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[1, 18]]);\n  }));\n  return _makeBrowserStreamIterator.apply(this, arguments);\n}\nfunction makeNodeStreamIterator(_x3, _x4) {\n  return _makeNodeStreamIterator.apply(this, arguments);\n}\nfunction _makeNodeStreamIterator() {\n  _makeNodeStreamIterator = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(stream, options) {\n    var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context2.prev = 2;\n          _iterator = _asyncIterator(stream);\n        case 4:\n          _context2.next = 6;\n          return _awaitAsyncGenerator(_iterator.next());\n        case 6:\n          if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n            _context2.next = 13;\n            break;\n          }\n          chunk = _step.value;\n          _context2.next = 10;\n          return toArrayBuffer(chunk);\n        case 10:\n          _iteratorAbruptCompletion = false;\n          _context2.next = 4;\n          break;\n        case 13:\n          _context2.next = 19;\n          break;\n        case 15:\n          _context2.prev = 15;\n          _context2.t0 = _context2[\"catch\"](2);\n          _didIteratorError = true;\n          _iteratorError = _context2.t0;\n        case 19:\n          _context2.prev = 19;\n          _context2.prev = 20;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context2.next = 24;\n            break;\n          }\n          _context2.next = 24;\n          return _awaitAsyncGenerator(_iterator.return());\n        case 24:\n          _context2.prev = 24;\n          if (!_didIteratorError) {\n            _context2.next = 27;\n            break;\n          }\n          throw _iteratorError;\n        case 27:\n          return _context2.finish(24);\n        case 28:\n          return _context2.finish(19);\n        case 29:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[2, 15, 19, 29], [20,, 24, 28]]);\n  }));\n  return _makeNodeStreamIterator.apply(this, arguments);\n}","map":{"version":3,"names":["isBrowser","toArrayBuffer","makeStreamIterator","stream","options","makeBrowserStreamIterator","makeNodeStreamIterator","_x","_x2","_makeBrowserStreamIterator","apply","arguments","_wrapAsyncGenerator","_regeneratorRuntime","mark","_callee","reader","nextBatchPromise","currentBatchPromise","_yield$_awaitAsyncGen","done","value","wrap","_callee$","_context","prev","next","getReader","read","_streamReadAhead","_awaitAsyncGenerator","sent","abrupt","t0","releaseLock","stop","_x3","_x4","_makeNodeStreamIterator","_callee2","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","chunk","_callee2$","_context2","_asyncIterator","return","finish"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/processors/node_modules/@loaders.gl/core/src/iterators/make-iterator/make-stream-iterator.ts"],"sourcesContent":["import type {Readable} from 'stream';\nimport {isBrowser, toArrayBuffer} from '@loaders.gl/loader-utils';\n\nexport type StreamIteratorOptions = {\n  _streamReadAhead?: boolean;\n};\n\n/**\n * Returns an async iterable that reads from a stream (works in both Node.js and browsers)\n * @param stream stream to iterator over\n */\nexport function makeStreamIterator(\n  stream: ReadableStream | Readable,\n  options?: StreamIteratorOptions\n): AsyncIterable<ArrayBuffer> {\n  return isBrowser\n    ? makeBrowserStreamIterator(stream as ReadableStream, options)\n    : makeNodeStreamIterator(stream as Readable, options);\n}\n\n/**\n * Returns an async iterable that reads from a DOM (browser) stream\n * @param stream stream to iterate from\n * @see https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate\n */\nasync function* makeBrowserStreamIterator(\n  stream: ReadableStream,\n  options?: StreamIteratorOptions\n): AsyncIterable<ArrayBuffer> {\n  // WhatWG: stream is supposed to have a `getIterator` method\n  // if (typeof stream.getIterator === 'function') {\n  //   return stream.getIterator();\n  // }\n  // if (typeof stream[Symbol.asyncIterator] === 'function') {\n  //   return makeToArrayBufferIterator(stream);\n  // }\n\n  // In the browser, we first need to get a lock on the stream\n  const reader = stream.getReader();\n\n  let nextBatchPromise: Promise<{done?: boolean; value?: Uint8Array}> | undefined;\n\n  try {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const currentBatchPromise = nextBatchPromise || reader.read();\n      // Issue a read for an additional batch, while we await the next batch\n      // Idea is to make fetching happen in parallel with processing / parsing\n      if (options?._streamReadAhead) {\n        nextBatchPromise = reader.read();\n      }\n      // Read from the stream\n      // value is a Uint8Array\n      const {done, value} = await currentBatchPromise;\n      // Exit if we're done\n      if (done) {\n        return;\n      }\n      // Else yield the chunk\n      yield toArrayBuffer(value);\n    }\n  } catch (error) {\n    // TODO - examples makes it look like this should always be called,\n    // but that generates exceptions so only call it if we do not reach the end\n    reader.releaseLock();\n  }\n}\n\n/**\n * Returns an async iterable that reads from a DOM (browser) stream\n * @param stream stream to iterate from\n * @note Requires Node.js >= 10\n */\nasync function* makeNodeStreamIterator(\n  stream: Readable,\n  options?: StreamIteratorOptions\n): AsyncIterable<ArrayBuffer> {\n  // Hacky test for node version to ensure we don't call bad polyfills\n  // NODE 10+: stream is an asyncIterator\n  for await (const chunk of stream) {\n    yield toArrayBuffer(chunk); // Coerce each chunk to ArrayBuffer\n  }\n}\n/* TODO - remove NODE < 10\n * @see https://github.com/bustle/streaming-iterables, MIT license\n *\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return;\n  }\n\n  // TODO - check if is this ever used in Node 10+?\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const data = stream.read();\n    if (data !== null) {\n      yield toArrayBuffer(data);\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (stream._readableState?.ended) {\n      return;\n    }\n    await onceReadable(stream);\n  }\n\nasync function onceReadable(stream: Readable): Promise<any> {\n  return new Promise((resolve) => {\n    stream.once('readable', resolve);\n  });\n}\n  */\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}