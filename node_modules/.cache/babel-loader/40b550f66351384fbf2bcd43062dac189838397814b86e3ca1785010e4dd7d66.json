{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Vector3, assert } from '@math.gl/core';\nimport { INTERSECTION } from '../constants';\nimport Plane from './plane';\nvar faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];\nvar scratchPlaneCenter = new Vector3();\nvar scratchPlaneNormal = new Vector3();\nvar scratchPlane = new Plane(new Vector3(1.0, 0.0, 0.0), 0.0);\nvar CullingVolume = /*#__PURE__*/function () {\n  function CullingVolume() {\n    var planes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    _classCallCheck(this, CullingVolume);\n    _defineProperty(this, \"planes\", void 0);\n    this.planes = planes;\n  }\n  _createClass(CullingVolume, [{\n    key: \"fromBoundingSphere\",\n    value: function fromBoundingSphere(boundingSphere) {\n      this.planes.length = 2 * faces.length;\n      var center = boundingSphere.center;\n      var radius = boundingSphere.radius;\n      var planeIndex = 0;\n      for (var _i = 0, _faces = faces; _i < _faces.length; _i++) {\n        var faceNormal = _faces[_i];\n        var plane0 = this.planes[planeIndex];\n        var plane1 = this.planes[planeIndex + 1];\n        if (!plane0) {\n          plane0 = this.planes[planeIndex] = new Plane();\n        }\n        if (!plane1) {\n          plane1 = this.planes[planeIndex + 1] = new Plane();\n        }\n        var plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n        var plane0Distance = -faceNormal.dot(plane0Center);\n        plane0.fromPointNormal(plane0Center, faceNormal);\n        var plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n        var negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n        var plane1Distance = -negatedFaceNormal.dot(plane1Center);\n        plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n        planeIndex += 2;\n      }\n      return this;\n    }\n  }, {\n    key: \"computeVisibility\",\n    value: function computeVisibility(boundingVolume) {\n      var intersect = INTERSECTION.INSIDE;\n      var _iterator = _createForOfIteratorHelper(this.planes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var plane = _step.value;\n          var result = boundingVolume.intersectPlane(plane);\n          switch (result) {\n            case INTERSECTION.OUTSIDE:\n              return INTERSECTION.OUTSIDE;\n            case INTERSECTION.INTERSECTING:\n              intersect = INTERSECTION.INTERSECTING;\n              break;\n            default:\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return intersect;\n    }\n  }, {\n    key: \"computeVisibilityWithPlaneMask\",\n    value: function computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {\n      assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n      if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {\n        return parentPlaneMask;\n      }\n      var mask = CullingVolume.MASK_INSIDE;\n      var planes = this.planes;\n      for (var k = 0; k < this.planes.length; ++k) {\n        var flag = k < 31 ? 1 << k : 0;\n        if (k < 31 && (parentPlaneMask & flag) === 0) {\n          continue;\n        }\n        var plane = planes[k];\n        var result = boundingVolume.intersectPlane(plane);\n        if (result === INTERSECTION.OUTSIDE) {\n          return CullingVolume.MASK_OUTSIDE;\n        } else if (result === INTERSECTION.INTERSECTING) {\n          mask |= flag;\n        }\n      }\n      return mask;\n    }\n  }]);\n  return CullingVolume;\n}();\nexport { CullingVolume as default };\n_defineProperty(CullingVolume, \"MASK_OUTSIDE\", 0xffffffff);\n_defineProperty(CullingVolume, \"MASK_INSIDE\", 0x00000000);\n_defineProperty(CullingVolume, \"MASK_INDETERMINATE\", 0x7fffffff);","map":{"version":3,"names":["Vector3","assert","INTERSECTION","Plane","faces","scratchPlaneCenter","scratchPlaneNormal","scratchPlane","CullingVolume","planes","arguments","length","undefined","_classCallCheck","_defineProperty","_createClass","key","value","fromBoundingSphere","boundingSphere","center","radius","planeIndex","_i","_faces","faceNormal","plane0","plane1","plane0Center","copy","scale","add","plane0Distance","dot","fromPointNormal","plane1Center","negatedFaceNormal","negate","plane1Distance","computeVisibility","boundingVolume","intersect","INSIDE","_iterator","_createForOfIteratorHelper","_step","s","n","done","plane","result","intersectPlane","OUTSIDE","INTERSECTING","err","e","f","computeVisibilityWithPlaneMask","parentPlaneMask","Number","isFinite","MASK_OUTSIDE","MASK_INSIDE","mask","k","flag","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@math.gl/culling/src/lib/culling-volume.ts"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, assert} from '@math.gl/core';\nimport {INTERSECTION} from '../constants';\nimport Plane from './plane';\nimport type {BoundingVolume} from './bounding-volumes/bounding-volume';\nimport type BoundingSphere from './bounding-volumes/bounding-sphere';\n\n// X, Y, Z Unit vectors\nconst faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];\n\nconst scratchPlaneCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\nconst scratchPlane = new Plane(new Vector3(1.0, 0.0, 0.0), 0.0);\n\n/** A culling volume defined by planes. */\nexport default class CullingVolume {\n  /**\n   * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n   * represents the case where the object bounding volume is entirely outside the culling volume.\n   */\n  static MASK_OUTSIDE = 0xffffffff;\n\n  /**\n   * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n   * represents the case where the object bounding volume is entirely inside the culling volume.\n   */\n  static MASK_INSIDE = 0x00000000;\n\n  /**\n   * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n   * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n   */\n  static MASK_INDETERMINATE = 0x7fffffff;\n\n  /** Array of clipping planes. */\n  readonly planes: Plane[];\n\n  /**\n   * Create a new `CullingVolume` bounded by an array of clipping planed\n   * @param planes Array of clipping planes.\n   * */\n  constructor(planes: Plane[] = []) {\n    this.planes = planes;\n  }\n\n  /**\n   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n   * The planes are aligned to the x, y, and z axes in world coordinates.\n   */\n  fromBoundingSphere(boundingSphere: BoundingSphere): CullingVolume {\n    this.planes.length = 2 * faces.length;\n\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n\n    let planeIndex = 0;\n\n    for (const faceNormal of faces) {\n      let plane0 = this.planes[planeIndex];\n      let plane1 = this.planes[planeIndex + 1];\n\n      if (!plane0) {\n        plane0 = this.planes[planeIndex] = new Plane();\n      }\n      if (!plane1) {\n        plane1 = this.planes[planeIndex + 1] = new Plane();\n      }\n\n      const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n      const plane0Distance = -faceNormal.dot(plane0Center);\n\n      plane0.fromPointNormal(plane0Center, faceNormal);\n\n      const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n\n      const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n\n      const plane1Distance = -negatedFaceNormal.dot(plane1Center);\n\n      plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n\n      planeIndex += 2;\n    }\n\n    return this;\n  }\n\n  /** Determines whether a bounding volume intersects the culling volume. */\n  computeVisibility(boundingVolume: BoundingVolume): number {\n    // const planes = this.planes;\n    let intersect: number = INTERSECTION.INSIDE;\n    for (const plane of this.planes) {\n      const result = boundingVolume.intersectPlane(plane);\n      switch (result) {\n        case INTERSECTION.OUTSIDE:\n          // We are done\n          return INTERSECTION.OUTSIDE;\n\n        case INTERSECTION.INTERSECTING:\n          // If no other intersection is outside, return INTERSECTING\n          intersect = INTERSECTION.INTERSECTING;\n          break;\n\n        default:\n      }\n    }\n\n    return intersect;\n  }\n\n  /**\n   * Determines whether a bounding volume intersects the culling volume.\n   *\n   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n   *   the parent (and therefore this) volume is completely inside plane[planeIndex]\n   *   and that plane check can be skipped.\n   */\n  computeVisibilityWithPlaneMask(boundingVolume: BoundingVolume, parentPlaneMask: number): number {\n    assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n    if (\n      parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n      parentPlaneMask === CullingVolume.MASK_INSIDE\n    ) {\n      // parent is completely outside or completely inside, so this child is as well.\n      return parentPlaneMask;\n    }\n\n    // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n    // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n    let mask = CullingVolume.MASK_INSIDE;\n\n    const planes = this.planes;\n    for (let k = 0; k < this.planes.length; ++k) {\n      // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n      const flag = k < 31 ? 1 << k : 0;\n      if (k < 31 && (parentPlaneMask & flag) === 0) {\n        // boundingVolume is known to be INSIDE this plane.\n        continue;\n      }\n\n      const plane = planes[k];\n      const result = boundingVolume.intersectPlane(plane);\n      if (result === INTERSECTION.OUTSIDE) {\n        return CullingVolume.MASK_OUTSIDE;\n      } else if (result === INTERSECTION.INTERSECTING) {\n        mask |= flag;\n      }\n    }\n\n    return mask;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}