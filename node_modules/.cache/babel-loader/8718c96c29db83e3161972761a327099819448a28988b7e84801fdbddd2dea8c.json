{"ast":null,"code":"import _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { h3ToGeoBoundary, h3GetResolution, h3ToGeo, geoToH3, h3IsPentagon, h3Distance, edgeLength } from 'h3-js';\nimport { lerp } from '@math.gl/core';\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport { ColumnLayer, PolygonLayer } from '@deck.gl/layers';\nvar UPDATE_THRESHOLD_KM = 10;\nexport function normalizeLongitudes(vertices, refLng) {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n  var _iterator = _createForOfIteratorHelper(vertices),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var pt = _step.value;\n      var deltaLng = pt[0] - refLng;\n      if (deltaLng > 180) {\n        pt[0] -= 360;\n      } else if (deltaLng < -180) {\n        pt[0] += 360;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nexport function scalePolygon(hexId, vertices, factor) {\n  var _h3ToGeo = h3ToGeo(hexId),\n    _h3ToGeo2 = _slicedToArray(_h3ToGeo, 2),\n    lat = _h3ToGeo2[0],\n    lng = _h3ToGeo2[1];\n  var actualCount = vertices.length;\n  normalizeLongitudes(vertices, lng);\n  var vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n  for (var i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\nfunction getHexagonCentroid(getHexagon, object, objectInfo) {\n  var hexagonId = getHexagon(object, objectInfo);\n  var _h3ToGeo3 = h3ToGeo(hexagonId),\n    _h3ToGeo4 = _slicedToArray(_h3ToGeo3, 2),\n    lat = _h3ToGeo4[0],\n    lng = _h3ToGeo4[1];\n  return [lng, lat];\n}\nfunction h3ToPolygon(hexId) {\n  var coverage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var vertices = h3ToGeoBoundary(hexId, true);\n  if (coverage !== 1) {\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    normalizeLongitudes(vertices);\n  }\n  return vertices;\n}\nfunction flattenPolygon(vertices) {\n  var positions = new Float64Array(vertices.length * 2);\n  var i = 0;\n  var _iterator2 = _createForOfIteratorHelper(vertices),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var pt = _step2.value;\n      positions[i++] = pt[0];\n      positions[i++] = pt[1];\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return positions;\n}\nfunction mergeTriggers(getHexagon, coverage) {\n  var trigger;\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (typeof getHexagon === 'object') {\n    trigger = _objectSpread(_objectSpread({}, getHexagon), {}, {\n      coverage: coverage\n    });\n  } else {\n    trigger = {\n      getHexagon: getHexagon,\n      coverage: coverage\n    };\n  }\n  return trigger;\n}\nvar defaultProps = _objectSpread(_objectSpread({}, PolygonLayer.defaultProps), {}, {\n  highPrecision: 'auto',\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  centerHexagon: null,\n  getHexagon: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.hexagon;\n    }\n  },\n  extruded: true\n});\nvar H3HexagonLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(H3HexagonLayer, _CompositeLayer);\n  var _super = _createSuper(H3HexagonLayer);\n  function H3HexagonLayer() {\n    var _this;\n    _classCallCheck(this, H3HexagonLayer);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"state\", void 0);\n    return _this;\n  }\n  _createClass(H3HexagonLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      H3HexagonLayer._checkH3Lib();\n      this.state = {\n        edgeLengthKM: 0,\n        resolution: -1\n      };\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var props = _ref2.props,\n        changeFlags = _ref2.changeFlags;\n      if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {\n        var dataProps = this._calculateH3DataProps();\n        this.setState(dataProps);\n      }\n      this._updateVertices(this.context.viewport);\n    }\n  }, {\n    key: \"_calculateH3DataProps\",\n    value: function _calculateH3DataProps() {\n      var resolution = -1;\n      var hasPentagon = false;\n      var hasMultipleRes = false;\n      var _createIterable = createIterable(this.props.data),\n        iterable = _createIterable.iterable,\n        objectInfo = _createIterable.objectInfo;\n      var _iterator3 = _createForOfIteratorHelper(iterable),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var object = _step3.value;\n          objectInfo.index++;\n          var hexId = this.props.getHexagon(object, objectInfo);\n          var hexResolution = h3GetResolution(hexId);\n          if (resolution < 0) {\n            resolution = hexResolution;\n            if (!this.props.highPrecision) break;\n          } else if (resolution !== hexResolution) {\n            hasMultipleRes = true;\n            break;\n          }\n          if (h3IsPentagon(hexId)) {\n            hasPentagon = true;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return {\n        resolution: resolution,\n        edgeLengthKM: resolution >= 0 ? edgeLength(resolution, 'km') : 0,\n        hasMultipleRes: hasMultipleRes,\n        hasPentagon: hasPentagon\n      };\n    }\n  }, {\n    key: \"_shouldUseHighPrecision\",\n    value: function _shouldUseHighPrecision() {\n      if (this.props.highPrecision === 'auto') {\n        var _this$state = this.state,\n          resolution = _this$state.resolution,\n          hasPentagon = _this$state.hasPentagon,\n          hasMultipleRes = _this$state.hasMultipleRes;\n        var viewport = this.context.viewport;\n        return Boolean(viewport === null || viewport === void 0 ? void 0 : viewport.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;\n      }\n      return this.props.highPrecision;\n    }\n  }, {\n    key: \"_updateVertices\",\n    value: function _updateVertices(viewport) {\n      if (this._shouldUseHighPrecision()) {\n        return;\n      }\n      var _this$state2 = this.state,\n        resolution = _this$state2.resolution,\n        edgeLengthKM = _this$state2.edgeLengthKM,\n        centerHex = _this$state2.centerHex;\n      if (resolution < 0) {\n        return;\n      }\n      var hex = this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);\n      if (centerHex === hex) {\n        return;\n      }\n      if (centerHex) {\n        var distance = h3Distance(centerHex, hex);\n        if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n          return;\n        }\n      }\n      var unitsPerMeter = viewport.distanceScales.unitsPerMeter;\n      var vertices = h3ToPolygon(hex);\n      var _h3ToGeo5 = h3ToGeo(hex),\n        _h3ToGeo6 = _slicedToArray(_h3ToGeo5, 2),\n        centerLat = _h3ToGeo6[0],\n        centerLng = _h3ToGeo6[1];\n      var _viewport$projectFlat = viewport.projectFlat([centerLng, centerLat]),\n        _viewport$projectFlat2 = _slicedToArray(_viewport$projectFlat, 2),\n        centerX = _viewport$projectFlat2[0],\n        centerY = _viewport$projectFlat2[1];\n      vertices = vertices.map(function (p) {\n        var worldPosition = viewport.projectFlat(p);\n        return [(worldPosition[0] - centerX) / unitsPerMeter[0], (worldPosition[1] - centerY) / unitsPerMeter[1]];\n      });\n      this.setState({\n        centerHex: hex,\n        vertices: vertices\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n    }\n  }, {\n    key: \"_getForwardProps\",\n    value: function _getForwardProps() {\n      var _this$props = this.props,\n        elevationScale = _this$props.elevationScale,\n        material = _this$props.material,\n        coverage = _this$props.coverage,\n        extruded = _this$props.extruded,\n        wireframe = _this$props.wireframe,\n        stroked = _this$props.stroked,\n        filled = _this$props.filled,\n        lineWidthUnits = _this$props.lineWidthUnits,\n        lineWidthScale = _this$props.lineWidthScale,\n        lineWidthMinPixels = _this$props.lineWidthMinPixels,\n        lineWidthMaxPixels = _this$props.lineWidthMaxPixels,\n        getFillColor = _this$props.getFillColor,\n        getElevation = _this$props.getElevation,\n        getLineColor = _this$props.getLineColor,\n        getLineWidth = _this$props.getLineWidth,\n        transitions = _this$props.transitions,\n        updateTriggers = _this$props.updateTriggers;\n      return {\n        elevationScale: elevationScale,\n        extruded: extruded,\n        coverage: coverage,\n        wireframe: wireframe,\n        stroked: stroked,\n        filled: filled,\n        lineWidthUnits: lineWidthUnits,\n        lineWidthScale: lineWidthScale,\n        lineWidthMinPixels: lineWidthMinPixels,\n        lineWidthMaxPixels: lineWidthMaxPixels,\n        material: material,\n        getElevation: getElevation,\n        getFillColor: getFillColor,\n        getLineColor: getLineColor,\n        getLineWidth: getLineWidth,\n        transitions: transitions,\n        updateTriggers: {\n          getFillColor: updateTriggers.getFillColor,\n          getElevation: updateTriggers.getElevation,\n          getLineColor: updateTriggers.getLineColor,\n          getLineWidth: updateTriggers.getLineWidth\n        }\n      };\n    }\n  }, {\n    key: \"_renderPolygonLayer\",\n    value: function _renderPolygonLayer() {\n      var _this$props2 = this.props,\n        data = _this$props2.data,\n        getHexagon = _this$props2.getHexagon,\n        updateTriggers = _this$props2.updateTriggers,\n        coverage = _this$props2.coverage;\n      var SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n      var forwardProps = this._getForwardProps();\n      forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n      return new SubLayerClass(forwardProps, this.getSubLayerProps({\n        id: 'hexagon-cell-hifi',\n        updateTriggers: forwardProps.updateTriggers\n      }), {\n        data: data,\n        _normalize: false,\n        _windingOrder: 'CCW',\n        positionFormat: 'XY',\n        getPolygon: function getPolygon(object, objectInfo) {\n          var hexagonId = getHexagon(object, objectInfo);\n          return flattenPolygon(h3ToPolygon(hexagonId, coverage));\n        }\n      });\n    }\n  }, {\n    key: \"_renderColumnLayer\",\n    value: function _renderColumnLayer() {\n      var _this$props3 = this.props,\n        data = _this$props3.data,\n        getHexagon = _this$props3.getHexagon,\n        updateTriggers = _this$props3.updateTriggers;\n      var SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n      var forwardProps = this._getForwardProps();\n      forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n      return new SubLayerClass(forwardProps, this.getSubLayerProps({\n        id: 'hexagon-cell',\n        flatShading: true,\n        updateTriggers: forwardProps.updateTriggers\n      }), {\n        data: data,\n        diskResolution: 6,\n        radius: 1,\n        vertices: this.state.vertices,\n        getPosition: getHexagonCentroid.bind(null, getHexagon)\n      });\n    }\n  }]);\n  return H3HexagonLayer;\n}(CompositeLayer);\nexport { H3HexagonLayer as default };\n_defineProperty(H3HexagonLayer, \"defaultProps\", defaultProps);\n_defineProperty(H3HexagonLayer, \"layerName\", 'H3HexagonLayer');\n_defineProperty(H3HexagonLayer, \"_checkH3Lib\", function () {});","map":{"version":3,"names":["h3ToGeoBoundary","h3GetResolution","h3ToGeo","geoToH3","h3IsPentagon","h3Distance","edgeLength","lerp","CompositeLayer","createIterable","ColumnLayer","PolygonLayer","UPDATE_THRESHOLD_KM","normalizeLongitudes","vertices","refLng","undefined","_iterator","_createForOfIteratorHelper","_step","s","n","done","pt","value","deltaLng","err","e","f","scalePolygon","hexId","factor","_h3ToGeo","_h3ToGeo2","_slicedToArray","lat","lng","actualCount","length","vertexCount","i","getHexagonCentroid","getHexagon","object","objectInfo","hexagonId","_h3ToGeo3","_h3ToGeo4","h3ToPolygon","coverage","arguments","flattenPolygon","positions","Float64Array","_iterator2","_step2","mergeTriggers","trigger","_objectSpread","defaultProps","highPrecision","type","min","max","centerHexagon","x","hexagon","extruded","H3HexagonLayer","_CompositeLayer","_inherits","_super","_createSuper","_this","_classCallCheck","_len","args","Array","_key","call","apply","concat","_defineProperty","_assertThisInitialized","_createClass","key","initializeState","_checkH3Lib","state","edgeLengthKM","resolution","shouldUpdateState","_ref","changeFlags","_shouldUseHighPrecision","propsOrDataChanged","somethingChanged","updateState","_ref2","props","dataChanged","updateTriggersChanged","dataProps","_calculateH3DataProps","setState","_updateVertices","context","viewport","hasPentagon","hasMultipleRes","_createIterable","data","iterable","_iterator3","_step3","index","hexResolution","_this$state","Boolean","_this$state2","centerHex","hex","latitude","longitude","distance","unitsPerMeter","distanceScales","_h3ToGeo5","_h3ToGeo6","centerLat","centerLng","_viewport$projectFlat","projectFlat","_viewport$projectFlat2","centerX","centerY","map","p","worldPosition","renderLayers","_renderPolygonLayer","_renderColumnLayer","_getForwardProps","_this$props","elevationScale","material","wireframe","stroked","filled","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","getFillColor","getElevation","getLineColor","getLineWidth","transitions","updateTriggers","_this$props2","SubLayerClass","getSubLayerClass","forwardProps","getPolygon","getSubLayerProps","id","_normalize","_windingOrder","positionFormat","_this$props3","getPosition","flatShading","diskResolution","radius","bind","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/geo-layers/src/h3-layers/h3-hexagon-layer.ts"],"sourcesContent":["import {\n  h3ToGeoBoundary,\n  h3GetResolution,\n  h3ToGeo,\n  geoToH3,\n  h3IsPentagon,\n  h3Distance,\n  edgeLength,\n  H3Index\n} from 'h3-js';\nimport {lerp} from '@math.gl/core';\nimport {\n  AccessorFunction,\n  CompositeLayer,\n  CompositeLayerProps,\n  createIterable,\n  Layer,\n  LayersList,\n  UpdateParameters,\n  WebMercatorViewport,\n  DefaultProps\n} from '@deck.gl/core';\nimport {ColumnLayer, PolygonLayer, PolygonLayerProps} from '@deck.gl/layers';\n\n// There is a cost to updating the instanced geometries when using highPrecision: false\n// This constant defines the distance between two hexagons that leads to \"significant\n// distortion.\" Smaller value makes the column layer more sensitive to viewport change.\nconst UPDATE_THRESHOLD_KM = 10;\n\n// normalize longitudes w.r.t center (refLng), when not provided first vertex\nexport function normalizeLongitudes(vertices: number[][], refLng?: number): void {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n  for (const pt of vertices) {\n    const deltaLng = pt[0] - refLng;\n    if (deltaLng > 180) {\n      pt[0] -= 360;\n    } else if (deltaLng < -180) {\n      pt[0] += 360;\n    }\n  }\n}\n\n// scale polygon vertices w.r.t center (hexId)\nexport function scalePolygon(hexId: H3Index, vertices: number[][], factor: number): void {\n  const [lat, lng] = h3ToGeo(hexId);\n  const actualCount = vertices.length;\n\n  // normalize with respect to center\n  normalizeLongitudes(vertices, lng);\n\n  // `h3ToGeoBoundary` returns same array object for first and last vertex (closed polygon),\n  // if so skip scaling the last vertex\n  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n  for (let i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\n\nfunction getHexagonCentroid(getHexagon, object, objectInfo) {\n  const hexagonId = getHexagon(object, objectInfo);\n  const [lat, lng] = h3ToGeo(hexagonId);\n  return [lng, lat];\n}\n\nfunction h3ToPolygon(hexId: H3Index, coverage: number = 1): number[][] {\n  const vertices = h3ToGeoBoundary(hexId, true);\n\n  if (coverage !== 1) {\n    // scale and normalize vertices w.r.t to center\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    // normalize w.r.t to start vertex\n    normalizeLongitudes(vertices);\n  }\n\n  return vertices;\n}\n\nfunction flattenPolygon(vertices: number[][]): Float64Array {\n  const positions = new Float64Array(vertices.length * 2);\n  let i = 0;\n  for (const pt of vertices) {\n    positions[i++] = pt[0];\n    positions[i++] = pt[1];\n  }\n  return positions;\n}\n\nfunction mergeTriggers(getHexagon, coverage) {\n  let trigger;\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (typeof getHexagon === 'object') {\n    trigger = {...getHexagon, coverage};\n  } else {\n    trigger = {getHexagon, coverage};\n  }\n  return trigger;\n}\n\nconst defaultProps: DefaultProps<H3HexagonLayerProps> = {\n  ...PolygonLayer.defaultProps,\n  highPrecision: 'auto',\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  centerHexagon: null,\n  getHexagon: {type: 'accessor', value: x => x.hexagon},\n  extruded: true\n};\n\n/** All properties supported by H3HexagonLayer */\nexport type H3HexagonLayerProps<DataT = any> = _H3HexagonLayerProps<DataT> &\n  PolygonLayerProps<DataT> &\n  CompositeLayerProps<DataT>;\n\n/** Props added by the H3HexagonLayer */\ntype _H3HexagonLayerProps<DataT> = {\n  /**\n   * Whether or not draw hexagons with high precision.\n   * @default 'auto'\n   */\n  highPrecision?: boolean | 'auto';\n  /**\n   * Coverage of hexagon in cell.\n   * @default 1\n   */\n  coverage?: number;\n  /**\n   * Center hexagon that best represents the shape of the set. If not specified, the hexagon closest to the center of the viewport is used.\n   */\n  centerHexagon?: H3Index | null;\n  /**\n   * Called for each data object to retrieve the quadkey string identifier.\n   *\n   * By default, it reads `hexagon` property of data object.\n   */\n  getHexagon?: AccessorFunction<DataT, string>;\n  /**\n   * Whether to extrude polygons.\n   * @default true\n   */\n  extruded?: boolean;\n};\n\n/**\n * Render hexagons from the [H3](https://h3geo.org/) geospatial indexing system.\n */\nexport default class H3HexagonLayer<DataT = any, ExtraPropsT = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_H3HexagonLayerProps<DataT> & Required<PolygonLayerProps<DataT>>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'H3HexagonLayer';\n\n  // See `main/bundle.ts`\n  static _checkH3Lib = () => {};\n\n  initializeState() {\n    H3HexagonLayer._checkH3Lib();\n    this.state = {\n      edgeLengthKM: 0,\n      resolution: -1\n    };\n  }\n\n  state!: {\n    centerHex?: H3Index;\n    edgeLengthKM: number;\n    hasMultipleRes?: boolean;\n    hasPentagon?: boolean;\n    resolution: number;\n    vertices?: number[][];\n  };\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>): boolean {\n    return this._shouldUseHighPrecision()\n      ? changeFlags.propsOrDataChanged\n      : changeFlags.somethingChanged;\n  }\n\n  updateState({props, changeFlags}: UpdateParameters<this>): void {\n    if (\n      props.highPrecision !== true &&\n      (changeFlags.dataChanged ||\n        (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon))\n    ) {\n      const dataProps = this._calculateH3DataProps();\n      this.setState(dataProps);\n    }\n\n    this._updateVertices(this.context.viewport as WebMercatorViewport);\n  }\n\n  private _calculateH3DataProps() {\n    let resolution = -1;\n    let hasPentagon = false;\n    let hasMultipleRes = false;\n\n    const {iterable, objectInfo} = createIterable(this.props.data);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const hexId = this.props.getHexagon(object, objectInfo);\n      // Take the resolution of the first hex\n      const hexResolution = h3GetResolution(hexId);\n      if (resolution < 0) {\n        resolution = hexResolution;\n        if (!this.props.highPrecision) break;\n      } else if (resolution !== hexResolution) {\n        hasMultipleRes = true;\n        break;\n      }\n      if (h3IsPentagon(hexId)) {\n        hasPentagon = true;\n        break;\n      }\n    }\n\n    return {\n      resolution,\n      edgeLengthKM: resolution >= 0 ? edgeLength(resolution, 'km') : 0,\n      hasMultipleRes,\n      hasPentagon\n    };\n  }\n\n  private _shouldUseHighPrecision(): boolean {\n    if (this.props.highPrecision === 'auto') {\n      const {resolution, hasPentagon, hasMultipleRes} = this.state;\n      const {viewport} = this.context;\n      return (\n        Boolean(viewport?.resolution) ||\n        hasMultipleRes ||\n        hasPentagon ||\n        (resolution >= 0 && resolution <= 5)\n      );\n    }\n\n    return this.props.highPrecision;\n  }\n\n  private _updateVertices(viewport: WebMercatorViewport): void {\n    if (this._shouldUseHighPrecision()) {\n      return;\n    }\n    const {resolution, edgeLengthKM, centerHex} = this.state;\n    if (resolution < 0) {\n      return;\n    }\n    const hex =\n      this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);\n    if (centerHex === hex) {\n      return;\n    }\n    if (centerHex) {\n      const distance = h3Distance(centerHex, hex);\n      // h3Distance returns a negative number if the distance could not be computed\n      // due to the two indexes very far apart or on opposite sides of a pentagon.\n      if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n        return;\n      }\n    }\n\n    const {unitsPerMeter} = viewport.distanceScales;\n\n    let vertices = h3ToPolygon(hex);\n    const [centerLat, centerLng] = h3ToGeo(hex);\n\n    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);\n    vertices = vertices.map(p => {\n      const worldPosition = viewport.projectFlat(p);\n      return [\n        (worldPosition[0] - centerX) / unitsPerMeter[0],\n        (worldPosition[1] - centerY) / unitsPerMeter[1]\n      ];\n    });\n\n    this.setState({centerHex: hex, vertices});\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n  }\n\n  private _getForwardProps() {\n    const {\n      elevationScale,\n      material,\n      coverage,\n      extruded,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      getFillColor,\n      getElevation,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers\n    } = this.props;\n\n    return {\n      elevationScale,\n      extruded,\n      coverage,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      material,\n      getElevation,\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers: {\n        getFillColor: updateTriggers.getFillColor,\n        getElevation: updateTriggers.getElevation,\n        getLineColor: updateTriggers.getLineColor,\n        getLineWidth: updateTriggers.getLineWidth\n      } as {\n        getFillColor: any;\n        getElevation: any;\n        getLineColor: any;\n        getLineWidth: any;\n        getPolygon?: any;\n        getPosition?: any;\n      }\n    };\n  }\n\n  private _renderPolygonLayer(): PolygonLayer {\n    const {data, getHexagon, updateTriggers, coverage} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell-hifi',\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        _normalize: false,\n        _windingOrder: 'CCW',\n        positionFormat: 'XY',\n        getPolygon: (object, objectInfo) => {\n          const hexagonId = getHexagon(object, objectInfo);\n          return flattenPolygon(h3ToPolygon(hexagonId, coverage));\n        }\n      }\n    );\n  }\n\n  private _renderColumnLayer(): ColumnLayer {\n    const {data, getHexagon, updateTriggers} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell',\n        flatShading: true,\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        diskResolution: 6, // generate an extruded hexagon as the base geometry\n        radius: 1,\n        vertices: this.state.vertices,\n        getPosition: getHexagonCentroid.bind(null, getHexagon)\n      }\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}