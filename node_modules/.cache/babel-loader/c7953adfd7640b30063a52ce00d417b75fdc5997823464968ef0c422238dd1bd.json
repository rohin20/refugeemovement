{"ast":null,"code":"import _regeneratorRuntime from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { isMobile } from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\nvar WorkerPool = /*#__PURE__*/function () {\n  function WorkerPool(props) {\n    _classCallCheck(this, WorkerPool);\n    _defineProperty(this, \"name\", 'unnamed');\n    _defineProperty(this, \"source\", void 0);\n    _defineProperty(this, \"url\", void 0);\n    _defineProperty(this, \"maxConcurrency\", 1);\n    _defineProperty(this, \"maxMobileConcurrency\", 1);\n    _defineProperty(this, \"onDebug\", function () {});\n    _defineProperty(this, \"reuseWorkers\", true);\n    _defineProperty(this, \"props\", {});\n    _defineProperty(this, \"jobQueue\", []);\n    _defineProperty(this, \"idleQueue\", []);\n    _defineProperty(this, \"count\", 0);\n    _defineProperty(this, \"isDestroyed\", false);\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n  _createClass(WorkerPool, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.idleQueue.forEach(function (worker) {\n        return worker.destroy();\n      });\n      this.isDestroyed = true;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      this.props = _objectSpread(_objectSpread({}, this.props), props);\n      if (props.name !== undefined) {\n        this.name = props.name;\n      }\n      if (props.maxConcurrency !== undefined) {\n        this.maxConcurrency = props.maxConcurrency;\n      }\n      if (props.maxMobileConcurrency !== undefined) {\n        this.maxMobileConcurrency = props.maxMobileConcurrency;\n      }\n      if (props.reuseWorkers !== undefined) {\n        this.reuseWorkers = props.reuseWorkers;\n      }\n      if (props.onDebug !== undefined) {\n        this.onDebug = props.onDebug;\n      }\n    }\n  }, {\n    key: \"startJob\",\n    value: function () {\n      var _startJob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(name) {\n        var _this = this;\n        var onMessage,\n          onError,\n          startPromise,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              onMessage = _args.length > 1 && _args[1] !== undefined ? _args[1] : function (job, type, data) {\n                return job.done(data);\n              };\n              onError = _args.length > 2 && _args[2] !== undefined ? _args[2] : function (job, error) {\n                return job.error(error);\n              };\n              startPromise = new Promise(function (onStart) {\n                _this.jobQueue.push({\n                  name: name,\n                  onMessage: onMessage,\n                  onError: onError,\n                  onStart: onStart\n                });\n                return _this;\n              });\n              this._startQueuedJob();\n              _context.next = 6;\n              return startPromise;\n            case 6:\n              return _context.abrupt(\"return\", _context.sent);\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function startJob(_x) {\n        return _startJob.apply(this, arguments);\n      }\n      return startJob;\n    }()\n  }, {\n    key: \"_startQueuedJob\",\n    value: function () {\n      var _startQueuedJob2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var workerThread, queuedJob, job;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (this.jobQueue.length) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 2:\n              workerThread = this._getAvailableWorker();\n              if (workerThread) {\n                _context2.next = 5;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 5:\n              queuedJob = this.jobQueue.shift();\n              if (!queuedJob) {\n                _context2.next = 18;\n                break;\n              }\n              this.onDebug({\n                message: 'Starting job',\n                name: queuedJob.name,\n                workerThread: workerThread,\n                backlog: this.jobQueue.length\n              });\n              job = new WorkerJob(queuedJob.name, workerThread);\n              workerThread.onMessage = function (data) {\n                return queuedJob.onMessage(job, data.type, data.payload);\n              };\n              workerThread.onError = function (error) {\n                return queuedJob.onError(job, error);\n              };\n              queuedJob.onStart(job);\n              _context2.prev = 12;\n              _context2.next = 15;\n              return job.result;\n            case 15:\n              _context2.prev = 15;\n              this.returnWorkerToQueue(workerThread);\n              return _context2.finish(15);\n            case 18:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[12,, 15, 18]]);\n      }));\n      function _startQueuedJob() {\n        return _startQueuedJob2.apply(this, arguments);\n      }\n      return _startQueuedJob;\n    }()\n  }, {\n    key: \"returnWorkerToQueue\",\n    value: function returnWorkerToQueue(worker) {\n      var shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n      if (shouldDestroyWorker) {\n        worker.destroy();\n        this.count--;\n      } else {\n        this.idleQueue.push(worker);\n      }\n      if (!this.isDestroyed) {\n        this._startQueuedJob();\n      }\n    }\n  }, {\n    key: \"_getAvailableWorker\",\n    value: function _getAvailableWorker() {\n      if (this.idleQueue.length > 0) {\n        return this.idleQueue.shift() || null;\n      }\n      if (this.count < this._getMaxConcurrency()) {\n        this.count++;\n        var name = \"\".concat(this.name.toLowerCase(), \" (#\").concat(this.count, \" of \").concat(this.maxConcurrency, \")\");\n        return new WorkerThread({\n          name: name,\n          source: this.source,\n          url: this.url\n        });\n      }\n      return null;\n    }\n  }, {\n    key: \"_getMaxConcurrency\",\n    value: function _getMaxConcurrency() {\n      return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n    }\n  }], [{\n    key: \"isSupported\",\n    value: function isSupported() {\n      return WorkerThread.isSupported();\n    }\n  }]);\n  return WorkerPool;\n}();\nexport { WorkerPool as default };","map":{"version":3,"names":["isMobile","WorkerThread","WorkerJob","WorkerPool","props","_classCallCheck","_defineProperty","source","url","setProps","_createClass","key","value","destroy","idleQueue","forEach","worker","isDestroyed","_objectSpread","name","undefined","maxConcurrency","maxMobileConcurrency","reuseWorkers","onDebug","_startJob","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_this","onMessage","onError","startPromise","_args","arguments","wrap","_callee$","_context","prev","next","length","job","type","data","done","error","Promise","onStart","jobQueue","push","_startQueuedJob","abrupt","sent","stop","startJob","_x","apply","_startQueuedJob2","_callee2","workerThread","queuedJob","_callee2$","_context2","_getAvailableWorker","shift","message","backlog","payload","result","returnWorkerToQueue","finish","shouldDestroyWorker","count","_getMaxConcurrency","concat","toLowerCase","isSupported","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/worker-utils/src/lib/worker-farm/worker-pool.ts"],"sourcesContent":["import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {isMobile} from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\n\n/** WorkerPool onDebug Callback Parameters */\ntype OnDebugParameters = {\n  message: string;\n  worker: string;\n  name: string;\n  job: string;\n  backlog: number;\n  workerThread: WorkerThread;\n};\n\n/** WorkerPool Properties */\nexport type WorkerPoolProps = {\n  name?: string;\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  onDebug?: (options: OnDebugParameters) => any;\n  reuseWorkers?: boolean;\n};\n\n/** Private helper types */\ntype OnMessage = (job: WorkerJob, type: WorkerMessageType, payload: WorkerMessagePayload) => void;\ntype OnError = (job: WorkerJob, error: Error) => void;\n\ntype QueuedJob = {\n  name: string;\n  onMessage: OnMessage;\n  onError: OnError;\n  onStart: (value: any) => void; // Resolve job start promise\n};\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  name: string = 'unnamed';\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency: number = 1;\n  maxMobileConcurrency: number = 1;\n  onDebug: (options: OnDebugParameters) => any = () => {};\n  reuseWorkers: boolean = true;\n\n  private props: WorkerPoolProps = {};\n  private jobQueue: QueuedJob[] = [];\n  private idleQueue: WorkerThread[] = [];\n  private count = 0;\n  private isDestroyed = false;\n\n  /** Checks if workers are supported on this platform */\n  static isSupported(): boolean {\n    return WorkerThread.isSupported();\n  }\n\n  /**\n   * @param processor - worker function\n   * @param maxConcurrency - max count of workers\n   */\n  constructor(props: WorkerPoolProps) {\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  /**\n   * Terminates all workers in the pool\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach((worker) => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  setProps(props: WorkerPoolProps) {\n    this.props = {...this.props, ...props};\n\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n\n  async startJob(\n    name: string,\n    onMessage: OnMessage = (job, type, data) => job.done(data),\n    onError: OnError = (job, error) => job.error(error)\n  ): Promise<WorkerJob> {\n    // Promise resolves when thread starts working on this job\n    const startPromise = new Promise<WorkerJob>((onStart) => {\n      // Promise resolves when thread completes or fails working on this job\n      this.jobQueue.push({name, onMessage, onError, onStart});\n      return this;\n    });\n    this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    return await startPromise;\n  }\n\n  // PRIVATE\n\n  /**\n   * Starts first queued job if worker is available or can be created\n   * Called when job is started and whenever a worker returns to the idleQueue\n   */\n  async _startQueuedJob(): Promise<void> {\n    if (!this.jobQueue.length) {\n      return;\n    }\n\n    const workerThread = this._getAvailableWorker();\n    if (!workerThread) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const queuedJob = this.jobQueue.shift();\n    if (queuedJob) {\n      // Emit a debug event\n      // @ts-ignore\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n\n      // Create a worker job to let the app access thread and manage job completion\n      const job = new WorkerJob(queuedJob.name, workerThread);\n\n      // Set the worker thread's message handlers\n      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);\n      workerThread.onError = (error) => queuedJob.onError(job, error);\n\n      // Resolve the start promise so that the app can start sending messages to worker\n      queuedJob.onStart(job);\n\n      // Wait for the app to signal that the job is complete, then return worker to queue\n      try {\n        await job.result;\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n\n  /**\n   * Returns a worker to the idle queue\n   * Destroys the worker if\n   *  - pool is destroyed\n   *  - if this pool doesn't reuse workers\n   *  - if maxConcurrency has been lowered\n   * @param worker\n   */\n  returnWorkerToQueue(worker: WorkerThread) {\n    const shouldDestroyWorker =\n      this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n\n    if (!this.isDestroyed) {\n      this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    }\n  }\n\n  /**\n   * Returns idle worker or creates new worker if maxConcurrency has not been reached\n   */\n  _getAvailableWorker(): WorkerThread | null {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({name, source: this.source, url: this.url});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}