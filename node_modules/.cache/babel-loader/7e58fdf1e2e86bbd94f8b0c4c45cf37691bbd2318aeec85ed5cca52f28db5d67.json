{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.coordHasLength4 = coordHasLength4;\nexports.containValidTime = containValidTime;\nexports.isTripGeoJsonField = isTripGeoJsonField;\nexports.parseTripGeoJsonTimestamp = parseTripGeoJsonTimestamp;\nexports.getAnimationDomainFromTimestamps = getAnimationDomainFromTimestamps;\nvar _typeAnalyzer = require(\"type-analyzer\");\nvar _geojsonUtils = require(\"../geojson-layer/geojson-utils\");\nvar _utils = require(\"@kepler.gl/utils\"); /**\n                                          * Parse geojson from string\n                                          * @param {array} samples feature object values\n                                          * @returns whether the geometry coordinates has length of 4\n                                          */\nfunction coordHasLength4(samples) {\n  var hasLength4 = true;\n  for (var i = 0; i < samples.length; i += 1) {\n    var _samples$i, _samples$i$geometry;\n    hasLength4 = Array.isArray((_samples$i = samples[i]) === null || _samples$i === void 0 ? void 0 : (_samples$i$geometry = _samples$i.geometry) === null || _samples$i$geometry === void 0 ? void 0 : _samples$i$geometry.coordinates) && !samples[i].geometry.coordinates.find(function (c) {\n      return c.length < 4;\n    });\n    if (!hasLength4) {\n      break;\n    }\n  }\n  return hasLength4;\n}\n/**\n * Check whether geojson linestring's 4th coordinate is 1) not timestamp 2) unix time stamp 3) real date time\n * @param timestamps array to be tested if its elements are timestamp\n * @returns the type of timestamp: unix/datetime/invalid(not timestamp)\n */\n\nfunction containValidTime(timestamps) {\n  var formattedTimeStamps = timestamps.map(function (ts) {\n    return {\n      ts: ts\n    };\n  });\n  var ignoredDataTypes = Object.keys(_typeAnalyzer.DATA_TYPES).filter(function (type) {\n    return ![_typeAnalyzer.DATA_TYPES.TIME, _typeAnalyzer.DATA_TYPES.DATETIME].includes(type);\n  }); // ignore all types but TIME to improve performance\n\n  var analyzedType = _typeAnalyzer.Analyzer.computeColMeta(formattedTimeStamps, [], {\n    ignoredDataTypes: ignoredDataTypes\n  })[0];\n  if (!analyzedType || analyzedType.category !== 'TIME') {\n    return null;\n  }\n  return analyzedType;\n}\n/**\n * Check if geojson features are trip layer animatable by meeting 3 conditions\n * @param dataContainer geojson feature objects container\n * @param {object} field array of geojson feature objects\n * @returns whether it is trip layer animatable\n */\n\nfunction isTripGeoJsonField(dataContainer, field) {\n  if (dataContainer.numRows() < 1) {\n    return false;\n  }\n  var maxCount = 10000;\n  var sampleRawFeatures = dataContainer.numRows() > maxCount ? (0, _utils.getSampleContainerData)(dataContainer, maxCount) : dataContainer;\n  var features = sampleRawFeatures.mapIndex(field.valueAccessor).map(_geojsonUtils.parseGeoJsonRawFeature).filter(_utils.notNullorUndefined);\n  var featureTypes = (0, _geojsonUtils.getGeojsonFeatureTypes)(features); // condition 1: contain line string\n  // @ts-expect-error\n\n  if (!featureTypes.line) {\n    return false;\n  } // condition 2:sample line strings contain 4 coordinates\n\n  if (!coordHasLength4(features)) {\n    return false;\n  } // condition 3:the 4th coordinate of the first feature line strings is valid time\n  // @ts-expect-error\n\n  var tsHolder = features[0].geometry.coordinates.map(function (coord) {\n    return coord[3];\n  });\n  return Boolean(containValidTime(tsHolder));\n}\n/**\n * Get unix timestamp from animatable geojson for deck.gl trip layer\n * @param dataToFeature array of geojson feature objects, can be null\n * @returns\n */\n\nfunction parseTripGeoJsonTimestamp(dataToFeature) {\n  // Analyze type based on coordinates of the 1st lineString\n  // select a sample trip to analyze time format\n  var empty = {\n    dataToTimeStamp: [],\n    animationDomain: null\n  };\n  var sampleTrip = dataToFeature.find(function (f) {\n    return f && f.geometry && f.geometry.coordinates && f.geometry.coordinates.length >= 3;\n  }); // if no valid geometry\n\n  if (!sampleTrip) {\n    return empty;\n  }\n  var analyzedType = containValidTime(sampleTrip.geometry.coordinates.map(function (coord) {\n    return coord[3];\n  }));\n  if (!analyzedType) {\n    return empty;\n  }\n  var format = analyzedType.format;\n  var getTimeValue = function getTimeValue(coord) {\n    return coord && (0, _utils.notNullorUndefined)(coord[3]) ? (0, _utils.timeToUnixMilli)(coord[3], format) : null;\n  };\n  var dataToTimeStamp = dataToFeature.map(function (f) {\n    return f && f.geometry && Array.isArray(f.geometry.coordinates) ? f.geometry.coordinates.map(getTimeValue) : null;\n  });\n  var animationDomain = getAnimationDomainFromTimestamps(dataToTimeStamp);\n  return {\n    dataToTimeStamp: dataToTimeStamp,\n    animationDomain: animationDomain\n  };\n}\nfunction findMinFromSorted(list) {\n  // check if list is null since the default value [] will only be applied when the param is undefined\n  return (list === null || list === void 0 ? void 0 : list.find(function (d) {\n    return (0, _utils.notNullorUndefined)(d) && Number.isFinite(d);\n  })) || null;\n}\nfunction findMaxFromSorted() {\n  var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var i = list.length - 1;\n  while (i > 0) {\n    if ((0, _utils.notNullorUndefined)(list[i]) && Number.isFinite(list[i])) {\n      return list[i];\n    }\n    i--;\n  }\n  return null;\n}\nfunction getAnimationDomainFromTimestamps() {\n  var dataToTimeStamp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return dataToTimeStamp.reduce(function (accu, tss) {\n    var tsMin = findMinFromSorted(tss);\n    var tsMax = findMaxFromSorted(tss);\n    if ((0, _utils.notNullorUndefined)(tsMin) && (0, _utils.notNullorUndefined)(tsMax) && Number.isFinite(tsMin) && Number.isFinite(tsMax)) {\n      accu[0] = Math.min(accu[0], tsMin);\n      accu[1] = Math.max(accu[1], tsMax);\n    }\n    return accu;\n  }, [Infinity, -Infinity]);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","coordHasLength4","containValidTime","isTripGeoJsonField","parseTripGeoJsonTimestamp","getAnimationDomainFromTimestamps","_typeAnalyzer","require","_geojsonUtils","_utils","samples","hasLength4","i","length","Array","isArray","_samples$i","_samples$i$geometry","geometry","coordinates","find","c","ts","ignoredDataTypes","keys","DATA_TYPES","filter","type","TIME","DATETIME","includes","analyzedType","Analyzer","computeColMeta","formattedTimeStamps","category","maxCount","features","sampleRawFeatures","mapIndex","field","valueAccessor","map","parseGeoJsonRawFeature","notNullorUndefined","featureTypes","getGeojsonFeatureTypes","line","Boolean","tsHolder","empty","dataToTimeStamp","animationDomain","sampleTrip","dataToFeature","f","coord","format","getTimeValue","findMinFromSorted","list","d","Number","isFinite","findMaxFromSorted","reduce","accu","tss","tsMin","tsMax","Math","max"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/layers/src/trip-layer/trip-utils.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Analyzer, DATA_TYPES} from 'type-analyzer';\n\nimport {Field} from '@kepler.gl/types';\n\nimport {parseGeoJsonRawFeature, getGeojsonFeatureTypes} from '../geojson-layer/geojson-utils';\nimport {\n  DataContainerInterface,\n  getSampleContainerData,\n  notNullorUndefined,\n  timeToUnixMilli\n} from '@kepler.gl/utils';\nimport {Feature} from '@turf/helpers';\nimport {GeoJsonProperties, Geometry} from 'geojson';\n\n/**\n * Parse geojson from string\n * @param {array} samples feature object values\n * @returns whether the geometry coordinates has length of 4\n */\nexport function coordHasLength4(samples): boolean {\n  let hasLength4 = true;\n  for (let i = 0; i < samples.length; i += 1) {\n    hasLength4 =\n      Array.isArray(samples[i]?.geometry?.coordinates) &&\n      !samples[i].geometry.coordinates.find(c => c.length < 4);\n\n    if (!hasLength4) {\n      break;\n    }\n  }\n  return hasLength4;\n}\n\n/**\n * Check whether geojson linestring's 4th coordinate is 1) not timestamp 2) unix time stamp 3) real date time\n * @param timestamps array to be tested if its elements are timestamp\n * @returns the type of timestamp: unix/datetime/invalid(not timestamp)\n */\nexport function containValidTime(timestamps: string[]): Field | null {\n  const formattedTimeStamps = timestamps.map(ts => ({ts}));\n  const ignoredDataTypes = Object.keys(DATA_TYPES).filter(\n    type => ![DATA_TYPES.TIME, DATA_TYPES.DATETIME].includes(type)\n  );\n\n  // ignore all types but TIME to improve performance\n  const analyzedType = Analyzer.computeColMeta(formattedTimeStamps, [], {ignoredDataTypes})[0];\n\n  if (!analyzedType || analyzedType.category !== 'TIME') {\n    return null;\n  }\n  return analyzedType;\n}\n\n/**\n * Check if geojson features are trip layer animatable by meeting 3 conditions\n * @param dataContainer geojson feature objects container\n * @param {object} field array of geojson feature objects\n * @returns whether it is trip layer animatable\n */\nexport function isTripGeoJsonField(dataContainer: DataContainerInterface, field): boolean {\n  if (dataContainer.numRows() < 1) {\n    return false;\n  }\n\n  const maxCount = 10000;\n  const sampleRawFeatures =\n    dataContainer.numRows() > maxCount\n      ? getSampleContainerData(dataContainer, maxCount)\n      : dataContainer;\n\n  const features: Feature<Geometry, GeoJsonProperties>[] = sampleRawFeatures\n    .mapIndex(field.valueAccessor)\n    .map(parseGeoJsonRawFeature)\n    .filter(notNullorUndefined);\n  const featureTypes = getGeojsonFeatureTypes(features);\n\n  // condition 1: contain line string\n  // @ts-expect-error\n  if (!featureTypes.line) {\n    return false;\n  }\n\n  // condition 2:sample line strings contain 4 coordinates\n  if (!coordHasLength4(features)) {\n    return false;\n  }\n\n  // condition 3:the 4th coordinate of the first feature line strings is valid time\n  // @ts-expect-error\n  const tsHolder = features[0].geometry.coordinates.map(coord => coord[3]);\n\n  return Boolean(containValidTime(tsHolder));\n}\n\n/**\n * Get unix timestamp from animatable geojson for deck.gl trip layer\n * @param dataToFeature array of geojson feature objects, can be null\n * @returns\n */\nexport function parseTripGeoJsonTimestamp(dataToFeature: any[]) {\n  // Analyze type based on coordinates of the 1st lineString\n  // select a sample trip to analyze time format\n  const empty = {dataToTimeStamp: [], animationDomain: null};\n  const sampleTrip = dataToFeature.find(\n    f => f && f.geometry && f.geometry.coordinates && f.geometry.coordinates.length >= 3\n  );\n\n  // if no valid geometry\n  if (!sampleTrip) {\n    return empty;\n  }\n\n  const analyzedType = containValidTime(sampleTrip.geometry.coordinates.map(coord => coord[3]));\n\n  if (!analyzedType) {\n    return empty;\n  }\n\n  const {format} = analyzedType;\n  const getTimeValue = coord =>\n    coord && notNullorUndefined(coord[3]) ? timeToUnixMilli(coord[3], format) : null;\n\n  const dataToTimeStamp: number[][] = dataToFeature.map(f =>\n    f && f.geometry && Array.isArray(f.geometry.coordinates)\n      ? f.geometry.coordinates.map(getTimeValue)\n      : null\n  );\n\n  const animationDomain = getAnimationDomainFromTimestamps(dataToTimeStamp);\n\n  return {dataToTimeStamp, animationDomain};\n}\n\nfunction findMinFromSorted(list: number[]) {\n  // check if list is null since the default value [] will only be applied when the param is undefined\n  return list?.find(d => notNullorUndefined(d) && Number.isFinite(d)) || null;\n}\n\nfunction findMaxFromSorted(list: number[] = []) {\n  let i = list.length - 1;\n  while (i > 0) {\n    if (notNullorUndefined(list[i]) && Number.isFinite(list[i])) {\n      return list[i];\n    }\n    i--;\n  }\n  return null;\n}\n\nexport function getAnimationDomainFromTimestamps(dataToTimeStamp: number[][] = []) {\n  return dataToTimeStamp.reduce(\n    (accu: [number, number], tss) => {\n      const tsMin = findMinFromSorted(tss);\n      const tsMax = findMaxFromSorted(tss);\n      if (\n        notNullorUndefined(tsMin) &&\n        notNullorUndefined(tsMax) &&\n        Number.isFinite(tsMin) &&\n        Number.isFinite(tsMax)\n      ) {\n        accu[0] = Math.min(accu[0], tsMin);\n        accu[1] = Math.max(accu[1], tsMax);\n      }\n      return accu;\n    },\n    [Infinity, -Infinity]\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}