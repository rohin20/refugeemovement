{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _constants = require(\"./constants\");\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar Feature = /*#__PURE__*/\nfunction () {\n  _createClass(Feature, null, [{\n    key: \"fromFeature\",\n    value: function fromFeature(feature) {\n      var id = feature.id,\n        _feature$geometry = feature.geometry,\n        coordinates = _feature$geometry.coordinates,\n        type = _feature$geometry.type,\n        _feature$properties = feature.properties,\n        renderType = _feature$properties.renderType,\n        otherProps = _objectWithoutProperties(_feature$properties, [\"renderType\"]);\n      switch (type) {\n        case _constants.GEOJSON_TYPE.POINT:\n          return new Feature({\n            id: id,\n            type: type,\n            renderType: renderType,\n            points: [coordinates],\n            otherProps: otherProps\n          });\n        case _constants.GEOJSON_TYPE.LINE_STRING:\n          return new Feature({\n            id: id,\n            type: type,\n            renderType: renderType,\n            points: coordinates,\n            otherProps: otherProps\n          });\n        case _constants.GEOJSON_TYPE.POLYGON:\n          var points = coordinates[0] && coordinates[0].slice(0, -1);\n          return new Feature({\n            id: id,\n            type: type,\n            renderType: renderType,\n            points: points,\n            isClosed: true,\n            otherProps: otherProps\n          });\n        default:\n          return null;\n      }\n    }\n  }]);\n  function Feature(props) {\n    _classCallCheck(this, Feature);\n    _defineProperty(this, \"id\", void 0);\n    _defineProperty(this, \"type\", void 0);\n    _defineProperty(this, \"renderType\", void 0);\n    _defineProperty(this, \"isClosed\", false);\n    _defineProperty(this, \"points\", void 0);\n    _defineProperty(this, \"otherProps\", void 0);\n    this.id = props.id;\n    this.type = props.type;\n    this.renderType = props.renderType;\n    this.points = props.points || [];\n    this.isClosed = props.isClosed;\n    this.otherProps = props.otherProps;\n  }\n  _createClass(Feature, [{\n    key: \"addPoint\",\n    value: function addPoint(pt) {\n      this.points.push(pt);\n      return true;\n    }\n  }, {\n    key: \"insertPoint\",\n    value: function insertPoint(pt, index) {\n      this.points.splice(index, 0, pt);\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox() {\n      if (!this.points || !this.points.length) {\n        return null;\n      }\n      var bbox = this.points.reduce(function (result, pt) {\n        result.xmin = Math.min(pt[0], result.xmin);\n        result.xmax = Math.min(pt[0], result.xmax);\n        result.ymin = Math.min(pt[1], result.ymin);\n        result.ymax = Math.min(pt[1], result.ymax);\n        return result;\n      }, {\n        xmin: Infinity,\n        xmax: -Infinity,\n        ymin: Infinity,\n        ymax: -Infinity\n      });\n      return bbox;\n    }\n  }, {\n    key: \"removePoint\",\n    value: function removePoint(index) {\n      var points = this.points;\n      if (index >= 0 && index < points.length) {\n        points.splice(index, 1);\n        if (points.length < 3) {\n          this.isClosed = false;\n        }\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"replacePoint\",\n    value: function replacePoint(index, pt) {\n      var points = this.points;\n      if (index >= 0 && index < points.length) {\n        points[index] = pt;\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"closePath\",\n    value: function closePath() {\n      var points = this.points;\n      if (points.length >= 3 && !this.isClosed) {\n        this.isClosed = true;\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"toFeature\",\n    value: function toFeature() {\n      var id = this.id,\n        points = this.points,\n        isClosed = this.isClosed,\n        renderType = this.renderType,\n        otherProps = this.otherProps;\n      var feature = null;\n      if (points.length < 2) {\n        feature = {\n          type: 'Feature',\n          geometry: {\n            type: _constants.GEOJSON_TYPE.POINT,\n            coordinates: points[0]\n          },\n          properties: _objectSpread({\n            renderType: renderType\n          }, otherProps),\n          id: id\n        };\n      } else if (points.length < 3 || !isClosed) {\n        feature = {\n          type: 'Feature',\n          geometry: {\n            type: _constants.GEOJSON_TYPE.LINE_STRING,\n            coordinates: points\n          },\n          properties: _objectSpread({\n            renderType: renderType,\n            bbox: this.getBoundingBox()\n          }, otherProps),\n          id: id\n        };\n      } else {\n        feature = {\n          type: 'Feature',\n          geometry: {\n            type: _constants.GEOJSON_TYPE.POLYGON,\n            coordinates: [_toConsumableArray(points).concat([points[0]])]\n          },\n          properties: _objectSpread({\n            renderType: renderType,\n            isClosed: isClosed,\n            bbox: this.getBoundingBox()\n          }, otherProps),\n          id: id\n        };\n      }\n      return feature;\n    }\n  }]);\n  return Feature;\n}();\nexports.default = Feature;","map":{"version":3,"names":["_constants","require","Feature","feature","id","_feature$geometry","geometry","coordinates","type","_feature$properties","properties","renderType","otherProps","_objectWithoutProperties","GEOJSON_TYPE","POINT","points","LINE_STRING","POLYGON","slice","isClosed","props","_classCallCheck","_defineProperty","pt","push","index","splice","length","bbox","reduce","result","xmin","Math","min","xmax","ymin","ymax","Infinity","_objectSpread","getBoundingBox","_toConsumableArray","concat"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/react-map-gl-draw/src/feature.js"],"sourcesContent":["// @flow\nimport type { Geometry, Position, Feature as GeoJson } from '@nebula.gl/edit-modes';\nimport type { Id, RenderType } from './types';\nimport { GEOJSON_TYPE } from './constants';\n\ntype FeatureProps = {\n  id: Id,\n  type: string,\n  renderType?: ?RenderType,\n  points?: ?any,\n  isClosed?: ?boolean,\n  otherProps?: ?any\n};\n\nexport default class Feature {\n  static fromFeature(feature: GeoJson) {\n    const {\n      id,\n      geometry: { coordinates, type },\n      properties: { renderType, ...otherProps }\n    } = feature;\n\n    switch (type) {\n      case GEOJSON_TYPE.POINT:\n        return new Feature({\n          id,\n          type,\n          renderType,\n          points: [coordinates],\n          otherProps\n        });\n\n      case GEOJSON_TYPE.LINE_STRING:\n        return new Feature({\n          id,\n          type,\n          renderType,\n          points: coordinates,\n          otherProps\n        });\n\n      case GEOJSON_TYPE.POLYGON:\n        const points = coordinates[0] && coordinates[0].slice(0, -1);\n        return new Feature({\n          id,\n          type,\n          renderType,\n          points,\n          isClosed: true,\n          otherProps\n        });\n\n      default:\n        return null;\n    }\n  }\n\n  constructor(props: FeatureProps) {\n    this.id = props.id;\n    this.type = props.type;\n    this.renderType = props.renderType;\n    this.points = props.points || [];\n    this.isClosed = props.isClosed;\n    this.otherProps = props.otherProps;\n  }\n\n  id: Id;\n  type: Geometry;\n  renderType: ?string;\n  isClosed: ?boolean = false;\n  points: Position[];\n  otherProps: ?any;\n\n  addPoint(pt: number[]) {\n    this.points.push(pt);\n    return true;\n  }\n\n  insertPoint(pt: number[], index: number) {\n    this.points.splice(index, 0, pt);\n  }\n\n  getBoundingBox() {\n    if (!this.points || !this.points.length) {\n      return null;\n    }\n    const bbox = this.points.reduce(\n      (result, pt) => {\n        result.xmin = Math.min(pt[0], result.xmin);\n        result.xmax = Math.min(pt[0], result.xmax);\n        result.ymin = Math.min(pt[1], result.ymin);\n        result.ymax = Math.min(pt[1], result.ymax);\n\n        return result;\n      },\n      { xmin: Infinity, xmax: -Infinity, ymin: Infinity, ymax: -Infinity }\n    );\n\n    return bbox;\n  }\n\n  removePoint(index: number) {\n    const { points } = this;\n    if (index >= 0 && index < points.length) {\n      points.splice(index, 1);\n      if (points.length < 3) {\n        this.isClosed = false;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  replacePoint(index: number, pt: Array<number>) {\n    const { points } = this;\n    if (index >= 0 && index < points.length) {\n      points[index] = pt;\n      return true;\n    }\n    return false;\n  }\n\n  closePath() {\n    const { points } = this;\n    if (points.length >= 3 && !this.isClosed) {\n      this.isClosed = true;\n      return true;\n    }\n    return false;\n  }\n\n  toFeature(): GeoJson {\n    const { id, points, isClosed, renderType, otherProps } = this;\n\n    let feature = null;\n    if (points.length < 2) {\n      feature = {\n        type: 'Feature',\n        geometry: {\n          type: GEOJSON_TYPE.POINT,\n          coordinates: points[0]\n        },\n        properties: {\n          renderType,\n          ...otherProps\n        },\n        id\n      };\n    } else if (points.length < 3 || !isClosed) {\n      feature = {\n        type: 'Feature',\n        geometry: {\n          type: GEOJSON_TYPE.LINE_STRING,\n          coordinates: points\n        },\n        properties: {\n          renderType,\n          bbox: this.getBoundingBox(),\n          ...otherProps\n        },\n        id\n      };\n    } else {\n      feature = {\n        type: 'Feature',\n        geometry: {\n          type: GEOJSON_TYPE.POLYGON,\n          coordinates: [[...points, points[0]]]\n        },\n        properties: {\n          renderType,\n          isClosed,\n          bbox: this.getBoundingBox(),\n          ...otherProps\n        },\n        id\n      };\n    }\n\n    return feature;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}