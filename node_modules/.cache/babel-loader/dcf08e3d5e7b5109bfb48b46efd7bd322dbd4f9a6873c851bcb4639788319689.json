{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Timeline } from '@luma.gl/core';\nimport { LIFECYCLE } from '../lifecycle/constants';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport { flatten } from '../utils/flatten';\nimport { Stats } from '@probe.gl/stats';\nimport ResourceManager from './resource/resource-manager';\nimport Viewport from '../viewports/viewport';\nimport { createProgramManager } from '../shaderlib';\nvar TRACE_SET_LAYERS = 'layerManager.setLayers';\nvar TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\nvar LayerManager = /*#__PURE__*/function () {\n  function LayerManager(gl) {\n    var _this = this;\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      deck = _ref.deck,\n      stats = _ref.stats,\n      _viewport = _ref.viewport,\n      timeline = _ref.timeline;\n    _classCallCheck(this, LayerManager);\n    _defineProperty(this, \"layers\", void 0);\n    _defineProperty(this, \"context\", void 0);\n    _defineProperty(this, \"resourceManager\", void 0);\n    _defineProperty(this, \"_lastRenderedLayers\", []);\n    _defineProperty(this, \"_needsRedraw\", false);\n    _defineProperty(this, \"_needsUpdate\", false);\n    _defineProperty(this, \"_nextLayers\", null);\n    _defineProperty(this, \"_debug\", false);\n    _defineProperty(this, \"activateViewport\", function (viewport) {\n      debug(TRACE_ACTIVATE_VIEWPORT, _this, viewport);\n      if (viewport) {\n        _this.context.viewport = viewport;\n      }\n    });\n    this.layers = [];\n    this.resourceManager = new ResourceManager({\n      gl: gl,\n      protocol: 'deck://'\n    });\n    this.context = {\n      mousePosition: null,\n      userData: {},\n      layerManager: this,\n      gl: gl,\n      deck: deck,\n      programManager: gl && createProgramManager(gl),\n      stats: stats || new Stats({\n        id: 'deck.gl'\n      }),\n      viewport: _viewport || new Viewport({\n        id: 'DEFAULT-INITIAL-VIEWPORT'\n      }),\n      timeline: timeline || new Timeline(),\n      resourceManager: this.resourceManager,\n      onError: undefined\n    };\n    Object.seal(this);\n  }\n  _createClass(LayerManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      this.resourceManager.finalize();\n      var _iterator = _createForOfIteratorHelper(this.layers),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var layer = _step.value;\n          this._finalizeLayer(layer);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"needsRedraw\",\n    value: function needsRedraw() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        clearRedrawFlags: false\n      };\n      var redraw = this._needsRedraw;\n      if (opts.clearRedrawFlags) {\n        this._needsRedraw = false;\n      }\n      var _iterator2 = _createForOfIteratorHelper(this.layers),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var layer = _step2.value;\n          var layerNeedsRedraw = layer.getNeedsRedraw(opts);\n          redraw = redraw || layerNeedsRedraw;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return redraw;\n    }\n  }, {\n    key: \"needsUpdate\",\n    value: function needsUpdate() {\n      if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {\n        return 'layers changed';\n      }\n      return this._needsUpdate;\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw(reason) {\n      this._needsRedraw = this._needsRedraw || reason;\n    }\n  }, {\n    key: \"setNeedsUpdate\",\n    value: function setNeedsUpdate(reason) {\n      this._needsUpdate = this._needsUpdate || reason;\n    }\n  }, {\n    key: \"getLayers\",\n    value: function getLayers() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        layerIds = _ref2.layerIds;\n      return layerIds ? this.layers.filter(function (layer) {\n        return layerIds.find(function (layerId) {\n          return layer.id.indexOf(layerId) === 0;\n        });\n      }) : this.layers;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('debug' in props) {\n        this._debug = props.debug;\n      }\n      if ('userData' in props) {\n        this.context.userData = props.userData;\n      }\n      if ('layers' in props) {\n        this._nextLayers = props.layers;\n      }\n      if ('onError' in props) {\n        this.context.onError = props.onError;\n      }\n    }\n  }, {\n    key: \"setLayers\",\n    value: function setLayers(newLayers, reason) {\n      debug(TRACE_SET_LAYERS, this, reason, newLayers);\n      this._lastRenderedLayers = newLayers;\n      var flatLayers = flatten(newLayers, Boolean);\n      var _iterator3 = _createForOfIteratorHelper(flatLayers),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var layer = _step3.value;\n          layer.context = this.context;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      this._updateLayers(this.layers, flatLayers);\n    }\n  }, {\n    key: \"updateLayers\",\n    value: function updateLayers() {\n      var reason = this.needsUpdate();\n      if (reason) {\n        this.setNeedsRedraw(\"updating layers: \".concat(reason));\n        this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);\n      }\n      this._nextLayers = null;\n    }\n  }, {\n    key: \"_handleError\",\n    value: function _handleError(stage, error, layer) {\n      layer.raiseError(error, \"\".concat(stage, \" of \").concat(layer));\n    }\n  }, {\n    key: \"_updateLayers\",\n    value: function _updateLayers(oldLayers, newLayers) {\n      var oldLayerMap = {};\n      var _iterator4 = _createForOfIteratorHelper(oldLayers),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var oldLayer = _step4.value;\n          if (oldLayerMap[oldLayer.id]) {\n            log.warn(\"Multiple old layers with same id \".concat(oldLayer.id))();\n          } else {\n            oldLayerMap[oldLayer.id] = oldLayer;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      var generatedLayers = [];\n      this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n      this._finalizeOldLayers(oldLayerMap);\n      var needsUpdate = false;\n      for (var _i = 0, _generatedLayers = generatedLayers; _i < _generatedLayers.length; _i++) {\n        var layer = _generatedLayers[_i];\n        if (layer.hasUniformTransition()) {\n          needsUpdate = \"Uniform transition in \".concat(layer);\n          break;\n        }\n      }\n      this._needsUpdate = needsUpdate;\n      this.layers = generatedLayers;\n    }\n  }, {\n    key: \"_updateSublayersRecursively\",\n    value: function _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {\n      var _iterator5 = _createForOfIteratorHelper(newLayers),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var newLayer = _step5.value;\n          newLayer.context = this.context;\n          var oldLayer = oldLayerMap[newLayer.id];\n          if (oldLayer === null) {\n            log.warn(\"Multiple new layers with same id \".concat(newLayer.id))();\n          }\n          oldLayerMap[newLayer.id] = null;\n          var sublayers = null;\n          try {\n            if (this._debug && oldLayer !== newLayer) {\n              newLayer.validateProps();\n            }\n            if (!oldLayer) {\n              this._initializeLayer(newLayer);\n            } else {\n              this._transferLayerState(oldLayer, newLayer);\n              this._updateLayer(newLayer);\n            }\n            generatedLayers.push(newLayer);\n            sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;\n          } catch (err) {\n            this._handleError('matching', err, newLayer);\n          }\n          if (sublayers) {\n            this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"_finalizeOldLayers\",\n    value: function _finalizeOldLayers(oldLayerMap) {\n      for (var layerId in oldLayerMap) {\n        var layer = oldLayerMap[layerId];\n        if (layer) {\n          this._finalizeLayer(layer);\n        }\n      }\n    }\n  }, {\n    key: \"_initializeLayer\",\n    value: function _initializeLayer(layer) {\n      try {\n        layer._initialize();\n        layer.lifecycle = LIFECYCLE.INITIALIZED;\n      } catch (err) {\n        this._handleError('initialization', err, layer);\n      }\n    }\n  }, {\n    key: \"_transferLayerState\",\n    value: function _transferLayerState(oldLayer, newLayer) {\n      newLayer._transferState(oldLayer);\n      newLayer.lifecycle = LIFECYCLE.MATCHED;\n      if (newLayer !== oldLayer) {\n        oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n      }\n    }\n  }, {\n    key: \"_updateLayer\",\n    value: function _updateLayer(layer) {\n      try {\n        layer._update();\n      } catch (err) {\n        this._handleError('update', err, layer);\n      }\n    }\n  }, {\n    key: \"_finalizeLayer\",\n    value: function _finalizeLayer(layer) {\n      this._needsRedraw = this._needsRedraw || \"finalized \".concat(layer);\n      layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n      try {\n        layer._finalize();\n        layer.lifecycle = LIFECYCLE.FINALIZED;\n      } catch (err) {\n        this._handleError('finalization', err, layer);\n      }\n    }\n  }]);\n  return LayerManager;\n}();\nexport { LayerManager as default };","map":{"version":3,"names":["Timeline","LIFECYCLE","log","debug","flatten","Stats","ResourceManager","Viewport","createProgramManager","TRACE_SET_LAYERS","TRACE_ACTIVATE_VIEWPORT","LayerManager","gl","_this","_ref","arguments","length","undefined","deck","stats","_viewport","viewport","timeline","_classCallCheck","_defineProperty","context","layers","resourceManager","protocol","mousePosition","userData","layerManager","programManager","id","onError","Object","seal","_createClass","key","value","finalize","_iterator","_createForOfIteratorHelper","_step","s","n","done","layer","_finalizeLayer","err","e","f","needsRedraw","opts","clearRedrawFlags","redraw","_needsRedraw","_iterator2","_step2","layerNeedsRedraw","getNeedsRedraw","needsUpdate","_nextLayers","_lastRenderedLayers","_needsUpdate","setNeedsRedraw","reason","setNeedsUpdate","getLayers","_ref2","layerIds","filter","find","layerId","indexOf","setProps","props","_debug","setLayers","newLayers","flatLayers","Boolean","_iterator3","_step3","_updateLayers","updateLayers","concat","_handleError","stage","error","raiseError","oldLayers","oldLayerMap","_iterator4","_step4","oldLayer","warn","generatedLayers","_updateSublayersRecursively","_finalizeOldLayers","_i","_generatedLayers","hasUniformTransition","_iterator5","_step5","newLayer","sublayers","validateProps","_initializeLayer","_transferLayerState","_updateLayer","push","isComposite","getSubLayers","_initialize","lifecycle","INITIALIZED","_transferState","MATCHED","AWAITING_GC","_update","AWAITING_FINALIZATION","_finalize","FINALIZED","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/core/src/lib/layer-manager.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Timeline} from '@luma.gl/core';\nimport {LIFECYCLE} from '../lifecycle/constants';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport {flatten} from '../utils/flatten';\nimport {Stats} from '@probe.gl/stats';\nimport ResourceManager from './resource/resource-manager';\n\nimport Viewport from '../viewports/viewport';\nimport {createProgramManager} from '../shaderlib';\n\nimport type Layer from './layer';\nimport type CompositeLayer from './composite-layer';\nimport type Deck from './deck';\nimport type {ProgramManager} from '@luma.gl/engine';\n\nconst TRACE_SET_LAYERS = 'layerManager.setLayers';\nconst TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\n\nexport type LayerContext = {\n  layerManager: LayerManager;\n  resourceManager: ResourceManager;\n  deck?: Deck;\n  gl: WebGLRenderingContext;\n  programManager: ProgramManager;\n  stats: Stats;\n  viewport: Viewport;\n  timeline: Timeline;\n  mousePosition: {x: number; y: number} | null;\n  userData: any;\n  onError?: <PropsT>(error: Error, source: Layer<PropsT>) => void;\n};\n\nexport type LayersList = (Layer | undefined | false | null | LayersList)[];\n\nexport default class LayerManager {\n  layers: Layer[];\n  context: LayerContext;\n  resourceManager: ResourceManager;\n\n  private _lastRenderedLayers: LayersList = [];\n  private _needsRedraw: string | false = false;\n  private _needsUpdate: string | false = false;\n  private _nextLayers: LayersList | null = null;\n  private _debug: boolean = false;\n\n  // eslint-disable-next-line\n  constructor(\n    gl,\n    {\n      deck,\n      stats,\n      viewport,\n      timeline\n    }: {\n      deck?: Deck;\n      stats?: Stats;\n      viewport?: Viewport;\n      timeline?: Timeline;\n    } = {}\n  ) {\n    // Currently deck.gl expects the DeckGL.layers array to be different\n    // whenever React rerenders. If the same layers array is used, the\n    // LayerManager's diffing algorithm will generate a fatal error and\n    // break the rendering.\n\n    // `this._lastRenderedLayers` stores the UNFILTERED layers sent\n    // down to LayerManager, so that `layers` reference can be compared.\n    // If it's the same across two React render calls, the diffing logic\n    // will be skipped.\n    this.layers = [];\n    this.resourceManager = new ResourceManager({gl, protocol: 'deck://'});\n\n    this.context = {\n      mousePosition: null,\n      userData: {},\n      layerManager: this,\n      gl,\n      deck,\n      // Enabling luma.gl Program caching using private API (_cachePrograms)\n      programManager: gl && createProgramManager(gl),\n      stats: stats || new Stats({id: 'deck.gl'}),\n      // Make sure context.viewport is not empty on the first layer initialization\n      viewport: viewport || new Viewport({id: 'DEFAULT-INITIAL-VIEWPORT'}), // Current viewport, exposed to layers for project* function\n      timeline: timeline || new Timeline(),\n      resourceManager: this.resourceManager,\n      onError: undefined\n    };\n\n    Object.seal(this);\n  }\n\n  /** Method to call when the layer manager is not needed anymore. */\n  finalize() {\n    this.resourceManager.finalize();\n    // Finalize all layers\n    for (const layer of this.layers) {\n      this._finalizeLayer(layer);\n    }\n  }\n\n  /** Check if a redraw is needed */\n  needsRedraw(\n    opts: {\n      /** Reset redraw flags to false after the call */\n      clearRedrawFlags: boolean;\n    } = {clearRedrawFlags: false}\n  ): string | false {\n    let redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    // This layers list doesn't include sublayers, relying on composite layers\n    for (const layer of this.layers) {\n      // Call every layer to clear their flags\n      const layerNeedsRedraw = layer.getNeedsRedraw(opts);\n      redraw = redraw || layerNeedsRedraw;\n    }\n\n    return redraw;\n  }\n\n  /** Check if a deep update of all layers is needed */\n  needsUpdate(): string | false {\n    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {\n      // New layers array may be the same as the old one if `setProps` is called by React\n      return 'layers changed';\n    }\n    return this._needsUpdate;\n  }\n\n  /** Layers will be redrawn (in next animation frame) */\n  setNeedsRedraw(reason: string): void {\n    this._needsRedraw = this._needsRedraw || reason;\n  }\n\n  /** Layers will be updated deeply (in next animation frame)\n    Potentially regenerating attributes and sub layers */\n  setNeedsUpdate(reason: string): void {\n    this._needsUpdate = this._needsUpdate || reason;\n  }\n\n  /** Gets a list of currently rendered layers. Optionally filter by id. */\n  getLayers({layerIds}: {layerIds?: string[]} = {}): Layer[] {\n    // Filtering by layerId compares beginning of strings, so that sublayers will be included\n    // Dependes on the convention of adding suffixes to the parent's layer name\n    return layerIds\n      ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0))\n      : this.layers;\n  }\n\n  /** Set props needed for layer rendering and picking. */\n  setProps(props: any): void {\n    if ('debug' in props) {\n      this._debug = props.debug;\n    }\n\n    // A way for apps to add data to context that can be accessed in layers\n    if ('userData' in props) {\n      this.context.userData = props.userData;\n    }\n\n    // New layers will be processed in `updateLayers` in the next update cycle\n    if ('layers' in props) {\n      this._nextLayers = props.layers;\n    }\n\n    if ('onError' in props) {\n      this.context.onError = props.onError;\n    }\n  }\n\n  /** Supply a new layer list, initiating sublayer generation and layer matching */\n  setLayers(newLayers: LayersList, reason?: string): void {\n    debug(TRACE_SET_LAYERS, this, reason, newLayers);\n\n    this._lastRenderedLayers = newLayers;\n\n    const flatLayers = flatten(newLayers, Boolean) as Layer[];\n\n    for (const layer of flatLayers) {\n      layer.context = this.context;\n    }\n\n    this._updateLayers(this.layers, flatLayers);\n  }\n\n  /** Update layers from last cycle if `setNeedsUpdate()` has been called */\n  updateLayers(): void {\n    // NOTE: For now, even if only some layer has changed, we update all layers\n    // to ensure that layer id maps etc remain consistent even if different\n    // sublayers are rendered\n    const reason = this.needsUpdate();\n    if (reason) {\n      this.setNeedsRedraw(`updating layers: ${reason}`);\n      // Force a full update\n      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);\n    }\n    // Updated, clear the backlog\n    this._nextLayers = null;\n  }\n\n  //\n  // INTERNAL METHODS\n  //\n\n  /** Make a viewport \"current\" in layer context, updating viewportChanged flags */\n  activateViewport = (viewport: Viewport) => {\n    debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n    if (viewport) {\n      this.context.viewport = viewport;\n    }\n  };\n\n  private _handleError(stage: string, error: Error, layer: Layer) {\n    layer.raiseError(error, `${stage} of ${layer}`);\n  }\n\n  // TODO - mark layers with exceptions as bad and remove from rendering cycle?\n  /** Match all layers, checking for caught errors\n    to avoid having an exception in one layer disrupt other layers */\n  private _updateLayers(oldLayers: Layer[], newLayers: Layer[]): void {\n    // Create old layer map\n    const oldLayerMap: {[layerId: string]: Layer | null} = {};\n    for (const oldLayer of oldLayers) {\n      if (oldLayerMap[oldLayer.id]) {\n        log.warn(`Multiple old layers with same id ${oldLayer.id}`)();\n      } else {\n        oldLayerMap[oldLayer.id] = oldLayer;\n      }\n    }\n\n    // Allocate array for generated layers\n    const generatedLayers: Layer[] = [];\n\n    // Match sublayers\n    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n\n    // Finalize unmatched layers\n    this._finalizeOldLayers(oldLayerMap);\n\n    let needsUpdate: string | false = false;\n    for (const layer of generatedLayers) {\n      if (layer.hasUniformTransition()) {\n        needsUpdate = `Uniform transition in ${layer}`;\n        break;\n      }\n    }\n\n    this._needsUpdate = needsUpdate;\n    this.layers = generatedLayers;\n  }\n\n  /* eslint-disable complexity,max-statements */\n  // Note: adds generated layers to `generatedLayers` array parameter\n  private _updateSublayersRecursively(\n    newLayers: Layer[],\n    oldLayerMap: {[layerId: string]: Layer | null},\n    generatedLayers: Layer[]\n  ) {\n    for (const newLayer of newLayers) {\n      newLayer.context = this.context;\n\n      // Given a new coming layer, find its matching old layer (if any)\n      const oldLayer = oldLayerMap[newLayer.id];\n      if (oldLayer === null) {\n        // null, rather than undefined, means this id was originally there\n        log.warn(`Multiple new layers with same id ${newLayer.id}`)();\n      }\n      // Remove the old layer from candidates, as it has been matched with this layer\n      oldLayerMap[newLayer.id] = null;\n\n      let sublayers: Layer[] | null = null;\n\n      // We must not generate exceptions until after layer matching is complete\n      try {\n        if (this._debug && oldLayer !== newLayer) {\n          newLayer.validateProps();\n        }\n\n        if (!oldLayer) {\n          this._initializeLayer(newLayer);\n        } else {\n          this._transferLayerState(oldLayer, newLayer);\n          this._updateLayer(newLayer);\n        }\n        generatedLayers.push(newLayer);\n\n        // Call layer lifecycle method: render sublayers\n        sublayers = newLayer.isComposite ? (newLayer as CompositeLayer).getSubLayers() : null;\n        // End layer lifecycle method: render sublayers\n      } catch (err) {\n        this._handleError('matching', err as Error, newLayer); // Record first exception\n      }\n\n      if (sublayers) {\n        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n      }\n    }\n  }\n  /* eslint-enable complexity,max-statements */\n\n  // Finalize any old layers that were not matched\n  private _finalizeOldLayers(oldLayerMap: {[layerId: string]: Layer | null}): void {\n    for (const layerId in oldLayerMap) {\n      const layer = oldLayerMap[layerId];\n      if (layer) {\n        this._finalizeLayer(layer);\n      }\n    }\n  }\n\n  // / EXCEPTION SAFE LAYER ACCESS\n\n  /** Safely initializes a single layer, calling layer methods */\n  private _initializeLayer(layer: Layer): void {\n    try {\n      layer._initialize();\n      layer.lifecycle = LIFECYCLE.INITIALIZED;\n    } catch (err) {\n      this._handleError('initialization', err as Error, layer);\n      // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?\n    }\n  }\n\n  /** Transfer state from one layer to a newer version */\n  private _transferLayerState(oldLayer: Layer, newLayer: Layer): void {\n    newLayer._transferState(oldLayer);\n    newLayer.lifecycle = LIFECYCLE.MATCHED;\n\n    if (newLayer !== oldLayer) {\n      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n    }\n  }\n\n  /** Safely updates a single layer, cleaning all flags */\n  private _updateLayer(layer: Layer): void {\n    try {\n      layer._update();\n    } catch (err) {\n      this._handleError('update', err as Error, layer);\n    }\n  }\n\n  /** Safely finalizes a single layer, removing all resources */\n  private _finalizeLayer(layer: Layer): void {\n    this._needsRedraw = this._needsRedraw || `finalized ${layer}`;\n\n    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n\n    try {\n      layer._finalize();\n      layer.lifecycle = LIFECYCLE.FINALIZED;\n    } catch (err) {\n      this._handleError('finalization', err as Error, layer);\n    }\n  }\n}\n"],"mappings":";;;;AAoBA,SAAQA,QAAR,QAAuB,eAAvB;AACA,SAAQC,SAAR,QAAwB,wBAAxB;AACA,OAAOC,GAAP,MAAgB,cAAhB;AACA,OAAOC,KAAP,MAAkB,UAAlB;AACA,SAAQC,OAAR,QAAsB,kBAAtB;AACA,SAAQC,KAAR,QAAoB,iBAApB;AACA,OAAOC,eAAP,MAA4B,6BAA5B;AAEA,OAAOC,QAAP,MAAqB,uBAArB;AACA,SAAQC,oBAAR,QAAmC,cAAnC;AAOA,IAAMC,gBAAgB,GAAG,wBAAzB;AACA,IAAMC,uBAAuB,GAAG,+BAAhC;AAAA,IAkBqBC,YAAN;EAYb,SAAAA,aACEC,EADS,EAaT;IAAA,IAAAC,KAAA;IAAA,IAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MADI,EAZK;MAGPG,IADF,GAAAJ,IAAA,CACEI,IADF;MAEEC,KAFF,GAAAL,IAAA,CAEEK,KAFF;MAGEC,SAHF,GAAAN,IAAA,CAGEO,QAAQ;MACRC,QAAA,GAAAR,IAAA,CAAAQ,QAAA;IAAAC,eAAA,OAAAZ,YAAA;IAOFa,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA,8BApBwC,EAoBxC;IAAAA,eAAA,uBAnBqC,KAmBrC;IAAAA,eAAA,uBAlBqC,KAkBrC;IAAAA,eAAA,sBAjBuC,IAiBvC;IAAAA,eAAA,iBAhBwB,KAgBxB;IAAAA,eAAA,2BAoJkB,UAAAH,QAAD,EAAwB;MACzClB,KAAK,CAACO,uBAAD,EAA0BG,KAA1B,EAAgCQ,QAAhC,CAAL;MACA,IAAIA,QAAJ,EAAc;QACZR,KAAA,CAAKY,OAAL,CAAaJ,QAAb,GAAwBA,QAAxB;MACD;IACF,CAzJC;IAUA,KAAKK,MAAL,GAAc,EAAd;IACA,KAAKC,eAAL,GAAuB,IAAIrB,eAAJ,CAAoB;MAACM,EAAD,EAACA,EAAD;MAAKgB,QAAQ,EAAE;IAAf,CAApB,CAAvB;IAEA,KAAKH,OAAL,GAAe;MACbI,aAAa,EAAE,IADF;MAEbC,QAAQ,EAAE,EAFG;MAGbC,YAAY,EAAE,IAHD;MAIbnB,EAJa,EAIbA,EAJa;MAKbM,IALa,EAKbA,IALa;MAObc,cAAc,EAAEpB,EAAE,IAAIJ,oBAAoB,CAACI,EAAD,CAP7B;MAQbO,KAAK,EAAEA,KAAK,IAAI,IAAId,KAAJ,CAAU;QAAC4B,EAAE,EAAE;MAAL,CAAV,CARH;MAUbZ,QAAQ,EAAED,SAAQ,IAAI,IAAIb,QAAJ,CAAa;QAAC0B,EAAE,EAAE;MAAL,CAAb,CAVT;MAWbX,QAAQ,EAAEA,QAAQ,IAAI,IAAItB,QAAJ,EAXT;MAYb2B,eAAe,EAAE,KAAKA,eAZT;MAabO,OAAO,EAAEjB;IAbI,CAAf;IAgBAkB,MAAM,CAACC,IAAP,CAAY,IAAZ;EACD;EAAAC,YAAA,CAAA1B,YAAA;IAAA2B,GAAA;IAAAC,KAAA,EAGD,SAAAC,SAAA,EAAW;MACT,KAAKb,eAAL,CAAqBa,QAArB;MAAA,IAAAC,SAAA,GAAAC,0BAAA,CAEoB,KAAKhB,MAAzB;QAAAiB,KAAA;MAAA;QAAA,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAiC;UAAA,IAAtBC,KAAX,GAAAJ,KAAA,CAAAJ,KAAA;UACE,KAAKS,cAAL,CAAoBD,KAApB;QACD;MAAA,SAAAE,GAAA;QAAAR,SAAA,CAAAS,CAAA,CAAAD,GAAA;MAAA;QAAAR,SAAA,CAAAU,CAAA;MAAA;IACF;EAAA;IAAAb,GAAA;IAAAC,KAAA,EAGD,SAAAa,YAAA,EAKkB;MAAA,IAJhBC,IAGC,GAAAtC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG;QAACuC,gBAAgB,EAAE;MAAnB,CAJK;MAMT,IAAIC,MAAM,GAAG,KAAKC,YAAlB;MACA,IAAIH,IAAI,CAACC,gBAAT,EAA2B;QACzB,KAAKE,YAAL,GAAoB,KAApB;MACD;MAAA,IAAAC,UAAA,GAAAf,0BAAA,CAGmB,KAAKhB,MAAzB;QAAAgC,MAAA;MAAA;QAAA,KAAAD,UAAA,CAAAb,CAAA,MAAAc,MAAA,GAAAD,UAAA,CAAAZ,CAAA,IAAAC,IAAA,GAAiC;UAAA,IAAtBC,KAAX,GAAAW,MAAA,CAAAnB,KAAA;UAEE,IAAMoB,gBAAgB,GAAGZ,KAAK,CAACa,cAAN,CAAqBP,IAArB,CAAzB;UACAE,MAAM,GAAGA,MAAM,IAAII,gBAAnB;QACD;MAAA,SAAAV,GAAA;QAAAQ,UAAA,CAAAP,CAAA,CAAAD,GAAA;MAAA;QAAAQ,UAAA,CAAAN,CAAA;MAAA;MAED,OAAOI,MAAP;IACD;EAAA;IAAAjB,GAAA;IAAAC,KAAA,EAGD,SAAAsB,YAAA,EAA8B;MAC5B,IAAI,KAAKC,WAAL,IAAoB,KAAKA,WAAL,KAAqB,KAAKC,mBAAlD,EAAuE;QAErE,OAAO,gBAAP;MACD;MACD,OAAO,KAAKC,YAAZ;IACD;EAAA;IAAA1B,GAAA;IAAAC,KAAA,EAGD,SAAA0B,eAAeC,MAAD,EAAuB;MACnC,KAAKV,YAAL,GAAoB,KAAKA,YAAL,IAAqBU,MAAzC;IACD;EAAA;IAAA5B,GAAA;IAAAC,KAAA,EAID,SAAA4B,eAAeD,MAAD,EAAuB;MACnC,KAAKF,YAAL,GAAoB,KAAKA,YAAL,IAAqBE,MAAzC;IACD;EAAA;IAAA5B,GAAA;IAAAC,KAAA,EAGD,SAAA6B,UAAA,EAA2D;MAAA,IAAAC,KAAA,GAAAtD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAb,EAArC;QAAEuD,QAAA,GAAAD,KAAA,CAAAC,QAAA;MAGT,OAAOA,QAAQ,GACX,KAAK5C,MAAL,CAAY6C,MAAZ,CAAmB,UAAAxB,KAAK;QAAA,OAAIuB,QAAQ,CAACE,IAAT,CAAc,UAAAC,OAAO;UAAA,OAAI1B,KAAK,CAACd,EAAN,CAASyC,OAAT,CAAiBD,OAAjB,MAA8B,CAAvD;QAAA,EAA5B;MAAA,EADW,GAEX,KAAK/C,MAFT;IAGD;EAAA;IAAAY,GAAA;IAAAC,KAAA,EAGD,SAAAoC,SAASC,KAAD,EAAmB;MACzB,IAAI,WAAWA,KAAf,EAAsB;QACpB,KAAKC,MAAL,GAAcD,KAAK,CAACzE,KAApB;MACD;MAGD,IAAI,cAAcyE,KAAlB,EAAyB;QACvB,KAAKnD,OAAL,CAAaK,QAAb,GAAwB8C,KAAK,CAAC9C,QAA9B;MACD;MAGD,IAAI,YAAY8C,KAAhB,EAAuB;QACrB,KAAKd,WAAL,GAAmBc,KAAK,CAAClD,MAAzB;MACD;MAED,IAAI,aAAakD,KAAjB,EAAwB;QACtB,KAAKnD,OAAL,CAAaS,OAAb,GAAuB0C,KAAK,CAAC1C,OAA7B;MACD;IACF;EAAA;IAAAI,GAAA;IAAAC,KAAA,EAGD,SAAAuC,UAAUC,SAAD,EAAwBb,MAAxB,EAA+C;MACtD/D,KAAK,CAACM,gBAAD,EAAmB,IAAnB,EAAyByD,MAAzB,EAAiCa,SAAjC,CAAL;MAEA,KAAKhB,mBAAL,GAA2BgB,SAA3B;MAEA,IAAMC,UAAU,GAAG5E,OAAO,CAAC2E,SAAD,EAAYE,OAAZ,CAA1B;MAAA,IAAAC,UAAA,GAAAxC,0BAAA,CAEoBsC,UAApB;QAAAG,MAAA;MAAA;QAAA,KAAAD,UAAA,CAAAtC,CAAA,MAAAuC,MAAA,GAAAD,UAAA,CAAArC,CAAA,IAAAC,IAAA,GAAgC;UAAA,IAArBC,KAAX,GAAAoC,MAAA,CAAA5C,KAAA;UACEQ,KAAK,CAACtB,OAAN,GAAgB,KAAKA,OAArB;QACD;MAAA,SAAAwB,GAAA;QAAAiC,UAAA,CAAAhC,CAAA,CAAAD,GAAA;MAAA;QAAAiC,UAAA,CAAA/B,CAAA;MAAA;MAED,KAAKiC,aAAL,CAAmB,KAAK1D,MAAxB,EAAgCsD,UAAhC;IACD;EAAA;IAAA1C,GAAA;IAAAC,KAAA,EAGD,SAAA8C,aAAA,EAAqB;MAInB,IAAMnB,MAAM,GAAG,KAAKL,WAAL,EAAf;MACA,IAAIK,MAAJ,EAAY;QACV,KAAKD,cAAL,qBAAAqB,MAAA,CAAwCpB,MAAxC;QAEA,KAAKY,SAAL,CAAe,KAAKhB,WAAL,IAAoB,KAAKC,mBAAxC,EAA6DG,MAA7D;MACD;MAED,KAAKJ,WAAL,GAAmB,IAAnB;IACD;EAAA;IAAAxB,GAAA;IAAAC,KAAA,EAcO,SAAAgD,aAAaC,KAAD,EAAgBC,KAAhB,EAA8B1C,KAA9B,EAA4C;MAC9DA,KAAK,CAAC2C,UAAN,CAAiBD,KAAjB,KAAAH,MAAA,CAA2BE,KAA3B,UAAAF,MAAA,CAAuCvC,KAAvC;IACD;EAAA;IAAAT,GAAA;IAAAC,KAAA,EAKO,SAAA6C,cAAcO,SAAD,EAAqBZ,SAArB,EAA+C;MAElE,IAAMa,WAA8C,GAAG,EAAvD;MAAA,IAAAC,UAAA,GAAAnD,0BAAA,CACuBiD,SAAvB;QAAAG,MAAA;MAAA;QAAA,KAAAD,UAAA,CAAAjD,CAAA,MAAAkD,MAAA,GAAAD,UAAA,CAAAhD,CAAA,IAAAC,IAAA,GAAkC;UAAA,IAAvBiD,QAAX,GAAAD,MAAA,CAAAvD,KAAA;UACE,IAAIqD,WAAW,CAACG,QAAQ,CAAC9D,EAAV,CAAf,EAA8B;YAC5B/B,GAAG,CAAC8F,IAAJ,qCAAAV,MAAA,CAA6CS,QAAQ,CAAC9D,EAAtD;UACD,CAFD,MAEO;YACL2D,WAAW,CAACG,QAAQ,CAAC9D,EAAV,CAAX,GAA2B8D,QAA3B;UACD;QACF;MAAA,SAAA9C,GAAA;QAAA4C,UAAA,CAAA3C,CAAA,CAAAD,GAAA;MAAA;QAAA4C,UAAA,CAAA1C,CAAA;MAAA;MAGD,IAAM8C,eAAwB,GAAG,EAAjC;MAGA,KAAKC,2BAAL,CAAiCnB,SAAjC,EAA4Ca,WAA5C,EAAyDK,eAAzD;MAGA,KAAKE,kBAAL,CAAwBP,WAAxB;MAEA,IAAI/B,WAA2B,GAAG,KAAlC;MACA,SAAAuC,EAAA,MAAAC,gBAAA,GAAoBJ,eAApB,EAAAG,EAAA,GAAAC,gBAAA,CAAArF,MAAA,EAAAoF,EAAA,IAAqC;QAAhC,IAAMrD,KAAX,GAAAsD,gBAAA,CAAAD,EAAA;QACE,IAAIrD,KAAK,CAACuD,oBAAN,EAAJ,EAAkC;UAChCzC,WAAW,4BAAAyB,MAAA,CAA4BvC,KAA5B,CAAX;UACA;QACD;MACF;MAED,KAAKiB,YAAL,GAAoBH,WAApB;MACA,KAAKnC,MAAL,GAAcuE,eAAd;IACD;EAAA;IAAA3D,GAAA;IAAAC,KAAA,EAIO,SAAA2D,4BACNnB,SADiC,EAEjCa,WAFiC,EAGjCK,eAHiC,EAIjC;MAAA,IAAAM,UAAA,GAAA7D,0BAAA,CACuBqC,SAAvB;QAAAyB,MAAA;MAAA;QAAA,KAAAD,UAAA,CAAA3D,CAAA,MAAA4D,MAAA,GAAAD,UAAA,CAAA1D,CAAA,IAAAC,IAAA,GAAkC;UAAA,IAAvB2D,QAAX,GAAAD,MAAA,CAAAjE,KAAA;UACEkE,QAAQ,CAAChF,OAAT,GAAmB,KAAKA,OAAxB;UAGA,IAAMsE,QAAQ,GAAGH,WAAW,CAACa,QAAQ,CAACxE,EAAV,CAA5B;UACA,IAAI8D,QAAQ,KAAK,IAAjB,EAAuB;YAErB7F,GAAG,CAAC8F,IAAJ,qCAAAV,MAAA,CAA6CmB,QAAQ,CAACxE,EAAtD;UACD;UAED2D,WAAW,CAACa,QAAQ,CAACxE,EAAV,CAAX,GAA2B,IAA3B;UAEA,IAAIyE,SAAyB,GAAG,IAAhC;UAGA,IAAI;YACF,IAAI,KAAK7B,MAAL,IAAekB,QAAQ,KAAKU,QAAhC,EAA0C;cACxCA,QAAQ,CAACE,aAAT;YACD;YAED,IAAI,CAACZ,QAAL,EAAe;cACb,KAAKa,gBAAL,CAAsBH,QAAtB;YACD,CAFD,MAEO;cACL,KAAKI,mBAAL,CAAyBd,QAAzB,EAAmCU,QAAnC;cACA,KAAKK,YAAL,CAAkBL,QAAlB;YACD;YACDR,eAAe,CAACc,IAAhB,CAAqBN,QAArB;YAGAC,SAAS,GAAGD,QAAQ,CAACO,WAAT,GAAwBP,QAAD,CAA6BQ,YAA7B,EAAvB,GAAqE,IAAjF;UAED,CAhBD,CAgBE,OAAOhE,GAAP,EAAY;YACZ,KAAKsC,YAAL,CAAkB,UAAlB,EAA8BtC,GAA9B,EAA4CwD,QAA5C;UACD;UAED,IAAIC,SAAJ,EAAe;YACb,KAAKR,2BAAL,CAAiCQ,SAAjC,EAA4Cd,WAA5C,EAAyDK,eAAzD;UACD;QACF;MAAA,SAAAhD,GAAA;QAAAsD,UAAA,CAAArD,CAAA,CAAAD,GAAA;MAAA;QAAAsD,UAAA,CAAApD,CAAA;MAAA;IACF;EAAA;IAAAb,GAAA;IAAAC,KAAA,EAIO,SAAA4D,mBAAmBP,WAAD,EAAuD;MAC/E,KAAK,IAAMnB,OAAX,IAAsBmB,WAAtB,EAAmC;QACjC,IAAM7C,KAAK,GAAG6C,WAAW,CAACnB,OAAD,CAAzB;QACA,IAAI1B,KAAJ,EAAW;UACT,KAAKC,cAAL,CAAoBD,KAApB;QACD;MACF;IACF;EAAA;IAAAT,GAAA;IAAAC,KAAA,EAKO,SAAAqE,iBAAiB7D,KAAD,EAAqB;MAC3C,IAAI;QACFA,KAAK,CAACmE,WAAN;QACAnE,KAAK,CAACoE,SAAN,GAAkBlH,SAAS,CAACmH,WAA5B;MACD,CAHD,CAGE,OAAOnE,GAAP,EAAY;QACZ,KAAKsC,YAAL,CAAkB,gBAAlB,EAAoCtC,GAApC,EAAkDF,KAAlD;MAED;IACF;EAAA;IAAAT,GAAA;IAAAC,KAAA,EAGO,SAAAsE,oBAAoBd,QAAD,EAAkBU,QAAlB,EAAyC;MAClEA,QAAQ,CAACY,cAAT,CAAwBtB,QAAxB;MACAU,QAAQ,CAACU,SAAT,GAAqBlH,SAAS,CAACqH,OAA/B;MAEA,IAAIb,QAAQ,KAAKV,QAAjB,EAA2B;QACzBA,QAAQ,CAACoB,SAAT,GAAqBlH,SAAS,CAACsH,WAA/B;MACD;IACF;EAAA;IAAAjF,GAAA;IAAAC,KAAA,EAGO,SAAAuE,aAAa/D,KAAD,EAAqB;MACvC,IAAI;QACFA,KAAK,CAACyE,OAAN;MACD,CAFD,CAEE,OAAOvE,GAAP,EAAY;QACZ,KAAKsC,YAAL,CAAkB,QAAlB,EAA4BtC,GAA5B,EAA0CF,KAA1C;MACD;IACF;EAAA;IAAAT,GAAA;IAAAC,KAAA,EAGO,SAAAS,eAAeD,KAAD,EAAqB;MACzC,KAAKS,YAAL,GAAoB,KAAKA,YAAL,iBAAA8B,MAAA,CAAkCvC,KAAlC,CAApB;MAEAA,KAAK,CAACoE,SAAN,GAAkBlH,SAAS,CAACwH,qBAA5B;MAEA,IAAI;QACF1E,KAAK,CAAC2E,SAAN;QACA3E,KAAK,CAACoE,SAAN,GAAkBlH,SAAS,CAAC0H,SAA5B;MACD,CAHD,CAGE,OAAO1E,GAAP,EAAY;QACZ,KAAKsC,YAAL,CAAkB,cAAlB,EAAkCtC,GAAlC,EAAgDF,KAAhD;MACD;IACF;EAAA;EAAA,OAAApC,YAAA;AAAA;AAAA,SAlUkBA,YAAN,IAAAiH,OAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}