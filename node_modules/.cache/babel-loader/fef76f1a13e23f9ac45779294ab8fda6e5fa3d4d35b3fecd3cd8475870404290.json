{"ast":null,"code":"import _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Model, Geometry, FEATURES, hasFeatures } from '@luma.gl/core';\nimport { Layer, log, picking } from '@deck.gl/core';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\nvar DEFAULT_MINCOLOR = [0, 0, 0, 0];\nvar DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nvar COLOR_PROPS = [\"minColor\", \"maxColor\", \"colorRange\", \"colorDomain\"];\nvar defaultProps = {\n  cellSizePixels: {\n    value: 100,\n    min: 1\n  },\n  cellMarginPixels: {\n    value: 2,\n    min: 0,\n    max: 5\n  },\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\nvar ScreenGridCellLayer = /*#__PURE__*/function (_Layer) {\n  _inherits(ScreenGridCellLayer, _Layer);\n  var _super = _createSuper(ScreenGridCellLayer);\n  function ScreenGridCellLayer() {\n    _classCallCheck(this, ScreenGridCellLayer);\n    return _super.apply(this, arguments);\n  }\n  _createClass(ScreenGridCellLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return {\n        vs: vs,\n        fs: fs,\n        modules: [picking]\n      };\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var gl = this.context.gl;\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instancePositions: {\n          size: 3,\n          update: this.calculateInstancePositions\n        },\n        instanceCounts: {\n          size: 4,\n          noAlloc: true\n        }\n      });\n      this.setState({\n        model: this._getModel(gl)\n      });\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var oldProps = _ref2.oldProps,\n        props = _ref2.props,\n        changeFlags = _ref2.changeFlags;\n      _get(_getPrototypeOf(ScreenGridCellLayer.prototype), \"updateState\", this).call(this, {\n        oldProps: oldProps,\n        props: props,\n        changeFlags: changeFlags\n      });\n      var attributeManager = this.getAttributeManager();\n      if (props.numInstances !== oldProps.numInstances) {\n        attributeManager.invalidateAll();\n      } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n        attributeManager.invalidate('instancePositions');\n      }\n      this._updateUniforms(oldProps, props, changeFlags);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref3) {\n      var uniforms = _ref3.uniforms;\n      var _this$props = this.props,\n        parameters = _this$props.parameters,\n        maxTexture = _this$props.maxTexture;\n      var minColor = this.props.minColor || DEFAULT_MINCOLOR;\n      var maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n      var colorDomain = this.props.colorDomain || [1, 0];\n      var model = this.state.model;\n      model.setUniforms(uniforms).setUniforms({\n        minColor: minColor,\n        maxColor: maxColor,\n        maxTexture: maxTexture,\n        colorDomain: colorDomain\n      }).draw({\n        parameters: _objectSpread({\n          depthTest: false,\n          depthMask: false\n        }, parameters)\n      });\n    }\n  }, {\n    key: \"calculateInstancePositions\",\n    value: function calculateInstancePositions(attribute, _ref4) {\n      var numInstances = _ref4.numInstances;\n      var _this$context$viewpor = this.context.viewport,\n        width = _this$context$viewpor.width,\n        height = _this$context$viewpor.height;\n      var cellSizePixels = this.props.cellSizePixels;\n      var numCol = Math.ceil(width / cellSizePixels);\n      var value = attribute.value,\n        size = attribute.size;\n      for (var i = 0; i < numInstances; i++) {\n        var x = i % numCol;\n        var y = Math.floor(i / numCol);\n        value[i * size + 0] = x * cellSizePixels / width * 2 - 1;\n        value[i * size + 1] = 1 - y * cellSizePixels / height * 2;\n        value[i * size + 2] = 0;\n      }\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      return new Model(gl, _objectSpread(_objectSpread({}, this.getShaders()), {}, {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: 6,\n          attributes: {\n            positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n          }\n        }),\n        isInstanced: true\n      }));\n    }\n  }, {\n    key: \"_shouldUseMinMax\",\n    value: function _shouldUseMinMax() {\n      var _this$props2 = this.props,\n        minColor = _this$props2.minColor,\n        maxColor = _this$props2.maxColor,\n        colorDomain = _this$props2.colorDomain,\n        colorRange = _this$props2.colorRange;\n      if (minColor || maxColor) {\n        log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n        return true;\n      }\n      if (colorDomain || colorRange) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"_updateUniforms\",\n    value: function _updateUniforms(oldProps, props, changeFlags) {\n      var model = this.state.model;\n      if (COLOR_PROPS.some(function (key) {\n        return oldProps[key] !== props[key];\n      })) {\n        model.setUniforms({\n          shouldUseMinMax: this._shouldUseMinMax()\n        });\n      }\n      if (oldProps.colorRange !== props.colorRange) {\n        model.setUniforms({\n          colorRange: colorRangeToFlatArray(props.colorRange)\n        });\n      }\n      if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {\n        var _this$context$viewpor2 = this.context.viewport,\n          width = _this$context$viewpor2.width,\n          height = _this$context$viewpor2.height;\n        var _this$props3 = this.props,\n          cellSizePixels = _this$props3.cellSizePixels,\n          cellMarginPixels = _this$props3.cellMarginPixels;\n        var margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n        var cellScale = new Float32Array([(cellSizePixels - margin) / width * 2, -(cellSizePixels - margin) / height * 2, 1]);\n        model.setUniforms({\n          cellScale: cellScale\n        });\n      }\n    }\n  }], [{\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n    }\n  }]);\n  return ScreenGridCellLayer;\n}(Layer);\nexport { ScreenGridCellLayer as default };\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;","map":{"version":3,"names":["Model","Geometry","FEATURES","hasFeatures","Layer","log","picking","defaultColorRange","colorRangeToFlatArray","vs","fs","DEFAULT_MINCOLOR","DEFAULT_MAXCOLOR","COLOR_PROPS","defaultProps","cellSizePixels","value","min","cellMarginPixels","max","colorDomain","colorRange","ScreenGridCellLayer","_Layer","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","getShaders","modules","initializeState","gl","context","attributeManager","getAttributeManager","addInstanced","instancePositions","size","update","calculateInstancePositions","instanceCounts","noAlloc","setState","model","_getModel","shouldUpdateState","_ref","changeFlags","somethingChanged","updateState","_ref2","oldProps","props","_get","_getPrototypeOf","prototype","call","numInstances","invalidateAll","invalidate","_updateUniforms","draw","_ref3","uniforms","_this$props","parameters","maxTexture","minColor","maxColor","state","setUniforms","_objectSpread","depthTest","depthMask","attribute","_ref4","_this$context$viewpor","viewport","width","height","numCol","Math","ceil","i","x","y","floor","id","geometry","drawMode","attributes","positions","Float32Array","isInstanced","_shouldUseMinMax","_this$props2","deprecated","some","shouldUseMinMax","viewportChanged","_this$context$viewpor2","_this$props3","margin","cellScale","isSupported","TEXTURE_FLOAT","default","layerName"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/aggregation-layers/src/screen-grid-layer/screen-grid-cell-layer.js"],"sourcesContent":["// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, FEATURES, hasFeatures} from '@luma.gl/core';\nimport {Layer, log, picking} from '@deck.gl/core';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\n\nconst DEFAULT_MINCOLOR = [0, 0, 0, 0];\nconst DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nconst COLOR_PROPS = [`minColor`, `maxColor`, `colorRange`, `colorDomain`];\n\nconst defaultProps = {\n  cellSizePixels: {value: 100, min: 1},\n  cellMarginPixels: {value: 2, min: 0, max: 5},\n\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\n\nexport default class ScreenGridCellLayer extends Layer {\n  static isSupported(gl) {\n    return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n  }\n\n  getShaders() {\n    return {vs, fs, modules: [picking]};\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {size: 3, update: this.calculateInstancePositions},\n      instanceCounts: {size: 4, noAlloc: true}\n    });\n    this.setState({\n      model: this._getModel(gl)\n    });\n  }\n\n  shouldUpdateState({changeFlags}) {\n    // 'instanceCounts' buffer contetns change on viewport change.\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({oldProps, props, changeFlags});\n\n    const attributeManager = this.getAttributeManager();\n    if (props.numInstances !== oldProps.numInstances) {\n      attributeManager.invalidateAll();\n    } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n      attributeManager.invalidate('instancePositions');\n    }\n\n    this._updateUniforms(oldProps, props, changeFlags);\n  }\n\n  draw({uniforms}) {\n    const {parameters, maxTexture} = this.props;\n    const minColor = this.props.minColor || DEFAULT_MINCOLOR;\n    const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n\n    // If colorDomain not specified we use default domain [1, maxCount]\n    // maxCount value will be sampled form maxTexture in vertex shader.\n    const colorDomain = this.props.colorDomain || [1, 0];\n    const {model} = this.state;\n    model\n      .setUniforms(uniforms)\n      .setUniforms({\n        minColor,\n        maxColor,\n        maxTexture,\n        colorDomain\n      })\n      .draw({\n        parameters: {\n          depthTest: false,\n          depthMask: false,\n          ...parameters\n        }\n      });\n  }\n\n  calculateInstancePositions(attribute, {numInstances}) {\n    const {width, height} = this.context.viewport;\n    const {cellSizePixels} = this.props;\n    const numCol = Math.ceil(width / cellSizePixels);\n\n    const {value, size} = attribute;\n\n    for (let i = 0; i < numInstances; i++) {\n      const x = i % numCol;\n      const y = Math.floor(i / numCol);\n      value[i * size + 0] = ((x * cellSizePixels) / width) * 2 - 1;\n      value[i * size + 1] = 1 - ((y * cellSizePixels) / height) * 2;\n      value[i * size + 2] = 0;\n    }\n  }\n\n  // Private Methods\n\n  _getModel(gl) {\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLE_FAN,\n        attributes: {\n          positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _shouldUseMinMax() {\n    const {minColor, maxColor, colorDomain, colorRange} = this.props;\n    if (minColor || maxColor) {\n      log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n      return true;\n    }\n    // minColor and maxColor not supplied, check if colorRange or colorDomain supplied.\n    // NOTE: colorDomain and colorRange are experimental features, use them only when supplied.\n    if (colorDomain || colorRange) {\n      return false;\n    }\n    // None specified, use default minColor and maxColor\n    return true;\n  }\n\n  _updateUniforms(oldProps, props, changeFlags) {\n    const {model} = this.state;\n    if (COLOR_PROPS.some(key => oldProps[key] !== props[key])) {\n      model.setUniforms({shouldUseMinMax: this._shouldUseMinMax()});\n    }\n\n    if (oldProps.colorRange !== props.colorRange) {\n      model.setUniforms({colorRange: colorRangeToFlatArray(props.colorRange)});\n    }\n\n    if (\n      oldProps.cellMarginPixels !== props.cellMarginPixels ||\n      oldProps.cellSizePixels !== props.cellSizePixels ||\n      changeFlags.viewportChanged\n    ) {\n      const {width, height} = this.context.viewport;\n      const {cellSizePixels, cellMarginPixels} = this.props;\n      const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n\n      const cellScale = new Float32Array([\n        ((cellSizePixels - margin) / width) * 2,\n        (-(cellSizePixels - margin) / height) * 2,\n        1\n      ]);\n      model.setUniforms({cellScale});\n    }\n  }\n}\n\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}