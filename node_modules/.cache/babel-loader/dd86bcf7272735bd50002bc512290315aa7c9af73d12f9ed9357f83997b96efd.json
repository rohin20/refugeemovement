{"ast":null,"code":"import _defineProperty from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getFloatTexture } from '../utils/resource-utils.js';\nvar defaultProps = _objectSpread(_objectSpread({}, ScreenGridCellLayer.defaultProps), {}, {\n  getPosition: {\n    type: 'accessor',\n    value: function value(d) {\n      return d.position;\n    }\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM'\n});\nvar POSITION_ATTRIBUTE_NAME = 'positions';\nvar DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\nvar ScreenGridLayer = /*#__PURE__*/function (_GridAggregationLayer) {\n  _inherits(ScreenGridLayer, _GridAggregationLayer);\n  var _super = _createSuper(ScreenGridLayer);\n  function ScreenGridLayer() {\n    _classCallCheck(this, ScreenGridLayer);\n    return _super.apply(this, arguments);\n  }\n  _createClass(ScreenGridLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _attributeManager$add;\n      var gl = this.context.gl;\n      if (!ScreenGridCellLayer.isSupported(gl)) {\n        this.setState({\n          supported: false\n        });\n        log.error(\"ScreenGridLayer: \".concat(this.id, \" is not supported on this browser\"))();\n        return;\n      }\n      _get(_getPrototypeOf(ScreenGridLayer.prototype), \"initializeState\", this).call(this, {\n        dimensions: DIMENSIONS,\n        getCellSize: function getCellSize(props) {\n          return props.cellSizePixels;\n        }\n      });\n      var weights = {\n        count: {\n          size: 1,\n          operation: AGGREGATION_OPERATION.SUM,\n          needMax: true,\n          maxTexture: getFloatTexture(gl, {\n            id: \"\".concat(this.id, \"-max-texture\")\n          })\n        }\n      };\n      this.setState({\n        supported: true,\n        projectPoints: true,\n        weights: weights,\n        subLayerData: {\n          attributes: {}\n        },\n        maxTexture: weights.count.maxTexture,\n        positionAttributeName: 'positions',\n        posOffset: [0, 0],\n        translation: [1, -1]\n      });\n      var attributeManager = this.getAttributeManager();\n      attributeManager.add((_attributeManager$add = {}, _defineProperty(_attributeManager$add, POSITION_ATTRIBUTE_NAME, {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      }), _defineProperty(_attributeManager$add, \"count\", {\n        size: 3,\n        accessor: 'getWeight'\n      }), _attributeManager$add));\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return this.state.supported && changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts) {\n      _get(_getPrototypeOf(ScreenGridLayer.prototype), \"updateState\", this).call(this, opts);\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      if (!this.state.supported) {\n        return [];\n      }\n      var _this$state = this.state,\n        maxTexture = _this$state.maxTexture,\n        numRow = _this$state.numRow,\n        numCol = _this$state.numCol,\n        weights = _this$state.weights;\n      var updateTriggers = this.props.updateTriggers;\n      var aggregationBuffer = weights.count.aggregationBuffer;\n      var CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n      return new CellLayerClass(this.props, this.getSubLayerProps({\n        id: 'cell-layer',\n        updateTriggers: updateTriggers\n      }), {\n        data: {\n          attributes: {\n            instanceCounts: aggregationBuffer\n          }\n        },\n        maxTexture: maxTexture,\n        numInstances: numRow * numCol\n      });\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      _get(_getPrototypeOf(ScreenGridLayer.prototype), \"finalizeState\", this).call(this);\n      var _this$state2 = this.state,\n        aggregationBuffer = _this$state2.aggregationBuffer,\n        maxBuffer = _this$state2.maxBuffer,\n        maxTexture = _this$state2.maxTexture;\n      aggregationBuffer === null || aggregationBuffer === void 0 ? void 0 : aggregationBuffer.delete();\n      maxBuffer === null || maxBuffer === void 0 ? void 0 : maxBuffer.delete();\n      maxTexture === null || maxTexture === void 0 ? void 0 : maxTexture.delete();\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref2) {\n      var info = _ref2.info,\n        mode = _ref2.mode;\n      var index = info.index;\n      if (index >= 0) {\n        var _this$state3 = this.state,\n          gpuGridAggregator = _this$state3.gpuGridAggregator,\n          gpuAggregation = _this$state3.gpuAggregation,\n          weights = _this$state3.weights;\n        var aggregationResults = gpuAggregation ? gpuGridAggregator.getData('count') : weights.count;\n        info.object = GPUGridAggregator.getAggregationData(_objectSpread({\n          pixelIndex: index\n        }, aggregationResults));\n      }\n      return info;\n    }\n  }, {\n    key: \"updateResults\",\n    value: function updateResults(_ref3) {\n      var aggregationData = _ref3.aggregationData,\n        maxData = _ref3.maxData;\n      var count = this.state.weights.count;\n      count.aggregationData = aggregationData;\n      count.aggregationBuffer.setData({\n        data: aggregationData\n      });\n      count.maxData = maxData;\n      count.maxTexture.setImageData({\n        data: maxData\n      });\n    }\n  }, {\n    key: \"updateAggregationState\",\n    value: function updateAggregationState(opts) {\n      var cellSize = opts.props.cellSizePixels;\n      var cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n      var viewportChanged = opts.changeFlags.viewportChanged;\n      var gpuAggregation = opts.props.gpuAggregation;\n      if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n        if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n          log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n          gpuAggregation = false;\n        }\n      }\n      var gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n      this.setState({\n        gpuAggregation: gpuAggregation\n      });\n      var positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n      var dimensions = this.state.dimensions;\n      var data = dimensions.data,\n        weights = dimensions.weights;\n      var aggregationDataDirty = positionsChanged || gpuAggregationChanged || viewportChanged || this.isAggregationDirty(opts, {\n        compareAll: gpuAggregation,\n        dimension: data\n      });\n      var aggregationWeightsDirty = this.isAggregationDirty(opts, {\n        dimension: weights\n      });\n      this.setState({\n        aggregationDataDirty: aggregationDataDirty,\n        aggregationWeightsDirty: aggregationWeightsDirty\n      });\n      var viewport = this.context.viewport;\n      if (viewportChanged || cellSizeChanged) {\n        var width = viewport.width,\n          height = viewport.height;\n        var numCol = Math.ceil(width / cellSize);\n        var numRow = Math.ceil(height / cellSize);\n        this.allocateResources(numRow, numCol);\n        this.setState({\n          scaling: [width / 2, -height / 2, 1],\n          gridOffset: {\n            xOffset: cellSize,\n            yOffset: cellSize\n          },\n          width: width,\n          height: height,\n          numCol: numCol,\n          numRow: numRow\n        });\n      }\n      if (aggregationWeightsDirty) {\n        this._updateAccessors(opts);\n      }\n      if (aggregationDataDirty || aggregationWeightsDirty) {\n        this._resetResults();\n      }\n    }\n  }, {\n    key: \"_updateAccessors\",\n    value: function _updateAccessors(opts) {\n      var _opts$props = opts.props,\n        getWeight = _opts$props.getWeight,\n        aggregation = _opts$props.aggregation,\n        data = _opts$props.data;\n      var count = this.state.weights.count;\n      if (count) {\n        count.getWeight = getWeight;\n        count.operation = AGGREGATION_OPERATION[aggregation];\n      }\n      this.setState({\n        getValue: getValueFunc(aggregation, getWeight, {\n          data: data\n        })\n      });\n    }\n  }, {\n    key: \"_resetResults\",\n    value: function _resetResults() {\n      var count = this.state.weights.count;\n      if (count) {\n        count.aggregationData = null;\n      }\n    }\n  }]);\n  return ScreenGridLayer;\n}(GridAggregationLayer);\nexport { ScreenGridLayer as default };\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;","map":{"version":3,"names":["log","GPUGridAggregator","AGGREGATION_OPERATION","getValueFunc","ScreenGridCellLayer","GridAggregationLayer","getFloatTexture","defaultProps","_objectSpread","getPosition","type","value","d","position","getWeight","gpuAggregation","aggregation","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","props","weights","accessors","ScreenGridLayer","_GridAggregationLayer","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","initializeState","_attributeManager$add","gl","context","isSupported","setState","supported","error","concat","id","_get","_getPrototypeOf","prototype","call","dimensions","getCellSize","cellSizePixels","count","size","operation","SUM","needMax","maxTexture","projectPoints","subLayerData","attributes","positionAttributeName","posOffset","translation","attributeManager","getAttributeManager","add","_defineProperty","accessor","fp64","use64bitPositions","shouldUpdateState","_ref","changeFlags","state","somethingChanged","updateState","opts","renderLayers","_this$state","numRow","numCol","updateTriggers","aggregationBuffer","CellLayerClass","getSubLayerClass","getSubLayerProps","instanceCounts","numInstances","finalizeState","_this$state2","maxBuffer","delete","getPickingInfo","_ref2","info","mode","index","_this$state3","gpuGridAggregator","aggregationResults","getData","object","getAggregationData","pixelIndex","updateResults","_ref3","aggregationData","maxData","setData","setImageData","updateAggregationState","cellSize","cellSizeChanged","oldProps","viewportChanged","warn","gpuAggregationChanged","positionsChanged","isAttributeChanged","aggregationDataDirty","isAggregationDirty","compareAll","dimension","aggregationWeightsDirty","viewport","width","height","Math","ceil","allocateResources","scaling","gridOffset","xOffset","yOffset","_updateAccessors","_resetResults","_opts$props","getValue","default","layerName"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/aggregation-layers/src/screen-grid-layer/screen-grid-layer.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {log} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION, getValueFunc} from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport {getFloatTexture} from '../utils/resource-utils.js';\n\nconst defaultProps = {\n  ...ScreenGridCellLayer.defaultProps,\n  getPosition: {type: 'accessor', value: d => d.position},\n  getWeight: {type: 'accessor', value: 1},\n\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\n\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\nexport default class ScreenGridLayer extends GridAggregationLayer {\n  initializeState() {\n    const {gl} = this.context;\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      // max aggregated value is sampled from a float texture\n      this.setState({supported: false});\n      log.error(`ScreenGridLayer: ${this.id} is not supported on this browser`)();\n      return;\n    }\n    super.initializeState({\n      dimensions: DIMENSIONS,\n      getCellSize: props => props.cellSizePixels\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {id: `${this.id}-max-texture`})\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true, // aggregation in screen space\n      weights,\n      subLayerData: {attributes: {}},\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      count: {size: 3, accessor: 'getWeight'}\n    });\n  }\n\n  shouldUpdateState({changeFlags}) {\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n  }\n\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n    const {maxTexture, numRow, numCol, weights} = this.state;\n    const {updateTriggers} = this.props;\n    const {aggregationBuffer} = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n\n    return new CellLayerClass(\n      this.props,\n      this.getSubLayerProps({\n        id: 'cell-layer',\n        updateTriggers\n      }),\n      {\n        data: {attributes: {instanceCounts: aggregationBuffer}},\n        maxTexture,\n        numInstances: numRow * numCol\n      }\n    );\n  }\n\n  finalizeState() {\n    super.finalizeState();\n\n    const {aggregationBuffer, maxBuffer, maxTexture} = this.state;\n\n    aggregationBuffer?.delete();\n    maxBuffer?.delete();\n    maxTexture?.delete();\n  }\n\n  getPickingInfo({info, mode}) {\n    const {index} = info;\n    if (index >= 0) {\n      const {gpuGridAggregator, gpuAggregation, weights} = this.state;\n      // Get count aggregation results\n      const aggregationResults = gpuAggregation\n        ? gpuGridAggregator.getData('count')\n        : weights.count;\n\n      // Each instance (one cell) is aggregated into single pixel,\n      // Get current instance's aggregation details.\n      info.object = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...aggregationResults\n      });\n    }\n\n    return info;\n  }\n\n  // Aggregation Overrides\n\n  updateResults({aggregationData, maxData}) {\n    const {count} = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({data: aggregationData});\n    count.maxData = maxData;\n    count.maxTexture.setImageData({data: maxData});\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {viewportChanged} = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n\n    const {dimensions} = this.state;\n    const {data, weights} = dimensions;\n    const aggregationDataDirty =\n      positionsChanged ||\n      gpuAggregationChanged ||\n      viewportChanged ||\n      this.isAggregationDirty(opts, {\n        compareAll: gpuAggregation, // check for all (including extentions props) when using gpu aggregation\n        dimension: data\n      });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {dimension: weights});\n\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n\n    const {viewport} = this.context;\n\n    if (viewportChanged || cellSizeChanged) {\n      const {width, height} = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        // transformation from clipspace to screen(pixel) space\n        scaling: [width / 2, -height / 2, 1],\n\n        gridOffset: {xOffset: cellSize, yOffset: cellSize},\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n  /* eslint-enable complexity, max-statements */\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {getWeight, aggregation, data} = opts.props;\n    const {count} = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({getValue: getValueFunc(aggregation, getWeight, {data})});\n  }\n\n  _resetResults() {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n}\n\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}