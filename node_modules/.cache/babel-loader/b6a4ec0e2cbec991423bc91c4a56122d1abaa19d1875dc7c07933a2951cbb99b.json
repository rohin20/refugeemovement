{"ast":null,"code":"import _regeneratorRuntime from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport Martini from '@mapbox/martini';\nimport Delatin from './delatin';\nimport { addSkirt } from './helpers/skirt';\nfunction getTerrain(imageData, width, height, elevationDecoder, tesselator) {\n  var rScaler = elevationDecoder.rScaler,\n    bScaler = elevationDecoder.bScaler,\n    gScaler = elevationDecoder.gScaler,\n    offset = elevationDecoder.offset;\n  var terrain = new Float32Array((width + 1) * (height + 1));\n  for (var i = 0, y = 0; y < height; y++) {\n    for (var x = 0; x < width; x++, i++) {\n      var k = i * 4;\n      var r = imageData[k + 0];\n      var g = imageData[k + 1];\n      var b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n  if (tesselator === 'martini') {\n    for (var _i = (width + 1) * width, _x = 0; _x < width; _x++, _i++) {\n      terrain[_i] = terrain[_i - width - 1];\n    }\n    for (var _i2 = height, _y = 0; _y < height + 1; _y++, _i2 += height + 1) {\n      terrain[_i2] = terrain[_i2 - 1];\n    }\n  }\n  return terrain;\n}\nfunction getMeshAttributes(vertices, terrain, width, height, bounds) {\n  var gridSize = width + 1;\n  var numOfVerticies = vertices.length / 2;\n  var positions = new Float32Array(numOfVerticies * 3);\n  var texCoords = new Float32Array(numOfVerticies * 2);\n  var _ref = bounds || [0, 0, width, height],\n    _ref2 = _slicedToArray(_ref, 4),\n    minX = _ref2[0],\n    minY = _ref2[1],\n    maxX = _ref2[2],\n    maxY = _ref2[3];\n  var xScale = (maxX - minX) / width;\n  var yScale = (maxY - minY) / height;\n  for (var i = 0; i < numOfVerticies; i++) {\n    var x = vertices[i * 2];\n    var y = vertices[i * 2 + 1];\n    var pixelIdx = y * gridSize + x;\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n    texCoords[2 * i + 0] = x / width;\n    texCoords[2 * i + 1] = y / height;\n  }\n  return {\n    POSITION: {\n      value: positions,\n      size: 3\n    },\n    TEXCOORD_0: {\n      value: texCoords,\n      size: 2\n    }\n  };\n}\nfunction getMesh(terrainImage, terrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n  var meshMaxError = terrainOptions.meshMaxError,\n    bounds = terrainOptions.bounds,\n    elevationDecoder = terrainOptions.elevationDecoder;\n  var data = terrainImage.data,\n    width = terrainImage.width,\n    height = terrainImage.height;\n  var terrain;\n  var mesh;\n  switch (terrainOptions.tesselator) {\n    case 'martini':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      break;\n    case 'delatin':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      break;\n    default:\n      if (width === height && !(height & width - 1)) {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'martini');\n        mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      } else {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'delatin');\n        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      }\n      break;\n  }\n  var _mesh = mesh,\n    vertices = _mesh.vertices;\n  var _mesh2 = mesh,\n    triangles = _mesh2.triangles;\n  var attributes = getMeshAttributes(vertices, terrain, width, height, bounds);\n  var boundingBox = getMeshBoundingBox(attributes);\n  if (terrainOptions.skirtHeight) {\n    var _addSkirt = addSkirt(attributes, triangles, terrainOptions.skirtHeight),\n      newAttributes = _addSkirt.attributes,\n      newTriangles = _addSkirt.triangles;\n    attributes = newAttributes;\n    triangles = newTriangles;\n  }\n  return {\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox: boundingBox\n    },\n    mode: 4,\n    indices: {\n      value: Uint32Array.from(triangles),\n      size: 1\n    },\n    attributes: attributes\n  };\n}\nfunction getMartiniTileMesh(meshMaxError, width, terrain) {\n  var gridSize = width + 1;\n  var martini = new Martini(gridSize);\n  var tile = martini.createTile(terrain);\n  var _tile$getMesh = tile.getMesh(meshMaxError),\n    vertices = _tile$getMesh.vertices,\n    triangles = _tile$getMesh.triangles;\n  return {\n    vertices: vertices,\n    triangles: triangles\n  };\n}\nfunction getDelatinTileMesh(meshMaxError, width, height, terrain) {\n  var tin = new Delatin(terrain, width + 1, height + 1);\n  tin.run(meshMaxError);\n  var coords = tin.coords,\n    triangles = tin.triangles;\n  var vertices = coords;\n  return {\n    vertices: vertices,\n    triangles: triangles\n  };\n}\nexport default function loadTerrain(_x2, _x3, _x4) {\n  return _loadTerrain.apply(this, arguments);\n}\nfunction _loadTerrain() {\n  _loadTerrain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(arrayBuffer, options, context) {\n    var loadImageOptions, image;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          loadImageOptions = _objectSpread(_objectSpread({}, options), {}, {\n            mimeType: 'application/x.image',\n            image: _objectSpread(_objectSpread({}, options.image), {}, {\n              type: 'data'\n            })\n          });\n          _context.next = 3;\n          return context.parse(arrayBuffer, loadImageOptions);\n        case 3:\n          image = _context.sent;\n          return _context.abrupt(\"return\", getMesh(image, options.terrain));\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _loadTerrain.apply(this, arguments);\n}","map":{"version":3,"names":["getMeshBoundingBox","Martini","Delatin","addSkirt","getTerrain","imageData","width","height","elevationDecoder","tesselator","rScaler","bScaler","gScaler","offset","terrain","Float32Array","i","y","x","k","r","g","b","getMeshAttributes","vertices","bounds","gridSize","numOfVerticies","length","positions","texCoords","_ref","_ref2","_slicedToArray","minX","minY","maxX","maxY","xScale","yScale","pixelIdx","POSITION","value","size","TEXCOORD_0","getMesh","terrainImage","terrainOptions","meshMaxError","data","mesh","getMartiniTileMesh","getDelatinTileMesh","_mesh","_mesh2","triangles","attributes","boundingBox","skirtHeight","_addSkirt","newAttributes","newTriangles","loaderData","header","vertexCount","mode","indices","Uint32Array","from","martini","tile","createTile","_tile$getMesh","tin","run","coords","loadTerrain","_x2","_x3","_x4","_loadTerrain","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","arrayBuffer","options","context","loadImageOptions","image","wrap","_callee$","_context","prev","next","_objectSpread","mimeType","type","parse","sent","abrupt","stop"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/terrain/src/lib/parse-terrain.ts"],"sourcesContent":["import {getMeshBoundingBox} from '@loaders.gl/schema';\nimport Martini from '@mapbox/martini';\nimport Delatin from './delatin';\nimport {addSkirt} from './helpers/skirt';\n\ntype TerrainOptions = {\n  meshMaxError: number;\n  bounds: number[];\n  elevationDecoder: ElevationDecoder;\n  tesselator: 'martini' | 'delatin';\n  skirtHeight?: number;\n};\n\ntype TerrainImage = {\n  data: Uint8Array;\n  width: number;\n  height: number;\n};\n\ntype ElevationDecoder = {\n  rScaler: any;\n  bScaler: any;\n  gScaler: any;\n  offset: number;\n};\n\nfunction getTerrain(\n  imageData: Uint8Array,\n  width: number,\n  height: number,\n  elevationDecoder: ElevationDecoder,\n  tesselator: 'martini' | 'delatin'\n) {\n  const {rScaler, bScaler, gScaler, offset} = elevationDecoder;\n\n  // From Martini demo\n  // https://observablehq.com/@mourner/martin-real-time-rtin-terrain-mesh\n  const terrain = new Float32Array((width + 1) * (height + 1));\n  // decode terrain values\n  for (let i = 0, y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++, i++) {\n      const k = i * 4;\n      const r = imageData[k + 0];\n      const g = imageData[k + 1];\n      const b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n\n  if (tesselator === 'martini') {\n    // backfill bottom border\n    for (let i = (width + 1) * width, x = 0; x < width; x++, i++) {\n      terrain[i] = terrain[i - width - 1];\n    }\n    // backfill right border\n    for (let i = height, y = 0; y < height + 1; y++, i += height + 1) {\n      terrain[i] = terrain[i - 1];\n    }\n  }\n\n  return terrain;\n}\n\nfunction getMeshAttributes(\n  vertices,\n  terrain: Uint8Array,\n  width: number,\n  height: number,\n  bounds: number[]\n) {\n  const gridSize = width + 1;\n  const numOfVerticies = vertices.length / 2;\n  // vec3. x, y in pixels, z in meters\n  const positions = new Float32Array(numOfVerticies * 3);\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(numOfVerticies * 2);\n\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];\n  const xScale = (maxX - minX) / width;\n  const yScale = (maxY - minY) / height;\n\n  for (let i = 0; i < numOfVerticies; i++) {\n    const x = vertices[i * 2];\n    const y = vertices[i * 2 + 1];\n    const pixelIdx = y * gridSize + x;\n\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n\n    texCoords[2 * i + 0] = x / width;\n    texCoords[2 * i + 1] = y / height;\n  }\n\n  return {\n    POSITION: {value: positions, size: 3},\n    TEXCOORD_0: {value: texCoords, size: 2}\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}\n\n/**\n * Returns generated mesh object from image data\n *\n * @param {object} terrainImage terrain image data\n * @param {object} terrainOptions terrain options\n * @returns mesh object\n */\nfunction getMesh(terrainImage: TerrainImage, terrainOptions: TerrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n  const {meshMaxError, bounds, elevationDecoder} = terrainOptions;\n\n  const {data, width, height} = terrainImage;\n\n  let terrain;\n  let mesh;\n  switch (terrainOptions.tesselator) {\n    case 'martini':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      break;\n    case 'delatin':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      break;\n    // auto\n    default:\n      if (width === height && !(height & (width - 1))) {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'martini');\n        mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      } else {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'delatin');\n        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      }\n      break;\n  }\n\n  const {vertices} = mesh;\n  let {triangles} = mesh;\n  let attributes = getMeshAttributes(vertices, terrain, width, height, bounds);\n\n  // Compute bounding box before adding skirt so that z values are not skewed\n  const boundingBox = getMeshBoundingBox(attributes);\n\n  if (terrainOptions.skirtHeight) {\n    const {attributes: newAttributes, triangles: newTriangles} = addSkirt(\n      attributes,\n      triangles,\n      terrainOptions.skirtHeight\n    );\n    attributes = newAttributes;\n    triangles = newTriangles;\n  }\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox\n    },\n    mode: 4, // TRIANGLES\n    indices: {value: Uint32Array.from(triangles), size: 1},\n    attributes\n  };\n}\n\n/**\n * Get Martini generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: Uint16Array, triangles: Uint32Array}} vertices and triangles data\n */\nfunction getMartiniTileMesh(meshMaxError, width, terrain) {\n  const gridSize = width + 1;\n  const martini = new Martini(gridSize);\n  const tile = martini.createTile(terrain);\n  const {vertices, triangles} = tile.getMesh(meshMaxError);\n\n  return {vertices, triangles};\n}\n\n/**\n * Get Delatin generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data array\n * @param {number} height height of the input data array\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: number[], triangles: number[]}} vertices and triangles data\n */\nfunction getDelatinTileMesh(meshMaxError, width, height, terrain) {\n  const tin = new Delatin(terrain, width + 1, height + 1);\n  tin.run(meshMaxError);\n  // @ts-expect-error\n  const {coords, triangles} = tin;\n  const vertices = coords;\n  return {vertices, triangles};\n}\n\nexport default async function loadTerrain(arrayBuffer, options, context) {\n  const loadImageOptions = {\n    ...options,\n    mimeType: 'application/x.image',\n    image: {...options.image, type: 'data'}\n  };\n  const image = await context.parse(arrayBuffer, loadImageOptions);\n  // Extend function to support additional mesh generation options (square grid or delatin)\n  return getMesh(image, options.terrain);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}