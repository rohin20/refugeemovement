{"ast":null,"code":"import _defineProperty from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _MODULE_INJECTORS;\nimport { MODULE_INJECTORS_VS, MODULE_INJECTORS_FS } from '../modules/module-injectors';\nimport { VERTEX_SHADER, FRAGMENT_SHADER } from './constants';\nimport { assert } from '../utils';\nvar MODULE_INJECTORS = (_MODULE_INJECTORS = {}, _defineProperty(_MODULE_INJECTORS, VERTEX_SHADER, MODULE_INJECTORS_VS), _defineProperty(_MODULE_INJECTORS, FRAGMENT_SHADER, MODULE_INJECTORS_FS), _MODULE_INJECTORS);\nexport var DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';\nvar REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/;\nvar REGEX_END_OF_MAIN = /}\\n?[^{}]*$/;\nvar fragments = [];\nexport default function injectShader(source, type, inject) {\n  var injectStandardStubs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var isVertex = type === VERTEX_SHADER;\n  var _loop = function _loop() {\n    var fragmentData = inject[key];\n    fragmentData.sort(function (a, b) {\n      return a.order - b.order;\n    });\n    fragments.length = fragmentData.length;\n    for (var i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    var fragmentString = \"\".concat(fragments.join('\\n'), \"\\n\");\n    switch (key) {\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, function (match) {\n            return match + fragmentString;\n          });\n        }\n        break;\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, function (match) {\n            return fragmentString + match;\n          });\n        }\n        break;\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, function (match) {\n            return match + fragmentString;\n          });\n        }\n        break;\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, function (match) {\n            return fragmentString + match;\n          });\n        }\n        break;\n      default:\n        source = source.replace(key, function (match) {\n          return match + fragmentString;\n        });\n    }\n  };\n  for (var key in inject) {\n    _loop();\n  }\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, function (match) {\n      return match + MODULE_INJECTORS[type];\n    });\n  }\n  return source;\n}\nexport function combineInjects(injects) {\n  var result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(function (inject) {\n    for (var key in inject) {\n      result[key] = result[key] ? \"\".concat(result[key], \"\\n\").concat(inject[key]) : inject[key];\n    }\n  });\n  return result;\n}","map":{"version":3,"names":["MODULE_INJECTORS_VS","MODULE_INJECTORS_FS","VERTEX_SHADER","FRAGMENT_SHADER","assert","MODULE_INJECTORS","_MODULE_INJECTORS","_defineProperty","DECLARATION_INJECT_MARKER","REGEX_START_OF_MAIN","REGEX_END_OF_MAIN","fragments","injectShader","source","type","inject","injectStandardStubs","arguments","length","undefined","isVertex","_loop","fragmentData","key","sort","a","b","order","i","len","injection","fragmentString","concat","join","replace","match","combineInjects","injects","result","Array","isArray","forEach"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@luma.gl/shadertools/src/lib/inject-shader.js"],"sourcesContent":["import {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {assert} from '../utils';\n\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__'; // Uniform/attribute declarations\n\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments = [];\n\n// A minimal shader injection/templating system.\n// RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n/* eslint-disable complexity */\nexport default function injectShader(source, type, inject, injectStandardStubs = false) {\n  const isVertex = type === VERTEX_SHADER;\n\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a, b) => a.order - b.order);\n    fragments.length = fragmentData.length;\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    const fragmentString = `${fragments.join('\\n')}\\n`;\n    switch (key) {\n      // declarations are injected before the main function\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // inject code at the beginning of the main function\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      // inject code at the end of main function\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n      // declarations are injected before the main function\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // inject code at the beginning of the main function\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      // inject code at the end of main function\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n\n      default:\n        // TODO(Tarek): I think this usage should be deprecated.\n\n        // inject code after key, leaving key in place\n        source = source.replace(key, match => match + fragmentString);\n    }\n  }\n\n  // Remove if it hasn't already been replaced\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, match => match + MODULE_INJECTORS[type]);\n  }\n\n  return source;\n}\n\n/* eslint-enable complexity */\n\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects) {\n  const result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}