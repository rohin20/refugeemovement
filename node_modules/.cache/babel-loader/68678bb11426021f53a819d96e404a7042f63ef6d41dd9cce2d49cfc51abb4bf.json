{"ast":null,"code":"// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n'use strict';\n\nvar CONSTANT = require('./constant');\nvar VALIDATOR_MAP = require('./validator-map');\nvar Utils = require('./utils');\nvar NUMBER_OF_ALLOWED_HITS = 3;\nvar Analyzer = {};\nAnalyzer._category = function _category(colType) {\n  return CONSTANT.TYPES_TO_CATEGORIES[colType] || CONSTANT.CATEGORIES.DIMENSION;\n};\nvar VALIDATOR_CONSIDERS_EMPTY_STRING_NULL = {\n  PAIR_GEOMETRY_FROM_STRING: true,\n  GEOMETRY_FROM_STRING: true,\n  NUMBER: true\n};\nvar VALIDATOR_CONSIDERS_NAN_NULL = {\n  INT: true,\n  NUMBER: true,\n  FLOAT: true\n};\n\n/**\n * Check if a given value is a null for a validator\n * @param {String} value - value to be checked if null\n * @param {String} validatorName - the name of the current validation function\n * @return {Boolean} whether or not the current value is null\n **/\nfunction valueIsNullForValidator(value, validatorName) {\n  if (value === null || value === CONSTANT.NULL || value === CONSTANT.DB_NULL || typeof value === 'undefined') {\n    return true;\n  }\n  if (Number.isNaN(value) && VALIDATOR_CONSIDERS_NAN_NULL[validatorName]) {\n    return true;\n  }\n  if (value === '' && VALIDATOR_CONSIDERS_EMPTY_STRING_NULL[validatorName]) {\n    return true;\n  }\n  return false;\n}\nfunction buildValidatorFinder(data, columnName) {\n  return function findTypeFromValidators(validatorName) {\n    // you get three strikes until we dont think you are this type\n    var nonNullData = data.filter(function iterator(row) {\n      var value = row[columnName];\n      return !valueIsNullForValidator(value, validatorName);\n    });\n    var validator = VALIDATOR_MAP[validatorName];\n    var strikes = Math.min(NUMBER_OF_ALLOWED_HITS, nonNullData.length);\n    var hits = 0;\n    nonNullData.some(function iterateAcrossData(row) {\n      var isValueValid = Boolean(validator(row[columnName]));\n      if (isValueValid) {\n        hits++;\n      } else {\n        strikes--;\n      }\n      if (strikes <= 0) {\n        return true;\n      }\n      return false;\n    });\n    return strikes > 0 && hits > 0;\n  };\n}\nfunction getTypeFromRules(analyzerRules, columnName) {\n  return (analyzerRules || []).reduce(function checkClmns(newType, rule) {\n    if (newType) {\n      return newType;\n    }\n    if (rule.name && rule.name === columnName) {\n      return rule.dataType;\n    }\n    if (rule.regex && rule.regex.test(columnName)) {\n      return rule.dataType;\n    }\n    return newType;\n  }, false);\n}\nfunction _pushIntoArr(arr, item) {\n  arr.push(item);\n}\nfunction _noop() {}\n\n/**\n * Generate metadata about columns in a dataset\n * @param {Object} data - data for which meta will be generated\n * @param {Object} analyzerRules - regexs describing column overrides\n * @param {Object.array} ignoredDataTypes - array of datatypes to ignore when validating\n * @return {Object} column metadata\n **/\nAnalyzer.computeColMeta = function computeColMeta(data, analyzerRules, options) {\n  options = options || {};\n  var ignoredDataTypes = options.ignoredDataTypes || [];\n  var keepUnknowns = options.keepUnknowns;\n  var maybePushUnknown = keepUnknowns ? _pushIntoArr : _noop;\n  var allValidators = CONSTANT.VALIDATORS.filter(function filterValidators(validator) {\n    return this.indexOf(validator) < 0;\n  }, ignoredDataTypes);\n  if (!data || Object.keys(data).length === 0) {\n    return [];\n  }\n  var _columns = Object.keys(data[0]);\n  /* eslint-disable max-statements, complexity */\n  return _columns.reduce(function iterator(res, columnName) {\n    var format = '';\n    // First try to get the column from the rules\n    var type = getTypeFromRules(analyzerRules, columnName);\n    // ff it's not there then try to infer the type\n    if (!type) {\n      type = allValidators.find(buildValidatorFinder(data, columnName));\n    }\n    var category = Analyzer._category(type);\n    var colMeta = {\n      key: columnName,\n      label: columnName,\n      type: CONSTANT.DATA_TYPES.STRING,\n      category: category || CONSTANT.CATEGORIES.DIMENSION,\n      format: ''\n    };\n\n    // if theres still no type, potentially dump this column\n    if (!type) {\n      maybePushUnknown(res, colMeta);\n      return res;\n    }\n    colMeta.type = type;\n\n    // if its a time, detect and record the time\n    if (type && CONSTANT.TIME_VALIDATORS.indexOf(type) !== -1) {\n      // Find the first non-null value.\n      var sample = Utils.findFirstNonNullValue(data, columnName);\n      if (sample === null) {\n        maybePushUnknown(res, colMeta);\n        return res;\n      }\n      format = Utils.detectTimeFormat(sample, type);\n    }\n    colMeta.format = format;\n    if (type === CONSTANT.DATA_TYPES.GEOMETRY) {\n      var geoSample = Utils.findFirstNonNullValue(data, columnName);\n      if (geoSample === null) {\n        maybePushUnknown(res, colMeta);\n        return res;\n      }\n      colMeta.geoType = typeof geoSample.type === 'string' ? geoSample.type.toUpperCase() : null;\n    }\n    if (type === CONSTANT.DATA_TYPES.GEOMETRY_FROM_STRING) {\n      var geoStringSample = Utils.findFirstNonNullValue(data, columnName);\n      if (geoStringSample === null) {\n        maybePushUnknown(res, colMeta);\n        return res;\n      }\n      colMeta.geoType = geoStringSample.split(' ')[0].toUpperCase();\n    }\n    if (type === CONSTANT.DATA_TYPES.PAIR_GEOMETRY_FROM_STRING) {\n      colMeta.geoType = 'POINT';\n    }\n    res.push(colMeta);\n    return res;\n  }, []);\n};\n/* eslint-enable max-statements */\n\nmodule.exports = Analyzer;","map":{"version":3,"names":["CONSTANT","require","VALIDATOR_MAP","Utils","NUMBER_OF_ALLOWED_HITS","Analyzer","_category","colType","TYPES_TO_CATEGORIES","CATEGORIES","DIMENSION","VALIDATOR_CONSIDERS_EMPTY_STRING_NULL","PAIR_GEOMETRY_FROM_STRING","GEOMETRY_FROM_STRING","NUMBER","VALIDATOR_CONSIDERS_NAN_NULL","INT","FLOAT","valueIsNullForValidator","value","validatorName","NULL","DB_NULL","Number","isNaN","buildValidatorFinder","data","columnName","findTypeFromValidators","nonNullData","filter","iterator","row","validator","strikes","Math","min","length","hits","some","iterateAcrossData","isValueValid","Boolean","getTypeFromRules","analyzerRules","reduce","checkClmns","newType","rule","name","dataType","regex","test","_pushIntoArr","arr","item","push","_noop","computeColMeta","options","ignoredDataTypes","keepUnknowns","maybePushUnknown","allValidators","VALIDATORS","filterValidators","indexOf","Object","keys","_columns","res","format","type","find","category","colMeta","key","label","DATA_TYPES","STRING","TIME_VALIDATORS","sample","findFirstNonNullValue","detectTimeFormat","GEOMETRY","geoSample","geoType","toUpperCase","geoStringSample","split","module","exports"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/type-analyzer/src/analyzer.js"],"sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n'use strict';\n\nvar CONSTANT = require('./constant');\nvar VALIDATOR_MAP = require('./validator-map');\nvar Utils = require('./utils');\n\nvar NUMBER_OF_ALLOWED_HITS = 3;\n\nvar Analyzer = {};\n\nAnalyzer._category = function _category(colType) {\n  return CONSTANT.TYPES_TO_CATEGORIES[colType] || CONSTANT.CATEGORIES.DIMENSION;\n};\n\nvar VALIDATOR_CONSIDERS_EMPTY_STRING_NULL = {\n  PAIR_GEOMETRY_FROM_STRING: true,\n  GEOMETRY_FROM_STRING: true,\n  NUMBER: true\n};\n\nvar VALIDATOR_CONSIDERS_NAN_NULL = {\n  INT: true,\n  NUMBER: true,\n  FLOAT: true\n};\n\n/**\n * Check if a given value is a null for a validator\n * @param {String} value - value to be checked if null\n * @param {String} validatorName - the name of the current validation function\n * @return {Boolean} whether or not the current value is null\n **/\nfunction valueIsNullForValidator(value, validatorName) {\n  if (\n    value === null ||\n    value === CONSTANT.NULL ||\n    value === CONSTANT.DB_NULL ||\n    typeof value === 'undefined'\n  ) {\n    return true;\n  }\n\n  if (Number.isNaN(value) && VALIDATOR_CONSIDERS_NAN_NULL[validatorName]) {\n    return true;\n  }\n\n  if (value === '' && VALIDATOR_CONSIDERS_EMPTY_STRING_NULL[validatorName]) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction buildValidatorFinder(data, columnName) {\n  return function findTypeFromValidators(validatorName) {\n    // you get three strikes until we dont think you are this type\n    var nonNullData = data.filter(function iterator(row) {\n      var value = row[columnName];\n      return !valueIsNullForValidator(value, validatorName);\n    });\n\n    var validator = VALIDATOR_MAP[validatorName];\n\n    var strikes = Math.min(NUMBER_OF_ALLOWED_HITS, nonNullData.length);\n    var hits = 0;\n    nonNullData.some(function iterateAcrossData(row) {\n      var isValueValid = Boolean(validator(row[columnName]));\n      if (isValueValid) {\n        hits++;\n      } else {\n        strikes--;\n      }\n\n      if (strikes <= 0) {\n        return true;\n      }\n      return false;\n    });\n\n    return strikes > 0 && hits > 0;\n  };\n}\n\nfunction getTypeFromRules(analyzerRules, columnName) {\n  return (analyzerRules || []).reduce(function checkClmns(newType, rule) {\n    if (newType) {\n      return newType;\n    }\n    if (rule.name && rule.name === columnName) {\n      return rule.dataType;\n    }\n    if (rule.regex && rule.regex.test(columnName)) {\n      return rule.dataType;\n    }\n    return newType;\n  }, false);\n}\n\nfunction _pushIntoArr(arr, item) {\n  arr.push(item);\n}\n\nfunction _noop() {}\n\n/**\n * Generate metadata about columns in a dataset\n * @param {Object} data - data for which meta will be generated\n * @param {Object} analyzerRules - regexs describing column overrides\n * @param {Object.array} ignoredDataTypes - array of datatypes to ignore when validating\n * @return {Object} column metadata\n **/\nAnalyzer.computeColMeta = function computeColMeta(\n  data,\n  analyzerRules,\n  options\n) {\n  options = options || {};\n  var ignoredDataTypes = options.ignoredDataTypes || [];\n  var keepUnknowns = options.keepUnknowns;\n  var maybePushUnknown = keepUnknowns ? _pushIntoArr : _noop;\n  var allValidators = CONSTANT.VALIDATORS.filter(function filterValidators(\n    validator\n  ) {\n    return this.indexOf(validator) < 0;\n  },\n  ignoredDataTypes);\n\n  if (!data || Object.keys(data).length === 0) {\n    return [];\n  }\n\n  var _columns = Object.keys(data[0]);\n  /* eslint-disable max-statements, complexity */\n  return _columns.reduce(function iterator(res, columnName) {\n    var format = '';\n    // First try to get the column from the rules\n    var type = getTypeFromRules(analyzerRules, columnName);\n    // ff it's not there then try to infer the type\n    if (!type) {\n      type = allValidators.find(buildValidatorFinder(data, columnName));\n    }\n    var category = Analyzer._category(type);\n    var colMeta = {\n      key: columnName,\n      label: columnName,\n      type: CONSTANT.DATA_TYPES.STRING,\n      category: category || CONSTANT.CATEGORIES.DIMENSION,\n      format: ''\n    };\n\n    // if theres still no type, potentially dump this column\n    if (!type) {\n      maybePushUnknown(res, colMeta);\n      return res;\n    }\n    colMeta.type = type;\n\n    // if its a time, detect and record the time\n    if (type && CONSTANT.TIME_VALIDATORS.indexOf(type) !== -1) {\n      // Find the first non-null value.\n      var sample = Utils.findFirstNonNullValue(data, columnName);\n      if (sample === null) {\n        maybePushUnknown(res, colMeta);\n        return res;\n      }\n      format = Utils.detectTimeFormat(sample, type);\n    }\n    colMeta.format = format;\n\n    if (type === CONSTANT.DATA_TYPES.GEOMETRY) {\n      var geoSample = Utils.findFirstNonNullValue(data, columnName);\n      if (geoSample === null) {\n        maybePushUnknown(res, colMeta);\n        return res;\n      }\n      colMeta.geoType =\n        typeof geoSample.type === 'string'\n          ? geoSample.type.toUpperCase()\n          : null;\n    }\n    if (type === CONSTANT.DATA_TYPES.GEOMETRY_FROM_STRING) {\n      var geoStringSample = Utils.findFirstNonNullValue(data, columnName);\n      if (geoStringSample === null) {\n        maybePushUnknown(res, colMeta);\n        return res;\n      }\n      colMeta.geoType = geoStringSample.split(' ')[0].toUpperCase();\n    }\n    if (type === CONSTANT.DATA_TYPES.PAIR_GEOMETRY_FROM_STRING) {\n      colMeta.geoType = 'POINT';\n    }\n    res.push(colMeta);\n    return res;\n  }, []);\n};\n/* eslint-enable max-statements */\n\nmodule.exports = Analyzer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}