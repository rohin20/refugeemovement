{"ast":null,"code":"import _regeneratorRuntime from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Tile3DSubtreeLoader } from '../../../tile-3d-subtree-loader';\nimport { load } from '@loaders.gl/core';\nvar QUADTREE_DEVISION_COUNT = 4;\nvar OCTREE_DEVISION_COUNT = 8;\nvar SUBDIVISION_COUNT_MAP = {\n  QUADTREE: QUADTREE_DEVISION_COUNT,\n  OCTREE: OCTREE_DEVISION_COUNT\n};\nexport function parseImplicitTiles(_x) {\n  return _parseImplicitTiles.apply(this, arguments);\n}\nfunction _parseImplicitTiles() {\n  _parseImplicitTiles = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {\n    var options, _params$parentData, parentData, _params$childIndex, childIndex, _params$globalData, globalData, subtree, _params$level, level, subdivisionScheme, subtreeLevels, maximumLevel, contentUrlTemplate, subtreesUriTemplate, basePath, tile, childrenPerTile, childX, childY, childZ, levelOffset, childTileMortonIndex, tileAvailabilityIndex, childTileX, childTileY, childTileZ, isChildSubtreeAvailable, x, y, z, lev, subtreePath, childSubtreeUrl, childSubtree, isTileAvailable, isContentAvailable, childTileLevel, pData, index, currentTile, globalLevel, childCoordinates, formattedTile;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          options = params.options, _params$parentData = params.parentData, parentData = _params$parentData === void 0 ? {\n            mortonIndex: 0,\n            x: 0,\n            y: 0,\n            z: 0\n          } : _params$parentData, _params$childIndex = params.childIndex, childIndex = _params$childIndex === void 0 ? 0 : _params$childIndex, _params$globalData = params.globalData, globalData = _params$globalData === void 0 ? {\n            level: 0,\n            mortonIndex: 0,\n            x: 0,\n            y: 0,\n            z: 0\n          } : _params$globalData;\n          subtree = params.subtree, _params$level = params.level, level = _params$level === void 0 ? 0 : _params$level;\n          subdivisionScheme = options.subdivisionScheme, subtreeLevels = options.subtreeLevels, maximumLevel = options.maximumLevel, contentUrlTemplate = options.contentUrlTemplate, subtreesUriTemplate = options.subtreesUriTemplate, basePath = options.basePath;\n          tile = {\n            children: [],\n            lodMetricValue: 0,\n            contentUrl: ''\n          };\n          childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];\n          childX = childIndex & 1;\n          childY = childIndex >> 1 & 1;\n          childZ = childIndex >> 2 & 1;\n          levelOffset = (Math.pow(childrenPerTile, level) - 1) / (childrenPerTile - 1);\n          childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex);\n          tileAvailabilityIndex = levelOffset + childTileMortonIndex;\n          childTileX = concatBits(parentData.x, childX);\n          childTileY = concatBits(parentData.y, childY);\n          childTileZ = concatBits(parentData.z, childZ);\n          isChildSubtreeAvailable = false;\n          if (level + 1 > subtreeLevels) {\n            isChildSubtreeAvailable = getAvailabilityResult(subtree.childSubtreeAvailability, childTileMortonIndex);\n          }\n          x = concatBits(globalData.x, childTileX);\n          y = concatBits(globalData.y, childTileY);\n          z = concatBits(globalData.z, childTileZ);\n          lev = level + globalData.level;\n          if (!isChildSubtreeAvailable) {\n            _context.next = 38;\n            break;\n          }\n          subtreePath = \"\".concat(basePath, \"/\").concat(subtreesUriTemplate);\n          childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x, y, z);\n          _context.next = 25;\n          return load(childSubtreeUrl, Tile3DSubtreeLoader);\n        case 25:\n          childSubtree = _context.sent;\n          subtree = childSubtree;\n          globalData.mortonIndex = childTileMortonIndex;\n          globalData.x = childTileX;\n          globalData.y = childTileY;\n          globalData.z = childTileZ;\n          globalData.level = level;\n          childTileMortonIndex = 0;\n          tileAvailabilityIndex = 0;\n          childTileX = 0;\n          childTileY = 0;\n          childTileZ = 0;\n          level = 0;\n        case 38:\n          isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);\n          if (!(!isTileAvailable || level > maximumLevel)) {\n            _context.next = 41;\n            break;\n          }\n          return _context.abrupt(\"return\", tile);\n        case 41:\n          isContentAvailable = getAvailabilityResult(subtree.contentAvailability, tileAvailabilityIndex);\n          if (isContentAvailable) {\n            tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x, y, z);\n          }\n          childTileLevel = level + 1;\n          pData = {\n            mortonIndex: childTileMortonIndex,\n            x: childTileX,\n            y: childTileY,\n            z: childTileZ\n          };\n          index = 0;\n        case 46:\n          if (!(index < childrenPerTile)) {\n            _context.next = 54;\n            break;\n          }\n          _context.next = 49;\n          return parseImplicitTiles({\n            subtree: subtree,\n            options: options,\n            parentData: pData,\n            childIndex: index,\n            level: childTileLevel,\n            globalData: globalData\n          });\n        case 49:\n          currentTile = _context.sent;\n          if (currentTile.contentUrl || currentTile.children.length) {\n            globalLevel = lev + 1;\n            childCoordinates = {\n              childTileX: childTileX,\n              childTileY: childTileY,\n              childTileZ: childTileZ\n            };\n            formattedTile = formatTileData(currentTile, globalLevel, childCoordinates, options);\n            tile.children.push(formattedTile);\n          }\n        case 51:\n          index++;\n          _context.next = 46;\n          break;\n        case 54:\n          return _context.abrupt(\"return\", tile);\n        case 55:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _parseImplicitTiles.apply(this, arguments);\n}\nfunction getAvailabilityResult(availabilityData, index) {\n  if ('constant' in availabilityData) {\n    return Boolean(availabilityData.constant);\n  }\n  if (availabilityData.explicitBitstream) {\n    return getBooleanValueFromBitstream(index, availabilityData.explicitBitstream);\n  }\n  return false;\n}\nfunction formatTileData(tile, level, childCoordinates, options) {\n  var basePath = options.basePath,\n    refine = options.refine,\n    getRefine = options.getRefine,\n    lodMetricType = options.lodMetricType,\n    getTileType = options.getTileType,\n    rootLodMetricValue = options.rootLodMetricValue,\n    rootBoundingVolume = options.rootBoundingVolume;\n  var uri = tile.contentUrl && tile.contentUrl.replace(\"\".concat(basePath, \"/\"), '');\n  var lodMetricValue = rootLodMetricValue / Math.pow(2, level);\n  var boundingVolume = calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates);\n  return {\n    children: tile.children,\n    contentUrl: tile.contentUrl,\n    content: {\n      uri: uri\n    },\n    id: tile.contentUrl,\n    refine: getRefine(refine),\n    type: getTileType(tile),\n    lodMetricType: lodMetricType,\n    lodMetricValue: lodMetricValue,\n    geometricError: lodMetricValue,\n    transform: tile.transform,\n    boundingVolume: boundingVolume\n  };\n}\nfunction calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates) {\n  if (rootBoundingVolume.region) {\n    var childTileX = childCoordinates.childTileX,\n      childTileY = childCoordinates.childTileY,\n      childTileZ = childCoordinates.childTileZ;\n    var _rootBoundingVolume$r = _slicedToArray(rootBoundingVolume.region, 6),\n      west = _rootBoundingVolume$r[0],\n      south = _rootBoundingVolume$r[1],\n      east = _rootBoundingVolume$r[2],\n      north = _rootBoundingVolume$r[3],\n      minimumHeight = _rootBoundingVolume$r[4],\n      maximumHeight = _rootBoundingVolume$r[5];\n    var boundingVolumesCount = Math.pow(2, level);\n    var sizeX = (east - west) / boundingVolumesCount;\n    var sizeY = (north - south) / boundingVolumesCount;\n    var sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;\n    var childWest = west + sizeX * childTileX,\n      childEast = west + sizeX * (childTileX + 1);\n    var childSouth = south + sizeY * childTileY,\n      childNorth = south + sizeY * (childTileY + 1);\n    var childMinimumHeight = minimumHeight + sizeZ * childTileZ,\n      childMaximumHeight = minimumHeight + sizeZ * (childTileZ + 1);\n    return {\n      region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]\n    };\n  }\n  console.warn('Unsupported bounding volume type: ', rootBoundingVolume);\n  return null;\n}\nfunction concatBits(first, second) {\n  return parseInt(first.toString(2) + second.toString(2), 2);\n}\nexport function replaceContentUrlTemplate(templateUrl, level, x, y, z) {\n  var mapUrl = generateMapUrl({\n    level: level,\n    x: x,\n    y: y,\n    z: z\n  });\n  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, function (matched) {\n    return mapUrl[matched];\n  });\n}\nfunction generateMapUrl(items) {\n  var mapUrl = {};\n  for (var key in items) {\n    mapUrl[\"{\".concat(key, \"}\")] = items[key];\n  }\n  return mapUrl;\n}\nfunction getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {\n  var byteIndex = Math.floor(availabilityIndex / 8);\n  var bitIndex = availabilityIndex % 8;\n  var bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;\n  return bitValue === 1;\n}","map":{"version":3,"names":["Tile3DSubtreeLoader","load","QUADTREE_DEVISION_COUNT","OCTREE_DEVISION_COUNT","SUBDIVISION_COUNT_MAP","QUADTREE","OCTREE","parseImplicitTiles","_x","_parseImplicitTiles","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","params","options","_params$parentData","parentData","_params$childIndex","childIndex","_params$globalData","globalData","subtree","_params$level","level","subdivisionScheme","subtreeLevels","maximumLevel","contentUrlTemplate","subtreesUriTemplate","basePath","tile","childrenPerTile","childX","childY","childZ","levelOffset","childTileMortonIndex","tileAvailabilityIndex","childTileX","childTileY","childTileZ","isChildSubtreeAvailable","x","y","z","lev","subtreePath","childSubtreeUrl","childSubtree","isTileAvailable","isContentAvailable","childTileLevel","pData","index","currentTile","globalLevel","childCoordinates","formattedTile","wrap","_callee$","_context","prev","next","mortonIndex","children","lodMetricValue","contentUrl","Math","pow","concatBits","getAvailabilityResult","childSubtreeAvailability","concat","replaceContentUrlTemplate","sent","tileAvailability","abrupt","contentAvailability","length","formatTileData","push","stop","availabilityData","Boolean","constant","explicitBitstream","getBooleanValueFromBitstream","refine","getRefine","lodMetricType","getTileType","rootLodMetricValue","rootBoundingVolume","uri","replace","boundingVolume","calculateBoundingVolumeForChildTile","content","id","type","geometricError","transform","region","_rootBoundingVolume$r","_slicedToArray","west","south","east","north","minimumHeight","maximumHeight","boundingVolumesCount","sizeX","sizeY","sizeZ","childWest","childEast","childSouth","childNorth","childMinimumHeight","childMaximumHeight","console","warn","first","second","parseInt","toString","templateUrl","mapUrl","generateMapUrl","matched","items","key","availabilityIndex","availabilityBuffer","byteIndex","floor","bitIndex","bitValue"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/geo-layers/node_modules/@loaders.gl/3d-tiles/src/lib/parsers/helpers/parse-3d-implicit-tiles.ts"],"sourcesContent":["import type {Availability, BoundingVolume, Subtree} from '../../../types';\nimport {Tile3DSubtreeLoader} from '../../../tile-3d-subtree-loader';\nimport {load} from '@loaders.gl/core';\n\nconst QUADTREE_DEVISION_COUNT = 4;\nconst OCTREE_DEVISION_COUNT = 8;\n\nconst SUBDIVISION_COUNT_MAP = {\n  QUADTREE: QUADTREE_DEVISION_COUNT,\n  OCTREE: OCTREE_DEVISION_COUNT\n};\n\n/**\n * Recursively parse implicit tiles tree\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling\n * TODO Check out do we able to use Tile3D class as return type here.\n * @param subtree\n * @param lodMetricValue\n * @param options\n * @param parentData\n * @param childIndex\n * @param level\n * @param globalData\n */\n// eslint-disable-next-line max-statements\nexport async function parseImplicitTiles(params: {\n  subtree: Subtree;\n  options: any;\n  parentData?: {mortonIndex: number; x: number; y: number; z: number};\n  childIndex?: number;\n  level?: number;\n  globalData?: {level: number; mortonIndex: number; x: number; y: number; z: number};\n}) {\n  const {\n    options,\n    parentData = {\n      mortonIndex: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    },\n    childIndex = 0,\n    globalData = {\n      level: 0,\n      mortonIndex: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    }\n  } = params;\n  let {subtree, level = 0} = params;\n  const {\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    basePath\n  } = options;\n\n  const tile = {children: [], lodMetricValue: 0, contentUrl: ''};\n\n  const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];\n\n  const childX = childIndex & 0b01;\n  const childY = (childIndex >> 1) & 0b01;\n  const childZ = (childIndex >> 2) & 0b01;\n\n  const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);\n  let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex);\n  let tileAvailabilityIndex = levelOffset + childTileMortonIndex;\n\n  // Local tile coordinates\n  let childTileX = concatBits(parentData.x, childX);\n  let childTileY = concatBits(parentData.y, childY);\n  let childTileZ = concatBits(parentData.z, childZ);\n\n  let isChildSubtreeAvailable = false;\n\n  if (level + 1 > subtreeLevels) {\n    isChildSubtreeAvailable = getAvailabilityResult(\n      subtree.childSubtreeAvailability,\n      childTileMortonIndex\n    );\n  }\n\n  const x = concatBits(globalData.x, childTileX);\n  const y = concatBits(globalData.y, childTileY);\n  const z = concatBits(globalData.z, childTileZ);\n  const lev = level + globalData.level;\n\n  if (isChildSubtreeAvailable) {\n    const subtreePath = `${basePath}/${subtreesUriTemplate}`;\n    const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x, y, z);\n    const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader);\n\n    subtree = childSubtree;\n\n    globalData.mortonIndex = childTileMortonIndex;\n    globalData.x = childTileX;\n    globalData.y = childTileY;\n    globalData.z = childTileZ;\n    globalData.level = level;\n\n    childTileMortonIndex = 0;\n    tileAvailabilityIndex = 0;\n    childTileX = 0;\n    childTileY = 0;\n    childTileZ = 0;\n    level = 0;\n  }\n\n  const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);\n\n  if (!isTileAvailable || level > maximumLevel) {\n    return tile;\n  }\n\n  const isContentAvailable = getAvailabilityResult(\n    subtree.contentAvailability,\n    tileAvailabilityIndex\n  );\n\n  if (isContentAvailable) {\n    tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x, y, z);\n  }\n\n  const childTileLevel = level + 1;\n  const pData = {mortonIndex: childTileMortonIndex, x: childTileX, y: childTileY, z: childTileZ};\n\n  for (let index = 0; index < childrenPerTile; index++) {\n    const currentTile = await parseImplicitTiles({\n      subtree,\n      options,\n      parentData: pData,\n      childIndex: index,\n      level: childTileLevel,\n      globalData\n    });\n\n    if (currentTile.contentUrl || currentTile.children.length) {\n      const globalLevel = lev + 1;\n      const childCoordinates = {childTileX, childTileY, childTileZ};\n      const formattedTile = formatTileData(currentTile, globalLevel, childCoordinates, options);\n      // @ts-ignore\n      tile.children.push(formattedTile);\n    }\n  }\n\n  return tile;\n}\n\nfunction getAvailabilityResult(availabilityData: Availability, index: number): boolean {\n  if ('constant' in availabilityData) {\n    return Boolean(availabilityData.constant);\n  }\n\n  if (availabilityData.explicitBitstream) {\n    return getBooleanValueFromBitstream(index, availabilityData.explicitBitstream);\n  }\n\n  return false;\n}\n\n/**\n * Do formatting of implicit tile data.\n * TODO Check out do we able to use Tile3D class as type here.\n * @param tile\n * @param lodMetricValue\n * @param options\n * @returns\n */\nfunction formatTileData(\n  tile,\n  level: number,\n  childCoordinates: {childTileX: number; childTileY: number; childTileZ: number},\n  options: any\n) {\n  const {\n    basePath,\n    refine,\n    getRefine,\n    lodMetricType,\n    getTileType,\n    rootLodMetricValue,\n    rootBoundingVolume\n  } = options;\n  const uri = tile.contentUrl && tile.contentUrl.replace(`${basePath}/`, '');\n  const lodMetricValue = rootLodMetricValue / 2 ** level;\n  const boundingVolume = calculateBoundingVolumeForChildTile(\n    level,\n    rootBoundingVolume,\n    childCoordinates\n  );\n\n  return {\n    children: tile.children,\n    contentUrl: tile.contentUrl,\n    content: {uri},\n    id: tile.contentUrl,\n    refine: getRefine(refine),\n    type: getTileType(tile),\n    lodMetricType,\n    lodMetricValue,\n    geometricError: lodMetricValue,\n    transform: tile.transform,\n    boundingVolume\n  };\n}\n\n/**\n * Calculate child bounding volume.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling#subdivision-rules\n * @param level\n * @param rootBoundingVolume\n * @param childCoordinates\n */\nfunction calculateBoundingVolumeForChildTile(\n  level: number,\n  rootBoundingVolume: BoundingVolume,\n  childCoordinates: {childTileX: number; childTileY: number; childTileZ: number}\n): BoundingVolume | null {\n  if (rootBoundingVolume.region) {\n    const {childTileX, childTileY, childTileZ} = childCoordinates;\n    const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;\n    const boundingVolumesCount = 2 ** level;\n\n    const sizeX = (east - west) / boundingVolumesCount;\n    const sizeY = (north - south) / boundingVolumesCount;\n    const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;\n\n    const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];\n    const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];\n    const [childMinimumHeight, childMaximumHeight] = [\n      minimumHeight + sizeZ * childTileZ,\n      minimumHeight + sizeZ * (childTileZ + 1)\n    ];\n\n    return {\n      region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]\n    };\n  }\n\n  // eslint-disable-next-line no-console\n  console.warn('Unsupported bounding volume type: ', rootBoundingVolume);\n  return null;\n}\n\n/**\n * Do binary concatenation\n * @param first\n * @param second\n */\nfunction concatBits(first: number, second: number): number {\n  return parseInt(first.toString(2) + second.toString(2), 2);\n}\n\n/**\n * Replace implicit tile content url with real coordinates.\n * @param templateUrl\n * @param level\n * @param x\n * @param y\n * @param z\n */\nexport function replaceContentUrlTemplate(\n  templateUrl: string,\n  level: number,\n  x: number,\n  y: number,\n  z: number\n): string {\n  const mapUrl = generateMapUrl({level, x, y, z});\n  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, (matched) => mapUrl[matched]);\n}\n\n/**\n * Get Map object for content url generation\n * @param items\n */\nfunction generateMapUrl(items: {[key: string]: number}): {[key: string]: string} {\n  const mapUrl = {};\n\n  for (const key in items) {\n    mapUrl[`{${key}}`] = items[key];\n  }\n  return mapUrl;\n}\n\n/**\n * Get boolean value from bistream by index\n * A boolean value is encoded as a single bit, either 0 (false) or 1 (true).\n * Multiple boolean values are packed tightly in the same buffer.\n * These buffers of tightly-packed bits are sometimes referred to as bitstreams.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/implicit-revisions/specification/Metadata#booleans\n * @param availabilitiIndex\n */\nfunction getBooleanValueFromBitstream(\n  availabilityIndex: number,\n  availabilityBuffer: Uint8Array\n): boolean {\n  const byteIndex = Math.floor(availabilityIndex / 8);\n  const bitIndex = availabilityIndex % 8;\n  const bitValue = (availabilityBuffer[byteIndex] >> bitIndex) & 1;\n\n  return bitValue === 1;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}