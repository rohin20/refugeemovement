{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.colorMaker = exports.layerColors = exports.OVERLAY_TYPE_CONST = exports.LAYER_ID_LENGTH = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _window = require(\"global/window\");\nvar _keymirror = _interopRequireDefault(require(\"keymirror\"));\nvar _extensions = require(\"@deck.gl/extensions\");\nvar _core = require(\"@deck.gl/core\");\nvar _layers = require(\"@deck.gl/layers\");\nvar _defaultLayerIcon = _interopRequireDefault(require(\"./default-layer-icon\"));\nvar _layerUpdate = require(\"./layer-update\");\nvar _constants = require(\"@kepler.gl/constants\");\nvar _utils = require(\"@kepler.gl/utils\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar _marked = /*#__PURE__*/_regenerator[\"default\"].mark(generateColor);\n\n/**\n * Approx. number of points to sample in a large data set\n */\nvar LAYER_ID_LENGTH = 6;\nexports.LAYER_ID_LENGTH = LAYER_ID_LENGTH;\nvar MAX_SAMPLE_SIZE = 5000;\nvar defaultDomain = [0, 1];\nvar dataFilterExtension = new _extensions.DataFilterExtension({\n  filterSize: _constants.MAX_GPU_FILTERS\n});\nvar defaultDataAccessor = function defaultDataAccessor(dc) {\n  return function (d) {\n    return d;\n  };\n};\nvar defaultGetFieldValue = function defaultGetFieldValue(field, d) {\n  return field.valueAccessor(d);\n};\nvar OVERLAY_TYPE_CONST = (0, _keymirror[\"default\"])({\n  deckgl: null,\n  mapboxgl: null\n});\nexports.OVERLAY_TYPE_CONST = OVERLAY_TYPE_CONST;\nvar layerColors = Object.values(_constants.DataVizColors).map(_utils.hexToRgb);\nexports.layerColors = layerColors;\nfunction generateColor() {\n  var index;\n  return _regenerator[\"default\"].wrap(function generateColor$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          index = 0;\n        case 1:\n          if (!(index < layerColors.length + 1)) {\n            _context.next = 7;\n            break;\n          }\n          if (index === layerColors.length) {\n            index = 0;\n          }\n          _context.next = 5;\n          return layerColors[index++];\n        case 5:\n          _context.next = 1;\n          break;\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\nvar colorMaker = generateColor();\nexports.colorMaker = colorMaker;\nvar Layer = /*#__PURE__*/function () {\n  // TODO: define meta\n  // TODO: define _oldDataUpdateTriggers\n  function Layer() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0, _classCallCheck2[\"default\"])(this, Layer);\n    (0, _defineProperty2[\"default\"])(this, \"id\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"meta\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"visConfigSettings\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"config\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"_oldDataUpdateTriggers\", void 0);\n    this.id = props.id || (0, _utils.generateHashId)(LAYER_ID_LENGTH); // meta\n\n    this.meta = {}; // visConfigSettings\n\n    this.visConfigSettings = {};\n    this.config = this.getDefaultLayerConfig(_objectSpread({\n      columns: this.getLayerColumns()\n    }, props));\n  }\n  (0, _createClass2[\"default\"])(Layer, [{\n    key: \"layerIcon\",\n    get: function get() {\n      return _defaultLayerIcon[\"default\"];\n    }\n  }, {\n    key: \"overlayType\",\n    get: function get() {\n      return OVERLAY_TYPE_CONST.deckgl;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this.type;\n    }\n  }, {\n    key: \"isAggregated\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"requiredLayerColumns\",\n    get: function get() {\n      return [];\n    }\n  }, {\n    key: \"optionalColumns\",\n    get: function get() {\n      return [];\n    }\n  }, {\n    key: \"noneLayerDataAffectingProps\",\n    get: function get() {\n      return ['label', 'opacity', 'thickness', 'isVisible', 'hidden'];\n    }\n  }, {\n    key: \"visualChannels\",\n    get: function get() {\n      return {\n        color: {\n          property: 'color',\n          field: 'colorField',\n          scale: 'colorScale',\n          domain: 'colorDomain',\n          range: 'colorRange',\n          key: 'color',\n          channelScaleType: _constants.CHANNEL_SCALES.color,\n          nullValue: _constants.NO_VALUE_COLOR,\n          defaultValue: function defaultValue(config) {\n            return config.color;\n          }\n        },\n        size: {\n          property: 'size',\n          field: 'sizeField',\n          scale: 'sizeScale',\n          domain: 'sizeDomain',\n          range: 'sizeRange',\n          key: 'size',\n          channelScaleType: _constants.CHANNEL_SCALES.size,\n          nullValue: 0,\n          defaultValue: 1\n        }\n      };\n    }\n  }, {\n    key: \"columnValidators\",\n    get: function get() {\n      return {};\n    }\n    /*\n     * Column pairs maps layer column to a specific field pairs,\n     * By default, it is set to null\n     */\n  }, {\n    key: \"columnPairs\",\n    get: function get() {\n      return null;\n    }\n    /*\n     * Default point column pairs, can be used for point based layers: point, icon etc.\n     */\n  }, {\n    key: \"defaultPointColumnPairs\",\n    get: function get() {\n      return {\n        lat: {\n          pair: 'lng',\n          fieldPairKey: 'lat'\n        },\n        lng: {\n          pair: 'lat',\n          fieldPairKey: 'lng'\n        }\n      };\n    }\n    /*\n     * Default link column pairs, can be used for link based layers: arc, line etc\n     */\n  }, {\n    key: \"defaultLinkColumnPairs\",\n    get: function get() {\n      return {\n        lat0: {\n          pair: 'lng0',\n          fieldPairKey: 'lat'\n        },\n        lng0: {\n          pair: 'lat0',\n          fieldPairKey: 'lng'\n        },\n        lat1: {\n          pair: 'lng1',\n          fieldPairKey: 'lat'\n        },\n        lng1: {\n          pair: 'lat1',\n          fieldPairKey: 'lng'\n        }\n      };\n    }\n    /**\n     * Return a React component for to render layer instructions in a modal\n     * @returns {object} - an object\n     * @example\n     *  return {\n     *    id: 'iconInfo',\n     *    template: IconInfoModal,\n     *    modalProps: {\n     *      title: 'How to draw icons'\n     *   };\n     * }\n     */\n  }, {\n    key: \"layerInfoModal\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"supportedDatasetTypes\",\n    get: function get() {\n      return null;\n    }\n    /*\n     * Given a dataset, automatically find props to create layer based on it\n     * and return the props and previous found layers.\n     * By default, no layers will be found\n     */\n  }, {\n    key: \"getDefaultLayerConfig\",\n    value: function getDefaultLayerConfig() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        dataId: props.dataId || null,\n        label: props.label || _constants.DEFAULT_LAYER_LABEL,\n        color: props.color || colorMaker.next().value,\n        columns: props.columns || {},\n        isVisible: props.isVisible || false,\n        isConfigActive: props.isConfigActive || false,\n        highlightColor: props.highlightColor || _constants.DEFAULT_HIGHLIGHT_COLOR,\n        hidden: props.hidden || false,\n        // TODO: refactor this into separate visual Channel config\n        // color by field, domain is set by filters, field, scale type\n        colorField: null,\n        colorDomain: [0, 1],\n        colorScale: _constants.SCALE_TYPES.quantile,\n        // color by size, domain is set by filters, field, scale type\n        sizeDomain: [0, 1],\n        sizeScale: _constants.SCALE_TYPES.linear,\n        sizeField: null,\n        visConfig: {},\n        textLabel: [_constants.DEFAULT_TEXT_LABEL],\n        colorUI: {\n          color: _constants.DEFAULT_COLOR_UI,\n          colorRange: _constants.DEFAULT_COLOR_UI\n        },\n        animation: {\n          enabled: false\n        }\n      };\n    }\n    /**\n     * Get the description of a visualChannel config\n     * @param key\n     * @returns\n     */\n  }, {\n    key: \"getVisualChannelDescription\",\n    value: function getVisualChannelDescription(key) {\n      // e.g. label: Color, measure: Vehicle Type\n      var channel = this.visualChannels[key];\n      if (!channel) return {\n        label: '',\n        measure: undefined\n      };\n      var rangeSettings = this.visConfigSettings[channel.range];\n      var fieldSettings = this.config[channel.field];\n      var label = rangeSettings === null || rangeSettings === void 0 ? void 0 : rangeSettings.label;\n      return {\n        label: typeof label === 'function' ? label(this.config) : label || '',\n        measure: fieldSettings ? fieldSettings.displayName || fieldSettings.name : channel.defaultMeasure\n      };\n    }\n    /**\n     * Assign a field to layer column, return column config\n     * @param key - Column Key\n     * @param field - Selected field\n     * @returns {{}} - Column config\n     */\n  }, {\n    key: \"assignColumn\",\n    value: function assignColumn(key, field) {\n      // field value could be null for optional columns\n      var update = field ? {\n        value: field.name,\n        fieldIdx: field.fieldIdx\n      } : {\n        value: null,\n        fieldIdx: -1\n      };\n      return _objectSpread(_objectSpread({}, this.config.columns), {}, (0, _defineProperty2[\"default\"])({}, key, _objectSpread(_objectSpread({}, this.config.columns[key]), update)));\n    }\n    /**\n     * Assign a field pair to column config, return column config\n     * @param key - Column Key\n     * @param pair - field Pair\n     * @returns {object} - Column config\n     */\n  }, {\n    key: \"assignColumnPairs\",\n    value: function assignColumnPairs(key, pair) {\n      var _this$columnPairs, _this$columnPairs2, _this$columnPairs3, _objectSpread3;\n      if (!this.columnPairs || !((_this$columnPairs = this.columnPairs) !== null && _this$columnPairs !== void 0 && _this$columnPairs[key])) {\n        // should not end in this state\n        return this.config.columns;\n      }\n      var _this$columnPairs$key = (_this$columnPairs2 = this.columnPairs) === null || _this$columnPairs2 === void 0 ? void 0 : _this$columnPairs2[key],\n        partnerKey = _this$columnPairs$key.pair,\n        fieldPairKey = _this$columnPairs$key.fieldPairKey;\n      var _this$columnPairs$par = (_this$columnPairs3 = this.columnPairs) === null || _this$columnPairs3 === void 0 ? void 0 : _this$columnPairs3[partnerKey],\n        partnerFieldPairKey = _this$columnPairs$par.fieldPairKey;\n      return _objectSpread(_objectSpread({}, this.config.columns), {}, (_objectSpread3 = {}, (0, _defineProperty2[\"default\"])(_objectSpread3, key, pair[fieldPairKey]), (0, _defineProperty2[\"default\"])(_objectSpread3, partnerKey, pair[partnerFieldPairKey]), _objectSpread3));\n    }\n    /**\n     * Calculate a radius zoom multiplier to render points, so they are visible in all zoom level\n     * @param {object} mapState\n     * @param {number} mapState.zoom - actual zoom\n     * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image\n     * @returns {number}\n     */\n  }, {\n    key: \"getZoomFactor\",\n    value: function getZoomFactor(_ref) {\n      var zoom = _ref.zoom,\n        _ref$zoomOffset = _ref.zoomOffset,\n        zoomOffset = _ref$zoomOffset === void 0 ? 0 : _ref$zoomOffset;\n      return Math.pow(2, Math.max(14 - zoom + zoomOffset, 0));\n    }\n    /**\n     * Calculate a elevation zoom multiplier to render points, so they are visible in all zoom level\n     * @param {object} mapState\n     * @param {number} mapState.zoom - actual zoom\n     * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image\n     * @returns {number}\n     */\n  }, {\n    key: \"getElevationZoomFactor\",\n    value: function getElevationZoomFactor(_ref2) {\n      var zoom = _ref2.zoom,\n        _ref2$zoomOffset = _ref2.zoomOffset,\n        zoomOffset = _ref2$zoomOffset === void 0 ? 0 : _ref2$zoomOffset;\n      return this.config.visConfig.enableElevationZoomFactor ? Math.pow(2, Math.max(8 - zoom + zoomOffset, 0)) : 1;\n    }\n  }, {\n    key: \"formatLayerData\",\n    value: function formatLayerData(datasets, oldLayerData) {\n      return {};\n    }\n  }, {\n    key: \"renderLayer\",\n    value: function renderLayer() {\n      return [];\n    }\n  }, {\n    key: \"getHoverData\",\n    value: function getHoverData(object, dataContainer, fields) {\n      if (!object) {\n        return null;\n      } // By default, each entry of layerData should have an index of a row in the original data container.\n      // Each layer can implement its own getHoverData method\n\n      return dataContainer.row(object.index);\n    }\n    /**\n     * When change layer type, try to copy over layer configs as much as possible\n     * @param configToCopy - config to copy over\n     * @param visConfigSettings - visConfig settings of config to copy\n     */\n  }, {\n    key: \"assignConfigToLayer\",\n    value: function assignConfigToLayer(configToCopy, visConfigSettings) {\n      var _this = this;\n\n      // don't deep merge visualChannel field\n      // don't deep merge color range, reversed: is not a key by default\n      var shallowCopy = ['colorRange', 'strokeColorRange'].concat(Object.values(this.visualChannels).map(function (v) {\n        return v.field;\n      })); // don't copy over domain and animation\n\n      var notToCopy = ['animation'].concat(Object.values(this.visualChannels).map(function (v) {\n        return v.domain;\n      })); // if range is for the same property group copy it, otherwise, not to copy\n\n      Object.values(this.visualChannels).forEach(function (v) {\n        if (configToCopy.visConfig[v.range] && _this.visConfigSettings[v.range] && visConfigSettings[v.range].group !== _this.visConfigSettings[v.range].group) {\n          notToCopy.push(v.range);\n        }\n      }); // don't copy over visualChannel range\n\n      var currentConfig = this.config;\n      var copied = this.copyLayerConfig(currentConfig, configToCopy, {\n        shallowCopy: shallowCopy,\n        notToCopy: notToCopy\n      });\n      this.updateLayerConfig(copied); // validate visualChannel field type and scale types\n\n      Object.keys(this.visualChannels).forEach(function (channel) {\n        _this.validateVisualChannel(channel);\n      });\n    }\n    /*\n     * Recursively copy config over to an empty layer\n     * when received saved config, or copy config over from a different layer type\n     * make sure to only copy over value to existing keys\n     * @param {object} currentConfig - existing config to be override\n     * @param {object} configToCopy - new Config to copy over\n     * @param {string[]} shallowCopy - array of properties to not to be deep copied\n     * @param {string[]} notToCopy - array of properties not to copy\n     * @returns {object} - copied config\n     */\n  }, {\n    key: \"copyLayerConfig\",\n    value: function copyLayerConfig(currentConfig, configToCopy) {\n      var _this2 = this;\n      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref3$shallowCopy = _ref3.shallowCopy,\n        shallowCopy = _ref3$shallowCopy === void 0 ? [] : _ref3$shallowCopy,\n        _ref3$notToCopy = _ref3.notToCopy,\n        notToCopy = _ref3$notToCopy === void 0 ? [] : _ref3$notToCopy;\n      var copied = {};\n      Object.keys(currentConfig).forEach(function (key) {\n        if ((0, _utils.isPlainObject)(currentConfig[key]) && (0, _utils.isPlainObject)(configToCopy[key]) && !shallowCopy.includes(key) && !notToCopy.includes(key)) {\n          // recursively assign object value\n          copied[key] = _this2.copyLayerConfig(currentConfig[key], configToCopy[key], {\n            shallowCopy: shallowCopy,\n            notToCopy: notToCopy\n          });\n        } else if ((0, _utils.notNullorUndefined)(configToCopy[key]) && !notToCopy.includes(key)) {\n          // copy\n          copied[key] = configToCopy[key];\n        } else {\n          // keep existing\n          copied[key] = currentConfig[key];\n        }\n      });\n      return copied;\n    }\n  }, {\n    key: \"registerVisConfig\",\n    value: function registerVisConfig(layerVisConfigs) {\n      var _this3 = this;\n      Object.keys(layerVisConfigs).forEach(function (item) {\n        var configItem = layerVisConfigs[item];\n        if (typeof configItem === 'string' && _constants.LAYER_VIS_CONFIGS[configItem]) {\n          // if assigned one of default LAYER_CONFIGS\n          _this3.config.visConfig[item] = _constants.LAYER_VIS_CONFIGS[configItem].defaultValue;\n          _this3.visConfigSettings[item] = _constants.LAYER_VIS_CONFIGS[configItem];\n        } else if ((0, _typeof2[\"default\"])(configItem) === 'object' && ['type', 'defaultValue'].every(function (p) {\n          return configItem.hasOwnProperty(p);\n        })) {\n          // if provided customized visConfig, and has type && defaultValue\n          // TODO: further check if customized visConfig is valid\n          _this3.config.visConfig[item] = configItem.defaultValue;\n          _this3.visConfigSettings[item] = configItem;\n        }\n      });\n    }\n  }, {\n    key: \"getLayerColumns\",\n    value: function getLayerColumns() {\n      var columnValidators = this.columnValidators;\n      var required = this.requiredLayerColumns.reduce(function (accu, key) {\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, columnValidators[key] ? {\n          value: null,\n          fieldIdx: -1,\n          validator: columnValidators[key]\n        } : {\n          value: null,\n          fieldIdx: -1\n        }));\n      }, {});\n      var optional = this.optionalColumns.reduce(function (accu, key) {\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, {\n          value: null,\n          fieldIdx: -1,\n          optional: true\n        }));\n      }, {});\n      return _objectSpread(_objectSpread({}, required), optional);\n    }\n  }, {\n    key: \"updateLayerConfig\",\n    value: function updateLayerConfig(newConfig) {\n      this.config = _objectSpread(_objectSpread({}, this.config), newConfig);\n      return this;\n    }\n  }, {\n    key: \"updateLayerVisConfig\",\n    value: function updateLayerVisConfig(newVisConfig) {\n      this.config.visConfig = _objectSpread(_objectSpread({}, this.config.visConfig), newVisConfig);\n      return this;\n    }\n  }, {\n    key: \"updateLayerColorUI\",\n    value: function updateLayerColorUI(prop, newConfig) {\n      var _this$config = this.config,\n        previous = _this$config.colorUI,\n        visConfig = _this$config.visConfig;\n      if (!(0, _utils.isPlainObject)(newConfig) || typeof prop !== 'string') {\n        return this;\n      }\n      var colorUIProp = Object.entries(newConfig).reduce(function (accu, _ref4) {\n        var _ref5 = (0, _slicedToArray2[\"default\"])(_ref4, 2),\n          key = _ref5[0],\n          value = _ref5[1];\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, key, (0, _utils.isPlainObject)(accu[key]) && (0, _utils.isPlainObject)(value) ? _objectSpread(_objectSpread({}, accu[key]), value) : value));\n      }, previous[prop] || _constants.DEFAULT_COLOR_UI);\n      var colorUI = _objectSpread(_objectSpread({}, previous), {}, (0, _defineProperty2[\"default\"])({}, prop, colorUIProp));\n      this.updateLayerConfig({\n        colorUI: colorUI\n      }); // if colorUI[prop] is colorRange\n\n      var isColorRange = visConfig[prop] && visConfig[prop].colors;\n      if (isColorRange) {\n        this.updateColorUIByColorRange(newConfig, prop);\n        this.updateColorRangeByColorUI(newConfig, previous, prop);\n        this.updateCustomPalette(newConfig, previous, prop);\n      }\n      return this;\n    }\n  }, {\n    key: \"updateCustomPalette\",\n    value: function updateCustomPalette(newConfig, previous, prop) {\n      if (!newConfig.colorRangeConfig || !newConfig.colorRangeConfig.custom) {\n        return;\n      }\n      var _this$config2 = this.config,\n        colorUI = _this$config2.colorUI,\n        visConfig = _this$config2.visConfig;\n      if (!visConfig[prop]) return;\n      var colors = visConfig[prop].colors;\n      var customPalette = _objectSpread(_objectSpread({}, colorUI[prop].customPalette), {}, {\n        name: 'Custom Palette',\n        colors: (0, _toConsumableArray2[\"default\"])(colors)\n      });\n      this.updateLayerConfig({\n        colorUI: _objectSpread(_objectSpread({}, colorUI), {}, (0, _defineProperty2[\"default\"])({}, prop, _objectSpread(_objectSpread({}, colorUI[prop]), {}, {\n          customPalette: customPalette\n        })))\n      });\n    }\n    /**\n     * if open dropdown and prop is color range\n     * Automatically set colorRangeConfig's step and reversed\n     * @param {*} newConfig\n     * @param {*} prop\n     */\n  }, {\n    key: \"updateColorUIByColorRange\",\n    value: function updateColorUIByColorRange(newConfig, prop) {\n      if (typeof newConfig.showDropdown !== 'number') return;\n      var _this$config3 = this.config,\n        colorUI = _this$config3.colorUI,\n        visConfig = _this$config3.visConfig;\n      this.updateLayerConfig({\n        colorUI: _objectSpread(_objectSpread({}, colorUI), {}, (0, _defineProperty2[\"default\"])({}, prop, _objectSpread(_objectSpread({}, colorUI[prop]), {}, {\n          colorRangeConfig: _objectSpread(_objectSpread({}, colorUI[prop].colorRangeConfig), {}, {\n            steps: visConfig[prop].colors.length,\n            reversed: Boolean(visConfig[prop].reversed)\n          })\n        })))\n      });\n    }\n  }, {\n    key: \"updateColorRangeByColorUI\",\n    value: function updateColorRangeByColorUI(newConfig, previous, prop) {\n      // only update colorRange if changes in UI is made to 'reversed', 'steps' or steps\n      var shouldUpdate = newConfig.colorRangeConfig && ['reversed', 'steps'].some(function (key) {\n        return newConfig.colorRangeConfig.hasOwnProperty(key) && newConfig.colorRangeConfig[key] !== (previous[prop] || _constants.DEFAULT_COLOR_UI).colorRangeConfig[key];\n      });\n      if (!shouldUpdate) return;\n      var _this$config4 = this.config,\n        colorUI = _this$config4.colorUI,\n        visConfig = _this$config4.visConfig;\n      var _colorUI$prop$colorRa = colorUI[prop].colorRangeConfig,\n        steps = _colorUI$prop$colorRa.steps,\n        reversed = _colorUI$prop$colorRa.reversed;\n      var colorRange = visConfig[prop]; // find based on step or reversed\n\n      var update;\n      if (newConfig.colorRangeConfig.hasOwnProperty('steps')) {\n        var group = (0, _utils.getColorGroupByName)(colorRange);\n        if (group) {\n          var sameGroup = _constants.COLOR_RANGES.filter(function (cr) {\n            return (0, _utils.getColorGroupByName)(cr) === group;\n          });\n          update = sameGroup.find(function (cr) {\n            return cr.colors.length === steps;\n          });\n          if (update && colorRange.reversed) {\n            update = (0, _utils.reverseColorRange)(true, update);\n          }\n        }\n      }\n      if (newConfig.colorRangeConfig.hasOwnProperty('reversed')) {\n        update = (0, _utils.reverseColorRange)(reversed, update || colorRange);\n      }\n      if (update) {\n        this.updateLayerVisConfig((0, _defineProperty2[\"default\"])({}, prop, update));\n      }\n    }\n    /**\n     * Check whether layer has all columns\n     * @returns yes or no\n     */\n  }, {\n    key: \"hasAllColumns\",\n    value: function hasAllColumns() {\n      var columns = this.config.columns;\n      return columns && Object.values(columns).every(function (v) {\n        return Boolean(v.optional || v.value && v.fieldIdx > -1);\n      });\n    }\n    /**\n     * Check whether layer has data\n     *\n     * @param {Array | Object} layerData\n     * @returns {boolean} yes or no\n     */\n  }, {\n    key: \"hasLayerData\",\n    value: function hasLayerData(layerData) {\n      if (!layerData) {\n        return false;\n      }\n      return Boolean(layerData.data && layerData.data.length);\n    }\n  }, {\n    key: \"isValidToSave\",\n    value: function isValidToSave() {\n      return Boolean(this.type && this.hasAllColumns());\n    }\n  }, {\n    key: \"shouldRenderLayer\",\n    value: function shouldRenderLayer(data) {\n      return Boolean(this.type) && this.hasAllColumns() && this.hasLayerData(data) && typeof this.renderLayer === 'function';\n    }\n  }, {\n    key: \"getColorScale\",\n    value: function getColorScale(colorScale, colorDomain, colorRange) {\n      if (Array.isArray(colorRange.colorMap)) {\n        var cMap = new Map();\n        colorRange.colorMap.forEach(function (_ref6) {\n          var _ref7 = (0, _slicedToArray2[\"default\"])(_ref6, 2),\n            k = _ref7[0],\n            v = _ref7[1];\n          cMap.set(k, typeof v === 'string' ? (0, _utils.hexToRgb)(v) : v);\n        });\n        var scale = _constants.SCALE_FUNC[_constants.SCALE_TYPES.ordinal]().domain(cMap.keys()).range(cMap.values()).unknown(cMap.get(_constants.UNKNOWN_COLOR_KEY) || _constants.NO_VALUE_COLOR);\n        return scale;\n      }\n      return this.getVisChannelScale(colorScale, colorDomain, colorRange.colors.map(_utils.hexToRgb));\n    }\n    /**\n     * Mapping from visual channels to deck.gl accesors\n     * @param {Object} param Parameters\n     * @param {Function} param.dataAccessor Access kepler.gl layer data from deck.gl layer\n     * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} param.dataContainer DataContainer to use use with dataAccessor\n     * @return {Object} attributeAccessors - deck.gl layer attribute accessors\n     */\n  }, {\n    key: \"getAttributeAccessors\",\n    value: function getAttributeAccessors(_ref8) {\n      var _this4 = this;\n      var _ref8$dataAccessor = _ref8.dataAccessor,\n        dataAccessor = _ref8$dataAccessor === void 0 ? defaultDataAccessor : _ref8$dataAccessor,\n        dataContainer = _ref8.dataContainer;\n      var attributeAccessors = {};\n      Object.keys(this.visualChannels).forEach(function (channel) {\n        var _this4$visualChannels = _this4.visualChannels[channel],\n          field = _this4$visualChannels.field,\n          fixed = _this4$visualChannels.fixed,\n          scale = _this4$visualChannels.scale,\n          domain = _this4$visualChannels.domain,\n          range = _this4$visualChannels.range,\n          accessor = _this4$visualChannels.accessor,\n          defaultValue = _this4$visualChannels.defaultValue,\n          getAttributeValue = _this4$visualChannels.getAttributeValue,\n          nullValue = _this4$visualChannels.nullValue,\n          channelScaleType = _this4$visualChannels.channelScaleType;\n        if (accessor) {\n          var shouldGetScale = _this4.config[field];\n          if (shouldGetScale) {\n            var isFixed = fixed && _this4.config.visConfig[fixed];\n            var scaleFunction = channelScaleType === _constants.CHANNEL_SCALES.color ? _this4.getColorScale(_this4.config[scale], _this4.config[domain], _this4.config.visConfig[range]) : _this4.getVisChannelScale(_this4.config[scale], _this4.config[domain], _this4.config.visConfig[range], isFixed);\n            attributeAccessors[accessor] = function (d) {\n              return _this4.getEncodedChannelValue(scaleFunction, dataAccessor(dataContainer)(d), _this4.config[field], nullValue);\n            };\n          } else if (typeof getAttributeValue === 'function') {\n            attributeAccessors[accessor] = getAttributeValue(_this4.config);\n          } else {\n            attributeAccessors[accessor] = typeof defaultValue === 'function' ? defaultValue(_this4.config) : defaultValue;\n          }\n          if (!attributeAccessors[accessor]) {\n            _window.console.warn(\"Failed to provide accessor function for \".concat(accessor || channel));\n          }\n        }\n      });\n      return attributeAccessors;\n    }\n  }, {\n    key: \"getVisChannelScale\",\n    value: function getVisChannelScale(scale, domain, range, fixed) {\n      return _constants.SCALE_FUNC[fixed ? 'linear' : scale]().domain(domain).range(fixed ? domain : range);\n    }\n    /**\n     * Get longitude and latitude bounds of the data.\n     * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} dataContainer DataContainer to calculate bounds for.\n     * @param {(d: {index: number}, dc: import('utils/table-utils/data-container-interface').DataContainerInterface) => number[]} getPosition Access kepler.gl layer data from deck.gl layer\n     * @return {number[]|null} bounds of the data.\n     */\n  }, {\n    key: \"getPointsBounds\",\n    value: function getPointsBounds(dataContainer, getPosition) {\n      // no need to loop through the entire dataset\n      // get a sample of data to calculate bounds\n      var sampleData = dataContainer.numRows() > MAX_SAMPLE_SIZE ? (0, _utils.getSampleContainerData)(dataContainer, MAX_SAMPLE_SIZE) : dataContainer;\n      var points = sampleData.mapIndex(getPosition);\n      var latBounds = (0, _utils.getLatLngBounds)(points, 1, [-90, 90]);\n      var lngBounds = (0, _utils.getLatLngBounds)(points, 0, [-180, 180]);\n      if (!latBounds || !lngBounds) {\n        return null;\n      }\n      return [lngBounds[0], latBounds[0], lngBounds[1], latBounds[1]];\n    }\n  }, {\n    key: \"getChangedTriggers\",\n    value: function getChangedTriggers(dataUpdateTriggers) {\n      var triggerChanged = (0, _layerUpdate.diffUpdateTriggers)(dataUpdateTriggers, this._oldDataUpdateTriggers);\n      this._oldDataUpdateTriggers = dataUpdateTriggers;\n      return triggerChanged;\n    }\n  }, {\n    key: \"getEncodedChannelValue\",\n    value: function getEncodedChannelValue(scale, data, field) {\n      var nullValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _constants.NO_VALUE_COLOR;\n      var getValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultGetFieldValue;\n      // @ts-expect-error TODO: VisualChannelField better typing\n      var type = field.type;\n      var value = getValue(field, data);\n      if (!(0, _utils.notNullorUndefined)(value)) {\n        return nullValue;\n      }\n      var attributeValue;\n      if (type === _constants.ALL_FIELD_TYPES.timestamp) {\n        // shouldn't need to convert here\n        // scale Function should take care of it\n        attributeValue = scale(new Date(value));\n      } else {\n        attributeValue = scale(value);\n      }\n      if (!(0, _utils.notNullorUndefined)(attributeValue)) {\n        attributeValue = nullValue;\n      }\n      return attributeValue;\n    }\n  }, {\n    key: \"updateMeta\",\n    value: function updateMeta(meta) {\n      this.meta = _objectSpread(_objectSpread({}, this.meta), meta);\n    }\n  }, {\n    key: \"getDataUpdateTriggers\",\n    value: function getDataUpdateTriggers(_ref9) {\n      var filteredIndex = _ref9.filteredIndex,\n        id = _ref9.id,\n        dataContainer = _ref9.dataContainer;\n      var columns = this.config.columns;\n      return _objectSpread({\n        getData: {\n          datasetId: id,\n          dataContainer: dataContainer,\n          columns: columns,\n          filteredIndex: filteredIndex\n        },\n        getMeta: {\n          datasetId: id,\n          dataContainer: dataContainer,\n          columns: columns\n        }\n      }, (this.config.textLabel || []).reduce(function (accu, tl, i) {\n        return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2[\"default\"])({}, \"getLabelCharacterSet-\".concat(i), tl.field ? tl.field.name : null));\n      }, {}));\n    }\n  }, {\n    key: \"updateData\",\n    value: function updateData(datasets, oldLayerData) {\n      if (!this.config.dataId) {\n        return {};\n      }\n      var layerDataset = datasets[this.config.dataId];\n      var dataContainer = layerDataset.dataContainer;\n      var getPosition = this.getPositionAccessor(dataContainer);\n      var dataUpdateTriggers = this.getDataUpdateTriggers(layerDataset);\n      var triggerChanged = this.getChangedTriggers(dataUpdateTriggers);\n      if (triggerChanged && triggerChanged.getMeta) {\n        this.updateLayerMeta(dataContainer, getPosition);\n      }\n      var data = [];\n      if (!(triggerChanged && triggerChanged.getData) && oldLayerData && oldLayerData.data) {\n        // same data\n        data = oldLayerData.data;\n      } else {\n        data = this.calculateDataAttribute(layerDataset, getPosition);\n      }\n      return {\n        data: data,\n        triggerChanged: triggerChanged\n      };\n    }\n    /**\n     * helper function to update one layer domain when state.data changed\n     * if state.data change is due ot update filter, newFiler will be passed\n     * called by updateAllLayerDomainData\n     * @param datasets\n     * @param newFilter\n     * @returns layer\n     */\n  }, {\n    key: \"updateLayerDomain\",\n    value: function updateLayerDomain(datasets, newFilter) {\n      var _this5 = this;\n      var table = this.getDataset(datasets);\n      if (!table) {\n        return this;\n      }\n      Object.values(this.visualChannels).forEach(function (channel) {\n        var scale = channel.scale;\n        var scaleType = _this5.config[scale]; // ordinal domain is based on dataContainer, if only filter changed\n        // no need to update ordinal domain\n\n        if (!newFilter || scaleType !== _constants.SCALE_TYPES.ordinal) {\n          var domain = channel.domain;\n          var updatedDomain = _this5.calculateLayerDomain(table, channel);\n          _this5.updateLayerConfig((0, _defineProperty2[\"default\"])({}, domain, updatedDomain));\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"getDataset\",\n    value: function getDataset(datasets) {\n      return this.config.dataId ? datasets[this.config.dataId] : null;\n    }\n    /**\n     * Validate visual channel field and scales based on supported field & scale type\n     * @param channel\n     */\n  }, {\n    key: \"validateVisualChannel\",\n    value: function validateVisualChannel(channel) {\n      this.validateFieldType(channel);\n      this.validateScale(channel);\n    }\n    /**\n     * Validate field type based on channelScaleType\n     */\n  }, {\n    key: \"validateFieldType\",\n    value: function validateFieldType(channel) {\n      var visualChannel = this.visualChannels[channel];\n      var field = visualChannel.field,\n        channelScaleType = visualChannel.channelScaleType,\n        supportedFieldTypes = visualChannel.supportedFieldTypes;\n      if (this.config[field]) {\n        // if field is selected, check if field type is supported\n        var channelSupportedFieldTypes = supportedFieldTypes || _constants.CHANNEL_SCALE_SUPPORTED_FIELDS[channelScaleType];\n        if (!channelSupportedFieldTypes.includes(this.config[field].type)) {\n          // field type is not supported, set it back to null\n          // set scale back to default\n          this.updateLayerConfig((0, _defineProperty2[\"default\"])({}, field, null));\n        }\n      }\n    }\n    /**\n     * Validate scale type based on aggregation\n     */\n  }, {\n    key: \"validateScale\",\n    value: function validateScale(channel) {\n      var visualChannel = this.visualChannels[channel];\n      var scale = visualChannel.scale;\n      if (!scale) {\n        // visualChannel doesn't have scale\n        return;\n      }\n      var scaleOptions = this.getScaleOptions(channel); // check if current selected scale is\n      // supported, if not, change to default\n\n      if (!scaleOptions.includes(this.config[scale])) {\n        this.updateLayerConfig((0, _defineProperty2[\"default\"])({}, scale, scaleOptions[0]));\n      }\n    }\n    /**\n     * Get scale options based on current field\n     * @param {string} channel\n     * @returns {string[]}\n     */\n  }, {\n    key: \"getScaleOptions\",\n    value: function getScaleOptions(channel) {\n      var visualChannel = this.visualChannels[channel];\n      var field = visualChannel.field,\n        scale = visualChannel.scale,\n        channelScaleType = visualChannel.channelScaleType;\n      return this.config[field] ? _constants.FIELD_OPTS[this.config[field].type].scale[channelScaleType] : [this.getDefaultLayerConfig()[scale]];\n    }\n  }, {\n    key: \"updateLayerVisualChannel\",\n    value: function updateLayerVisualChannel(dataset, channel) {\n      var visualChannel = this.visualChannels[channel];\n      this.validateVisualChannel(channel); // calculate layer channel domain\n\n      var updatedDomain = this.calculateLayerDomain(dataset, visualChannel);\n      this.updateLayerConfig((0, _defineProperty2[\"default\"])({}, visualChannel.domain, updatedDomain));\n    }\n  }, {\n    key: \"getVisualChannelUpdateTriggers\",\n    value: function getVisualChannelUpdateTriggers() {\n      var _this6 = this;\n      var updateTriggers = {};\n      Object.values(this.visualChannels).forEach(function (visualChannel) {\n        // field range scale domain\n        var accessor = visualChannel.accessor,\n          field = visualChannel.field,\n          scale = visualChannel.scale,\n          domain = visualChannel.domain,\n          range = visualChannel.range,\n          defaultValue = visualChannel.defaultValue,\n          fixed = visualChannel.fixed;\n        if (accessor) {\n          var _objectSpread11;\n          updateTriggers[accessor] = _objectSpread((_objectSpread11 = {}, (0, _defineProperty2[\"default\"])(_objectSpread11, field, _this6.config[field]), (0, _defineProperty2[\"default\"])(_objectSpread11, scale, _this6.config[scale]), (0, _defineProperty2[\"default\"])(_objectSpread11, domain, _this6.config[domain]), (0, _defineProperty2[\"default\"])(_objectSpread11, range, _this6.config.visConfig[range]), (0, _defineProperty2[\"default\"])(_objectSpread11, \"defaultValue\", typeof defaultValue === 'function' ? defaultValue(_this6.config) : defaultValue), _objectSpread11), fixed ? (0, _defineProperty2[\"default\"])({}, fixed, _this6.config.visConfig[fixed]) : {});\n        }\n      });\n      return updateTriggers;\n    }\n  }, {\n    key: \"calculateLayerDomain\",\n    value: function calculateLayerDomain(dataset, visualChannel) {\n      var scale = visualChannel.scale;\n      var scaleType = this.config[scale];\n      var field = this.config[visualChannel.field];\n      if (!field) {\n        // if colorField or sizeField were set back to null\n        return defaultDomain;\n      }\n      return dataset.getColumnLayerDomain(field, scaleType) || defaultDomain;\n    }\n  }, {\n    key: \"hasHoveredObject\",\n    value: function hasHoveredObject(objectInfo) {\n      return this.isLayerHovered(objectInfo) && objectInfo.object ? objectInfo.object : null;\n    }\n  }, {\n    key: \"isLayerHovered\",\n    value: function isLayerHovered(objectInfo) {\n      var _objectInfo$layer, _objectInfo$layer$pro;\n      return (objectInfo === null || objectInfo === void 0 ? void 0 : objectInfo.picked) && (objectInfo === null || objectInfo === void 0 ? void 0 : (_objectInfo$layer = objectInfo.layer) === null || _objectInfo$layer === void 0 ? void 0 : (_objectInfo$layer$pro = _objectInfo$layer.props) === null || _objectInfo$layer$pro === void 0 ? void 0 : _objectInfo$layer$pro.id) === this.id;\n    }\n  }, {\n    key: \"getRadiusScaleByZoom\",\n    value: function getRadiusScaleByZoom(mapState, fixedRadius) {\n      var radiusChannel = Object.values(this.visualChannels).find(function (vc) {\n        return vc.property === 'radius';\n      });\n      if (!radiusChannel) {\n        return 1;\n      }\n      var field = radiusChannel.field;\n      var fixed = fixedRadius === undefined ? this.config.visConfig.fixedRadius : fixedRadius;\n      var radius = this.config.visConfig.radius;\n      return fixed ? 1 : (this.config[field] ? 1 : radius) * this.getZoomFactor(mapState);\n    }\n  }, {\n    key: \"shouldCalculateLayerData\",\n    value: function shouldCalculateLayerData(props) {\n      var _this7 = this;\n      return props.some(function (p) {\n        return !_this7.noneLayerDataAffectingProps.includes(p);\n      });\n    }\n  }, {\n    key: \"getBrushingExtensionProps\",\n    value: function getBrushingExtensionProps(interactionConfig, brushingTarget) {\n      var brush = interactionConfig.brush;\n      return {\n        // brushing\n        autoHighlight: !brush.enabled,\n        brushingRadius: brush.config.size * 1000,\n        brushingTarget: brushingTarget || 'source',\n        brushingEnabled: brush.enabled\n      };\n    }\n  }, {\n    key: \"getDefaultDeckLayerProps\",\n    value: function getDefaultDeckLayerProps(_ref11) {\n      var idx = _ref11.idx,\n        gpuFilter = _ref11.gpuFilter,\n        mapState = _ref11.mapState,\n        visible = _ref11.visible;\n      return {\n        id: this.id,\n        idx: idx,\n        coordinateSystem: _core.COORDINATE_SYSTEM.LNGLAT,\n        pickable: true,\n        wrapLongitude: true,\n        parameters: {\n          depthTest: Boolean(mapState.dragRotate || this.config.visConfig.enable3d)\n        },\n        hidden: this.config.hidden,\n        // visconfig\n        opacity: this.config.visConfig.opacity,\n        highlightColor: this.config.highlightColor,\n        // data filtering\n        extensions: [dataFilterExtension],\n        filterRange: gpuFilter ? gpuFilter.filterRange : undefined,\n        // layer should be visible and if splitMap, shown in to one of panel\n        visible: this.config.isVisible && visible\n      };\n    }\n  }, {\n    key: \"getDefaultHoverLayerProps\",\n    value: function getDefaultHoverLayerProps() {\n      return {\n        id: \"\".concat(this.id, \"-hovered\"),\n        pickable: false,\n        wrapLongitude: true,\n        coordinateSystem: _core.COORDINATE_SYSTEM.LNGLAT\n      };\n    }\n  }, {\n    key: \"renderTextLabelLayer\",\n    value: function renderTextLabelLayer(_ref12, renderOpts) {\n      var _this8 = this;\n      var getPosition = _ref12.getPosition,\n        getPixelOffset = _ref12.getPixelOffset,\n        updateTriggers = _ref12.updateTriggers,\n        sharedProps = _ref12.sharedProps;\n      var data = renderOpts.data,\n        mapState = renderOpts.mapState;\n      var textLabel = this.config.textLabel;\n      return data.textLabels.reduce(function (accu, d, i) {\n        if (d.getText) {\n          var _textLabel$i$field, _textLabel$i$field2;\n          accu.push(new _layers.TextLayer(_objectSpread(_objectSpread({}, sharedProps), {}, {\n            id: \"\".concat(_this8.id, \"-label-\").concat((_textLabel$i$field = textLabel[i].field) === null || _textLabel$i$field === void 0 ? void 0 : _textLabel$i$field.name),\n            data: data.data,\n            getText: d.getText,\n            getPosition: getPosition,\n            characterSet: d.characterSet,\n            getPixelOffset: getPixelOffset(textLabel[i]),\n            getSize: _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER,\n            sizeScale: textLabel[i].size,\n            getTextAnchor: textLabel[i].anchor,\n            getAlignmentBaseline: textLabel[i].alignment,\n            getColor: textLabel[i].color,\n            parameters: {\n              // text will always show on top of all layers\n              depthTest: false\n            },\n            getFilterValue: data.getFilterValue,\n            updateTriggers: _objectSpread(_objectSpread({}, updateTriggers), {}, {\n              getText: (_textLabel$i$field2 = textLabel[i].field) === null || _textLabel$i$field2 === void 0 ? void 0 : _textLabel$i$field2.name,\n              getPixelOffset: _objectSpread(_objectSpread({}, updateTriggers.getRadius), {}, {\n                mapState: mapState,\n                anchor: textLabel[i].anchor,\n                alignment: textLabel[i].alignment\n              }),\n              getTextAnchor: textLabel[i].anchor,\n              getAlignmentBaseline: textLabel[i].alignment,\n              getColor: textLabel[i].color\n            })\n          })));\n        }\n        return accu;\n      }, []);\n    }\n  }, {\n    key: \"calculateDataAttribute\",\n    value: function calculateDataAttribute(keplerTable, getPosition) {\n      // implemented in subclasses\n      return [];\n    }\n  }, {\n    key: \"updateLayerMeta\",\n    value: function updateLayerMeta(dataContainer, getPosition) {// implemented in subclasses\n    }\n  }, {\n    key: \"getPositionAccessor\",\n    value: function getPositionAccessor(dataContainer) {\n      // implemented in subclasses\n      return function () {\n        return null;\n      };\n    }\n  }], [{\n    key: \"findDefaultLayerProps\",\n    value: function findDefaultLayerProps(dataset, foundLayers) {\n      return {\n        props: [],\n        foundLayers: foundLayers\n      };\n    }\n    /**\n     * Given a array of preset required column names\n     * found field that has the same name to set as layer column\n     *\n     * @param {object} defaultFields\n     * @param {object[]} allFields\n     * @returns {object[] | null} all possible required layer column pairs\n     */\n  }, {\n    key: \"findDefaultColumnField\",\n    value: function findDefaultColumnField(defaultFields, allFields) {\n      // find all matched fields for each required col\n      var requiredColumns = Object.keys(defaultFields).reduce(function (prev, key) {\n        var requiredFields = allFields.filter(function (f) {\n          return f.name === defaultFields[key] || defaultFields[key].includes(f.name);\n        });\n        prev[key] = requiredFields.length ? requiredFields.map(function (f) {\n          return {\n            value: f.name,\n            fieldIdx: f.fieldIdx\n          };\n        }) : null;\n        return prev;\n      }, {});\n      if (!Object.values(requiredColumns).every(Boolean)) {\n        // if any field missing, return null\n        return null;\n      }\n      return this.getAllPossibleColumnParis(requiredColumns);\n    }\n  }, {\n    key: \"getAllPossibleColumnParis\",\n    value: function getAllPossibleColumnParis(requiredColumns) {\n      // for multiple matched field for one required column, return multiple\n      // combinations, e. g. if column a has 2 matched, column b has 3 matched\n      // 6 possible column pairs will be returned\n      var allKeys = Object.keys(requiredColumns);\n      var pointers = allKeys.map(function (k, i) {\n        return i === allKeys.length - 1 ? -1 : 0;\n      });\n      var countPerKey = allKeys.map(function (k) {\n        return requiredColumns[k].length;\n      }); // TODO: Better typings\n\n      var pairs = [];\n      /* eslint-disable no-loop-func */\n\n      while (incrementPointers(pointers, countPerKey, pointers.length - 1)) {\n        var newPair = pointers.reduce(function (prev, cuur, i) {\n          prev[allKeys[i]] = requiredColumns[allKeys[i]][cuur];\n          return prev;\n        }, {});\n        pairs.push(newPair);\n      }\n      /* eslint-enable no-loop-func */\n      // recursively increment pointers\n\n      function incrementPointers(pts, counts, index) {\n        if (index === 0 && pts[0] === counts[0] - 1) {\n          // nothing to increment\n          return false;\n        }\n        if (pts[index] + 1 < counts[index]) {\n          pts[index] = pts[index] + 1;\n          return true;\n        }\n        pts[index] = 0;\n        return incrementPointers(pts, counts, index - 1);\n      }\n      return pairs;\n    }\n  }, {\n    key: \"hexToRgb\",\n    value: function hexToRgb(c) {\n      return (0, _utils.hexToRgb)(c);\n    }\n  }]);\n  return Layer;\n}();\nvar _default = Layer;\nexports[\"default\"] = _default;","map":{"version":3,"names":["value","exports","colorMaker","layerColors","OVERLAY_TYPE_CONST","LAYER_ID_LENGTH","_toConsumableArray2","_interopRequireDefault","require","_slicedToArray2","_typeof2","_classCallCheck2","_createClass2","_defineProperty2","_extensions","_core","_defaultLayerIcon","_layerUpdate","_utils","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_marked","_regenerator","mark","generateColor","defaultDomain","defaultDataAccessor","dc","d","defaultGetFieldValue","field","valueAccessor","_keymirror","mapboxgl","index","wrap","generateColor$","_context","length","next","stop","Layer","props","arguments","undefined","meta","visConfigSettings","get","deckgl","type","key","color","property","scale","domain","range","nullValue","_constants","NO_VALUE_COLOR","defaultValue","config","size","channelScaleType","CHANNEL_SCALES","lat","pair","fieldPairKey","lng","lat0","lng0","lat1","getDefaultLayerConfig","dataId","label","DEFAULT_LAYER_LABEL","columns","isVisible","isConfigActive","highlightColor","DEFAULT_HIGHLIGHT_COLOR","hidden","colorField","colorDomain","colorScale","SCALE_TYPES","quantile","visConfig","textLabel","DEFAULT_TEXT_LABEL","colorUI","DEFAULT_COLOR_UI","colorRange","animation","enabled","getVisualChannelDescription","measure","rangeSettings","channel","fieldSettings","displayName","name","defaultMeasure","assignColumn","fieldIdx","_objectSpread","update","assignColumnPairs","_this$columnPairs","_this$columnPairs2","_this$columnPairs3","_objectSpread3","columnPairs","_this$columnPairs$key","partnerKey","_this$columnPairs$par","partnerFieldPairKey","getZoomFactor","_ref","zoom","Math","pow","max","zoomOffset","getElevationZoomFactor","_ref2","_ref2$zoomOffset","formatLayerData","datasets","oldLayerData","getHoverData","dataContainer","fields","row","assignConfigToLayer","configToCopy","_this","v","notToCopy","concat","values","visualChannels","map","forEach","group","currentConfig","updateLayerConfig","copied","validateVisualChannel","copyLayerConfig","_this2","_ref3","_ref3$shallowCopy","shallowCopy","_ref3$notToCopy","notNullorUndefined","includes","layerVisConfigs","item","configItem","LAYER_VIS_CONFIGS","_this3","every","p","hasOwnProperty","getLayerColumns","accu","columnValidators","validator","optional","optionalColumns","reduce","newConfig","updateLayerVisConfig","newVisConfig","updateLayerColorUI","prop","_this$config","isPlainObject","colorUIProp","entries","_ref4","_ref5","previous","isColorRange","colors","updateColorUIByColorRange","updateColorRangeByColorUI","updateCustomPalette","colorRangeConfig","custom","_this$config2","customPalette","showDropdown","_this$config3","steps","shouldUpdate","some","_this$config4","_colorUI$prop$colorRa","reversed","sameGroup","COLOR_RANGES","cr","getColorGroupByName","find","reverseColorRange","hasAllColumns","hasLayerData","layerData","Boolean","data","renderLayer","getColorScale","Array","isArray","colorMap","cMap","Map","_ref6","_ref7","set","k","hexToRgb","SCALE_FUNC","ordinal","unknown","UNKNOWN_COLOR_KEY","getVisChannelScale","getAttributeAccessors","_ref8","_this4","_ref8$dataAccessor","dataAccessor","_this4$visualChannels","fixed","accessor","getAttributeValue","shouldGetScale","scaleFunction","isFixed","attributeAccessors","getEncodedChannelValue","_window","console","warn","getPointsBounds","getPosition","numRows","MAX_SAMPLE_SIZE","getSampleContainerData","points","sampleData","mapIndex","latBounds","getLatLngBounds","lngBounds","getChangedTriggers","dataUpdateTriggers","triggerChanged","diffUpdateTriggers","_oldDataUpdateTriggers","getValue","attributeValue","Date","updateMeta","getDataUpdateTriggers","_ref9","getData","filteredIndex","getMeta","i","tl","updateData","layerDataset","getPositionAccessor","updateLayerMeta","calculateDataAttribute","updateLayerDomain","newFilter","_this5","table","getDataset","scaleType","updatedDomain","calculateLayerDomain","validateFieldType","validateScale","visualChannel","supportedFieldTypes","channelSupportedFieldTypes","CHANNEL_SCALE_SUPPORTED_FIELDS","scaleOptions","getScaleOptions","FIELD_OPTS","updateLayerVisualChannel","dataset","getVisualChannelUpdateTriggers","updateTriggers","_this6","_objectSpread11","isLayerHovered","objectInfo","picked","_objectInfo$layer","layer","_objectInfo$layer$pro","id","getRadiusScaleByZoom","mapState","fixedRadius","radiusChannel","vc","radius","_this7","noneLayerDataAffectingProps","getBrushingExtensionProps","interactionConfig","brushingTarget","brush","autoHighlight","brushingRadius","brushingEnabled","getDefaultDeckLayerProps","_ref11","idx","gpuFilter","visible","coordinateSystem","COORDINATE_SYSTEM","LNGLAT","pickable","wrapLongitude","parameters","depthTest","dragRotate","enable3d","filterRange","getDefaultHoverLayerProps","textLabels","renderTextLabelLayer","_ref12","renderOpts","_this8","getPixelOffset","sharedProps","getText","_textLabel$i$field","_textLabel$i$field2","_layers","TextLayer","characterSet","getSize","PROJECTED_PIXEL_SIZE_MULTIPLIER","sizeScale","getTextAnchor","anchor","getColor","getFilterValue","getRadius","alignment","keplerTable","findDefaultLayerProps","foundLayers","findDefaultColumnField","defaultFields","allFields","f","prev","requiredFields","getAllPossibleColumnParis","requiredColumns","newPair","allKeys","countPerKey","pairs","incrementPointers","pointers","cuur","pts","counts"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/layers/src/base-layer.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport React from 'react';\nimport {console as Console} from 'global/window';\nimport keymirror from 'keymirror';\nimport {DataFilterExtension} from '@deck.gl/extensions';\nimport {COORDINATE_SYSTEM} from '@deck.gl/core';\nimport {TextLayer} from '@deck.gl/layers';\n\nimport DefaultLayerIcon from './default-layer-icon';\nimport {diffUpdateTriggers} from './layer-update';\n\nimport {\n  ALL_FIELD_TYPES,\n  NO_VALUE_COLOR,\n  SCALE_TYPES,\n  CHANNEL_SCALES,\n  FIELD_OPTS,\n  SCALE_FUNC,\n  CHANNEL_SCALE_SUPPORTED_FIELDS,\n  MAX_GPU_FILTERS,\n  ColorRange,\n  COLOR_RANGES,\n  DataVizColors,\n  LAYER_VIS_CONFIGS,\n  DEFAULT_TEXT_LABEL,\n  DEFAULT_COLOR_UI,\n  UNKNOWN_COLOR_KEY,\n  DEFAULT_HIGHLIGHT_COLOR,\n  DEFAULT_LAYER_LABEL,\n  PROJECTED_PIXEL_SIZE_MULTIPLIER\n} from '@kepler.gl/constants';\n\nimport {\n  generateHashId,\n  getColorGroupByName,\n  reverseColorRange,\n  hexToRgb,\n  getLatLngBounds,\n  isPlainObject,\n  notNullorUndefined,\n  DataContainerInterface,\n  getSampleContainerData\n} from '@kepler.gl/utils';\n\nimport {\n  RGBColor,\n  RGBAColor,\n  ValueOf,\n  NestedPartial,\n  LayerTextLabel,\n  ColorUI,\n  LayerVisConfig,\n  LayerVisConfigSettings,\n  Field,\n  MapState,\n  Filter\n} from '@kepler.gl/types';\nimport {KeplerTable, Datasets, GpuFilter} from '@kepler.gl/table';\n\nexport type LayerColumn = {value: string | null; fieldIdx: number; optional?: boolean};\n\nexport type LayerColumns = {\n  [key: string]: LayerColumn;\n};\nexport type VisualChannelDomain = number[] | string[];\nexport type VisualChannelField = Field | null;\nexport type VisualChannelScale = keyof typeof SCALE_TYPES;\n\nexport type LayerBaseConfig = {\n  dataId: string | null;\n  label: string;\n  color: RGBColor;\n\n  columns: LayerColumns;\n  isVisible: boolean;\n  isConfigActive: boolean;\n  highlightColor: RGBColor | RGBAColor;\n  hidden: boolean;\n\n  visConfig: LayerVisConfig;\n  textLabel: LayerTextLabel[];\n\n  colorUI: {\n    color: ColorUI;\n    colorRange: ColorUI;\n  };\n  animation: {\n    enabled: boolean;\n    domain?: null;\n  };\n};\n\nexport type LayerColorConfig = {\n  colorField: VisualChannelField;\n  colorDomain: VisualChannelDomain;\n  colorScale: VisualChannelScale;\n};\nexport type LayerSizeConfig = {\n  // color by size, domain is set by filters, field, scale type\n  sizeDomain: VisualChannelDomain;\n  sizeScale: VisualChannelScale;\n  sizeField: VisualChannelField;\n};\nexport type LayerHeightConfig = {\n  heightField: VisualChannelField;\n  heightDomain: VisualChannelDomain;\n  heightScale: VisualChannelScale;\n};\nexport type LayerStrokeColorConfig = {\n  strokeColorField: VisualChannelField;\n  strokeColorDomain: VisualChannelDomain;\n  strokeColorScale: VisualChannelScale;\n};\nexport type LayerCoverageConfig = {\n  coverageField: VisualChannelField;\n  coverageDomain: VisualChannelDomain;\n  coverageScale: VisualChannelScale;\n};\nexport type LayerRadiusConfig = {\n  radiusField: VisualChannelField;\n  radiusDomain: VisualChannelDomain;\n  radiusScale: VisualChannelScale;\n};\nexport type LayerWeightConfig = {\n  weightField: VisualChannelField;\n};\n\nexport type VisualChannels = {[key: string]: VisualChannel};\n\nexport type VisualChannelAggregation = 'colorAggregation' | 'sizeAggregation';\n\nexport type VisualChannel = {\n  property: string;\n  field: string;\n  scale: string;\n  domain: string;\n  range: string;\n  key: string;\n  channelScaleType: string;\n  nullValue?: any;\n  defaultMeasure?: any;\n  accessor?: string;\n  condition?: (config: any) => boolean;\n  getAttributeValue?: (config: any) => (d: any) => any;\n\n  // TODO: define defaultValue\n  defaultValue?: any;\n  // TODO: define fixed\n  fixed?: any;\n\n  supportedFieldTypes?: Array<keyof typeof ALL_FIELD_TYPES>;\n\n  aggregation?: VisualChannelAggregation;\n};\n\nexport type VisualChannelDescription = {\n  label: string;\n  measure: string | undefined;\n};\n\nexport type ColumnPairs = {[key: string]: {pair: string; fieldPairKey: string}};\n\ntype ColumnValidator = (column: LayerColumn, columns: LayerColumns, allFields: Field[]) => boolean;\n\nexport type UpdateTriggers = {\n  [key: string]: UpdateTrigger;\n};\nexport type UpdateTrigger = {\n  [key: string]: {};\n};\nexport type LayerBounds = [number, number, number, number];\nexport type FindDefaultLayerPropsReturnValue = {props: any[]; foundLayers?: any[]};\n/**\n * Approx. number of points to sample in a large data set\n */\nexport const LAYER_ID_LENGTH = 6;\n\nconst MAX_SAMPLE_SIZE = 5000;\nconst defaultDomain: [number, number] = [0, 1];\nconst dataFilterExtension = new DataFilterExtension({filterSize: MAX_GPU_FILTERS});\n\nconst defaultDataAccessor = dc => d => d;\nconst defaultGetFieldValue = (field, d) => field.valueAccessor(d);\n\nexport const OVERLAY_TYPE_CONST = keymirror({\n  deckgl: null,\n  mapboxgl: null\n});\n\nexport const layerColors = Object.values(DataVizColors).map(hexToRgb);\nfunction* generateColor(): Generator<RGBColor> {\n  let index = 0;\n  while (index < layerColors.length + 1) {\n    if (index === layerColors.length) {\n      index = 0;\n    }\n    yield layerColors[index++];\n  }\n}\n\nexport const colorMaker = generateColor();\n\nclass Layer {\n  id: string;\n  // TODO: define meta\n  meta: {};\n  visConfigSettings: {\n    [key: string]: ValueOf<LayerVisConfigSettings>;\n  };\n  config: LayerBaseConfig;\n  // TODO: define _oldDataUpdateTriggers\n  _oldDataUpdateTriggers: any;\n\n  constructor(\n    props: {\n      id?: string;\n    } & Partial<LayerBaseConfig> = {}\n  ) {\n    this.id = props.id || generateHashId(LAYER_ID_LENGTH);\n\n    // meta\n    this.meta = {};\n\n    // visConfigSettings\n    this.visConfigSettings = {};\n\n    this.config = this.getDefaultLayerConfig({\n      columns: this.getLayerColumns(),\n      ...props\n    });\n  }\n\n  get layerIcon(): React.ElementType {\n    return DefaultLayerIcon;\n  }\n\n  get overlayType(): keyof typeof OVERLAY_TYPE_CONST {\n    return OVERLAY_TYPE_CONST.deckgl;\n  }\n\n  get type(): string | null {\n    return null;\n  }\n\n  get name() {\n    return this.type;\n  }\n\n  get isAggregated() {\n    return false;\n  }\n\n  get requiredLayerColumns(): string[] {\n    return [];\n  }\n\n  get optionalColumns(): string[] {\n    return [];\n  }\n\n  get noneLayerDataAffectingProps() {\n    return ['label', 'opacity', 'thickness', 'isVisible', 'hidden'];\n  }\n\n  get visualChannels(): VisualChannels {\n    return {\n      color: {\n        property: 'color',\n        field: 'colorField',\n        scale: 'colorScale',\n        domain: 'colorDomain',\n        range: 'colorRange',\n        key: 'color',\n        channelScaleType: CHANNEL_SCALES.color,\n        nullValue: NO_VALUE_COLOR,\n        defaultValue: config => config.color\n      },\n      size: {\n        property: 'size',\n        field: 'sizeField',\n        scale: 'sizeScale',\n        domain: 'sizeDomain',\n        range: 'sizeRange',\n        key: 'size',\n        channelScaleType: CHANNEL_SCALES.size,\n        nullValue: 0,\n        defaultValue: 1\n      }\n    };\n  }\n\n  get columnValidators(): {[key: string]: ColumnValidator} {\n    return {};\n  }\n  /*\n   * Column pairs maps layer column to a specific field pairs,\n   * By default, it is set to null\n   */\n  get columnPairs(): ColumnPairs | null {\n    return null;\n  }\n\n  /*\n   * Default point column pairs, can be used for point based layers: point, icon etc.\n   */\n  get defaultPointColumnPairs(): ColumnPairs {\n    return {\n      lat: {pair: 'lng', fieldPairKey: 'lat'},\n      lng: {pair: 'lat', fieldPairKey: 'lng'}\n    };\n  }\n\n  /*\n   * Default link column pairs, can be used for link based layers: arc, line etc\n   */\n  get defaultLinkColumnPairs(): ColumnPairs {\n    return {\n      lat0: {pair: 'lng0', fieldPairKey: 'lat'},\n      lng0: {pair: 'lat0', fieldPairKey: 'lng'},\n      lat1: {pair: 'lng1', fieldPairKey: 'lat'},\n      lng1: {pair: 'lat1', fieldPairKey: 'lng'}\n    };\n  }\n\n  /**\n   * Return a React component for to render layer instructions in a modal\n   * @returns {object} - an object\n   * @example\n   *  return {\n   *    id: 'iconInfo',\n   *    template: IconInfoModal,\n   *    modalProps: {\n   *      title: 'How to draw icons'\n   *   };\n   * }\n   */\n  get layerInfoModal(): any {\n    return null;\n  }\n\n  get supportedDatasetTypes(): string[] | null {\n    return null;\n  }\n  /*\n   * Given a dataset, automatically find props to create layer based on it\n   * and return the props and previous found layers.\n   * By default, no layers will be found\n   */\n  static findDefaultLayerProps(\n    dataset: KeplerTable,\n    foundLayers?: any[]\n  ): FindDefaultLayerPropsReturnValue {\n    return {props: [], foundLayers};\n  }\n\n  /**\n   * Given a array of preset required column names\n   * found field that has the same name to set as layer column\n   *\n   * @param {object} defaultFields\n   * @param {object[]} allFields\n   * @returns {object[] | null} all possible required layer column pairs\n   */\n  static findDefaultColumnField(defaultFields, allFields) {\n    // find all matched fields for each required col\n    const requiredColumns = Object.keys(defaultFields).reduce((prev, key) => {\n      const requiredFields = allFields.filter(\n        f => f.name === defaultFields[key] || defaultFields[key].includes(f.name)\n      );\n\n      prev[key] = requiredFields.length\n        ? requiredFields.map(f => ({\n            value: f.name,\n            fieldIdx: f.fieldIdx\n          }))\n        : null;\n      return prev;\n    }, {});\n\n    if (!Object.values(requiredColumns).every(Boolean)) {\n      // if any field missing, return null\n      return null;\n    }\n\n    return this.getAllPossibleColumnParis(requiredColumns);\n  }\n\n  static getAllPossibleColumnParis(requiredColumns) {\n    // for multiple matched field for one required column, return multiple\n    // combinations, e. g. if column a has 2 matched, column b has 3 matched\n    // 6 possible column pairs will be returned\n    const allKeys = Object.keys(requiredColumns);\n    const pointers = allKeys.map((k, i) => (i === allKeys.length - 1 ? -1 : 0));\n    const countPerKey = allKeys.map(k => requiredColumns[k].length);\n    // TODO: Better typings\n    const pairs: any[] = [];\n\n    /* eslint-disable no-loop-func */\n    while (incrementPointers(pointers, countPerKey, pointers.length - 1)) {\n      const newPair = pointers.reduce((prev, cuur, i) => {\n        prev[allKeys[i]] = requiredColumns[allKeys[i]][cuur];\n        return prev;\n      }, {});\n\n      pairs.push(newPair);\n    }\n    /* eslint-enable no-loop-func */\n\n    // recursively increment pointers\n    function incrementPointers(pts, counts, index) {\n      if (index === 0 && pts[0] === counts[0] - 1) {\n        // nothing to increment\n        return false;\n      }\n\n      if (pts[index] + 1 < counts[index]) {\n        pts[index] = pts[index] + 1;\n        return true;\n      }\n\n      pts[index] = 0;\n      return incrementPointers(pts, counts, index - 1);\n    }\n\n    return pairs;\n  }\n\n  static hexToRgb(c) {\n    return hexToRgb(c);\n  }\n\n  getDefaultLayerConfig(\n    props: Partial<LayerBaseConfig> = {}\n  ): LayerBaseConfig & Partial<LayerColorConfig & LayerSizeConfig> {\n    return {\n      dataId: props.dataId || null,\n      label: props.label || DEFAULT_LAYER_LABEL,\n      color: props.color || colorMaker.next().value,\n      columns: props.columns || {},\n      isVisible: props.isVisible || false,\n      isConfigActive: props.isConfigActive || false,\n      highlightColor: props.highlightColor || DEFAULT_HIGHLIGHT_COLOR,\n      hidden: props.hidden || false,\n\n      // TODO: refactor this into separate visual Channel config\n      // color by field, domain is set by filters, field, scale type\n      colorField: null,\n      colorDomain: [0, 1],\n      colorScale: SCALE_TYPES.quantile,\n\n      // color by size, domain is set by filters, field, scale type\n      sizeDomain: [0, 1],\n      sizeScale: SCALE_TYPES.linear,\n      sizeField: null,\n\n      visConfig: {},\n\n      textLabel: [DEFAULT_TEXT_LABEL],\n\n      colorUI: {\n        color: DEFAULT_COLOR_UI,\n        colorRange: DEFAULT_COLOR_UI\n      },\n      animation: {enabled: false}\n    };\n  }\n\n  /**\n   * Get the description of a visualChannel config\n   * @param key\n   * @returns\n   */\n  getVisualChannelDescription(key: string): VisualChannelDescription {\n    // e.g. label: Color, measure: Vehicle Type\n    const channel = this.visualChannels[key];\n    if (!channel) return {label: '', measure: undefined};\n    const rangeSettings = this.visConfigSettings[channel.range];\n    const fieldSettings = this.config[channel.field];\n    const label = rangeSettings?.label;\n    return {\n      label: typeof label === 'function' ? label(this.config) : label || '',\n      measure: fieldSettings\n        ? fieldSettings.displayName || fieldSettings.name\n        : channel.defaultMeasure\n    };\n  }\n\n  /**\n   * Assign a field to layer column, return column config\n   * @param key - Column Key\n   * @param field - Selected field\n   * @returns {{}} - Column config\n   */\n  assignColumn(key: string, field: Field): LayerColumns {\n    // field value could be null for optional columns\n    const update = field\n      ? {\n          value: field.name,\n          fieldIdx: field.fieldIdx\n        }\n      : {value: null, fieldIdx: -1};\n\n    return {\n      ...this.config.columns,\n      [key]: {\n        ...this.config.columns[key],\n        ...update\n      }\n    };\n  }\n\n  /**\n   * Assign a field pair to column config, return column config\n   * @param key - Column Key\n   * @param pair - field Pair\n   * @returns {object} - Column config\n   */\n  assignColumnPairs(key, pair) {\n    if (!this.columnPairs || !this.columnPairs?.[key]) {\n      // should not end in this state\n      return this.config.columns;\n    }\n\n    const {pair: partnerKey, fieldPairKey} = this.columnPairs?.[key];\n    const {fieldPairKey: partnerFieldPairKey} = this.columnPairs?.[partnerKey];\n\n    return {\n      ...this.config.columns,\n      [key]: pair[fieldPairKey],\n      [partnerKey]: pair[partnerFieldPairKey]\n    };\n  }\n\n  /**\n   * Calculate a radius zoom multiplier to render points, so they are visible in all zoom level\n   * @param {object} mapState\n   * @param {number} mapState.zoom - actual zoom\n   * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image\n   * @returns {number}\n   */\n  getZoomFactor({zoom, zoomOffset = 0}) {\n    return Math.pow(2, Math.max(14 - zoom + zoomOffset, 0));\n  }\n\n  /**\n   * Calculate a elevation zoom multiplier to render points, so they are visible in all zoom level\n   * @param {object} mapState\n   * @param {number} mapState.zoom - actual zoom\n   * @param {number | void} mapState.zoomOffset - zoomOffset when render in the plot container for export image\n   * @returns {number}\n   */\n  getElevationZoomFactor({zoom, zoomOffset = 0}: {zoom: number; zoomOffset?: number}) {\n    return this.config.visConfig.enableElevationZoomFactor\n      ? Math.pow(2, Math.max(8 - zoom + zoomOffset, 0))\n      : 1;\n  }\n\n  formatLayerData(datasets: Datasets, oldLayerData?: any) {\n    return {};\n  }\n\n  renderLayer(...args: any[]): any[] {\n    return [];\n  }\n\n  getHoverData(object, dataContainer: DataContainerInterface, fields: Field[]) {\n    if (!object) {\n      return null;\n    }\n\n    // By default, each entry of layerData should have an index of a row in the original data container.\n    // Each layer can implement its own getHoverData method\n    return dataContainer.row(object.index);\n  }\n\n  /**\n   * When change layer type, try to copy over layer configs as much as possible\n   * @param configToCopy - config to copy over\n   * @param visConfigSettings - visConfig settings of config to copy\n   */\n  assignConfigToLayer(configToCopy, visConfigSettings) {\n    // don't deep merge visualChannel field\n    // don't deep merge color range, reversed: is not a key by default\n    const shallowCopy = ['colorRange', 'strokeColorRange'].concat(\n      Object.values(this.visualChannels).map(v => v.field)\n    );\n\n    // don't copy over domain and animation\n    const notToCopy = ['animation'].concat(Object.values(this.visualChannels).map(v => v.domain));\n    // if range is for the same property group copy it, otherwise, not to copy\n    Object.values(this.visualChannels).forEach(v => {\n      if (\n        configToCopy.visConfig[v.range] &&\n        this.visConfigSettings[v.range] &&\n        visConfigSettings[v.range].group !== this.visConfigSettings[v.range].group\n      ) {\n        notToCopy.push(v.range);\n      }\n    });\n\n    // don't copy over visualChannel range\n    const currentConfig = this.config;\n    const copied = this.copyLayerConfig(currentConfig, configToCopy, {\n      shallowCopy,\n      notToCopy\n    });\n\n    this.updateLayerConfig(copied);\n    // validate visualChannel field type and scale types\n    Object.keys(this.visualChannels).forEach(channel => {\n      this.validateVisualChannel(channel);\n    });\n  }\n\n  /*\n   * Recursively copy config over to an empty layer\n   * when received saved config, or copy config over from a different layer type\n   * make sure to only copy over value to existing keys\n   * @param {object} currentConfig - existing config to be override\n   * @param {object} configToCopy - new Config to copy over\n   * @param {string[]} shallowCopy - array of properties to not to be deep copied\n   * @param {string[]} notToCopy - array of properties not to copy\n   * @returns {object} - copied config\n   */\n  copyLayerConfig(\n    currentConfig,\n    configToCopy,\n    {shallowCopy = [], notToCopy = []}: {shallowCopy?: string[]; notToCopy?: string[]} = {}\n  ) {\n    const copied = {};\n    Object.keys(currentConfig).forEach(key => {\n      if (\n        isPlainObject(currentConfig[key]) &&\n        isPlainObject(configToCopy[key]) &&\n        !shallowCopy.includes(key) &&\n        !notToCopy.includes(key)\n      ) {\n        // recursively assign object value\n        copied[key] = this.copyLayerConfig(currentConfig[key], configToCopy[key], {\n          shallowCopy,\n          notToCopy\n        });\n      } else if (notNullorUndefined(configToCopy[key]) && !notToCopy.includes(key)) {\n        // copy\n        copied[key] = configToCopy[key];\n      } else {\n        // keep existing\n        copied[key] = currentConfig[key];\n      }\n    });\n\n    return copied;\n  }\n\n  registerVisConfig(layerVisConfigs: {\n    [key: string]: keyof LayerVisConfigSettings | ValueOf<LayerVisConfigSettings>;\n  }) {\n    Object.keys(layerVisConfigs).forEach(item => {\n      const configItem = layerVisConfigs[item];\n      if (typeof configItem === 'string' && LAYER_VIS_CONFIGS[configItem]) {\n        // if assigned one of default LAYER_CONFIGS\n        this.config.visConfig[item] = LAYER_VIS_CONFIGS[configItem].defaultValue;\n        this.visConfigSettings[item] = LAYER_VIS_CONFIGS[configItem];\n      } else if (\n        typeof configItem === 'object' &&\n        ['type', 'defaultValue'].every(p => configItem.hasOwnProperty(p))\n      ) {\n        // if provided customized visConfig, and has type && defaultValue\n        // TODO: further check if customized visConfig is valid\n        this.config.visConfig[item] = configItem.defaultValue;\n        this.visConfigSettings[item] = configItem;\n      }\n    });\n  }\n\n  getLayerColumns() {\n    const columnValidators = this.columnValidators;\n    const required = this.requiredLayerColumns.reduce(\n      (accu, key) => ({\n        ...accu,\n        [key]: columnValidators[key]\n          ? {value: null, fieldIdx: -1, validator: columnValidators[key]}\n          : {value: null, fieldIdx: -1}\n      }),\n      {}\n    );\n    const optional = this.optionalColumns.reduce(\n      (accu, key) => ({\n        ...accu,\n        [key]: {value: null, fieldIdx: -1, optional: true}\n      }),\n      {}\n    );\n\n    return {...required, ...optional};\n  }\n\n  updateLayerConfig<LayerConfig extends LayerBaseConfig = LayerBaseConfig>(\n    newConfig: Partial<LayerConfig>\n  ): Layer {\n    this.config = {...this.config, ...newConfig};\n    return this;\n  }\n\n  updateLayerVisConfig(newVisConfig) {\n    this.config.visConfig = {...this.config.visConfig, ...newVisConfig};\n    return this;\n  }\n\n  updateLayerColorUI(prop: string, newConfig: NestedPartial<ColorUI>): Layer {\n    const {colorUI: previous, visConfig} = this.config;\n\n    if (!isPlainObject(newConfig) || typeof prop !== 'string') {\n      return this;\n    }\n\n    const colorUIProp = Object.entries(newConfig).reduce((accu, [key, value]) => {\n      return {\n        ...accu,\n        [key]: isPlainObject(accu[key]) && isPlainObject(value) ? {...accu[key], ...value} : value\n      };\n    }, previous[prop] || DEFAULT_COLOR_UI);\n\n    const colorUI = {\n      ...previous,\n      [prop]: colorUIProp\n    };\n\n    this.updateLayerConfig({colorUI});\n    // if colorUI[prop] is colorRange\n    const isColorRange = visConfig[prop] && visConfig[prop].colors;\n\n    if (isColorRange) {\n      this.updateColorUIByColorRange(newConfig, prop);\n      this.updateColorRangeByColorUI(newConfig, previous, prop);\n      this.updateCustomPalette(newConfig, previous, prop);\n    }\n\n    return this;\n  }\n\n  updateCustomPalette(newConfig, previous, prop) {\n    if (!newConfig.colorRangeConfig || !newConfig.colorRangeConfig.custom) {\n      return;\n    }\n\n    const {colorUI, visConfig} = this.config;\n\n    if (!visConfig[prop]) return;\n    const {colors} = visConfig[prop];\n    const customPalette = {\n      ...colorUI[prop].customPalette,\n      name: 'Custom Palette',\n      colors: [...colors]\n    };\n    this.updateLayerConfig({\n      colorUI: {\n        ...colorUI,\n        [prop]: {\n          ...colorUI[prop],\n          customPalette\n        }\n      }\n    });\n  }\n  /**\n   * if open dropdown and prop is color range\n   * Automatically set colorRangeConfig's step and reversed\n   * @param {*} newConfig\n   * @param {*} prop\n   */\n  updateColorUIByColorRange(newConfig, prop) {\n    if (typeof newConfig.showDropdown !== 'number') return;\n\n    const {colorUI, visConfig} = this.config;\n    this.updateLayerConfig({\n      colorUI: {\n        ...colorUI,\n        [prop]: {\n          ...colorUI[prop],\n          colorRangeConfig: {\n            ...colorUI[prop].colorRangeConfig,\n            steps: visConfig[prop].colors.length,\n            reversed: Boolean(visConfig[prop].reversed)\n          }\n        }\n      }\n    });\n  }\n\n  updateColorRangeByColorUI(newConfig, previous, prop) {\n    // only update colorRange if changes in UI is made to 'reversed', 'steps' or steps\n    const shouldUpdate =\n      newConfig.colorRangeConfig &&\n      ['reversed', 'steps'].some(\n        key =>\n          newConfig.colorRangeConfig.hasOwnProperty(key) &&\n          newConfig.colorRangeConfig[key] !==\n            (previous[prop] || DEFAULT_COLOR_UI).colorRangeConfig[key]\n      );\n    if (!shouldUpdate) return;\n\n    const {colorUI, visConfig} = this.config;\n    const {steps, reversed} = colorUI[prop].colorRangeConfig;\n    const colorRange = visConfig[prop];\n    // find based on step or reversed\n    let update;\n    if (newConfig.colorRangeConfig.hasOwnProperty('steps')) {\n      const group = getColorGroupByName(colorRange);\n\n      if (group) {\n        const sameGroup = COLOR_RANGES.filter(cr => getColorGroupByName(cr) === group);\n\n        update = sameGroup.find(cr => cr.colors.length === steps);\n\n        if (update && colorRange.reversed) {\n          update = reverseColorRange(true, update);\n        }\n      }\n    }\n\n    if (newConfig.colorRangeConfig.hasOwnProperty('reversed')) {\n      update = reverseColorRange(reversed, update || colorRange);\n    }\n\n    if (update) {\n      this.updateLayerVisConfig({[prop]: update});\n    }\n  }\n\n  /**\n   * Check whether layer has all columns\n   * @returns yes or no\n   */\n  hasAllColumns(): boolean {\n    const {columns} = this.config;\n    return (\n      columns &&\n      Object.values(columns).every(v => {\n        return Boolean(v.optional || (v.value && v.fieldIdx > -1));\n      })\n    );\n  }\n\n  /**\n   * Check whether layer has data\n   *\n   * @param {Array | Object} layerData\n   * @returns {boolean} yes or no\n   */\n  hasLayerData(layerData) {\n    if (!layerData) {\n      return false;\n    }\n    return Boolean(layerData.data && layerData.data.length);\n  }\n\n  isValidToSave(): boolean {\n    return Boolean(this.type && this.hasAllColumns());\n  }\n\n  shouldRenderLayer(data): boolean {\n    return (\n      Boolean(this.type) &&\n      this.hasAllColumns() &&\n      this.hasLayerData(data) &&\n      typeof this.renderLayer === 'function'\n    );\n  }\n\n  getColorScale(colorScale: string, colorDomain: VisualChannelDomain, colorRange: ColorRange) {\n    if (Array.isArray(colorRange.colorMap)) {\n      const cMap = new Map();\n      colorRange.colorMap.forEach(([k, v]) => {\n        cMap.set(k, typeof v === 'string' ? hexToRgb(v) : v);\n      });\n\n      const scale = SCALE_FUNC[SCALE_TYPES.ordinal]()\n        .domain(cMap.keys())\n        .range(cMap.values())\n        .unknown(cMap.get(UNKNOWN_COLOR_KEY) || NO_VALUE_COLOR);\n      return scale;\n    }\n    return this.getVisChannelScale(colorScale, colorDomain, colorRange.colors.map(hexToRgb));\n  }\n\n  /**\n   * Mapping from visual channels to deck.gl accesors\n   * @param {Object} param Parameters\n   * @param {Function} param.dataAccessor Access kepler.gl layer data from deck.gl layer\n   * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} param.dataContainer DataContainer to use use with dataAccessor\n   * @return {Object} attributeAccessors - deck.gl layer attribute accessors\n   */\n  getAttributeAccessors({\n    dataAccessor = defaultDataAccessor,\n    dataContainer\n  }: {\n    dataAccessor?: typeof defaultDataAccessor;\n    dataContainer: DataContainerInterface;\n  }) {\n    const attributeAccessors: {[key: string]: any} = {};\n\n    Object.keys(this.visualChannels).forEach(channel => {\n      const {\n        field,\n        fixed,\n        scale,\n        domain,\n        range,\n        accessor,\n        defaultValue,\n        getAttributeValue,\n        nullValue,\n        channelScaleType\n      } = this.visualChannels[channel];\n\n      if (accessor) {\n        const shouldGetScale = this.config[field];\n\n        if (shouldGetScale) {\n          const isFixed = fixed && this.config.visConfig[fixed];\n\n          const scaleFunction =\n            channelScaleType === CHANNEL_SCALES.color\n              ? this.getColorScale(\n                  this.config[scale],\n                  this.config[domain],\n                  this.config.visConfig[range]\n                )\n              : this.getVisChannelScale(\n                  this.config[scale],\n                  this.config[domain],\n                  this.config.visConfig[range],\n                  isFixed\n                );\n\n          attributeAccessors[accessor] = d =>\n            this.getEncodedChannelValue(\n              scaleFunction,\n              dataAccessor(dataContainer)(d),\n              this.config[field],\n              nullValue\n            );\n        } else if (typeof getAttributeValue === 'function') {\n          attributeAccessors[accessor] = getAttributeValue(this.config);\n        } else {\n          attributeAccessors[accessor] =\n            typeof defaultValue === 'function' ? defaultValue(this.config) : defaultValue;\n        }\n\n        if (!attributeAccessors[accessor]) {\n          Console.warn(`Failed to provide accessor function for ${accessor || channel}`);\n        }\n      }\n    });\n\n    return attributeAccessors;\n  }\n\n  getVisChannelScale(\n    scale: string,\n    domain: VisualChannelDomain,\n    range: any,\n    fixed?: boolean\n  ): () => any | null {\n    return SCALE_FUNC[fixed ? 'linear' : scale]()\n      .domain(domain)\n      .range(fixed ? domain : range);\n  }\n\n  /**\n   * Get longitude and latitude bounds of the data.\n   * @param {import('utils/table-utils/data-container-interface').DataContainerInterface} dataContainer DataContainer to calculate bounds for.\n   * @param {(d: {index: number}, dc: import('utils/table-utils/data-container-interface').DataContainerInterface) => number[]} getPosition Access kepler.gl layer data from deck.gl layer\n   * @return {number[]|null} bounds of the data.\n   */\n  getPointsBounds(dataContainer, getPosition) {\n    // no need to loop through the entire dataset\n    // get a sample of data to calculate bounds\n    const sampleData =\n      dataContainer.numRows() > MAX_SAMPLE_SIZE\n        ? getSampleContainerData(dataContainer, MAX_SAMPLE_SIZE)\n        : dataContainer;\n\n    const points = sampleData.mapIndex(getPosition);\n\n    const latBounds = getLatLngBounds(points, 1, [-90, 90]);\n    const lngBounds = getLatLngBounds(points, 0, [-180, 180]);\n\n    if (!latBounds || !lngBounds) {\n      return null;\n    }\n\n    return [lngBounds[0], latBounds[0], lngBounds[1], latBounds[1]];\n  }\n\n  getChangedTriggers(dataUpdateTriggers) {\n    const triggerChanged = diffUpdateTriggers(dataUpdateTriggers, this._oldDataUpdateTriggers);\n    this._oldDataUpdateTriggers = dataUpdateTriggers;\n\n    return triggerChanged;\n  }\n\n  getEncodedChannelValue(\n    scale: (value) => any,\n    data: any[],\n    field: VisualChannelField,\n    nullValue = NO_VALUE_COLOR,\n    getValue = defaultGetFieldValue\n  ) {\n    // @ts-expect-error TODO: VisualChannelField better typing\n    const {type} = field;\n    const value = getValue(field, data);\n\n    if (!notNullorUndefined(value)) {\n      return nullValue;\n    }\n\n    let attributeValue;\n    if (type === ALL_FIELD_TYPES.timestamp) {\n      // shouldn't need to convert here\n      // scale Function should take care of it\n      attributeValue = scale(new Date(value));\n    } else {\n      attributeValue = scale(value);\n    }\n\n    if (!notNullorUndefined(attributeValue)) {\n      attributeValue = nullValue;\n    }\n\n    return attributeValue;\n  }\n\n  updateMeta(meta) {\n    this.meta = {...this.meta, ...meta};\n  }\n\n  getDataUpdateTriggers({filteredIndex, id, dataContainer}: KeplerTable): any {\n    const {columns} = this.config;\n\n    return {\n      getData: {datasetId: id, dataContainer, columns, filteredIndex},\n      getMeta: {datasetId: id, dataContainer, columns},\n      ...(this.config.textLabel || []).reduce(\n        (accu, tl, i) => ({\n          ...accu,\n          [`getLabelCharacterSet-${i}`]: tl.field ? tl.field.name : null\n        }),\n        {}\n      )\n    };\n  }\n\n  updateData(datasets, oldLayerData) {\n    if (!this.config.dataId) {\n      return {};\n    }\n    const layerDataset = datasets[this.config.dataId];\n    const {dataContainer} = layerDataset;\n\n    const getPosition = this.getPositionAccessor(dataContainer);\n    const dataUpdateTriggers = this.getDataUpdateTriggers(layerDataset);\n    const triggerChanged = this.getChangedTriggers(dataUpdateTriggers);\n\n    if (triggerChanged && triggerChanged.getMeta) {\n      this.updateLayerMeta(dataContainer, getPosition);\n    }\n\n    let data = [];\n\n    if (!(triggerChanged && triggerChanged.getData) && oldLayerData && oldLayerData.data) {\n      // same data\n      data = oldLayerData.data;\n    } else {\n      data = this.calculateDataAttribute(layerDataset, getPosition);\n    }\n\n    return {data, triggerChanged};\n  }\n\n  /**\n   * helper function to update one layer domain when state.data changed\n   * if state.data change is due ot update filter, newFiler will be passed\n   * called by updateAllLayerDomainData\n   * @param datasets\n   * @param newFilter\n   * @returns layer\n   */\n  updateLayerDomain(datasets: Datasets, newFilter?: Filter): Layer {\n    const table = this.getDataset(datasets);\n    if (!table) {\n      return this;\n    }\n    Object.values(this.visualChannels).forEach(channel => {\n      const {scale} = channel;\n      const scaleType = this.config[scale];\n      // ordinal domain is based on dataContainer, if only filter changed\n      // no need to update ordinal domain\n      if (!newFilter || scaleType !== SCALE_TYPES.ordinal) {\n        const {domain} = channel;\n        const updatedDomain = this.calculateLayerDomain(table, channel);\n        this.updateLayerConfig({[domain]: updatedDomain});\n      }\n    });\n\n    return this;\n  }\n\n  getDataset(datasets) {\n    return this.config.dataId ? datasets[this.config.dataId] : null;\n  }\n\n  /**\n   * Validate visual channel field and scales based on supported field & scale type\n   * @param channel\n   */\n  validateVisualChannel(channel: string) {\n    this.validateFieldType(channel);\n    this.validateScale(channel);\n  }\n\n  /**\n   * Validate field type based on channelScaleType\n   */\n  validateFieldType(channel: string) {\n    const visualChannel = this.visualChannels[channel];\n    const {field, channelScaleType, supportedFieldTypes} = visualChannel;\n\n    if (this.config[field]) {\n      // if field is selected, check if field type is supported\n      const channelSupportedFieldTypes =\n        supportedFieldTypes || CHANNEL_SCALE_SUPPORTED_FIELDS[channelScaleType];\n\n      if (!channelSupportedFieldTypes.includes(this.config[field].type)) {\n        // field type is not supported, set it back to null\n        // set scale back to default\n        this.updateLayerConfig({[field]: null});\n      }\n    }\n  }\n\n  /**\n   * Validate scale type based on aggregation\n   */\n  validateScale(channel) {\n    const visualChannel = this.visualChannels[channel];\n    const {scale} = visualChannel;\n    if (!scale) {\n      // visualChannel doesn't have scale\n      return;\n    }\n    const scaleOptions = this.getScaleOptions(channel);\n    // check if current selected scale is\n    // supported, if not, change to default\n    if (!scaleOptions.includes(this.config[scale])) {\n      this.updateLayerConfig({[scale]: scaleOptions[0]});\n    }\n  }\n\n  /**\n   * Get scale options based on current field\n   * @param {string} channel\n   * @returns {string[]}\n   */\n  getScaleOptions(channel) {\n    const visualChannel = this.visualChannels[channel];\n    const {field, scale, channelScaleType} = visualChannel;\n\n    return this.config[field]\n      ? FIELD_OPTS[this.config[field].type].scale[channelScaleType]\n      : [this.getDefaultLayerConfig()[scale]];\n  }\n\n  updateLayerVisualChannel(dataset: KeplerTable, channel: string) {\n    const visualChannel = this.visualChannels[channel];\n    this.validateVisualChannel(channel);\n    // calculate layer channel domain\n    const updatedDomain = this.calculateLayerDomain(dataset, visualChannel);\n    this.updateLayerConfig({[visualChannel.domain]: updatedDomain});\n  }\n\n  getVisualChannelUpdateTriggers(): UpdateTriggers {\n    const updateTriggers: UpdateTriggers = {};\n    Object.values(this.visualChannels).forEach(visualChannel => {\n      // field range scale domain\n      const {accessor, field, scale, domain, range, defaultValue, fixed} = visualChannel;\n\n      if (accessor) {\n        updateTriggers[accessor] = {\n          [field]: this.config[field],\n          [scale]: this.config[scale],\n          [domain]: this.config[domain],\n          [range]: this.config.visConfig[range],\n          defaultValue:\n            typeof defaultValue === 'function' ? defaultValue(this.config) : defaultValue,\n          ...(fixed ? {[fixed]: this.config.visConfig[fixed]} : {})\n        };\n      }\n    });\n    return updateTriggers;\n  }\n\n  calculateLayerDomain(dataset, visualChannel) {\n    const {scale} = visualChannel;\n    const scaleType = this.config[scale];\n\n    const field = this.config[visualChannel.field];\n    if (!field) {\n      // if colorField or sizeField were set back to null\n      return defaultDomain;\n    }\n\n    return dataset.getColumnLayerDomain(field, scaleType) || defaultDomain;\n  }\n\n  hasHoveredObject(objectInfo) {\n    return this.isLayerHovered(objectInfo) && objectInfo.object ? objectInfo.object : null;\n  }\n\n  isLayerHovered(objectInfo): boolean {\n    return objectInfo?.picked && objectInfo?.layer?.props?.id === this.id;\n  }\n\n  getRadiusScaleByZoom(mapState: MapState, fixedRadius?: boolean) {\n    const radiusChannel = Object.values(this.visualChannels).find(vc => vc.property === 'radius');\n\n    if (!radiusChannel) {\n      return 1;\n    }\n\n    const field = radiusChannel.field;\n    const fixed = fixedRadius === undefined ? this.config.visConfig.fixedRadius : fixedRadius;\n    const {radius} = this.config.visConfig;\n\n    return fixed ? 1 : (this.config[field] ? 1 : radius) * this.getZoomFactor(mapState);\n  }\n\n  shouldCalculateLayerData(props: string[]) {\n    return props.some(p => !this.noneLayerDataAffectingProps.includes(p));\n  }\n\n  getBrushingExtensionProps(interactionConfig, brushingTarget?) {\n    const {brush} = interactionConfig;\n\n    return {\n      // brushing\n      autoHighlight: !brush.enabled,\n      brushingRadius: brush.config.size * 1000,\n      brushingTarget: brushingTarget || 'source',\n      brushingEnabled: brush.enabled\n    };\n  }\n\n  getDefaultDeckLayerProps({\n    idx,\n    gpuFilter,\n    mapState,\n    visible\n  }: {\n    idx: number;\n    gpuFilter: GpuFilter;\n    mapState: MapState;\n    visible: boolean;\n  }) {\n    return {\n      id: this.id,\n      idx,\n      coordinateSystem: COORDINATE_SYSTEM.LNGLAT,\n      pickable: true,\n      wrapLongitude: true,\n      parameters: {depthTest: Boolean(mapState.dragRotate || this.config.visConfig.enable3d)},\n      hidden: this.config.hidden,\n      // visconfig\n      opacity: this.config.visConfig.opacity,\n      highlightColor: this.config.highlightColor,\n      // data filtering\n      extensions: [dataFilterExtension],\n      filterRange: gpuFilter ? gpuFilter.filterRange : undefined,\n\n      // layer should be visible and if splitMap, shown in to one of panel\n      visible: this.config.isVisible && visible\n    };\n  }\n\n  getDefaultHoverLayerProps() {\n    return {\n      id: `${this.id}-hovered`,\n      pickable: false,\n      wrapLongitude: true,\n      coordinateSystem: COORDINATE_SYSTEM.LNGLAT\n    };\n  }\n\n  renderTextLabelLayer({getPosition, getPixelOffset, updateTriggers, sharedProps}, renderOpts) {\n    const {data, mapState} = renderOpts;\n    const {textLabel} = this.config;\n\n    return data.textLabels.reduce((accu, d, i) => {\n      if (d.getText) {\n        accu.push(\n          new TextLayer({\n            ...sharedProps,\n            id: `${this.id}-label-${textLabel[i].field?.name}`,\n            data: data.data,\n            getText: d.getText,\n            getPosition,\n            characterSet: d.characterSet,\n            getPixelOffset: getPixelOffset(textLabel[i]),\n            getSize: PROJECTED_PIXEL_SIZE_MULTIPLIER,\n            sizeScale: textLabel[i].size,\n            getTextAnchor: textLabel[i].anchor,\n            getAlignmentBaseline: textLabel[i].alignment,\n            getColor: textLabel[i].color,\n            parameters: {\n              // text will always show on top of all layers\n              depthTest: false\n            },\n\n            getFilterValue: data.getFilterValue,\n            updateTriggers: {\n              ...updateTriggers,\n              getText: textLabel[i].field?.name,\n              getPixelOffset: {\n                ...updateTriggers.getRadius,\n                mapState,\n                anchor: textLabel[i].anchor,\n                alignment: textLabel[i].alignment\n              },\n              getTextAnchor: textLabel[i].anchor,\n              getAlignmentBaseline: textLabel[i].alignment,\n              getColor: textLabel[i].color\n            }\n          })\n        );\n      }\n      return accu;\n    }, []);\n  }\n\n  calculateDataAttribute(keplerTable: KeplerTable, getPosition): any {\n    // implemented in subclasses\n    return [];\n  }\n\n  updateLayerMeta(dataContainer: DataContainerInterface, getPosition) {\n    // implemented in subclasses\n  }\n\n  getPositionAccessor(dataContainer?: DataContainerInterface): (...args: any[]) => any {\n    // implemented in subclasses\n    return () => null;\n  }\n}\n\nexport default Layer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}