{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport React from 'react';\nimport AbstractSeries from '../plot/series/abstract-series';\nimport { DISCRETE_COLOR_RANGE, DEFAULT_OPACITY } from '../theme';\n\n/**\n * Check if the component is series or not.\n * @param {React.Component} child Component.\n * @returns {boolean} True if the child is series, false otherwise.\n */\nexport function isSeriesChild(child) {\n  var prototype = child.type.prototype;\n  return prototype instanceof AbstractSeries;\n}\n\n/**\n * Get all series from the 'children' object of the component.\n * @param {Object} children Children.\n * @returns {Array} Array of children.\n */\nexport function getSeriesChildren(children) {\n  return React.Children.toArray(children).filter(function (child) {\n    return child && isSeriesChild(child);\n  });\n}\n\n/**\n * Collect the map of repetitions of the series type for all children.\n * @param {Array} children Array of children.\n * @returns {{}} Map of repetitions where sameTypeTotal is the total amount and\n * sameTypeIndex is always 0.\n */\nfunction collectSeriesTypesInfo(children) {\n  var result = {};\n  children.filter(isSeriesChild).forEach(function (child) {\n    var displayName = child.type.displayName;\n    var cluster = child.props.cluster;\n    if (!result[displayName]) {\n      result[displayName] = {\n        sameTypeTotal: 0,\n        sameTypeIndex: 0,\n        clusters: new Set()\n      };\n    }\n    result[displayName].clusters.add(cluster);\n    result[displayName].sameTypeTotal++;\n  });\n  return result;\n}\n\n/**\n * Check series to see if it has angular data that needs to be converted\n * @param {Array} data - an array of objects to check\n * @returns {Boolean} whether or not this series contains polar configuration\n */\nfunction seriesHasAngleRadius() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  if (!data) {\n    return false;\n  }\n  return data.some(function (row) {\n    return row.radius && row.angle;\n  });\n}\n\n/**\n * Possibly convert polar coordinates to x/y for computing domain\n * @param {Array} data - an array of objects to check\n * @param {String} attr - the property being checked\n * @returns {Boolean} whether or not this series contains polar configuration\n */\nfunction prepareData(data) {\n  if (!seriesHasAngleRadius(data)) {\n    return data;\n  }\n  return data.map(function (row) {\n    return _extends({}, row, {\n      x: row.radius * Math.cos(row.angle),\n      y: row.radius * Math.sin(row.angle)\n    });\n  });\n}\n\n/**\n * Collect the stacked data for all children in use. If the children don't have\n * the data (e.g. the child is invalid series or something else), then the child\n * is skipped.\n * Each next value of attr is equal to the previous value plus the difference\n * between attr0 and attr.\n * @param {Array} children Array of children.\n * @param {string} attr Attribute to stack by.\n * @returns {Array} New array of children for the series.\n */\nexport function getStackedData(children, attr) {\n  var areSomeSeriesStacked = children.some(function (series) {\n    return series && series.props.stack;\n  });\n  // It stores the last segment position added to each bar, separated by cluster.\n  var latestAttrPositions = {};\n  return children.reduce(function (accumulator, series, seriesIndex) {\n    // Skip the children that are not series (e.g. don't have any data).\n    if (!series) {\n      accumulator.push(null);\n      return accumulator;\n    }\n    var seriesType = series.type.displayName;\n    var _series$props = series.props,\n      data = _series$props.data,\n      _series$props$cluster = _series$props.cluster,\n      cluster = _series$props$cluster === undefined ? 'default' : _series$props$cluster,\n      stack = _series$props.stack;\n    var preppedData = prepareData(data, attr);\n    if (!attr || !preppedData || !preppedData.length || areSomeSeriesStacked && !stack) {\n      accumulator.push(preppedData);\n      return accumulator;\n    }\n    var attr0 = attr + '0';\n    var baseAttr = attr === 'y' ? 'x' : 'y';\n    accumulator.push(preppedData.map(function (d, dIndex) {\n      var _extends2, _latestAttrPositions$2;\n      if (!latestAttrPositions[cluster]) {\n        latestAttrPositions[cluster] = {};\n      }\n      if (!latestAttrPositions[cluster][seriesType]) {\n        latestAttrPositions[cluster][seriesType] = {};\n      }\n      var prevD = latestAttrPositions[cluster][seriesType][d[baseAttr]];\n      // It is the first segment of a bar.\n      if (!prevD) {\n        var _latestAttrPositions$;\n        latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$ = {}, _defineProperty(_latestAttrPositions$, attr0, d[attr0]), _defineProperty(_latestAttrPositions$, attr, d[attr]), _latestAttrPositions$);\n        return _extends({}, d);\n      }\n\n      // Calculate the position of the next segment in a bar.\n      var nextD = _extends({}, d, (_extends2 = {}, _defineProperty(_extends2, attr0, prevD[attr]), _defineProperty(_extends2, attr, prevD[attr] + d[attr] - (d[attr0] || 0)), _extends2));\n      latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$2 = {}, _defineProperty(_latestAttrPositions$2, attr0, nextD[attr0]), _defineProperty(_latestAttrPositions$2, attr, nextD[attr]), _latestAttrPositions$2);\n      return nextD;\n    }));\n    return accumulator;\n  }, []);\n}\n\n/**\n * Get the list of series props for a child.\n * @param {Array} children Array of all children.\n * @returns {Array} Array of series props for each child. If a child is not a\n * series, than it's undefined.\n */\nexport function getSeriesPropsFromChildren(children) {\n  var result = [];\n  var seriesTypesInfo = collectSeriesTypesInfo(children);\n  var seriesIndex = 0;\n  var _opacityValue = DEFAULT_OPACITY;\n  children.forEach(function (child) {\n    var props = void 0;\n    if (isSeriesChild(child)) {\n      var seriesTypeInfo = seriesTypesInfo[child.type.displayName];\n      var _colorValue = DISCRETE_COLOR_RANGE[seriesIndex % DISCRETE_COLOR_RANGE.length];\n      props = _extends({}, seriesTypeInfo, {\n        seriesIndex: seriesIndex,\n        _colorValue: _colorValue,\n        _opacityValue: _opacityValue\n      });\n      seriesTypeInfo.sameTypeIndex++;\n      seriesIndex++;\n      if (child.props.cluster) {\n        props.cluster = child.props.cluster;\n        // Using Array.from() so we can use .indexOf\n        props.clusters = Array.from(seriesTypeInfo.clusters);\n        props.sameTypeTotal = props.clusters.length;\n        props.sameTypeIndex = props.clusters.indexOf(child.props.cluster);\n      }\n    }\n    result.push(props);\n  });\n  return result;\n}\n\n/**\n * Find the max radius value from the nodes to be rendered after they have been\n * transformed into an array\n * @param {Array} data - the tree data after it has been broken into a iterable\n * it is an array of objects!\n * @returns {number} the maximum value in coordinates for the radial variable\n */\nexport function getRadialDomain(data) {\n  return data.reduce(function (res, row) {\n    return Math.max(row.radius, res);\n  }, 0);\n}\nexport var ANIMATED_SERIES_PROPS = ['xRange', 'xDomain', 'x', 'yRange', 'yDomain', 'y', 'colorRange', 'colorDomain', 'color', 'opacityRange', 'opacityDomain', 'opacity', 'strokeRange', 'strokeDomain', 'stroke', 'fillRange', 'fillDomain', 'fill', 'width', 'height', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'data', 'angleDomain', 'angleRange', 'angle', 'radiusDomain', 'radiusRange', 'radius', 'innerRadiusDomain', 'innerRadiusRange', 'innerRadius'];\nexport function getStackParams(props) {\n  var _stackBy = props._stackBy,\n    valuePosAttr = props.valuePosAttr,\n    cluster = props.cluster;\n  var _props$sameTypeTotal = props.sameTypeTotal,\n    sameTypeTotal = _props$sameTypeTotal === undefined ? 1 : _props$sameTypeTotal,\n    _props$sameTypeIndex = props.sameTypeIndex,\n    sameTypeIndex = _props$sameTypeIndex === undefined ? 0 : _props$sameTypeIndex;\n\n  // If bars are stacked, but not clustering, override `sameTypeTotal` and\n  // `sameTypeIndex` such that bars are stacked and not staggered.\n\n  if (_stackBy === valuePosAttr && !cluster) {\n    sameTypeTotal = 1;\n    sameTypeIndex = 0;\n  }\n  return {\n    sameTypeTotal: sameTypeTotal,\n    sameTypeIndex: sameTypeIndex\n  };\n}","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_defineProperty","obj","value","defineProperty","enumerable","configurable","writable","React","AbstractSeries","DISCRETE_COLOR_RANGE","DEFAULT_OPACITY","isSeriesChild","child","type","getSeriesChildren","children","Children","toArray","filter","collectSeriesTypesInfo","result","forEach","displayName","cluster","props","sameTypeTotal","sameTypeIndex","clusters","Set","add","seriesHasAngleRadius","data","undefined","some","row","radius","angle","prepareData","map","x","Math","cos","y","sin","getStackedData","attr","areSomeSeriesStacked","series","stack","latestAttrPositions","reduce","accumulator","seriesIndex","push","seriesType","_series$props","_series$props$cluster","preppedData","attr0","baseAttr","d","dIndex","_extends2","_latestAttrPositions$2","prevD","_latestAttrPositions$","nextD","getSeriesPropsFromChildren","seriesTypesInfo","_opacityValue","seriesTypeInfo","_colorValue","Array","from","indexOf","getRadialDomain","res","max","ANIMATED_SERIES_PROPS","getStackParams","_stackBy","valuePosAttr","_props$sameTypeTotal","_props$sameTypeIndex"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/react-vis/es/utils/series-utils.js"],"sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport React from 'react';\n\nimport AbstractSeries from '../plot/series/abstract-series';\nimport { DISCRETE_COLOR_RANGE, DEFAULT_OPACITY } from '../theme';\n\n/**\n * Check if the component is series or not.\n * @param {React.Component} child Component.\n * @returns {boolean} True if the child is series, false otherwise.\n */\nexport function isSeriesChild(child) {\n  var prototype = child.type.prototype;\n\n  return prototype instanceof AbstractSeries;\n}\n\n/**\n * Get all series from the 'children' object of the component.\n * @param {Object} children Children.\n * @returns {Array} Array of children.\n */\nexport function getSeriesChildren(children) {\n  return React.Children.toArray(children).filter(function (child) {\n    return child && isSeriesChild(child);\n  });\n}\n\n/**\n * Collect the map of repetitions of the series type for all children.\n * @param {Array} children Array of children.\n * @returns {{}} Map of repetitions where sameTypeTotal is the total amount and\n * sameTypeIndex is always 0.\n */\nfunction collectSeriesTypesInfo(children) {\n  var result = {};\n  children.filter(isSeriesChild).forEach(function (child) {\n    var displayName = child.type.displayName;\n    var cluster = child.props.cluster;\n\n    if (!result[displayName]) {\n      result[displayName] = {\n        sameTypeTotal: 0,\n        sameTypeIndex: 0,\n        clusters: new Set()\n      };\n    }\n    result[displayName].clusters.add(cluster);\n    result[displayName].sameTypeTotal++;\n  });\n  return result;\n}\n\n/**\n * Check series to see if it has angular data that needs to be converted\n * @param {Array} data - an array of objects to check\n * @returns {Boolean} whether or not this series contains polar configuration\n */\nfunction seriesHasAngleRadius() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  if (!data) {\n    return false;\n  }\n  return data.some(function (row) {\n    return row.radius && row.angle;\n  });\n}\n\n/**\n * Possibly convert polar coordinates to x/y for computing domain\n * @param {Array} data - an array of objects to check\n * @param {String} attr - the property being checked\n * @returns {Boolean} whether or not this series contains polar configuration\n */\nfunction prepareData(data) {\n  if (!seriesHasAngleRadius(data)) {\n    return data;\n  }\n\n  return data.map(function (row) {\n    return _extends({}, row, {\n      x: row.radius * Math.cos(row.angle),\n      y: row.radius * Math.sin(row.angle)\n    });\n  });\n}\n\n/**\n * Collect the stacked data for all children in use. If the children don't have\n * the data (e.g. the child is invalid series or something else), then the child\n * is skipped.\n * Each next value of attr is equal to the previous value plus the difference\n * between attr0 and attr.\n * @param {Array} children Array of children.\n * @param {string} attr Attribute to stack by.\n * @returns {Array} New array of children for the series.\n */\nexport function getStackedData(children, attr) {\n  var areSomeSeriesStacked = children.some(function (series) {\n    return series && series.props.stack;\n  });\n  // It stores the last segment position added to each bar, separated by cluster.\n  var latestAttrPositions = {};\n\n  return children.reduce(function (accumulator, series, seriesIndex) {\n    // Skip the children that are not series (e.g. don't have any data).\n    if (!series) {\n      accumulator.push(null);\n      return accumulator;\n    }\n    var seriesType = series.type.displayName;\n\n    var _series$props = series.props,\n        data = _series$props.data,\n        _series$props$cluster = _series$props.cluster,\n        cluster = _series$props$cluster === undefined ? 'default' : _series$props$cluster,\n        stack = _series$props.stack;\n\n    var preppedData = prepareData(data, attr);\n\n    if (!attr || !preppedData || !preppedData.length || areSomeSeriesStacked && !stack) {\n      accumulator.push(preppedData);\n      return accumulator;\n    }\n\n    var attr0 = attr + '0';\n    var baseAttr = attr === 'y' ? 'x' : 'y';\n\n    accumulator.push(preppedData.map(function (d, dIndex) {\n      var _extends2, _latestAttrPositions$2;\n\n      if (!latestAttrPositions[cluster]) {\n        latestAttrPositions[cluster] = {};\n      }\n      if (!latestAttrPositions[cluster][seriesType]) {\n        latestAttrPositions[cluster][seriesType] = {};\n      }\n\n      var prevD = latestAttrPositions[cluster][seriesType][d[baseAttr]];\n      // It is the first segment of a bar.\n      if (!prevD) {\n        var _latestAttrPositions$;\n\n        latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$ = {}, _defineProperty(_latestAttrPositions$, attr0, d[attr0]), _defineProperty(_latestAttrPositions$, attr, d[attr]), _latestAttrPositions$);\n\n        return _extends({}, d);\n      }\n\n      // Calculate the position of the next segment in a bar.\n      var nextD = _extends({}, d, (_extends2 = {}, _defineProperty(_extends2, attr0, prevD[attr]), _defineProperty(_extends2, attr, prevD[attr] + d[attr] - (d[attr0] || 0)), _extends2));\n\n      latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$2 = {}, _defineProperty(_latestAttrPositions$2, attr0, nextD[attr0]), _defineProperty(_latestAttrPositions$2, attr, nextD[attr]), _latestAttrPositions$2);\n\n      return nextD;\n    }));\n\n    return accumulator;\n  }, []);\n}\n\n/**\n * Get the list of series props for a child.\n * @param {Array} children Array of all children.\n * @returns {Array} Array of series props for each child. If a child is not a\n * series, than it's undefined.\n */\nexport function getSeriesPropsFromChildren(children) {\n  var result = [];\n  var seriesTypesInfo = collectSeriesTypesInfo(children);\n  var seriesIndex = 0;\n  var _opacityValue = DEFAULT_OPACITY;\n  children.forEach(function (child) {\n    var props = void 0;\n    if (isSeriesChild(child)) {\n      var seriesTypeInfo = seriesTypesInfo[child.type.displayName];\n      var _colorValue = DISCRETE_COLOR_RANGE[seriesIndex % DISCRETE_COLOR_RANGE.length];\n      props = _extends({}, seriesTypeInfo, {\n        seriesIndex: seriesIndex,\n        _colorValue: _colorValue,\n        _opacityValue: _opacityValue\n      });\n      seriesTypeInfo.sameTypeIndex++;\n      seriesIndex++;\n      if (child.props.cluster) {\n        props.cluster = child.props.cluster;\n        // Using Array.from() so we can use .indexOf\n        props.clusters = Array.from(seriesTypeInfo.clusters);\n        props.sameTypeTotal = props.clusters.length;\n        props.sameTypeIndex = props.clusters.indexOf(child.props.cluster);\n      }\n    }\n    result.push(props);\n  });\n  return result;\n}\n\n/**\n * Find the max radius value from the nodes to be rendered after they have been\n * transformed into an array\n * @param {Array} data - the tree data after it has been broken into a iterable\n * it is an array of objects!\n * @returns {number} the maximum value in coordinates for the radial variable\n */\nexport function getRadialDomain(data) {\n  return data.reduce(function (res, row) {\n    return Math.max(row.radius, res);\n  }, 0);\n}\n\nexport var ANIMATED_SERIES_PROPS = ['xRange', 'xDomain', 'x', 'yRange', 'yDomain', 'y', 'colorRange', 'colorDomain', 'color', 'opacityRange', 'opacityDomain', 'opacity', 'strokeRange', 'strokeDomain', 'stroke', 'fillRange', 'fillDomain', 'fill', 'width', 'height', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'data', 'angleDomain', 'angleRange', 'angle', 'radiusDomain', 'radiusRange', 'radius', 'innerRadiusDomain', 'innerRadiusRange', 'innerRadius'];\n\nexport function getStackParams(props) {\n  var _stackBy = props._stackBy,\n      valuePosAttr = props.valuePosAttr,\n      cluster = props.cluster;\n  var _props$sameTypeTotal = props.sameTypeTotal,\n      sameTypeTotal = _props$sameTypeTotal === undefined ? 1 : _props$sameTypeTotal,\n      _props$sameTypeIndex = props.sameTypeIndex,\n      sameTypeIndex = _props$sameTypeIndex === undefined ? 0 : _props$sameTypeIndex;\n\n  // If bars are stacked, but not clustering, override `sameTypeTotal` and\n  // `sameTypeIndex` such that bars are stacked and not staggered.\n\n  if (_stackBy === valuePosAttr && !cluster) {\n    sameTypeTotal = 1;\n    sameTypeIndex = 0;\n  }\n  return { sameTypeTotal: sameTypeTotal, sameTypeIndex: sameTypeIndex };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}