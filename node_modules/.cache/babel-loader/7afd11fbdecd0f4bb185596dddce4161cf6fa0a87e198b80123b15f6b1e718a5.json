{"ast":null,"code":"/* eslint-disable */\n// @ts-nocheck\n\n// Copied from https://github.com/inexorabletash/text-encoding/blob/b4e5bc26e26e51f56e3daa9f13138c79f49d3c34/lib/encoding.js\n//\n// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n// FORK: indices add half a megabyte to bundle. Ignore, since we only want the built-in UTF8...\nvar indexes = require('./encoding-indexes.js');\nglobal['encoding-indexes'] = indexes && indexes['encoding-indexes'] || {};\n\n//\n// Utilities\n//\n\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n/**\n * @param {!Array.<*>} array The array to check.\n * @param {*} item The item to look for in the array.\n * @return {boolean} True if the item appears in the array.\n */\nfunction includes(array, item) {\n  return array.indexOf(item) !== -1;\n}\nvar floor = Math.floor;\n\n/**\n * @param {*} o\n * @return {Object}\n */\nfunction ToDictionary(o) {\n  if (o === undefined) return {};\n  if (o === Object(o)) return o;\n  throw TypeError('Could not convert argument to dictionary');\n}\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nfunction stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string);\n\n  // 2. Let n be the length of S.\n  var n = s.length;\n\n  // 3. Initialize i to 0.\n  var i = 0;\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = [];\n\n  // 5. While i < n:\n  while (i < n) {\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i);\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xd800 || c > 0xdfff) {\n      // Append to U the Unicode character with code point c.\n      u.push(c);\n    }\n\n    // 0xDC00 ≤ c ≤ 0xDFFF\n    else if (0xdc00 <= c && c <= 0xdfff) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xfffd);\n    }\n\n    // 0xD800 ≤ c ≤ 0xDBFF\n    else if (0xd800 <= c && c <= 0xdbff) {\n      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xfffd);\n      }\n      // 2. Otherwise, i < n−1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = s.charCodeAt(i + 1);\n\n        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n        if (0xdc00 <= d && d <= 0xdfff) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3ff;\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3ff;\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b);\n\n          // 4. Set i to i+1.\n          i += 1;\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else {\n          u.push(0xfffd);\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1;\n  }\n\n  // 6. Return U.\n  return u;\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nfunction codePointsToString(code_points) {\n  var s = '';\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i];\n    if (cp <= 0xffff) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xd800, (cp & 0x3ff) + 0xdc00);\n    }\n  }\n  return s;\n}\n\n//\n// Implementation of Encoding specification\n// https://encoding.spec.whatwg.org/\n//\n\n//\n// 4. Terminology\n//\n\n/**\n * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n * @param {number} a The number to test.\n * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n */\nfunction isASCIIByte(a) {\n  return 0x00 <= a && a <= 0x7f;\n}\n\n/**\n * An ASCII code point is a code point in the range U+0000 to\n * U+007F, inclusive.\n */\nvar isASCIICodePoint = isASCIIByte;\n\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n * @const\n */\nvar end_of_stream = -1;\n\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n * the stream.\n */\nfunction Stream(tokens) {\n  /** @type {!Array.<number>} */\n  this.tokens = [].slice.call(tokens);\n  // Reversed as push/pop is more efficient than shift/unshift.\n  this.tokens.reverse();\n}\nStream.prototype = {\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream: function endOfStream() {\n    return !this.tokens.length;\n  },\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n  read: function read() {\n    if (!this.tokens.length) return end_of_stream;\n    return this.tokens.pop();\n  },\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n   * stream.\n   */\n  prepend: function prepend(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/token;\n      while (tokens.length) this.tokens.push(tokens.pop());\n    } else {\n      this.tokens.push(token);\n    }\n  },\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n   * stream.\n   */\n  push: function push(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/token;\n      while (tokens.length) this.tokens.unshift(tokens.shift());\n    } else {\n      this.tokens.unshift(token);\n    }\n  }\n};\n\n//\n// 5. Encodings\n//\n\n// 5.1 Encoders and decoders\n\n/** @const */\nvar finished = -1;\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return {number} The code point to insert on a decoding error.\n */\nfunction decoderError(fatal, opt_code_point) {\n  if (fatal) throw TypeError('Decoder error');\n  return opt_code_point || 0xfffd;\n}\n\n/**\n * @param {number} code_point The code point that could not be encoded.\n * @return {number} Always throws, no value is actually returned.\n */\nfunction encoderError(code_point) {\n  throw TypeError('The code point ' + code_point + ' could not be encoded.');\n}\n\n/** @interface */\nfunction Decoder() {}\nDecoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point, or |finished|.\n   */\n  handler: function handler(stream, bite) {}\n};\n\n/** @interface */\nfunction Encoder() {}\nEncoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of code points being encoded.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n   */\n  handler: function handler(stream, code_point) {}\n};\n\n// 5.2 Names and labels\n\n// TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}\n// https://github.com/google/closure-compiler/issues/247\n\n/**\n * @param {string} label The encoding label.\n * @return {?{name:string,labels:Array.<string>}}\n */\nfunction getEncoding(label) {\n  // 1. Remove any leading and trailing ASCII whitespace from label.\n  label = String(label).trim().toLowerCase();\n\n  // 2. If label is an ASCII case-insensitive match for any of the\n  // labels listed in the table below, return the corresponding\n  // encoding, and failure otherwise.\n  if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n    return label_to_encoding[label];\n  }\n  return null;\n}\n\n/**\n * Encodings table: https://encoding.spec.whatwg.org/encodings.json\n * @const\n * @type {!Array.<{\n *          heading: string,\n *          encodings: Array.<{name:string,labels:Array.<string>}>\n *        }>}\n */\nvar encodings = [{\n  encodings: [{\n    labels: ['unicode-1-1-utf-8', 'utf-8', 'utf8'],\n    name: 'UTF-8'\n  }],\n  heading: 'The Encoding'\n}, {\n  encodings: [{\n    labels: ['866', 'cp866', 'csibm866', 'ibm866'],\n    name: 'IBM866'\n  }, {\n    labels: ['csisolatin2', 'iso-8859-2', 'iso-ir-101', 'iso8859-2', 'iso88592', 'iso_8859-2', 'iso_8859-2:1987', 'l2', 'latin2'],\n    name: 'ISO-8859-2'\n  }, {\n    labels: ['csisolatin3', 'iso-8859-3', 'iso-ir-109', 'iso8859-3', 'iso88593', 'iso_8859-3', 'iso_8859-3:1988', 'l3', 'latin3'],\n    name: 'ISO-8859-3'\n  }, {\n    labels: ['csisolatin4', 'iso-8859-4', 'iso-ir-110', 'iso8859-4', 'iso88594', 'iso_8859-4', 'iso_8859-4:1988', 'l4', 'latin4'],\n    name: 'ISO-8859-4'\n  }, {\n    labels: ['csisolatincyrillic', 'cyrillic', 'iso-8859-5', 'iso-ir-144', 'iso8859-5', 'iso88595', 'iso_8859-5', 'iso_8859-5:1988'],\n    name: 'ISO-8859-5'\n  }, {\n    labels: ['arabic', 'asmo-708', 'csiso88596e', 'csiso88596i', 'csisolatinarabic', 'ecma-114', 'iso-8859-6', 'iso-8859-6-e', 'iso-8859-6-i', 'iso-ir-127', 'iso8859-6', 'iso88596', 'iso_8859-6', 'iso_8859-6:1987'],\n    name: 'ISO-8859-6'\n  }, {\n    labels: ['csisolatingreek', 'ecma-118', 'elot_928', 'greek', 'greek8', 'iso-8859-7', 'iso-ir-126', 'iso8859-7', 'iso88597', 'iso_8859-7', 'iso_8859-7:1987', 'sun_eu_greek'],\n    name: 'ISO-8859-7'\n  }, {\n    labels: ['csiso88598e', 'csisolatinhebrew', 'hebrew', 'iso-8859-8', 'iso-8859-8-e', 'iso-ir-138', 'iso8859-8', 'iso88598', 'iso_8859-8', 'iso_8859-8:1988', 'visual'],\n    name: 'ISO-8859-8'\n  }, {\n    labels: ['csiso88598i', 'iso-8859-8-i', 'logical'],\n    name: 'ISO-8859-8-I'\n  }, {\n    labels: ['csisolatin6', 'iso-8859-10', 'iso-ir-157', 'iso8859-10', 'iso885910', 'l6', 'latin6'],\n    name: 'ISO-8859-10'\n  }, {\n    labels: ['iso-8859-13', 'iso8859-13', 'iso885913'],\n    name: 'ISO-8859-13'\n  }, {\n    labels: ['iso-8859-14', 'iso8859-14', 'iso885914'],\n    name: 'ISO-8859-14'\n  }, {\n    labels: ['csisolatin9', 'iso-8859-15', 'iso8859-15', 'iso885915', 'iso_8859-15', 'l9'],\n    name: 'ISO-8859-15'\n  }, {\n    labels: ['iso-8859-16'],\n    name: 'ISO-8859-16'\n  }, {\n    labels: ['cskoi8r', 'koi', 'koi8', 'koi8-r', 'koi8_r'],\n    name: 'KOI8-R'\n  }, {\n    labels: ['koi8-ru', 'koi8-u'],\n    name: 'KOI8-U'\n  }, {\n    labels: ['csmacintosh', 'mac', 'macintosh', 'x-mac-roman'],\n    name: 'macintosh'\n  }, {\n    labels: ['dos-874', 'iso-8859-11', 'iso8859-11', 'iso885911', 'tis-620', 'windows-874'],\n    name: 'windows-874'\n  }, {\n    labels: ['cp1250', 'windows-1250', 'x-cp1250'],\n    name: 'windows-1250'\n  }, {\n    labels: ['cp1251', 'windows-1251', 'x-cp1251'],\n    name: 'windows-1251'\n  }, {\n    labels: ['ansi_x3.4-1968', 'ascii', 'cp1252', 'cp819', 'csisolatin1', 'ibm819', 'iso-8859-1', 'iso-ir-100', 'iso8859-1', 'iso88591', 'iso_8859-1', 'iso_8859-1:1987', 'l1', 'latin1', 'us-ascii', 'windows-1252', 'x-cp1252'],\n    name: 'windows-1252'\n  }, {\n    labels: ['cp1253', 'windows-1253', 'x-cp1253'],\n    name: 'windows-1253'\n  }, {\n    labels: ['cp1254', 'csisolatin5', 'iso-8859-9', 'iso-ir-148', 'iso8859-9', 'iso88599', 'iso_8859-9', 'iso_8859-9:1989', 'l5', 'latin5', 'windows-1254', 'x-cp1254'],\n    name: 'windows-1254'\n  }, {\n    labels: ['cp1255', 'windows-1255', 'x-cp1255'],\n    name: 'windows-1255'\n  }, {\n    labels: ['cp1256', 'windows-1256', 'x-cp1256'],\n    name: 'windows-1256'\n  }, {\n    labels: ['cp1257', 'windows-1257', 'x-cp1257'],\n    name: 'windows-1257'\n  }, {\n    labels: ['cp1258', 'windows-1258', 'x-cp1258'],\n    name: 'windows-1258'\n  }, {\n    labels: ['x-mac-cyrillic', 'x-mac-ukrainian'],\n    name: 'x-mac-cyrillic'\n  }],\n  heading: 'Legacy single-byte encodings'\n}, {\n  encodings: [{\n    labels: ['chinese', 'csgb2312', 'csiso58gb231280', 'gb2312', 'gb_2312', 'gb_2312-80', 'gbk', 'iso-ir-58', 'x-gbk'],\n    name: 'GBK'\n  }, {\n    labels: ['gb18030'],\n    name: 'gb18030'\n  }],\n  heading: 'Legacy multi-byte Chinese (simplified) encodings'\n}, {\n  encodings: [{\n    labels: ['big5', 'big5-hkscs', 'cn-big5', 'csbig5', 'x-x-big5'],\n    name: 'Big5'\n  }],\n  heading: 'Legacy multi-byte Chinese (traditional) encodings'\n}, {\n  encodings: [{\n    labels: ['cseucpkdfmtjapanese', 'euc-jp', 'x-euc-jp'],\n    name: 'EUC-JP'\n  }, {\n    labels: ['csiso2022jp', 'iso-2022-jp'],\n    name: 'ISO-2022-JP'\n  }, {\n    labels: ['csshiftjis', 'ms932', 'ms_kanji', 'shift-jis', 'shift_jis', 'sjis', 'windows-31j', 'x-sjis'],\n    name: 'Shift_JIS'\n  }],\n  heading: 'Legacy multi-byte Japanese encodings'\n}, {\n  encodings: [{\n    labels: ['cseuckr', 'csksc56011987', 'euc-kr', 'iso-ir-149', 'korean', 'ks_c_5601-1987', 'ks_c_5601-1989', 'ksc5601', 'ksc_5601', 'windows-949'],\n    name: 'EUC-KR'\n  }],\n  heading: 'Legacy multi-byte Korean encodings'\n}, {\n  encodings: [{\n    labels: ['csiso2022kr', 'hz-gb-2312', 'iso-2022-cn', 'iso-2022-cn-ext', 'iso-2022-kr'],\n    name: 'replacement'\n  }, {\n    labels: ['utf-16be'],\n    name: 'UTF-16BE'\n  }, {\n    labels: ['utf-16', 'utf-16le'],\n    name: 'UTF-16LE'\n  }, {\n    labels: ['x-user-defined'],\n    name: 'x-user-defined'\n  }],\n  heading: 'Legacy miscellaneous encodings'\n}];\n\n// Label to encoding registry.\n/** @type {Object.<string,{name:string,labels:Array.<string>}>} */\nvar label_to_encoding = {};\nencodings.forEach(function (category) {\n  category.encodings.forEach(function (encoding) {\n    encoding.labels.forEach(function (label) {\n      label_to_encoding[label] = encoding;\n    });\n  });\n});\n\n// Registry of of encoder/decoder factories, by encoding name.\n/** @type {Object.<string, function({fatal:boolean}): Encoder>} */\nvar encoders = {};\n/** @type {Object.<string, function({fatal:boolean}): Decoder>} */\nvar decoders = {};\n\n//\n// 6. Indexes\n//\n\n/**\n * @param {number} pointer The |pointer| to search for.\n * @param {(!Array.<?number>|undefined)} index The |index| to search within.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in |index|.\n */\nfunction indexCodePointFor(pointer, index) {\n  if (!index) return null;\n  return index[pointer] || null;\n}\n\n/**\n * @param {number} code_point The |code point| to search for.\n * @param {!Array.<?number>} index The |index| to search within.\n * @return {?number} The first pointer corresponding to |code point| in\n *     |index|, or null if |code point| is not in |index|.\n */\nfunction indexPointerFor(code_point, index) {\n  var pointer = index.indexOf(code_point);\n  return pointer === -1 ? null : pointer;\n}\n\n/**\n * @param {string} name Name of the index.\n * @return {(!Array.<number>|!Array.<Array.<number>>)}\n *  */\nfunction index(name) {\n  if (!('encoding-indexes' in global)) {\n    throw Error('Indexes missing.' + ' Did you forget to include encoding-indexes.js first?');\n  }\n  return global['encoding-indexes'][name];\n}\n\n/**\n * @param {number} pointer The |pointer| to search for in the gb18030 index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the gb18030 index.\n */\nfunction indexGB18030RangesCodePointFor(pointer) {\n  // 1. If pointer is greater than 39419 and less than 189000, or\n  // pointer is greater than 1237575, return null.\n  if (pointer > 39419 && pointer < 189000 || pointer > 1237575) return null;\n\n  // 2. If pointer is 7457, return code point U+E7C7.\n  if (pointer === 7457) return 0xe7c7;\n\n  // 3. Let offset be the last pointer in index gb18030 ranges that\n  // is equal to or less than pointer and let code point offset be\n  // its corresponding code point.\n  var offset = 0;\n  var code_point_offset = 0;\n  var idx = index('gb18030-ranges');\n  var i;\n  for (i = 0; i < idx.length; ++i) {\n    /** @type {!Array.<number>} */\n    var entry = idx[i];\n    if (entry[0] <= pointer) {\n      offset = entry[0];\n      code_point_offset = entry[1];\n    } else {\n      break;\n    }\n  }\n\n  // 4. Return a code point whose value is code point offset +\n  // pointer − offset.\n  return code_point_offset + pointer - offset;\n}\n\n/**\n * @param {number} code_point The |code point| to locate in the gb18030 index.\n * @return {number} The first pointer corresponding to |code point| in the\n *     gb18030 index.\n */\nfunction indexGB18030RangesPointerFor(code_point) {\n  // 1. If code point is U+E7C7, return pointer 7457.\n  if (code_point === 0xe7c7) return 7457;\n\n  // 2. Let offset be the last code point in index gb18030 ranges\n  // that is equal to or less than code point and let pointer offset\n  // be its corresponding pointer.\n  var offset = 0;\n  var pointer_offset = 0;\n  var idx = index('gb18030-ranges');\n  var i;\n  for (i = 0; i < idx.length; ++i) {\n    /** @type {!Array.<number>} */\n    var entry = idx[i];\n    if (entry[1] <= code_point) {\n      offset = entry[1];\n      pointer_offset = entry[0];\n    } else {\n      break;\n    }\n  }\n\n  // 3. Return a pointer whose value is pointer offset + code point\n  // − offset.\n  return pointer_offset + code_point - offset;\n}\n\n/**\n * @param {number} code_point The |code_point| to search for in the Shift_JIS\n *     index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the Shift_JIS index.\n */\nfunction indexShiftJISPointerFor(code_point) {\n  // 1. Let index be index jis0208 excluding all entries whose\n  // pointer is in the range 8272 to 8835, inclusive.\n  shift_jis_index = shift_jis_index || index('jis0208').map(function (code_point, pointer) {\n    return inRange(pointer, 8272, 8835) ? null : code_point;\n  });\n  var index_ = shift_jis_index;\n\n  // 2. Return the index pointer for code point in index.\n  return index_.indexOf(code_point);\n}\nvar shift_jis_index;\n\n/**\n * @param {number} code_point The |code_point| to search for in the big5\n *     index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the big5 index.\n */\nfunction indexBig5PointerFor(code_point) {\n  // 1. Let index be index Big5 excluding all entries whose pointer\n  big5_index_no_hkscs = big5_index_no_hkscs || index('big5').map(function (code_point, pointer) {\n    return pointer < (0xa1 - 0x81) * 157 ? null : code_point;\n  });\n  var index_ = big5_index_no_hkscs;\n\n  // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or\n  // U+5345, return the last pointer corresponding to code point in\n  // index.\n  if (code_point === 0x2550 || code_point === 0x255e || code_point === 0x2561 || code_point === 0x256a || code_point === 0x5341 || code_point === 0x5345) {\n    return index_.lastIndexOf(code_point);\n  }\n\n  // 3. Return the index pointer for code point in index.\n  return indexPointerFor(code_point, index_);\n}\nvar big5_index_no_hkscs;\n\n//\n// 8. API\n//\n\n/** @const */\nvar DEFAULT_ENCODING = 'utf-8';\n\n// 8.1 Interface TextDecoder\n\n/**\n * @constructor\n * @param {string=} label The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextDecoder(label, options) {\n  // Web IDL conventions\n  if (!(this instanceof TextDecoder)) throw TypeError(\"Called as a function. Did you forget 'new'?\");\n  label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n  options = ToDictionary(options);\n\n  // A TextDecoder object has an associated encoding, decoder,\n  // stream, ignore BOM flag (initially unset), BOM seen flag\n  // (initially unset), error mode (initially replacement), and do\n  // not flush flag (initially unset).\n\n  /** @private */\n  this._encoding = null;\n  /** @private @type {?Decoder} */\n  this._decoder = null;\n  /** @private @type {boolean} */\n  this._ignoreBOM = false;\n  /** @private @type {boolean} */\n  this._BOMseen = false;\n  /** @private @type {string} */\n  this._error_mode = 'replacement';\n  /** @private @type {boolean} */\n  this._do_not_flush = false;\n\n  // 1. Let encoding be the result of getting an encoding from\n  // label.\n  var encoding = getEncoding(label);\n\n  // 2. If encoding is failure or replacement, throw a RangeError.\n  if (encoding === null || encoding.name === 'replacement') throw RangeError('Unknown encoding: ' + label);\n  if (!decoders[encoding.name]) {\n    throw Error('Decoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n  }\n\n  // 3. Let dec be a new TextDecoder object.\n  var dec = this;\n\n  // 4. Set dec's encoding to encoding.\n  dec._encoding = encoding;\n\n  // 5. If options's fatal member is true, set dec's error mode to\n  // fatal.\n  if (Boolean(options['fatal'])) dec._error_mode = 'fatal';\n\n  // 6. If options's ignoreBOM member is true, set dec's ignore BOM\n  // flag.\n  if (Boolean(options['ignoreBOM'])) dec._ignoreBOM = true;\n\n  // For pre-ES5 runtimes:\n  if (!Object.defineProperty) {\n    this.encoding = dec._encoding.name.toLowerCase();\n    this.fatal = dec._error_mode === 'fatal';\n    this.ignoreBOM = dec._ignoreBOM;\n  }\n\n  // 7. Return dec.\n  return dec;\n}\nif (Object.defineProperty) {\n  // The encoding attribute's getter must return encoding's name.\n  Object.defineProperty(TextDecoder.prototype, 'encoding', {\n    /** @this {TextDecoder} */\n    get: function get() {\n      return this._encoding.name.toLowerCase();\n    }\n  });\n\n  // The fatal attribute's getter must return true if error mode\n  // is fatal, and false otherwise.\n  Object.defineProperty(TextDecoder.prototype, 'fatal', {\n    /** @this {TextDecoder} */\n    get: function get() {\n      return this._error_mode === 'fatal';\n    }\n  });\n\n  // The ignoreBOM attribute's getter must return true if ignore\n  // BOM flag is set, and false otherwise.\n  Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {\n    /** @this {TextDecoder} */\n    get: function get() {\n      return this._ignoreBOM;\n    }\n  });\n}\n\n/**\n * @param {BufferSource=} input The buffer of bytes to decode.\n * @param {Object=} options\n * @return {string} The decoded string.\n */\nTextDecoder.prototype.decode = function decode(input, options) {\n  var bytes;\n  if (typeof input === 'object' && input instanceof ArrayBuffer) {\n    bytes = new Uint8Array(input);\n  } else if (typeof input === 'object' && 'buffer' in input && input.buffer instanceof ArrayBuffer) {\n    bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);\n  } else {\n    bytes = new Uint8Array(0);\n  }\n  options = ToDictionary(options);\n\n  // 1. If the do not flush flag is unset, set decoder to a new\n  // encoding's decoder, set stream to a new stream, and unset the\n  // BOM seen flag.\n  if (!this._do_not_flush) {\n    this._decoder = decoders[this._encoding.name]({\n      fatal: this._error_mode === 'fatal'\n    });\n    this._BOMseen = false;\n  }\n\n  // 2. If options's stream is true, set the do not flush flag, and\n  // unset the do not flush flag otherwise.\n  this._do_not_flush = Boolean(options['stream']);\n\n  // 3. If input is given, push a copy of input to stream.\n  // TODO: Align with spec algorithm - maintain stream on instance.\n  var input_stream = new Stream(bytes);\n\n  // 4. Let output be a new stream.\n  var output = [];\n\n  /** @type {?(number|!Array.<number>)} */\n  var result;\n\n  // 5. While true:\n  while (true) {\n    // 1. Let token be the result of reading from stream.\n    var token = input_stream.read();\n\n    // 2. If token is end-of-stream and the do not flush flag is\n    // set, return output, serialized.\n    // TODO: Align with spec algorithm.\n    if (token === end_of_stream) break;\n\n    // 3. Otherwise, run these subsubsteps:\n\n    // 1. Let result be the result of processing token for decoder,\n    // stream, output, and error mode.\n    result = this._decoder.handler(input_stream, token);\n\n    // 2. If result is finished, return output, serialized.\n    if (result === finished) break;\n    if (result !== null) {\n      if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/result);else output.push(result);\n    }\n\n    // 3. Otherwise, if result is error, throw a TypeError.\n    // (Thrown in handler)\n\n    // 4. Otherwise, do nothing.\n  }\n  // TODO: Align with spec algorithm.\n  if (!this._do_not_flush) {\n    do {\n      result = this._decoder.handler(input_stream, input_stream.read());\n      if (result === finished) break;\n      if (result === null) continue;\n      if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/result);else output.push(result);\n    } while (!input_stream.endOfStream());\n    this._decoder = null;\n  }\n\n  // A TextDecoder object also has an associated serialize stream\n  // algorithm...\n  /**\n   * @param {!Array.<number>} stream\n   * @return {string}\n   * @this {TextDecoder}\n   */\n  function serializeStream(stream) {\n    // 1. Let token be the result of reading from stream.\n    // (Done in-place on array, rather than as a stream)\n\n    // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n    // BOM flag and BOM seen flag are unset, run these subsubsteps:\n    if (includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) && !this._ignoreBOM && !this._BOMseen) {\n      if (stream.length > 0 && stream[0] === 0xfeff) {\n        // 1. If token is U+FEFF, set BOM seen flag.\n        this._BOMseen = true;\n        stream.shift();\n      } else if (stream.length > 0) {\n        // 2. Otherwise, if token is not end-of-stream, set BOM seen\n        // flag and append token to stream.\n        this._BOMseen = true;\n      } else {\n        // 3. Otherwise, if token is not end-of-stream, append token\n        // to output.\n        // (no-op)\n      }\n    }\n    // 4. Otherwise, return output.\n    return codePointsToString(stream);\n  }\n  return serializeStream.call(this, output);\n};\n\n// 8.2 Interface TextEncoder\n\n/**\n * @constructor\n * @param {string=} label The label of the encoding. NONSTANDARD.\n * @param {Object=} options NONSTANDARD.\n */\nfunction TextEncoder(label, options) {\n  // Web IDL conventions\n  if (!(this instanceof TextEncoder)) throw TypeError(\"Called as a function. Did you forget 'new'?\");\n  options = ToDictionary(options);\n\n  // A TextEncoder object has an associated encoding and encoder.\n\n  /** @private */\n  this._encoding = null;\n  /** @private @type {?Encoder} */\n  this._encoder = null;\n\n  // Non-standard\n  /** @private @type {boolean} */\n  this._do_not_flush = false;\n  /** @private @type {string} */\n  this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';\n\n  // 1. Let enc be a new TextEncoder object.\n  var enc = this;\n\n  // 2. Set enc's encoding to UTF-8's encoder.\n  if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {\n    // NONSTANDARD behavior.\n    label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n    var encoding = getEncoding(label);\n    if (encoding === null || encoding.name === 'replacement') throw RangeError('Unknown encoding: ' + label);\n    if (!encoders[encoding.name]) {\n      throw Error('Encoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n    }\n    enc._encoding = encoding;\n  } else {\n    // Standard behavior.\n    enc._encoding = getEncoding('utf-8');\n    if (label !== undefined && 'console' in global) {\n      console.warn('TextEncoder constructor called with encoding label, ' + 'which is ignored.');\n    }\n  }\n\n  // For pre-ES5 runtimes:\n  if (!Object.defineProperty) this.encoding = enc._encoding.name.toLowerCase();\n\n  // 3. Return enc.\n  return enc;\n}\nif (Object.defineProperty) {\n  // The encoding attribute's getter must return encoding's name.\n  Object.defineProperty(TextEncoder.prototype, 'encoding', {\n    /** @this {TextEncoder} */\n    get: function get() {\n      return this._encoding.name.toLowerCase();\n    }\n  });\n}\n\n/**\n * @param {string=} opt_string The string to encode.\n * @param {Object=} options\n * @return {!Uint8Array} Encoded bytes, as a Uint8Array.\n */\nTextEncoder.prototype.encode = function encode(opt_string, options) {\n  opt_string = opt_string === undefined ? '' : String(opt_string);\n  options = ToDictionary(options);\n\n  // NOTE: This option is nonstandard. None of the encodings\n  // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when\n  // the input is a USVString so streaming is not necessary.\n  if (!this._do_not_flush) this._encoder = encoders[this._encoding.name]({\n    fatal: this._fatal === 'fatal'\n  });\n  this._do_not_flush = Boolean(options['stream']);\n\n  // 1. Convert input to a stream.\n  var input = new Stream(stringToCodePoints(opt_string));\n\n  // 2. Let output be a new stream\n  var output = [];\n\n  /** @type {?(number|!Array.<number>)} */\n  var result;\n  // 3. While true, run these substeps:\n  while (true) {\n    // 1. Let token be the result of reading from input.\n    var token = input.read();\n    if (token === end_of_stream) break;\n    // 2. Let result be the result of processing token for encoder,\n    // input, output.\n    result = this._encoder.handler(input, token);\n    if (result === finished) break;\n    if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/result);else output.push(result);\n  }\n  // TODO: Align with spec algorithm.\n  if (!this._do_not_flush) {\n    while (true) {\n      result = this._encoder.handler(input, input.read());\n      if (result === finished) break;\n      if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/result);else output.push(result);\n    }\n    this._encoder = null;\n  }\n  // 3. If result is finished, convert output into a byte sequence,\n  // and then return a Uint8Array object wrapping an ArrayBuffer\n  // containing output.\n  return new Uint8Array(output);\n};\n\n//\n// 9. The encoding\n//\n\n// 9.1 utf-8\n\n// 9.1.1 utf-8 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Decoder(options) {\n  var fatal = options.fatal;\n\n  // utf-8's decoder's has an associated utf-8 code point, utf-8\n  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n  // lower boundary (initially 0x80), and a utf-8 upper boundary\n  // (initially 0xBF).\n  var /** @type {number} */utf8_code_point = 0,\n    /** @type {number} */utf8_bytes_seen = 0,\n    /** @type {number} */utf8_bytes_needed = 0,\n    /** @type {number} */utf8_lower_boundary = 0x80,\n    /** @type {number} */utf8_upper_boundary = 0xbf;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n    // set utf-8 bytes needed to 0 and return error.\n    if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n      utf8_bytes_needed = 0;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream) return finished;\n\n    // 3. If utf-8 bytes needed is 0, based on byte:\n    if (utf8_bytes_needed === 0) {\n      // 0x00 to 0x7F\n      if (inRange(bite, 0x00, 0x7f)) {\n        // Return a code point whose value is byte.\n        return bite;\n      }\n\n      // 0xC2 to 0xDF\n      else if (inRange(bite, 0xc2, 0xdf)) {\n        // 1. Set utf-8 bytes needed to 1.\n        utf8_bytes_needed = 1;\n\n        // 2. Set UTF-8 code point to byte & 0x1F.\n        utf8_code_point = bite & 0x1f;\n      }\n\n      // 0xE0 to 0xEF\n      else if (inRange(bite, 0xe0, 0xef)) {\n        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (bite === 0xe0) utf8_lower_boundary = 0xa0;\n        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (bite === 0xed) utf8_upper_boundary = 0x9f;\n        // 3. Set utf-8 bytes needed to 2.\n        utf8_bytes_needed = 2;\n        // 4. Set UTF-8 code point to byte & 0xF.\n        utf8_code_point = bite & 0xf;\n      }\n\n      // 0xF0 to 0xF4\n      else if (inRange(bite, 0xf0, 0xf4)) {\n        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (bite === 0xf0) utf8_lower_boundary = 0x90;\n        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (bite === 0xf4) utf8_upper_boundary = 0x8f;\n        // 3. Set utf-8 bytes needed to 3.\n        utf8_bytes_needed = 3;\n        // 4. Set UTF-8 code point to byte & 0x7.\n        utf8_code_point = bite & 0x7;\n      }\n\n      // Otherwise\n      else {\n        // Return error.\n        return decoderError(fatal);\n      }\n\n      // Return continue.\n      return null;\n    }\n\n    // 4. If byte is not in the range utf-8 lower boundary to utf-8\n    // upper boundary, inclusive, run these substeps:\n    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n      // utf-8 upper boundary to 0xBF.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xbf;\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite);\n\n      // 3. Return error.\n      return decoderError(fatal);\n    }\n\n    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n    // to 0xBF.\n    utf8_lower_boundary = 0x80;\n    utf8_upper_boundary = 0xbf;\n\n    // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n    // 0x3F)\n    utf8_code_point = utf8_code_point << 6 | bite & 0x3f;\n\n    // 7. Increase utf-8 bytes seen by one.\n    utf8_bytes_seen += 1;\n\n    // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n    // continue.\n    if (utf8_bytes_seen !== utf8_bytes_needed) return null;\n\n    // 9. Let code point be utf-8 code point.\n    var code_point = utf8_code_point;\n\n    // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n    // seen to 0.\n    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n    // 11. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n// 9.1.2 utf-8 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Set count and offset based on the range code point is in:\n    var count, offset;\n    // U+0080 to U+07FF, inclusive:\n    if (inRange(code_point, 0x0080, 0x07ff)) {\n      // 1 and 0xC0\n      count = 1;\n      offset = 0xc0;\n    }\n    // U+0800 to U+FFFF, inclusive:\n    else if (inRange(code_point, 0x0800, 0xffff)) {\n      // 2 and 0xE0\n      count = 2;\n      offset = 0xe0;\n    }\n    // U+10000 to U+10FFFF, inclusive:\n    else if (inRange(code_point, 0x10000, 0x10ffff)) {\n      // 3 and 0xF0\n      count = 3;\n      offset = 0xf0;\n    }\n\n    // 4. Let bytes be a byte sequence whose first byte is (code\n    // point >> (6 × count)) + offset.\n    var bytes = [(code_point >> 6 * count) + offset];\n\n    // 5. Run these substeps while count is greater than 0:\n    while (count > 0) {\n      // 1. Set temp to code point >> (6 × (count − 1)).\n      var temp = code_point >> 6 * (count - 1);\n\n      // 2. Append to bytes 0x80 | (temp & 0x3F).\n      bytes.push(0x80 | temp & 0x3f);\n\n      // 3. Decrease count by one.\n      count -= 1;\n    }\n\n    // 6. Return bytes bytes, in order.\n    return bytes;\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['UTF-8'] = function (options) {\n  return new UTF8Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['UTF-8'] = function (options) {\n  return new UTF8Decoder(options);\n};\n\n//\n// 10. Legacy single-byte encodings\n//\n\n// 10.1 single-byte decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {!Array.<number>} index The encoding index.\n * @param {{fatal: boolean}} options\n */\nfunction SingleByteDecoder(index, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream) return finished;\n\n    // 2. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 3. Let code point be the index code point for byte − 0x80 in\n    // index single-byte.\n    var code_point = index[bite - 0x80];\n\n    // 4. If code point is null, return error.\n    if (code_point === null) return decoderError(fatal);\n\n    // 5. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n// 10.2 single-byte encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {!Array.<?number>} index The encoding index.\n * @param {{fatal: boolean}} options\n */\nfunction SingleByteEncoder(index, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Let pointer be the index pointer for code point in index\n    // single-byte.\n    var pointer = indexPointerFor(code_point, index);\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null) encoderError(code_point);\n\n    // 5. Return a byte whose value is pointer + 0x80.\n    return pointer + 0x80;\n  };\n}\n(function () {\n  if (!('encoding-indexes' in global)) return;\n  encodings.forEach(function (category) {\n    if (category.heading !== 'Legacy single-byte encodings') return;\n    category.encodings.forEach(function (encoding) {\n      var name = encoding.name;\n      var idx = index(name.toLowerCase());\n      /** @param {{fatal: boolean}} options */\n      decoders[name] = function (options) {\n        return new SingleByteDecoder(idx, options);\n      };\n      /** @param {{fatal: boolean}} options */\n      encoders[name] = function (options) {\n        return new SingleByteEncoder(idx, options);\n      };\n    });\n  });\n})();\n\n//\n// 11. Legacy multi-byte Chinese (simplified) encodings\n//\n\n// 11.1 gbk\n\n// 11.1.1 gbk decoder\n// gbk's decoder is gb18030's decoder.\n/** @param {{fatal: boolean}} options */\ndecoders['GBK'] = function (options) {\n  return new GB18030Decoder(options);\n};\n\n// 11.1.2 gbk encoder\n// gbk's encoder is gb18030's encoder with its gbk flag set.\n/** @param {{fatal: boolean}} options */\nencoders['GBK'] = function (options) {\n  return new GB18030Encoder(options, true);\n};\n\n// 11.2 gb18030\n\n// 11.2.1 gb18030 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction GB18030Decoder(options) {\n  var fatal = options.fatal;\n  // gb18030's decoder has an associated gb18030 first, gb18030\n  // second, and gb18030 third (all initially 0x00).\n  var /** @type {number} */gb18030_first = 0x00,\n    /** @type {number} */gb18030_second = 0x00,\n    /** @type {number} */gb18030_third = 0x00;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream and gb18030 first, gb18030\n    // second, and gb18030 third are 0x00, return finished.\n    if (bite === end_of_stream && gb18030_first === 0x00 && gb18030_second === 0x00 && gb18030_third === 0x00) {\n      return finished;\n    }\n    // 2. If byte is end-of-stream, and gb18030 first, gb18030\n    // second, or gb18030 third is not 0x00, set gb18030 first,\n    // gb18030 second, and gb18030 third to 0x00, and return error.\n    if (bite === end_of_stream && (gb18030_first !== 0x00 || gb18030_second !== 0x00 || gb18030_third !== 0x00)) {\n      gb18030_first = 0x00;\n      gb18030_second = 0x00;\n      gb18030_third = 0x00;\n      decoderError(fatal);\n    }\n    var code_point;\n    // 3. If gb18030 third is not 0x00, run these substeps:\n    if (gb18030_third !== 0x00) {\n      // 1. Let code point be null.\n      code_point = null;\n      // 2. If byte is in the range 0x30 to 0x39, inclusive, set\n      // code point to the index gb18030 ranges code point for\n      // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×\n      // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.\n      if (inRange(bite, 0x30, 0x39)) {\n        code_point = indexGB18030RangesCodePointFor((((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 + gb18030_third - 0x81) * 10 + bite - 0x30);\n      }\n\n      // 3. Let buffer be a byte sequence consisting of gb18030\n      // second, gb18030 third, and byte, in order.\n      var buffer = [gb18030_second, gb18030_third, bite];\n\n      // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n      // 0x00.\n      gb18030_first = 0x00;\n      gb18030_second = 0x00;\n      gb18030_third = 0x00;\n\n      // 5. If code point is null, prepend buffer to stream and\n      // return error.\n      if (code_point === null) {\n        stream.prepend(buffer);\n        return decoderError(fatal);\n      }\n\n      // 6. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If gb18030 second is not 0x00, run these substeps:\n    if (gb18030_second !== 0x00) {\n      // 1. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // gb18030 third to byte and return continue.\n      if (inRange(bite, 0x81, 0xfe)) {\n        gb18030_third = bite;\n        return null;\n      }\n\n      // 2. Prepend gb18030 second followed by byte to stream, set\n      // gb18030 first and gb18030 second to 0x00, and return error.\n      stream.prepend([gb18030_second, bite]);\n      gb18030_first = 0x00;\n      gb18030_second = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 5. If gb18030 first is not 0x00, run these substeps:\n    if (gb18030_first !== 0x00) {\n      // 1. If byte is in the range 0x30 to 0x39, inclusive, set\n      // gb18030 second to byte and return continue.\n      if (inRange(bite, 0x30, 0x39)) {\n        gb18030_second = bite;\n        return null;\n      }\n\n      // 2. Let lead be gb18030 first, let pointer be null, and set\n      // gb18030 first to 0x00.\n      var lead = gb18030_first;\n      var pointer = null;\n      gb18030_first = 0x00;\n\n      // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n      // otherwise.\n      var offset = bite < 0x7f ? 0x40 : 0x41;\n\n      // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n      // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +\n      // (byte − offset).\n      if (inRange(bite, 0x40, 0x7e) || inRange(bite, 0x80, 0xfe)) pointer = (lead - 0x81) * 190 + (bite - offset);\n\n      // 5. Let code point be null if pointer is null and the index\n      // code point for pointer in index gb18030 otherwise.\n      code_point = pointer === null ? null : indexCodePointFor(pointer, index('gb18030'));\n\n      // 6. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 7. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 8. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 6. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 7. If byte is 0x80, return code point U+20AC.\n    if (bite === 0x80) return 0x20ac;\n\n    // 8. If byte is in the range 0x81 to 0xFE, inclusive, set\n    // gb18030 first to byte and return continue.\n    if (inRange(bite, 0x81, 0xfe)) {\n      gb18030_first = bite;\n      return null;\n    }\n\n    // 9. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 11.2.2 gb18030 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n * @param {boolean=} gbk_flag\n */\nfunction GB18030Encoder(options, gbk_flag) {\n  var fatal = options.fatal;\n  // gb18030's decoder has an associated gbk flag (initially unset).\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. If code point is U+E5E5, return error with code point.\n    if (code_point === 0xe5e5) return encoderError(code_point);\n\n    // 4. If the gbk flag is set and code point is U+20AC, return\n    // byte 0x80.\n    if (gbk_flag && code_point === 0x20ac) return 0x80;\n\n    // 5. Let pointer be the index pointer for code point in index\n    // gb18030.\n    var pointer = indexPointerFor(code_point, index('gb18030'));\n\n    // 6. If pointer is not null, run these substeps:\n    if (pointer !== null) {\n      // 1. Let lead be floor(pointer / 190) + 0x81.\n      var lead = floor(pointer / 190) + 0x81;\n\n      // 2. Let trail be pointer % 190.\n      var trail = pointer % 190;\n\n      // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n      var offset = trail < 0x3f ? 0x40 : 0x41;\n\n      // 4. Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset];\n    }\n\n    // 7. If gbk flag is set, return error with code point.\n    if (gbk_flag) return encoderError(code_point);\n\n    // 8. Set pointer to the index gb18030 ranges pointer for code\n    // point.\n    pointer = indexGB18030RangesPointerFor(code_point);\n\n    // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n    var byte1 = floor(pointer / 10 / 126 / 10);\n\n    // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.\n    pointer = pointer - byte1 * 10 * 126 * 10;\n\n    // 11. Let byte2 be floor(pointer / 10 / 126).\n    var byte2 = floor(pointer / 10 / 126);\n\n    // 12. Set pointer to pointer − byte2 × 10 × 126.\n    pointer = pointer - byte2 * 10 * 126;\n\n    // 13. Let byte3 be floor(pointer / 10).\n    var byte3 = floor(pointer / 10);\n\n    // 14. Let byte4 be pointer − byte3 × 10.\n    var byte4 = pointer - byte3 * 10;\n\n    // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n    // 0x30, byte3 + 0x81, byte4 + 0x30.\n    return [byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['gb18030'] = function (options) {\n  return new GB18030Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['gb18030'] = function (options) {\n  return new GB18030Decoder(options);\n};\n\n//\n// 12. Legacy multi-byte Chinese (traditional) encodings\n//\n\n// 12.1 Big5\n\n// 12.1.1 Big5 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction Big5Decoder(options) {\n  var fatal = options.fatal;\n  // Big5's decoder has an associated Big5 lead (initially 0x00).\n  var /** @type {number} */Big5_lead = 0x00;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream and Big5 lead is not 0x00, set\n    // Big5 lead to 0x00 and return error.\n    if (bite === end_of_stream && Big5_lead !== 0x00) {\n      Big5_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and Big5 lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && Big5_lead === 0x00) return finished;\n\n    // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let\n    // pointer be null, set Big5 lead to 0x00, and then run these\n    // substeps:\n    if (Big5_lead !== 0x00) {\n      var lead = Big5_lead;\n      var pointer = null;\n      Big5_lead = 0x00;\n\n      // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n      // otherwise.\n      var offset = bite < 0x7f ? 0x40 : 0x62;\n\n      // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1\n      // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +\n      // (byte − offset).\n      if (inRange(bite, 0x40, 0x7e) || inRange(bite, 0xa1, 0xfe)) pointer = (lead - 0x81) * 157 + (bite - offset);\n\n      // 3. If there is a row in the table below whose first column\n      // is pointer, return the two code points listed in its second\n      // column\n      // Pointer | Code points\n      // --------+--------------\n      // 1133    | U+00CA U+0304\n      // 1135    | U+00CA U+030C\n      // 1164    | U+00EA U+0304\n      // 1166    | U+00EA U+030C\n      switch (pointer) {\n        case 1133:\n          return [0x00ca, 0x0304];\n        case 1135:\n          return [0x00ca, 0x030c];\n        case 1164:\n          return [0x00ea, 0x0304];\n        case 1166:\n          return [0x00ea, 0x030c];\n      }\n\n      // 4. Let code point be null if pointer is null and the index\n      // code point for pointer in index Big5 otherwise.\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, index('big5'));\n\n      // 5. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 6. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 7. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5\n    // lead to byte and return continue.\n    if (inRange(bite, 0x81, 0xfe)) {\n      Big5_lead = bite;\n      return null;\n    }\n\n    // 6. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 12.1.2 Big5 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction Big5Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Let pointer be the index Big5 pointer for code point.\n    var pointer = indexBig5PointerFor(code_point);\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 5. Let lead be floor(pointer / 157) + 0x81.\n    var lead = floor(pointer / 157) + 0x81;\n\n    // 6. If lead is less than 0xA1, return error with code point.\n    if (lead < 0xa1) return encoderError(code_point);\n\n    // 7. Let trail be pointer % 157.\n    var trail = pointer % 157;\n\n    // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n    // otherwise.\n    var offset = trail < 0x3f ? 0x40 : 0x62;\n\n    // Return two bytes whose values are lead and trail + offset.\n    return [lead, trail + offset];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['Big5'] = function (options) {\n  return new Big5Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['Big5'] = function (options) {\n  return new Big5Decoder(options);\n};\n\n//\n// 13. Legacy multi-byte Japanese encodings\n//\n\n// 13.1 euc-jp\n\n// 13.1.1 euc-jp decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCJPDecoder(options) {\n  var fatal = options.fatal;\n\n  // euc-jp's decoder has an associated euc-jp jis0212 flag\n  // (initially unset) and euc-jp lead (initially 0x00).\n  var /** @type {boolean} */eucjp_jis0212_flag = false,\n    /** @type {number} */eucjp_lead = 0x00;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n    // euc-jp lead to 0x00, and return error.\n    if (bite === end_of_stream && eucjp_lead !== 0x00) {\n      eucjp_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && eucjp_lead === 0x00) return finished;\n\n    // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n    // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code\n    // point whose value is 0xFF61 − 0xA1 + byte.\n    if (eucjp_lead === 0x8e && inRange(bite, 0xa1, 0xdf)) {\n      eucjp_lead = 0x00;\n      return 0xff61 - 0xa1 + bite;\n    }\n\n    // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n    // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead\n    // to byte, and return continue.\n    if (eucjp_lead === 0x8f && inRange(bite, 0xa1, 0xfe)) {\n      eucjp_jis0212_flag = true;\n      eucjp_lead = bite;\n      return null;\n    }\n\n    // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n    // euc-jp lead to 0x00, and run these substeps:\n    if (eucjp_lead !== 0x00) {\n      var lead = eucjp_lead;\n      eucjp_lead = 0x00;\n\n      // 1. Let code point be null.\n      var code_point = null;\n\n      // 2. If lead and byte are both in the range 0xA1 to 0xFE,\n      // inclusive, set code point to the index code point for (lead\n      // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp\n      // jis0212 flag is unset and in index jis0212 otherwise.\n      if (inRange(lead, 0xa1, 0xfe) && inRange(bite, 0xa1, 0xfe)) {\n        code_point = indexCodePointFor((lead - 0xa1) * 94 + (bite - 0xa1), index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));\n      }\n\n      // 3. Unset the euc-jp jis0212 flag.\n      eucjp_jis0212_flag = false;\n\n      // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,\n      // prepend byte to stream.\n      if (!inRange(bite, 0xa1, 0xfe)) stream.prepend(bite);\n\n      // 5. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 6. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 6. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,\n    // inclusive, set euc-jp lead to byte and return continue.\n    if (bite === 0x8e || bite === 0x8f || inRange(bite, 0xa1, 0xfe)) {\n      eucjp_lead = bite;\n      return null;\n    }\n\n    // 8. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 13.1.2 euc-jp encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCJPEncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. If code point is U+00A5, return byte 0x5C.\n    if (code_point === 0x00a5) return 0x5c;\n\n    // 4. If code point is U+203E, return byte 0x7E.\n    if (code_point === 0x203e) return 0x7e;\n\n    // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n    // return two bytes whose values are 0x8E and code point −\n    // 0xFF61 + 0xA1.\n    if (inRange(code_point, 0xff61, 0xff9f)) return [0x8e, code_point - 0xff61 + 0xa1];\n\n    // 6. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xff0d;\n\n    // 7. Let pointer be the index pointer for code point in index\n    // jis0208.\n    var pointer = indexPointerFor(code_point, index('jis0208'));\n\n    // 8. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 9. Let lead be floor(pointer / 94) + 0xA1.\n    var lead = floor(pointer / 94) + 0xa1;\n\n    // 10. Let trail be pointer % 94 + 0xA1.\n    var trail = pointer % 94 + 0xa1;\n\n    // 11. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['EUC-JP'] = function (options) {\n  return new EUCJPEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['EUC-JP'] = function (options) {\n  return new EUCJPDecoder(options);\n};\n\n// 13.2 iso-2022-jp\n\n// 13.2.1 iso-2022-jp decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction ISO2022JPDecoder(options) {\n  var fatal = options.fatal;\n  /** @enum */\n  var states = {\n    ASCII: 0,\n    Roman: 1,\n    Katakana: 2,\n    LeadByte: 3,\n    TrailByte: 4,\n    EscapeStart: 5,\n    Escape: 6\n  };\n  // iso-2022-jp's decoder has an associated iso-2022-jp decoder\n  // state (initially ASCII), iso-2022-jp decoder output state\n  // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n  // iso-2022-jp output flag (initially unset).\n  var /** @type {number} */iso2022jp_decoder_state = states.ASCII,\n    /** @type {number} */iso2022jp_decoder_output_state = states.ASCII,\n    /** @type {number} */iso2022jp_lead = 0x00,\n    /** @type {boolean} */iso2022jp_output_flag = false;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // switching on iso-2022-jp decoder state:\n    switch (iso2022jp_decoder_state) {\n      default:\n      case states.ASCII:\n        // ASCII\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n        if (inRange(bite, 0x00, 0x7f) && bite !== 0x0e && bite !== 0x0f && bite !== 0x1b) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n      case states.Roman:\n        // Roman\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x5C\n        if (bite === 0x5c) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+00A5.\n          iso2022jp_output_flag = false;\n          return 0x00a5;\n        }\n\n        // 0x7E\n        if (bite === 0x7e) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+203E.\n          iso2022jp_output_flag = false;\n          return 0x203e;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n        if (inRange(bite, 0x00, 0x7f) && bite !== 0x0e && bite !== 0x0f && bite !== 0x1b && bite !== 0x5c && bite !== 0x7e) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n      case states.Katakana:\n        // Katakana\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x5F\n        if (inRange(bite, 0x21, 0x5f)) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is 0xFF61 − 0x21 + byte.\n          iso2022jp_output_flag = false;\n          return 0xff61 - 0x21 + bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n      case states.LeadByte:\n        // Lead byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7e)) {\n          // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n          // to byte, iso-2022-jp decoder state to trail byte, and\n          // return continue.\n          iso2022jp_output_flag = false;\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.TrailByte;\n          return null;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n      case states.TrailByte:\n        // Trail byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return decoderError(fatal);\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7e)) {\n          // 1. Set the iso-2022-jp decoder state to lead byte.\n          iso2022jp_decoder_state = states.LeadByte;\n\n          // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.\n          var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;\n\n          // 3. Let code point be the index code point for pointer in\n          // index jis0208.\n          var code_point = indexCodePointFor(pointer, index('jis0208'));\n\n          // 4. If code point is null, return error.\n          if (code_point === null) return decoderError(fatal);\n\n          // 5. Return a code point whose value is code point.\n          return code_point;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Set the iso-2022-jp decoder state to lead byte, prepend\n          // byte to stream, and return error.\n          iso2022jp_decoder_state = states.LeadByte;\n          stream.prepend(bite);\n          return decoderError(fatal);\n        }\n\n        // Otherwise\n        // Set iso-2022-jp decoder state to lead byte and return\n        // error.\n        iso2022jp_decoder_state = states.LeadByte;\n        return decoderError(fatal);\n      case states.EscapeStart:\n        // Escape start\n\n        // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n        // byte, iso-2022-jp decoder state to escape, and return\n        // continue.\n        if (bite === 0x24 || bite === 0x28) {\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.Escape;\n          return null;\n        }\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state, and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n      case states.Escape:\n        // Escape\n\n        // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n        // 0x00.\n        var lead = iso2022jp_lead;\n        iso2022jp_lead = 0x00;\n\n        // 2. Let state be null.\n        var state = null;\n\n        // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n        if (lead === 0x28 && bite === 0x42) state = states.ASCII;\n\n        // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n        if (lead === 0x28 && bite === 0x4a) state = states.Roman;\n\n        // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n        if (lead === 0x28 && bite === 0x49) state = states.Katakana;\n\n        // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n        // state to lead byte.\n        if (lead === 0x24 && (bite === 0x40 || bite === 0x42)) state = states.LeadByte;\n\n        // 7. If state is non-null, run these substeps:\n        if (state !== null) {\n          // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n          // output state to states.\n          iso2022jp_decoder_state = iso2022jp_decoder_state = state;\n\n          // 2. Let output flag be the iso-2022-jp output flag.\n          var output_flag = iso2022jp_output_flag;\n\n          // 3. Set the iso-2022-jp output flag.\n          iso2022jp_output_flag = true;\n\n          // 4. Return continue, if output flag is unset, and error\n          // otherwise.\n          return !output_flag ? null : decoderError(fatal);\n        }\n\n        // 8. Prepend lead and byte to stream.\n        stream.prepend([lead, bite]);\n\n        // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n    }\n  };\n}\n\n// 13.2.2 iso-2022-jp encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction ISO2022JPEncoder(options) {\n  var fatal = options.fatal;\n  // iso-2022-jp's encoder has an associated iso-2022-jp encoder\n  // state which is one of ASCII, Roman, and jis0208 (initially\n  // ASCII).\n  /** @enum */\n  var states = {\n    ASCII: 0,\n    Roman: 1,\n    jis0208: 2\n  };\n  var /** @type {number} */iso2022jp_state = states.ASCII;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream and iso-2022-jp encoder\n    // state is not ASCII, prepend code point to stream, set\n    // iso-2022-jp encoder state to ASCII, and return three bytes\n    // 0x1B 0x28 0x42.\n    if (code_point === end_of_stream && iso2022jp_state !== states.ASCII) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.ASCII;\n      return [0x1b, 0x28, 0x42];\n    }\n\n    // 2. If code point is end-of-stream and iso-2022-jp encoder\n    // state is ASCII, return finished.\n    if (code_point === end_of_stream && iso2022jp_state === states.ASCII) return finished;\n\n    // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n    // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n    if ((iso2022jp_state === states.ASCII || iso2022jp_state === states.Roman) && (code_point === 0x000e || code_point === 0x000f || code_point === 0x001b)) {\n      return encoderError(0xfffd);\n    }\n\n    // 4. If iso-2022-jp encoder state is ASCII and code point is an\n    // ASCII code point, return a byte whose value is code point.\n    if (iso2022jp_state === states.ASCII && isASCIICodePoint(code_point)) return code_point;\n\n    // 5. If iso-2022-jp encoder state is Roman and code point is an\n    // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n    // or U+203E, run these substeps:\n    if (iso2022jp_state === states.Roman && (isASCIICodePoint(code_point) && code_point !== 0x005c && code_point !== 0x007e || code_point == 0x00a5 || code_point == 0x203e)) {\n      // 1. If code point is an ASCII code point, return a byte\n      // whose value is code point.\n      if (isASCIICodePoint(code_point)) return code_point;\n\n      // 2. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00a5) return 0x5c;\n\n      // 3. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203e) return 0x7e;\n    }\n\n    // 6. If code point is an ASCII code point, and iso-2022-jp\n    // encoder state is not ASCII, prepend code point to stream, set\n    // iso-2022-jp encoder state to ASCII, and return three bytes\n    // 0x1B 0x28 0x42.\n    if (isASCIICodePoint(code_point) && iso2022jp_state !== states.ASCII) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.ASCII;\n      return [0x1b, 0x28, 0x42];\n    }\n\n    // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n    // encoder state is not Roman, prepend code point to stream, set\n    // iso-2022-jp encoder state to Roman, and return three bytes\n    // 0x1B 0x28 0x4A.\n    if ((code_point === 0x00a5 || code_point === 0x203e) && iso2022jp_state !== states.Roman) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.Roman;\n      return [0x1b, 0x28, 0x4a];\n    }\n\n    // 8. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xff0d;\n\n    // 9. Let pointer be the index pointer for code point in index\n    // jis0208.\n    var pointer = indexPointerFor(code_point, index('jis0208'));\n\n    // 10. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n    // point to stream, set iso-2022-jp encoder state to jis0208,\n    // and return three bytes 0x1B 0x24 0x42.\n    if (iso2022jp_state !== states.jis0208) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.jis0208;\n      return [0x1b, 0x24, 0x42];\n    }\n\n    // 12. Let lead be floor(pointer / 94) + 0x21.\n    var lead = floor(pointer / 94) + 0x21;\n\n    // 13. Let trail be pointer % 94 + 0x21.\n    var trail = pointer % 94 + 0x21;\n\n    // 14. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['ISO-2022-JP'] = function (options) {\n  return new ISO2022JPEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['ISO-2022-JP'] = function (options) {\n  return new ISO2022JPDecoder(options);\n};\n\n// 13.3 Shift_JIS\n\n// 13.3.1 Shift_JIS decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction ShiftJISDecoder(options) {\n  var fatal = options.fatal;\n  // Shift_JIS's decoder has an associated Shift_JIS lead (initially\n  // 0x00).\n  var /** @type {number} */Shift_JIS_lead = 0x00;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,\n    // set Shift_JIS lead to 0x00 and return error.\n    if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {\n      Shift_JIS_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,\n    // return finished.\n    if (bite === end_of_stream && Shift_JIS_lead === 0x00) return finished;\n\n    // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,\n    // let pointer be null, set Shift_JIS lead to 0x00, and then run\n    // these substeps:\n    if (Shift_JIS_lead !== 0x00) {\n      var lead = Shift_JIS_lead;\n      var pointer = null;\n      Shift_JIS_lead = 0x00;\n\n      // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n      // otherwise.\n      var offset = bite < 0x7f ? 0x40 : 0x41;\n\n      // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n      // 0xC1 otherwise.\n      var lead_offset = lead < 0xa0 ? 0x81 : 0xc1;\n\n      // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n      // to 0xFC, inclusive, set pointer to (lead − lead offset) ×\n      // 188 + byte − offset.\n      if (inRange(bite, 0x40, 0x7e) || inRange(bite, 0x80, 0xfc)) pointer = (lead - lead_offset) * 188 + bite - offset;\n\n      // 4. If pointer is in the range 8836 to 10715, inclusive,\n      // return a code point whose value is 0xE000 − 8836 + pointer.\n      if (inRange(pointer, 8836, 10715)) return 0xe000 - 8836 + pointer;\n\n      // 5. Let code point be null, if pointer is null, and the\n      // index code point for pointer in index jis0208 otherwise.\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, index('jis0208'));\n\n      // 6. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 7. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 8. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte or 0x80, return a code point\n    // whose value is byte.\n    if (isASCIIByte(bite) || bite === 0x80) return bite;\n\n    // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a\n    // code point whose value is 0xFF61 − 0xA1 + byte.\n    if (inRange(bite, 0xa1, 0xdf)) return 0xff61 - 0xa1 + bite;\n\n    // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0\n    // to 0xFC, inclusive, set Shift_JIS lead to byte and return\n    // continue.\n    if (inRange(bite, 0x81, 0x9f) || inRange(bite, 0xe0, 0xfc)) {\n      Shift_JIS_lead = bite;\n      return null;\n    }\n\n    // 7. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 13.3.2 Shift_JIS encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction ShiftJISEncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point or U+0080, return a\n    // byte whose value is code point.\n    if (isASCIICodePoint(code_point) || code_point === 0x0080) return code_point;\n\n    // 3. If code point is U+00A5, return byte 0x5C.\n    if (code_point === 0x00a5) return 0x5c;\n\n    // 4. If code point is U+203E, return byte 0x7E.\n    if (code_point === 0x203e) return 0x7e;\n\n    // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n    // return a byte whose value is code point − 0xFF61 + 0xA1.\n    if (inRange(code_point, 0xff61, 0xff9f)) return code_point - 0xff61 + 0xa1;\n\n    // 6. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xff0d;\n\n    // 7. Let pointer be the index Shift_JIS pointer for code point.\n    var pointer = indexShiftJISPointerFor(code_point);\n\n    // 8. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 9. Let lead be floor(pointer / 188).\n    var lead = floor(pointer / 188);\n\n    // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n    // 0xC1 otherwise.\n    var lead_offset = lead < 0x1f ? 0x81 : 0xc1;\n\n    // 11. Let trail be pointer % 188.\n    var trail = pointer % 188;\n\n    // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n    // otherwise.\n    var offset = trail < 0x3f ? 0x40 : 0x41;\n\n    // 13. Return two bytes whose values are lead + lead offset and\n    // trail + offset.\n    return [lead + lead_offset, trail + offset];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['Shift_JIS'] = function (options) {\n  return new ShiftJISEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['Shift_JIS'] = function (options) {\n  return new ShiftJISDecoder(options);\n};\n\n//\n// 14. Legacy multi-byte Korean encodings\n//\n\n// 14.1 euc-kr\n\n// 14.1.1 euc-kr decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCKRDecoder(options) {\n  var fatal = options.fatal;\n\n  // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\n  var /** @type {number} */euckr_lead = 0x00;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n    // euc-kr lead to 0x00 and return error.\n    if (bite === end_of_stream && euckr_lead !== 0) {\n      euckr_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && euckr_lead === 0) return finished;\n\n    // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n    // pointer be null, set euc-kr lead to 0x00, and then run these\n    // substeps:\n    if (euckr_lead !== 0x00) {\n      var lead = euckr_lead;\n      var pointer = null;\n      euckr_lead = 0x00;\n\n      // 1. If byte is in the range 0x41 to 0xFE, inclusive, set\n      // pointer to (lead − 0x81) × 190 + (byte − 0x41).\n      if (inRange(bite, 0x41, 0xfe)) pointer = (lead - 0x81) * 190 + (bite - 0x41);\n\n      // 2. Let code point be null, if pointer is null, and the\n      // index code point for pointer in index euc-kr otherwise.\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, index('euc-kr'));\n\n      // 3. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (pointer === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 4. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 5. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 5. If byte is in the range 0x81 to 0xFE, inclusive, set\n    // euc-kr lead to byte and return continue.\n    if (inRange(bite, 0x81, 0xfe)) {\n      euckr_lead = bite;\n      return null;\n    }\n\n    // 6. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 14.1.2 euc-kr encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCKREncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Let pointer be the index pointer for code point in index\n    // euc-kr.\n    var pointer = indexPointerFor(code_point, index('euc-kr'));\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 5. Let lead be floor(pointer / 190) + 0x81.\n    var lead = floor(pointer / 190) + 0x81;\n\n    // 6. Let trail be pointer % 190 + 0x41.\n    var trail = pointer % 190 + 0x41;\n\n    // 7. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['EUC-KR'] = function (options) {\n  return new EUCKREncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['EUC-KR'] = function (options) {\n  return new EUCKRDecoder(options);\n};\n\n//\n// 15. Legacy miscellaneous encodings\n//\n\n// 15.1 replacement\n\n// Not needed - API throws RangeError\n\n// 15.2 Common infrastructure for utf-16be and utf-16le\n\n/**\n * @param {number} code_unit\n * @param {boolean} utf16be\n * @return {!Array.<number>} bytes\n */\nfunction convertCodeUnitToBytes(code_unit, utf16be) {\n  // 1. Let byte1 be code unit >> 8.\n  var byte1 = code_unit >> 8;\n\n  // 2. Let byte2 be code unit & 0x00FF.\n  var byte2 = code_unit & 0x00ff;\n\n  // 3. Then return the bytes in order:\n  // utf-16be flag is set: byte1, then byte2.\n  if (utf16be) return [byte1, byte2];\n  // utf-16be flag is unset: byte2, then byte1.\n  return [byte2, byte1];\n}\n\n// 15.2.1 shared utf-16 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {boolean} utf16_be True if big-endian, false if little-endian.\n * @param {{fatal: boolean}} options\n */\nfunction UTF16Decoder(utf16_be, options) {\n  var fatal = options.fatal;\n  var /** @type {?number} */utf16_lead_byte = null,\n    /** @type {?number} */utf16_lead_surrogate = null;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream and either utf-16 lead byte or\n    // utf-16 lead surrogate is not null, set utf-16 lead byte and\n    // utf-16 lead surrogate to null, and return error.\n    if (bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and utf-16 lead byte and utf-16\n    // lead surrogate are null, return finished.\n    if (bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {\n      return finished;\n    }\n\n    // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte\n    // and return continue.\n    if (utf16_lead_byte === null) {\n      utf16_lead_byte = bite;\n      return null;\n    }\n\n    // 4. Let code unit be the result of:\n    var code_unit;\n    if (utf16_be) {\n      // utf-16be decoder flag is set\n      //   (utf-16 lead byte << 8) + byte.\n      code_unit = (utf16_lead_byte << 8) + bite;\n    } else {\n      // utf-16be decoder flag is unset\n      //   (byte << 8) + utf-16 lead byte.\n      code_unit = (bite << 8) + utf16_lead_byte;\n    }\n    // Then set utf-16 lead byte to null.\n    utf16_lead_byte = null;\n\n    // 5. If utf-16 lead surrogate is not null, let lead surrogate\n    // be utf-16 lead surrogate, set utf-16 lead surrogate to null,\n    // and then run these substeps:\n    if (utf16_lead_surrogate !== null) {\n      var lead_surrogate = utf16_lead_surrogate;\n      utf16_lead_surrogate = null;\n\n      // 1. If code unit is in the range U+DC00 to U+DFFF,\n      // inclusive, return a code point whose value is 0x10000 +\n      // ((lead surrogate − 0xD800) << 10) + (code unit − 0xDC00).\n      if (inRange(code_unit, 0xdc00, 0xdfff)) {\n        return 0x10000 + (lead_surrogate - 0xd800) * 0x400 + (code_unit - 0xdc00);\n      }\n\n      // 2. Prepend the sequence resulting of converting code unit\n      // to bytes using utf-16be decoder flag to stream and return\n      // error.\n      stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));\n      return decoderError(fatal);\n    }\n\n    // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,\n    // set utf-16 lead surrogate to code unit and return continue.\n    if (inRange(code_unit, 0xd800, 0xdbff)) {\n      utf16_lead_surrogate = code_unit;\n      return null;\n    }\n\n    // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,\n    // return error.\n    if (inRange(code_unit, 0xdc00, 0xdfff)) return decoderError(fatal);\n\n    // 8. Return code point code unit.\n    return code_unit;\n  };\n}\n\n// 15.2.2 shared utf-16 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {boolean} utf16_be True if big-endian, false if little-endian.\n * @param {{fatal: boolean}} options\n */\nfunction UTF16Encoder(utf16_be, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is in the range U+0000 to U+FFFF, inclusive,\n    // return the sequence resulting of converting code point to\n    // bytes using utf-16be encoder flag.\n    if (inRange(code_point, 0x0000, 0xffff)) return convertCodeUnitToBytes(code_point, utf16_be);\n\n    // 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,\n    // converted to bytes using utf-16be encoder flag.\n    var lead = convertCodeUnitToBytes((code_point - 0x10000 >> 10) + 0xd800, utf16_be);\n\n    // 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,\n    // converted to bytes using utf-16be encoder flag.\n    var trail = convertCodeUnitToBytes((code_point - 0x10000 & 0x3ff) + 0xdc00, utf16_be);\n\n    // 5. Return a byte sequence of lead followed by trail.\n    return lead.concat(trail);\n  };\n}\n\n// 15.3 utf-16be\n// 15.3.1 utf-16be decoder\n/** @param {{fatal: boolean}} options */\nencoders['UTF-16BE'] = function (options) {\n  return new UTF16Encoder(true, options);\n};\n// 15.3.2 utf-16be encoder\n/** @param {{fatal: boolean}} options */\ndecoders['UTF-16BE'] = function (options) {\n  return new UTF16Decoder(true, options);\n};\n\n// 15.4 utf-16le\n// 15.4.1 utf-16le decoder\n/** @param {{fatal: boolean}} options */\nencoders['UTF-16LE'] = function (options) {\n  return new UTF16Encoder(false, options);\n};\n// 15.4.2 utf-16le encoder\n/** @param {{fatal: boolean}} options */\ndecoders['UTF-16LE'] = function (options) {\n  return new UTF16Decoder(false, options);\n};\n\n// 15.5 x-user-defined\n\n// 15.5.1 x-user-defined decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction XUserDefinedDecoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function (stream, bite) {\n    // 1. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream) return finished;\n\n    // 2. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 3. Return a code point whose value is 0xF780 + byte − 0x80.\n    return 0xf780 + bite - 0x80;\n  };\n}\n\n// 15.5.2 x-user-defined encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction XUserDefinedEncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function (stream, code_point) {\n    // 1.If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. If code point is in the range U+F780 to U+F7FF, inclusive,\n    // return a byte whose value is code point − 0xF780 + 0x80.\n    if (inRange(code_point, 0xf780, 0xf7ff)) return code_point - 0xf780 + 0x80;\n\n    // 4. Return error with code point.\n    return encoderError(code_point);\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['x-user-defined'] = function (options) {\n  return new XUserDefinedEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['x-user-defined'] = function (options) {\n  return new XUserDefinedDecoder(options);\n};\n\n// FORK\n// if (!global['TextEncoder']) global['TextEncoder'] = TextEncoder;\n// if (!global['TextDecoder']) global['TextDecoder'] = TextDecoder;\n// babel.config.js skip transpiling files in `libs/`\nmodule.exports = {\n  TextEncoder: TextEncoder,\n  TextDecoder: TextDecoder\n};","map":{"version":3,"names":["indexes","require","global","inRange","a","min","max","includes","array","item","indexOf","floor","Math","ToDictionary","o","undefined","Object","TypeError","stringToCodePoints","string","s","String","n","length","i","u","c","charCodeAt","push","d","b","codePointsToString","code_points","cp","fromCharCode","isASCIIByte","isASCIICodePoint","end_of_stream","Stream","tokens","slice","call","reverse","prototype","endOfStream","read","pop","prepend","token","Array","isArray","unshift","shift","finished","decoderError","fatal","opt_code_point","encoderError","code_point","Decoder","handler","stream","bite","Encoder","getEncoding","label","trim","toLowerCase","hasOwnProperty","label_to_encoding","encodings","labels","name","heading","forEach","category","encoding","encoders","decoders","indexCodePointFor","pointer","index","indexPointerFor","Error","indexGB18030RangesCodePointFor","offset","code_point_offset","idx","entry","indexGB18030RangesPointerFor","pointer_offset","indexShiftJISPointerFor","shift_jis_index","map","index_","indexBig5PointerFor","big5_index_no_hkscs","lastIndexOf","DEFAULT_ENCODING","TextDecoder","options","_encoding","_decoder","_ignoreBOM","_BOMseen","_error_mode","_do_not_flush","RangeError","dec","Boolean","defineProperty","ignoreBOM","get","decode","input","bytes","ArrayBuffer","Uint8Array","buffer","byteOffset","byteLength","input_stream","output","result","apply","serializeStream","TextEncoder","_encoder","_fatal","enc","console","warn","encode","opt_string","UTF8Decoder","utf8_code_point","utf8_bytes_seen","utf8_bytes_needed","utf8_lower_boundary","utf8_upper_boundary","UTF8Encoder","count","temp","SingleByteDecoder","SingleByteEncoder","GB18030Decoder","GB18030Encoder","gb18030_first","gb18030_second","gb18030_third","lead","gbk_flag","trail","byte1","byte2","byte3","byte4","Big5Decoder","Big5_lead","Big5Encoder","EUCJPDecoder","eucjp_jis0212_flag","eucjp_lead","EUCJPEncoder","ISO2022JPDecoder","states","ASCII","Roman","Katakana","LeadByte","TrailByte","EscapeStart","Escape","iso2022jp_decoder_state","iso2022jp_decoder_output_state","iso2022jp_lead","iso2022jp_output_flag","state","output_flag","ISO2022JPEncoder","jis0208","iso2022jp_state","ShiftJISDecoder","Shift_JIS_lead","lead_offset","ShiftJISEncoder","EUCKRDecoder","euckr_lead","EUCKREncoder","convertCodeUnitToBytes","code_unit","utf16be","UTF16Decoder","utf16_be","utf16_lead_byte","utf16_lead_surrogate","lead_surrogate","UTF16Encoder","concat","XUserDefinedDecoder","XUserDefinedEncoder","module","exports"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/polyfills/dist/esm/libs/encoding.js"],"sourcesContent":["/* eslint-disable */\n// @ts-nocheck\n\n// Copied from https://github.com/inexorabletash/text-encoding/blob/b4e5bc26e26e51f56e3daa9f13138c79f49d3c34/lib/encoding.js\n//\n// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n// FORK: indices add half a megabyte to bundle. Ignore, since we only want the built-in UTF8...\nconst indexes = require('./encoding-indexes.js')\nglobal['encoding-indexes'] = (indexes && indexes['encoding-indexes']) || {};\n\n//\n// Utilities\n//\n\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n/**\n * @param {!Array.<*>} array The array to check.\n * @param {*} item The item to look for in the array.\n * @return {boolean} True if the item appears in the array.\n */\nfunction includes(array, item) {\n  return array.indexOf(item) !== -1;\n}\n\nvar floor = Math.floor;\n\n/**\n * @param {*} o\n * @return {Object}\n */\nfunction ToDictionary(o) {\n  if (o === undefined) return {};\n  if (o === Object(o)) return o;\n  throw TypeError('Could not convert argument to dictionary');\n}\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nfunction stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string);\n\n  // 2. Let n be the length of S.\n  var n = s.length;\n\n  // 3. Initialize i to 0.\n  var i = 0;\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = [];\n\n  // 5. While i < n:\n  while (i < n) {\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i);\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xd800 || c > 0xdfff) {\n      // Append to U the Unicode character with code point c.\n      u.push(c);\n    }\n\n    // 0xDC00 ≤ c ≤ 0xDFFF\n    else if (0xdc00 <= c && c <= 0xdfff) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xfffd);\n    }\n\n    // 0xD800 ≤ c ≤ 0xDBFF\n    else if (0xd800 <= c && c <= 0xdbff) {\n      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xfffd);\n      }\n      // 2. Otherwise, i < n−1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = s.charCodeAt(i + 1);\n\n        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n        if (0xdc00 <= d && d <= 0xdfff) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3ff;\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3ff;\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b);\n\n          // 4. Set i to i+1.\n          i += 1;\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else {\n          u.push(0xfffd);\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1;\n  }\n\n  // 6. Return U.\n  return u;\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nfunction codePointsToString(code_points) {\n  var s = '';\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i];\n    if (cp <= 0xffff) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xd800, (cp & 0x3ff) + 0xdc00);\n    }\n  }\n  return s;\n}\n\n//\n// Implementation of Encoding specification\n// https://encoding.spec.whatwg.org/\n//\n\n//\n// 4. Terminology\n//\n\n/**\n * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n * @param {number} a The number to test.\n * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n */\nfunction isASCIIByte(a) {\n  return 0x00 <= a && a <= 0x7f;\n}\n\n/**\n * An ASCII code point is a code point in the range U+0000 to\n * U+007F, inclusive.\n */\nvar isASCIICodePoint = isASCIIByte;\n\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n * @const\n */ var end_of_stream = -1;\n\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n * the stream.\n */\nfunction Stream(tokens) {\n  /** @type {!Array.<number>} */\n  this.tokens = [].slice.call(tokens);\n  // Reversed as push/pop is more efficient than shift/unshift.\n  this.tokens.reverse();\n}\n\nStream.prototype = {\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream: function() {\n    return !this.tokens.length;\n  },\n\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n  read: function() {\n    if (!this.tokens.length) return end_of_stream;\n    return this.tokens.pop();\n  },\n\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n   * stream.\n   */\n  prepend: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/ (token);\n      while (tokens.length) this.tokens.push(tokens.pop());\n    } else {\n      this.tokens.push(token);\n    }\n  },\n\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n   * stream.\n   */\n  push: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/ (token);\n      while (tokens.length) this.tokens.unshift(tokens.shift());\n    } else {\n      this.tokens.unshift(token);\n    }\n  }\n};\n\n//\n// 5. Encodings\n//\n\n// 5.1 Encoders and decoders\n\n/** @const */\nvar finished = -1;\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return {number} The code point to insert on a decoding error.\n */\nfunction decoderError(fatal, opt_code_point) {\n  if (fatal) throw TypeError('Decoder error');\n  return opt_code_point || 0xfffd;\n}\n\n/**\n * @param {number} code_point The code point that could not be encoded.\n * @return {number} Always throws, no value is actually returned.\n */\nfunction encoderError(code_point) {\n  throw TypeError('The code point ' + code_point + ' could not be encoded.');\n}\n\n/** @interface */\nfunction Decoder() {}\nDecoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point, or |finished|.\n   */\n  handler: function(stream, bite) {}\n};\n\n/** @interface */\nfunction Encoder() {}\nEncoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of code points being encoded.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n   */\n  handler: function(stream, code_point) {}\n};\n\n// 5.2 Names and labels\n\n// TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}\n// https://github.com/google/closure-compiler/issues/247\n\n/**\n * @param {string} label The encoding label.\n * @return {?{name:string,labels:Array.<string>}}\n */\nfunction getEncoding(label) {\n  // 1. Remove any leading and trailing ASCII whitespace from label.\n  label = String(label)\n    .trim()\n    .toLowerCase();\n\n  // 2. If label is an ASCII case-insensitive match for any of the\n  // labels listed in the table below, return the corresponding\n  // encoding, and failure otherwise.\n  if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n    return label_to_encoding[label];\n  }\n  return null;\n}\n\n/**\n * Encodings table: https://encoding.spec.whatwg.org/encodings.json\n * @const\n * @type {!Array.<{\n *          heading: string,\n *          encodings: Array.<{name:string,labels:Array.<string>}>\n *        }>}\n */\nvar encodings = [\n  {\n    encodings: [\n      {\n        labels: ['unicode-1-1-utf-8', 'utf-8', 'utf8'],\n        name: 'UTF-8'\n      }\n    ],\n    heading: 'The Encoding'\n  },\n  {\n    encodings: [\n      {\n        labels: ['866', 'cp866', 'csibm866', 'ibm866'],\n        name: 'IBM866'\n      },\n      {\n        labels: [\n          'csisolatin2',\n          'iso-8859-2',\n          'iso-ir-101',\n          'iso8859-2',\n          'iso88592',\n          'iso_8859-2',\n          'iso_8859-2:1987',\n          'l2',\n          'latin2'\n        ],\n        name: 'ISO-8859-2'\n      },\n      {\n        labels: [\n          'csisolatin3',\n          'iso-8859-3',\n          'iso-ir-109',\n          'iso8859-3',\n          'iso88593',\n          'iso_8859-3',\n          'iso_8859-3:1988',\n          'l3',\n          'latin3'\n        ],\n        name: 'ISO-8859-3'\n      },\n      {\n        labels: [\n          'csisolatin4',\n          'iso-8859-4',\n          'iso-ir-110',\n          'iso8859-4',\n          'iso88594',\n          'iso_8859-4',\n          'iso_8859-4:1988',\n          'l4',\n          'latin4'\n        ],\n        name: 'ISO-8859-4'\n      },\n      {\n        labels: [\n          'csisolatincyrillic',\n          'cyrillic',\n          'iso-8859-5',\n          'iso-ir-144',\n          'iso8859-5',\n          'iso88595',\n          'iso_8859-5',\n          'iso_8859-5:1988'\n        ],\n        name: 'ISO-8859-5'\n      },\n      {\n        labels: [\n          'arabic',\n          'asmo-708',\n          'csiso88596e',\n          'csiso88596i',\n          'csisolatinarabic',\n          'ecma-114',\n          'iso-8859-6',\n          'iso-8859-6-e',\n          'iso-8859-6-i',\n          'iso-ir-127',\n          'iso8859-6',\n          'iso88596',\n          'iso_8859-6',\n          'iso_8859-6:1987'\n        ],\n        name: 'ISO-8859-6'\n      },\n      {\n        labels: [\n          'csisolatingreek',\n          'ecma-118',\n          'elot_928',\n          'greek',\n          'greek8',\n          'iso-8859-7',\n          'iso-ir-126',\n          'iso8859-7',\n          'iso88597',\n          'iso_8859-7',\n          'iso_8859-7:1987',\n          'sun_eu_greek'\n        ],\n        name: 'ISO-8859-7'\n      },\n      {\n        labels: [\n          'csiso88598e',\n          'csisolatinhebrew',\n          'hebrew',\n          'iso-8859-8',\n          'iso-8859-8-e',\n          'iso-ir-138',\n          'iso8859-8',\n          'iso88598',\n          'iso_8859-8',\n          'iso_8859-8:1988',\n          'visual'\n        ],\n        name: 'ISO-8859-8'\n      },\n      {\n        labels: ['csiso88598i', 'iso-8859-8-i', 'logical'],\n        name: 'ISO-8859-8-I'\n      },\n      {\n        labels: [\n          'csisolatin6',\n          'iso-8859-10',\n          'iso-ir-157',\n          'iso8859-10',\n          'iso885910',\n          'l6',\n          'latin6'\n        ],\n        name: 'ISO-8859-10'\n      },\n      {\n        labels: ['iso-8859-13', 'iso8859-13', 'iso885913'],\n        name: 'ISO-8859-13'\n      },\n      {\n        labels: ['iso-8859-14', 'iso8859-14', 'iso885914'],\n        name: 'ISO-8859-14'\n      },\n      {\n        labels: ['csisolatin9', 'iso-8859-15', 'iso8859-15', 'iso885915', 'iso_8859-15', 'l9'],\n        name: 'ISO-8859-15'\n      },\n      {\n        labels: ['iso-8859-16'],\n        name: 'ISO-8859-16'\n      },\n      {\n        labels: ['cskoi8r', 'koi', 'koi8', 'koi8-r', 'koi8_r'],\n        name: 'KOI8-R'\n      },\n      {\n        labels: ['koi8-ru', 'koi8-u'],\n        name: 'KOI8-U'\n      },\n      {\n        labels: ['csmacintosh', 'mac', 'macintosh', 'x-mac-roman'],\n        name: 'macintosh'\n      },\n      {\n        labels: ['dos-874', 'iso-8859-11', 'iso8859-11', 'iso885911', 'tis-620', 'windows-874'],\n        name: 'windows-874'\n      },\n      {\n        labels: ['cp1250', 'windows-1250', 'x-cp1250'],\n        name: 'windows-1250'\n      },\n      {\n        labels: ['cp1251', 'windows-1251', 'x-cp1251'],\n        name: 'windows-1251'\n      },\n      {\n        labels: [\n          'ansi_x3.4-1968',\n          'ascii',\n          'cp1252',\n          'cp819',\n          'csisolatin1',\n          'ibm819',\n          'iso-8859-1',\n          'iso-ir-100',\n          'iso8859-1',\n          'iso88591',\n          'iso_8859-1',\n          'iso_8859-1:1987',\n          'l1',\n          'latin1',\n          'us-ascii',\n          'windows-1252',\n          'x-cp1252'\n        ],\n        name: 'windows-1252'\n      },\n      {\n        labels: ['cp1253', 'windows-1253', 'x-cp1253'],\n        name: 'windows-1253'\n      },\n      {\n        labels: [\n          'cp1254',\n          'csisolatin5',\n          'iso-8859-9',\n          'iso-ir-148',\n          'iso8859-9',\n          'iso88599',\n          'iso_8859-9',\n          'iso_8859-9:1989',\n          'l5',\n          'latin5',\n          'windows-1254',\n          'x-cp1254'\n        ],\n        name: 'windows-1254'\n      },\n      {\n        labels: ['cp1255', 'windows-1255', 'x-cp1255'],\n        name: 'windows-1255'\n      },\n      {\n        labels: ['cp1256', 'windows-1256', 'x-cp1256'],\n        name: 'windows-1256'\n      },\n      {\n        labels: ['cp1257', 'windows-1257', 'x-cp1257'],\n        name: 'windows-1257'\n      },\n      {\n        labels: ['cp1258', 'windows-1258', 'x-cp1258'],\n        name: 'windows-1258'\n      },\n      {\n        labels: ['x-mac-cyrillic', 'x-mac-ukrainian'],\n        name: 'x-mac-cyrillic'\n      }\n    ],\n    heading: 'Legacy single-byte encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: [\n          'chinese',\n          'csgb2312',\n          'csiso58gb231280',\n          'gb2312',\n          'gb_2312',\n          'gb_2312-80',\n          'gbk',\n          'iso-ir-58',\n          'x-gbk'\n        ],\n        name: 'GBK'\n      },\n      {\n        labels: ['gb18030'],\n        name: 'gb18030'\n      }\n    ],\n    heading: 'Legacy multi-byte Chinese (simplified) encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: ['big5', 'big5-hkscs', 'cn-big5', 'csbig5', 'x-x-big5'],\n        name: 'Big5'\n      }\n    ],\n    heading: 'Legacy multi-byte Chinese (traditional) encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: ['cseucpkdfmtjapanese', 'euc-jp', 'x-euc-jp'],\n        name: 'EUC-JP'\n      },\n      {\n        labels: ['csiso2022jp', 'iso-2022-jp'],\n        name: 'ISO-2022-JP'\n      },\n      {\n        labels: [\n          'csshiftjis',\n          'ms932',\n          'ms_kanji',\n          'shift-jis',\n          'shift_jis',\n          'sjis',\n          'windows-31j',\n          'x-sjis'\n        ],\n        name: 'Shift_JIS'\n      }\n    ],\n    heading: 'Legacy multi-byte Japanese encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: [\n          'cseuckr',\n          'csksc56011987',\n          'euc-kr',\n          'iso-ir-149',\n          'korean',\n          'ks_c_5601-1987',\n          'ks_c_5601-1989',\n          'ksc5601',\n          'ksc_5601',\n          'windows-949'\n        ],\n        name: 'EUC-KR'\n      }\n    ],\n    heading: 'Legacy multi-byte Korean encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: ['csiso2022kr', 'hz-gb-2312', 'iso-2022-cn', 'iso-2022-cn-ext', 'iso-2022-kr'],\n        name: 'replacement'\n      },\n      {\n        labels: ['utf-16be'],\n        name: 'UTF-16BE'\n      },\n      {\n        labels: ['utf-16', 'utf-16le'],\n        name: 'UTF-16LE'\n      },\n      {\n        labels: ['x-user-defined'],\n        name: 'x-user-defined'\n      }\n    ],\n    heading: 'Legacy miscellaneous encodings'\n  }\n];\n\n// Label to encoding registry.\n/** @type {Object.<string,{name:string,labels:Array.<string>}>} */\nvar label_to_encoding = {};\nencodings.forEach(function(category) {\n  category.encodings.forEach(function(encoding) {\n    encoding.labels.forEach(function(label) {\n      label_to_encoding[label] = encoding;\n    });\n  });\n});\n\n// Registry of of encoder/decoder factories, by encoding name.\n/** @type {Object.<string, function({fatal:boolean}): Encoder>} */\nvar encoders = {};\n/** @type {Object.<string, function({fatal:boolean}): Decoder>} */\nvar decoders = {};\n\n//\n// 6. Indexes\n//\n\n/**\n * @param {number} pointer The |pointer| to search for.\n * @param {(!Array.<?number>|undefined)} index The |index| to search within.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in |index|.\n */\nfunction indexCodePointFor(pointer, index) {\n  if (!index) return null;\n  return index[pointer] || null;\n}\n\n/**\n * @param {number} code_point The |code point| to search for.\n * @param {!Array.<?number>} index The |index| to search within.\n * @return {?number} The first pointer corresponding to |code point| in\n *     |index|, or null if |code point| is not in |index|.\n */\nfunction indexPointerFor(code_point, index) {\n  var pointer = index.indexOf(code_point);\n  return pointer === -1 ? null : pointer;\n}\n\n/**\n * @param {string} name Name of the index.\n * @return {(!Array.<number>|!Array.<Array.<number>>)}\n *  */\nfunction index(name) {\n  if (!('encoding-indexes' in global)) {\n    throw Error('Indexes missing.' + ' Did you forget to include encoding-indexes.js first?');\n  }\n  return global['encoding-indexes'][name];\n}\n\n/**\n * @param {number} pointer The |pointer| to search for in the gb18030 index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the gb18030 index.\n */\nfunction indexGB18030RangesCodePointFor(pointer) {\n  // 1. If pointer is greater than 39419 and less than 189000, or\n  // pointer is greater than 1237575, return null.\n  if ((pointer > 39419 && pointer < 189000) || pointer > 1237575) return null;\n\n  // 2. If pointer is 7457, return code point U+E7C7.\n  if (pointer === 7457) return 0xe7c7;\n\n  // 3. Let offset be the last pointer in index gb18030 ranges that\n  // is equal to or less than pointer and let code point offset be\n  // its corresponding code point.\n  var offset = 0;\n  var code_point_offset = 0;\n  var idx = index('gb18030-ranges');\n  var i;\n  for (i = 0; i < idx.length; ++i) {\n    /** @type {!Array.<number>} */\n    var entry = idx[i];\n    if (entry[0] <= pointer) {\n      offset = entry[0];\n      code_point_offset = entry[1];\n    } else {\n      break;\n    }\n  }\n\n  // 4. Return a code point whose value is code point offset +\n  // pointer − offset.\n  return code_point_offset + pointer - offset;\n}\n\n/**\n * @param {number} code_point The |code point| to locate in the gb18030 index.\n * @return {number} The first pointer corresponding to |code point| in the\n *     gb18030 index.\n */\nfunction indexGB18030RangesPointerFor(code_point) {\n  // 1. If code point is U+E7C7, return pointer 7457.\n  if (code_point === 0xe7c7) return 7457;\n\n  // 2. Let offset be the last code point in index gb18030 ranges\n  // that is equal to or less than code point and let pointer offset\n  // be its corresponding pointer.\n  var offset = 0;\n  var pointer_offset = 0;\n  var idx = index('gb18030-ranges');\n  var i;\n  for (i = 0; i < idx.length; ++i) {\n    /** @type {!Array.<number>} */\n    var entry = idx[i];\n    if (entry[1] <= code_point) {\n      offset = entry[1];\n      pointer_offset = entry[0];\n    } else {\n      break;\n    }\n  }\n\n  // 3. Return a pointer whose value is pointer offset + code point\n  // − offset.\n  return pointer_offset + code_point - offset;\n}\n\n/**\n * @param {number} code_point The |code_point| to search for in the Shift_JIS\n *     index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the Shift_JIS index.\n */\nfunction indexShiftJISPointerFor(code_point) {\n  // 1. Let index be index jis0208 excluding all entries whose\n  // pointer is in the range 8272 to 8835, inclusive.\n  shift_jis_index =\n    shift_jis_index ||\n    index('jis0208').map(function(code_point, pointer) {\n      return inRange(pointer, 8272, 8835) ? null : code_point;\n    });\n  var index_ = shift_jis_index;\n\n  // 2. Return the index pointer for code point in index.\n  return index_.indexOf(code_point);\n}\nvar shift_jis_index;\n\n/**\n * @param {number} code_point The |code_point| to search for in the big5\n *     index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the big5 index.\n */\nfunction indexBig5PointerFor(code_point) {\n  // 1. Let index be index Big5 excluding all entries whose pointer\n  big5_index_no_hkscs =\n    big5_index_no_hkscs ||\n    index('big5').map(function(code_point, pointer) {\n      return pointer < (0xa1 - 0x81) * 157 ? null : code_point;\n    });\n  var index_ = big5_index_no_hkscs;\n\n  // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or\n  // U+5345, return the last pointer corresponding to code point in\n  // index.\n  if (\n    code_point === 0x2550 ||\n    code_point === 0x255e ||\n    code_point === 0x2561 ||\n    code_point === 0x256a ||\n    code_point === 0x5341 ||\n    code_point === 0x5345\n  ) {\n    return index_.lastIndexOf(code_point);\n  }\n\n  // 3. Return the index pointer for code point in index.\n  return indexPointerFor(code_point, index_);\n}\nvar big5_index_no_hkscs;\n\n//\n// 8. API\n//\n\n/** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n// 8.1 Interface TextDecoder\n\n/**\n * @constructor\n * @param {string=} label The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextDecoder(label, options) {\n  // Web IDL conventions\n  if (!(this instanceof TextDecoder))\n    throw TypeError(\"Called as a function. Did you forget 'new'?\");\n  label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n  options = ToDictionary(options);\n\n  // A TextDecoder object has an associated encoding, decoder,\n  // stream, ignore BOM flag (initially unset), BOM seen flag\n  // (initially unset), error mode (initially replacement), and do\n  // not flush flag (initially unset).\n\n  /** @private */\n  this._encoding = null;\n  /** @private @type {?Decoder} */\n  this._decoder = null;\n  /** @private @type {boolean} */\n  this._ignoreBOM = false;\n  /** @private @type {boolean} */\n  this._BOMseen = false;\n  /** @private @type {string} */\n  this._error_mode = 'replacement';\n  /** @private @type {boolean} */\n  this._do_not_flush = false;\n\n  // 1. Let encoding be the result of getting an encoding from\n  // label.\n  var encoding = getEncoding(label);\n\n  // 2. If encoding is failure or replacement, throw a RangeError.\n  if (encoding === null || encoding.name === 'replacement')\n    throw RangeError('Unknown encoding: ' + label);\n  if (!decoders[encoding.name]) {\n    throw Error('Decoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n  }\n\n  // 3. Let dec be a new TextDecoder object.\n  var dec = this;\n\n  // 4. Set dec's encoding to encoding.\n  dec._encoding = encoding;\n\n  // 5. If options's fatal member is true, set dec's error mode to\n  // fatal.\n  if (Boolean(options['fatal'])) dec._error_mode = 'fatal';\n\n  // 6. If options's ignoreBOM member is true, set dec's ignore BOM\n  // flag.\n  if (Boolean(options['ignoreBOM'])) dec._ignoreBOM = true;\n\n  // For pre-ES5 runtimes:\n  if (!Object.defineProperty) {\n    this.encoding = dec._encoding.name.toLowerCase();\n    this.fatal = dec._error_mode === 'fatal';\n    this.ignoreBOM = dec._ignoreBOM;\n  }\n\n  // 7. Return dec.\n  return dec;\n}\n\nif (Object.defineProperty) {\n  // The encoding attribute's getter must return encoding's name.\n  Object.defineProperty(TextDecoder.prototype, 'encoding', {\n    /** @this {TextDecoder} */\n    get: function() {\n      return this._encoding.name.toLowerCase();\n    }\n  });\n\n  // The fatal attribute's getter must return true if error mode\n  // is fatal, and false otherwise.\n  Object.defineProperty(TextDecoder.prototype, 'fatal', {\n    /** @this {TextDecoder} */\n    get: function() {\n      return this._error_mode === 'fatal';\n    }\n  });\n\n  // The ignoreBOM attribute's getter must return true if ignore\n  // BOM flag is set, and false otherwise.\n  Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {\n    /** @this {TextDecoder} */\n    get: function() {\n      return this._ignoreBOM;\n    }\n  });\n}\n\n/**\n * @param {BufferSource=} input The buffer of bytes to decode.\n * @param {Object=} options\n * @return {string} The decoded string.\n */\nTextDecoder.prototype.decode = function decode(input, options) {\n  var bytes;\n  if (typeof input === 'object' && input instanceof ArrayBuffer) {\n    bytes = new Uint8Array(input);\n  } else if (\n    typeof input === 'object' &&\n    'buffer' in input &&\n    input.buffer instanceof ArrayBuffer\n  ) {\n    bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);\n  } else {\n    bytes = new Uint8Array(0);\n  }\n\n  options = ToDictionary(options);\n\n  // 1. If the do not flush flag is unset, set decoder to a new\n  // encoding's decoder, set stream to a new stream, and unset the\n  // BOM seen flag.\n  if (!this._do_not_flush) {\n    this._decoder = decoders[this._encoding.name]({\n      fatal: this._error_mode === 'fatal'\n    });\n    this._BOMseen = false;\n  }\n\n  // 2. If options's stream is true, set the do not flush flag, and\n  // unset the do not flush flag otherwise.\n  this._do_not_flush = Boolean(options['stream']);\n\n  // 3. If input is given, push a copy of input to stream.\n  // TODO: Align with spec algorithm - maintain stream on instance.\n  var input_stream = new Stream(bytes);\n\n  // 4. Let output be a new stream.\n  var output = [];\n\n  /** @type {?(number|!Array.<number>)} */\n  var result;\n\n  // 5. While true:\n  while (true) {\n    // 1. Let token be the result of reading from stream.\n    var token = input_stream.read();\n\n    // 2. If token is end-of-stream and the do not flush flag is\n    // set, return output, serialized.\n    // TODO: Align with spec algorithm.\n    if (token === end_of_stream) break;\n\n    // 3. Otherwise, run these subsubsteps:\n\n    // 1. Let result be the result of processing token for decoder,\n    // stream, output, and error mode.\n    result = this._decoder.handler(input_stream, token);\n\n    // 2. If result is finished, return output, serialized.\n    if (result === finished) break;\n\n    if (result !== null) {\n      if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/ (result));\n      else output.push(result);\n    }\n\n    // 3. Otherwise, if result is error, throw a TypeError.\n    // (Thrown in handler)\n\n    // 4. Otherwise, do nothing.\n  }\n  // TODO: Align with spec algorithm.\n  if (!this._do_not_flush) {\n    do {\n      result = this._decoder.handler(input_stream, input_stream.read());\n      if (result === finished) break;\n      if (result === null) continue;\n      if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/ (result));\n      else output.push(result);\n    } while (!input_stream.endOfStream());\n    this._decoder = null;\n  }\n\n  // A TextDecoder object also has an associated serialize stream\n  // algorithm...\n  /**\n   * @param {!Array.<number>} stream\n   * @return {string}\n   * @this {TextDecoder}\n   */\n  function serializeStream(stream) {\n    // 1. Let token be the result of reading from stream.\n    // (Done in-place on array, rather than as a stream)\n\n    // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n    // BOM flag and BOM seen flag are unset, run these subsubsteps:\n    if (\n      includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) &&\n      !this._ignoreBOM &&\n      !this._BOMseen\n    ) {\n      if (stream.length > 0 && stream[0] === 0xfeff) {\n        // 1. If token is U+FEFF, set BOM seen flag.\n        this._BOMseen = true;\n        stream.shift();\n      } else if (stream.length > 0) {\n        // 2. Otherwise, if token is not end-of-stream, set BOM seen\n        // flag and append token to stream.\n        this._BOMseen = true;\n      } else {\n        // 3. Otherwise, if token is not end-of-stream, append token\n        // to output.\n        // (no-op)\n      }\n    }\n    // 4. Otherwise, return output.\n    return codePointsToString(stream);\n  }\n\n  return serializeStream.call(this, output);\n};\n\n// 8.2 Interface TextEncoder\n\n/**\n * @constructor\n * @param {string=} label The label of the encoding. NONSTANDARD.\n * @param {Object=} options NONSTANDARD.\n */\nfunction TextEncoder(label, options) {\n  // Web IDL conventions\n  if (!(this instanceof TextEncoder))\n    throw TypeError(\"Called as a function. Did you forget 'new'?\");\n  options = ToDictionary(options);\n\n  // A TextEncoder object has an associated encoding and encoder.\n\n  /** @private */\n  this._encoding = null;\n  /** @private @type {?Encoder} */\n  this._encoder = null;\n\n  // Non-standard\n  /** @private @type {boolean} */\n  this._do_not_flush = false;\n  /** @private @type {string} */\n  this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';\n\n  // 1. Let enc be a new TextEncoder object.\n  var enc = this;\n\n  // 2. Set enc's encoding to UTF-8's encoder.\n  if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {\n    // NONSTANDARD behavior.\n    label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n    var encoding = getEncoding(label);\n    if (encoding === null || encoding.name === 'replacement')\n      throw RangeError('Unknown encoding: ' + label);\n    if (!encoders[encoding.name]) {\n      throw Error('Encoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n    }\n    enc._encoding = encoding;\n  } else {\n    // Standard behavior.\n    enc._encoding = getEncoding('utf-8');\n\n    if (label !== undefined && 'console' in global) {\n      console.warn('TextEncoder constructor called with encoding label, ' + 'which is ignored.');\n    }\n  }\n\n  // For pre-ES5 runtimes:\n  if (!Object.defineProperty) this.encoding = enc._encoding.name.toLowerCase();\n\n  // 3. Return enc.\n  return enc;\n}\n\nif (Object.defineProperty) {\n  // The encoding attribute's getter must return encoding's name.\n  Object.defineProperty(TextEncoder.prototype, 'encoding', {\n    /** @this {TextEncoder} */\n    get: function() {\n      return this._encoding.name.toLowerCase();\n    }\n  });\n}\n\n/**\n * @param {string=} opt_string The string to encode.\n * @param {Object=} options\n * @return {!Uint8Array} Encoded bytes, as a Uint8Array.\n */\nTextEncoder.prototype.encode = function encode(opt_string, options) {\n  opt_string = opt_string === undefined ? '' : String(opt_string);\n  options = ToDictionary(options);\n\n  // NOTE: This option is nonstandard. None of the encodings\n  // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when\n  // the input is a USVString so streaming is not necessary.\n  if (!this._do_not_flush)\n    this._encoder = encoders[this._encoding.name]({\n      fatal: this._fatal === 'fatal'\n    });\n  this._do_not_flush = Boolean(options['stream']);\n\n  // 1. Convert input to a stream.\n  var input = new Stream(stringToCodePoints(opt_string));\n\n  // 2. Let output be a new stream\n  var output = [];\n\n  /** @type {?(number|!Array.<number>)} */\n  var result;\n  // 3. While true, run these substeps:\n  while (true) {\n    // 1. Let token be the result of reading from input.\n    var token = input.read();\n    if (token === end_of_stream) break;\n    // 2. Let result be the result of processing token for encoder,\n    // input, output.\n    result = this._encoder.handler(input, token);\n    if (result === finished) break;\n    if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/ (result));\n    else output.push(result);\n  }\n  // TODO: Align with spec algorithm.\n  if (!this._do_not_flush) {\n    while (true) {\n      result = this._encoder.handler(input, input.read());\n      if (result === finished) break;\n      if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/ (result));\n      else output.push(result);\n    }\n    this._encoder = null;\n  }\n  // 3. If result is finished, convert output into a byte sequence,\n  // and then return a Uint8Array object wrapping an ArrayBuffer\n  // containing output.\n  return new Uint8Array(output);\n};\n\n//\n// 9. The encoding\n//\n\n// 9.1 utf-8\n\n// 9.1.1 utf-8 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Decoder(options) {\n  var fatal = options.fatal;\n\n  // utf-8's decoder's has an associated utf-8 code point, utf-8\n  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n  // lower boundary (initially 0x80), and a utf-8 upper boundary\n  // (initially 0xBF).\n  var /** @type {number} */ utf8_code_point = 0,\n    /** @type {number} */ utf8_bytes_seen = 0,\n    /** @type {number} */ utf8_bytes_needed = 0,\n    /** @type {number} */ utf8_lower_boundary = 0x80,\n    /** @type {number} */ utf8_upper_boundary = 0xbf;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n    // set utf-8 bytes needed to 0 and return error.\n    if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n      utf8_bytes_needed = 0;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream) return finished;\n\n    // 3. If utf-8 bytes needed is 0, based on byte:\n    if (utf8_bytes_needed === 0) {\n      // 0x00 to 0x7F\n      if (inRange(bite, 0x00, 0x7f)) {\n        // Return a code point whose value is byte.\n        return bite;\n      }\n\n      // 0xC2 to 0xDF\n      else if (inRange(bite, 0xc2, 0xdf)) {\n        // 1. Set utf-8 bytes needed to 1.\n        utf8_bytes_needed = 1;\n\n        // 2. Set UTF-8 code point to byte & 0x1F.\n        utf8_code_point = bite & 0x1f;\n      }\n\n      // 0xE0 to 0xEF\n      else if (inRange(bite, 0xe0, 0xef)) {\n        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (bite === 0xe0) utf8_lower_boundary = 0xa0;\n        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (bite === 0xed) utf8_upper_boundary = 0x9f;\n        // 3. Set utf-8 bytes needed to 2.\n        utf8_bytes_needed = 2;\n        // 4. Set UTF-8 code point to byte & 0xF.\n        utf8_code_point = bite & 0xf;\n      }\n\n      // 0xF0 to 0xF4\n      else if (inRange(bite, 0xf0, 0xf4)) {\n        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (bite === 0xf0) utf8_lower_boundary = 0x90;\n        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (bite === 0xf4) utf8_upper_boundary = 0x8f;\n        // 3. Set utf-8 bytes needed to 3.\n        utf8_bytes_needed = 3;\n        // 4. Set UTF-8 code point to byte & 0x7.\n        utf8_code_point = bite & 0x7;\n      }\n\n      // Otherwise\n      else {\n        // Return error.\n        return decoderError(fatal);\n      }\n\n      // Return continue.\n      return null;\n    }\n\n    // 4. If byte is not in the range utf-8 lower boundary to utf-8\n    // upper boundary, inclusive, run these substeps:\n    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n      // utf-8 upper boundary to 0xBF.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xbf;\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite);\n\n      // 3. Return error.\n      return decoderError(fatal);\n    }\n\n    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n    // to 0xBF.\n    utf8_lower_boundary = 0x80;\n    utf8_upper_boundary = 0xbf;\n\n    // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n    // 0x3F)\n    utf8_code_point = (utf8_code_point << 6) | (bite & 0x3f);\n\n    // 7. Increase utf-8 bytes seen by one.\n    utf8_bytes_seen += 1;\n\n    // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n    // continue.\n    if (utf8_bytes_seen !== utf8_bytes_needed) return null;\n\n    // 9. Let code point be utf-8 code point.\n    var code_point = utf8_code_point;\n\n    // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n    // seen to 0.\n    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n    // 11. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n// 9.1.2 utf-8 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Set count and offset based on the range code point is in:\n    var count, offset;\n    // U+0080 to U+07FF, inclusive:\n    if (inRange(code_point, 0x0080, 0x07ff)) {\n      // 1 and 0xC0\n      count = 1;\n      offset = 0xc0;\n    }\n    // U+0800 to U+FFFF, inclusive:\n    else if (inRange(code_point, 0x0800, 0xffff)) {\n      // 2 and 0xE0\n      count = 2;\n      offset = 0xe0;\n    }\n    // U+10000 to U+10FFFF, inclusive:\n    else if (inRange(code_point, 0x10000, 0x10ffff)) {\n      // 3 and 0xF0\n      count = 3;\n      offset = 0xf0;\n    }\n\n    // 4. Let bytes be a byte sequence whose first byte is (code\n    // point >> (6 × count)) + offset.\n    var bytes = [(code_point >> (6 * count)) + offset];\n\n    // 5. Run these substeps while count is greater than 0:\n    while (count > 0) {\n      // 1. Set temp to code point >> (6 × (count − 1)).\n      var temp = code_point >> (6 * (count - 1));\n\n      // 2. Append to bytes 0x80 | (temp & 0x3F).\n      bytes.push(0x80 | (temp & 0x3f));\n\n      // 3. Decrease count by one.\n      count -= 1;\n    }\n\n    // 6. Return bytes bytes, in order.\n    return bytes;\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['UTF-8'] = function(options) {\n  return new UTF8Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['UTF-8'] = function(options) {\n  return new UTF8Decoder(options);\n};\n\n//\n// 10. Legacy single-byte encodings\n//\n\n// 10.1 single-byte decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {!Array.<number>} index The encoding index.\n * @param {{fatal: boolean}} options\n */\nfunction SingleByteDecoder(index, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream) return finished;\n\n    // 2. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 3. Let code point be the index code point for byte − 0x80 in\n    // index single-byte.\n    var code_point = index[bite - 0x80];\n\n    // 4. If code point is null, return error.\n    if (code_point === null) return decoderError(fatal);\n\n    // 5. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n// 10.2 single-byte encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {!Array.<?number>} index The encoding index.\n * @param {{fatal: boolean}} options\n */\nfunction SingleByteEncoder(index, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Let pointer be the index pointer for code point in index\n    // single-byte.\n    var pointer = indexPointerFor(code_point, index);\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null) encoderError(code_point);\n\n    // 5. Return a byte whose value is pointer + 0x80.\n    return pointer + 0x80;\n  };\n}\n\n(function() {\n  if (!('encoding-indexes' in global)) return;\n  encodings.forEach(function(category) {\n    if (category.heading !== 'Legacy single-byte encodings') return;\n    category.encodings.forEach(function(encoding) {\n      var name = encoding.name;\n      var idx = index(name.toLowerCase());\n      /** @param {{fatal: boolean}} options */\n      decoders[name] = function(options) {\n        return new SingleByteDecoder(idx, options);\n      };\n      /** @param {{fatal: boolean}} options */\n      encoders[name] = function(options) {\n        return new SingleByteEncoder(idx, options);\n      };\n    });\n  });\n})();\n\n//\n// 11. Legacy multi-byte Chinese (simplified) encodings\n//\n\n// 11.1 gbk\n\n// 11.1.1 gbk decoder\n// gbk's decoder is gb18030's decoder.\n/** @param {{fatal: boolean}} options */\ndecoders['GBK'] = function(options) {\n  return new GB18030Decoder(options);\n};\n\n// 11.1.2 gbk encoder\n// gbk's encoder is gb18030's encoder with its gbk flag set.\n/** @param {{fatal: boolean}} options */\nencoders['GBK'] = function(options) {\n  return new GB18030Encoder(options, true);\n};\n\n// 11.2 gb18030\n\n// 11.2.1 gb18030 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction GB18030Decoder(options) {\n  var fatal = options.fatal;\n  // gb18030's decoder has an associated gb18030 first, gb18030\n  // second, and gb18030 third (all initially 0x00).\n  var /** @type {number} */ gb18030_first = 0x00,\n    /** @type {number} */ gb18030_second = 0x00,\n    /** @type {number} */ gb18030_third = 0x00;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and gb18030 first, gb18030\n    // second, and gb18030 third are 0x00, return finished.\n    if (\n      bite === end_of_stream &&\n      gb18030_first === 0x00 &&\n      gb18030_second === 0x00 &&\n      gb18030_third === 0x00\n    ) {\n      return finished;\n    }\n    // 2. If byte is end-of-stream, and gb18030 first, gb18030\n    // second, or gb18030 third is not 0x00, set gb18030 first,\n    // gb18030 second, and gb18030 third to 0x00, and return error.\n    if (\n      bite === end_of_stream &&\n      (gb18030_first !== 0x00 || gb18030_second !== 0x00 || gb18030_third !== 0x00)\n    ) {\n      gb18030_first = 0x00;\n      gb18030_second = 0x00;\n      gb18030_third = 0x00;\n      decoderError(fatal);\n    }\n    var code_point;\n    // 3. If gb18030 third is not 0x00, run these substeps:\n    if (gb18030_third !== 0x00) {\n      // 1. Let code point be null.\n      code_point = null;\n      // 2. If byte is in the range 0x30 to 0x39, inclusive, set\n      // code point to the index gb18030 ranges code point for\n      // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×\n      // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.\n      if (inRange(bite, 0x30, 0x39)) {\n        code_point = indexGB18030RangesCodePointFor(\n          (((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 + gb18030_third - 0x81) *\n            10 +\n            bite -\n            0x30\n        );\n      }\n\n      // 3. Let buffer be a byte sequence consisting of gb18030\n      // second, gb18030 third, and byte, in order.\n      var buffer = [gb18030_second, gb18030_third, bite];\n\n      // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n      // 0x00.\n      gb18030_first = 0x00;\n      gb18030_second = 0x00;\n      gb18030_third = 0x00;\n\n      // 5. If code point is null, prepend buffer to stream and\n      // return error.\n      if (code_point === null) {\n        stream.prepend(buffer);\n        return decoderError(fatal);\n      }\n\n      // 6. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If gb18030 second is not 0x00, run these substeps:\n    if (gb18030_second !== 0x00) {\n      // 1. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // gb18030 third to byte and return continue.\n      if (inRange(bite, 0x81, 0xfe)) {\n        gb18030_third = bite;\n        return null;\n      }\n\n      // 2. Prepend gb18030 second followed by byte to stream, set\n      // gb18030 first and gb18030 second to 0x00, and return error.\n      stream.prepend([gb18030_second, bite]);\n      gb18030_first = 0x00;\n      gb18030_second = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 5. If gb18030 first is not 0x00, run these substeps:\n    if (gb18030_first !== 0x00) {\n      // 1. If byte is in the range 0x30 to 0x39, inclusive, set\n      // gb18030 second to byte and return continue.\n      if (inRange(bite, 0x30, 0x39)) {\n        gb18030_second = bite;\n        return null;\n      }\n\n      // 2. Let lead be gb18030 first, let pointer be null, and set\n      // gb18030 first to 0x00.\n      var lead = gb18030_first;\n      var pointer = null;\n      gb18030_first = 0x00;\n\n      // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n      // otherwise.\n      var offset = bite < 0x7f ? 0x40 : 0x41;\n\n      // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n      // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +\n      // (byte − offset).\n      if (inRange(bite, 0x40, 0x7e) || inRange(bite, 0x80, 0xfe))\n        pointer = (lead - 0x81) * 190 + (bite - offset);\n\n      // 5. Let code point be null if pointer is null and the index\n      // code point for pointer in index gb18030 otherwise.\n      code_point = pointer === null ? null : indexCodePointFor(pointer, index('gb18030'));\n\n      // 6. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 7. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 8. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 6. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 7. If byte is 0x80, return code point U+20AC.\n    if (bite === 0x80) return 0x20ac;\n\n    // 8. If byte is in the range 0x81 to 0xFE, inclusive, set\n    // gb18030 first to byte and return continue.\n    if (inRange(bite, 0x81, 0xfe)) {\n      gb18030_first = bite;\n      return null;\n    }\n\n    // 9. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 11.2.2 gb18030 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n * @param {boolean=} gbk_flag\n */\nfunction GB18030Encoder(options, gbk_flag) {\n  var fatal = options.fatal;\n  // gb18030's decoder has an associated gbk flag (initially unset).\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. If code point is U+E5E5, return error with code point.\n    if (code_point === 0xe5e5) return encoderError(code_point);\n\n    // 4. If the gbk flag is set and code point is U+20AC, return\n    // byte 0x80.\n    if (gbk_flag && code_point === 0x20ac) return 0x80;\n\n    // 5. Let pointer be the index pointer for code point in index\n    // gb18030.\n    var pointer = indexPointerFor(code_point, index('gb18030'));\n\n    // 6. If pointer is not null, run these substeps:\n    if (pointer !== null) {\n      // 1. Let lead be floor(pointer / 190) + 0x81.\n      var lead = floor(pointer / 190) + 0x81;\n\n      // 2. Let trail be pointer % 190.\n      var trail = pointer % 190;\n\n      // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n      var offset = trail < 0x3f ? 0x40 : 0x41;\n\n      // 4. Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset];\n    }\n\n    // 7. If gbk flag is set, return error with code point.\n    if (gbk_flag) return encoderError(code_point);\n\n    // 8. Set pointer to the index gb18030 ranges pointer for code\n    // point.\n    pointer = indexGB18030RangesPointerFor(code_point);\n\n    // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n    var byte1 = floor(pointer / 10 / 126 / 10);\n\n    // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.\n    pointer = pointer - byte1 * 10 * 126 * 10;\n\n    // 11. Let byte2 be floor(pointer / 10 / 126).\n    var byte2 = floor(pointer / 10 / 126);\n\n    // 12. Set pointer to pointer − byte2 × 10 × 126.\n    pointer = pointer - byte2 * 10 * 126;\n\n    // 13. Let byte3 be floor(pointer / 10).\n    var byte3 = floor(pointer / 10);\n\n    // 14. Let byte4 be pointer − byte3 × 10.\n    var byte4 = pointer - byte3 * 10;\n\n    // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n    // 0x30, byte3 + 0x81, byte4 + 0x30.\n    return [byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['gb18030'] = function(options) {\n  return new GB18030Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['gb18030'] = function(options) {\n  return new GB18030Decoder(options);\n};\n\n//\n// 12. Legacy multi-byte Chinese (traditional) encodings\n//\n\n// 12.1 Big5\n\n// 12.1.1 Big5 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction Big5Decoder(options) {\n  var fatal = options.fatal;\n  // Big5's decoder has an associated Big5 lead (initially 0x00).\n  var /** @type {number} */ Big5_lead = 0x00;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and Big5 lead is not 0x00, set\n    // Big5 lead to 0x00 and return error.\n    if (bite === end_of_stream && Big5_lead !== 0x00) {\n      Big5_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and Big5 lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && Big5_lead === 0x00) return finished;\n\n    // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let\n    // pointer be null, set Big5 lead to 0x00, and then run these\n    // substeps:\n    if (Big5_lead !== 0x00) {\n      var lead = Big5_lead;\n      var pointer = null;\n      Big5_lead = 0x00;\n\n      // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n      // otherwise.\n      var offset = bite < 0x7f ? 0x40 : 0x62;\n\n      // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1\n      // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +\n      // (byte − offset).\n      if (inRange(bite, 0x40, 0x7e) || inRange(bite, 0xa1, 0xfe))\n        pointer = (lead - 0x81) * 157 + (bite - offset);\n\n      // 3. If there is a row in the table below whose first column\n      // is pointer, return the two code points listed in its second\n      // column\n      // Pointer | Code points\n      // --------+--------------\n      // 1133    | U+00CA U+0304\n      // 1135    | U+00CA U+030C\n      // 1164    | U+00EA U+0304\n      // 1166    | U+00EA U+030C\n      switch (pointer) {\n        case 1133:\n          return [0x00ca, 0x0304];\n        case 1135:\n          return [0x00ca, 0x030c];\n        case 1164:\n          return [0x00ea, 0x0304];\n        case 1166:\n          return [0x00ea, 0x030c];\n      }\n\n      // 4. Let code point be null if pointer is null and the index\n      // code point for pointer in index Big5 otherwise.\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, index('big5'));\n\n      // 5. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 6. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 7. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5\n    // lead to byte and return continue.\n    if (inRange(bite, 0x81, 0xfe)) {\n      Big5_lead = bite;\n      return null;\n    }\n\n    // 6. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 12.1.2 Big5 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction Big5Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Let pointer be the index Big5 pointer for code point.\n    var pointer = indexBig5PointerFor(code_point);\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 5. Let lead be floor(pointer / 157) + 0x81.\n    var lead = floor(pointer / 157) + 0x81;\n\n    // 6. If lead is less than 0xA1, return error with code point.\n    if (lead < 0xa1) return encoderError(code_point);\n\n    // 7. Let trail be pointer % 157.\n    var trail = pointer % 157;\n\n    // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n    // otherwise.\n    var offset = trail < 0x3f ? 0x40 : 0x62;\n\n    // Return two bytes whose values are lead and trail + offset.\n    return [lead, trail + offset];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['Big5'] = function(options) {\n  return new Big5Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['Big5'] = function(options) {\n  return new Big5Decoder(options);\n};\n\n//\n// 13. Legacy multi-byte Japanese encodings\n//\n\n// 13.1 euc-jp\n\n// 13.1.1 euc-jp decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCJPDecoder(options) {\n  var fatal = options.fatal;\n\n  // euc-jp's decoder has an associated euc-jp jis0212 flag\n  // (initially unset) and euc-jp lead (initially 0x00).\n  var /** @type {boolean} */ eucjp_jis0212_flag = false,\n    /** @type {number} */ eucjp_lead = 0x00;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n    // euc-jp lead to 0x00, and return error.\n    if (bite === end_of_stream && eucjp_lead !== 0x00) {\n      eucjp_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && eucjp_lead === 0x00) return finished;\n\n    // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n    // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code\n    // point whose value is 0xFF61 − 0xA1 + byte.\n    if (eucjp_lead === 0x8e && inRange(bite, 0xa1, 0xdf)) {\n      eucjp_lead = 0x00;\n      return 0xff61 - 0xa1 + bite;\n    }\n\n    // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n    // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead\n    // to byte, and return continue.\n    if (eucjp_lead === 0x8f && inRange(bite, 0xa1, 0xfe)) {\n      eucjp_jis0212_flag = true;\n      eucjp_lead = bite;\n      return null;\n    }\n\n    // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n    // euc-jp lead to 0x00, and run these substeps:\n    if (eucjp_lead !== 0x00) {\n      var lead = eucjp_lead;\n      eucjp_lead = 0x00;\n\n      // 1. Let code point be null.\n      var code_point = null;\n\n      // 2. If lead and byte are both in the range 0xA1 to 0xFE,\n      // inclusive, set code point to the index code point for (lead\n      // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp\n      // jis0212 flag is unset and in index jis0212 otherwise.\n      if (inRange(lead, 0xa1, 0xfe) && inRange(bite, 0xa1, 0xfe)) {\n        code_point = indexCodePointFor(\n          (lead - 0xa1) * 94 + (bite - 0xa1),\n          index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212')\n        );\n      }\n\n      // 3. Unset the euc-jp jis0212 flag.\n      eucjp_jis0212_flag = false;\n\n      // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,\n      // prepend byte to stream.\n      if (!inRange(bite, 0xa1, 0xfe)) stream.prepend(bite);\n\n      // 5. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 6. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 6. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,\n    // inclusive, set euc-jp lead to byte and return continue.\n    if (bite === 0x8e || bite === 0x8f || inRange(bite, 0xa1, 0xfe)) {\n      eucjp_lead = bite;\n      return null;\n    }\n\n    // 8. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 13.1.2 euc-jp encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCJPEncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. If code point is U+00A5, return byte 0x5C.\n    if (code_point === 0x00a5) return 0x5c;\n\n    // 4. If code point is U+203E, return byte 0x7E.\n    if (code_point === 0x203e) return 0x7e;\n\n    // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n    // return two bytes whose values are 0x8E and code point −\n    // 0xFF61 + 0xA1.\n    if (inRange(code_point, 0xff61, 0xff9f)) return [0x8e, code_point - 0xff61 + 0xa1];\n\n    // 6. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xff0d;\n\n    // 7. Let pointer be the index pointer for code point in index\n    // jis0208.\n    var pointer = indexPointerFor(code_point, index('jis0208'));\n\n    // 8. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 9. Let lead be floor(pointer / 94) + 0xA1.\n    var lead = floor(pointer / 94) + 0xa1;\n\n    // 10. Let trail be pointer % 94 + 0xA1.\n    var trail = (pointer % 94) + 0xa1;\n\n    // 11. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['EUC-JP'] = function(options) {\n  return new EUCJPEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['EUC-JP'] = function(options) {\n  return new EUCJPDecoder(options);\n};\n\n// 13.2 iso-2022-jp\n\n// 13.2.1 iso-2022-jp decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction ISO2022JPDecoder(options) {\n  var fatal = options.fatal;\n  /** @enum */\n  var states = {\n    ASCII: 0,\n    Roman: 1,\n    Katakana: 2,\n    LeadByte: 3,\n    TrailByte: 4,\n    EscapeStart: 5,\n    Escape: 6\n  };\n  // iso-2022-jp's decoder has an associated iso-2022-jp decoder\n  // state (initially ASCII), iso-2022-jp decoder output state\n  // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n  // iso-2022-jp output flag (initially unset).\n  var /** @type {number} */ iso2022jp_decoder_state = states.ASCII,\n    /** @type {number} */ iso2022jp_decoder_output_state = states.ASCII,\n    /** @type {number} */ iso2022jp_lead = 0x00,\n    /** @type {boolean} */ iso2022jp_output_flag = false;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // switching on iso-2022-jp decoder state:\n    switch (iso2022jp_decoder_state) {\n      default:\n      case states.ASCII:\n        // ASCII\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n        if (inRange(bite, 0x00, 0x7f) && bite !== 0x0e && bite !== 0x0f && bite !== 0x1b) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Roman:\n        // Roman\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x5C\n        if (bite === 0x5c) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+00A5.\n          iso2022jp_output_flag = false;\n          return 0x00a5;\n        }\n\n        // 0x7E\n        if (bite === 0x7e) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+203E.\n          iso2022jp_output_flag = false;\n          return 0x203e;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n        if (\n          inRange(bite, 0x00, 0x7f) &&\n          bite !== 0x0e &&\n          bite !== 0x0f &&\n          bite !== 0x1b &&\n          bite !== 0x5c &&\n          bite !== 0x7e\n        ) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Katakana:\n        // Katakana\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x5F\n        if (inRange(bite, 0x21, 0x5f)) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is 0xFF61 − 0x21 + byte.\n          iso2022jp_output_flag = false;\n          return 0xff61 - 0x21 + bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.LeadByte:\n        // Lead byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7e)) {\n          // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n          // to byte, iso-2022-jp decoder state to trail byte, and\n          // return continue.\n          iso2022jp_output_flag = false;\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.TrailByte;\n          return null;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.TrailByte:\n        // Trail byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return decoderError(fatal);\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7e)) {\n          // 1. Set the iso-2022-jp decoder state to lead byte.\n          iso2022jp_decoder_state = states.LeadByte;\n\n          // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.\n          var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;\n\n          // 3. Let code point be the index code point for pointer in\n          // index jis0208.\n          var code_point = indexCodePointFor(pointer, index('jis0208'));\n\n          // 4. If code point is null, return error.\n          if (code_point === null) return decoderError(fatal);\n\n          // 5. Return a code point whose value is code point.\n          return code_point;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Set the iso-2022-jp decoder state to lead byte, prepend\n          // byte to stream, and return error.\n          iso2022jp_decoder_state = states.LeadByte;\n          stream.prepend(bite);\n          return decoderError(fatal);\n        }\n\n        // Otherwise\n        // Set iso-2022-jp decoder state to lead byte and return\n        // error.\n        iso2022jp_decoder_state = states.LeadByte;\n        return decoderError(fatal);\n\n      case states.EscapeStart:\n        // Escape start\n\n        // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n        // byte, iso-2022-jp decoder state to escape, and return\n        // continue.\n        if (bite === 0x24 || bite === 0x28) {\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.Escape;\n          return null;\n        }\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state, and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n\n      case states.Escape:\n        // Escape\n\n        // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n        // 0x00.\n        var lead = iso2022jp_lead;\n        iso2022jp_lead = 0x00;\n\n        // 2. Let state be null.\n        var state = null;\n\n        // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n        if (lead === 0x28 && bite === 0x42) state = states.ASCII;\n\n        // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n        if (lead === 0x28 && bite === 0x4a) state = states.Roman;\n\n        // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n        if (lead === 0x28 && bite === 0x49) state = states.Katakana;\n\n        // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n        // state to lead byte.\n        if (lead === 0x24 && (bite === 0x40 || bite === 0x42)) state = states.LeadByte;\n\n        // 7. If state is non-null, run these substeps:\n        if (state !== null) {\n          // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n          // output state to states.\n          iso2022jp_decoder_state = iso2022jp_decoder_state = state;\n\n          // 2. Let output flag be the iso-2022-jp output flag.\n          var output_flag = iso2022jp_output_flag;\n\n          // 3. Set the iso-2022-jp output flag.\n          iso2022jp_output_flag = true;\n\n          // 4. Return continue, if output flag is unset, and error\n          // otherwise.\n          return !output_flag ? null : decoderError(fatal);\n        }\n\n        // 8. Prepend lead and byte to stream.\n        stream.prepend([lead, bite]);\n\n        // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n    }\n  };\n}\n\n// 13.2.2 iso-2022-jp encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction ISO2022JPEncoder(options) {\n  var fatal = options.fatal;\n  // iso-2022-jp's encoder has an associated iso-2022-jp encoder\n  // state which is one of ASCII, Roman, and jis0208 (initially\n  // ASCII).\n  /** @enum */\n  var states = {\n    ASCII: 0,\n    Roman: 1,\n    jis0208: 2\n  };\n  var /** @type {number} */ iso2022jp_state = states.ASCII;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream and iso-2022-jp encoder\n    // state is not ASCII, prepend code point to stream, set\n    // iso-2022-jp encoder state to ASCII, and return three bytes\n    // 0x1B 0x28 0x42.\n    if (code_point === end_of_stream && iso2022jp_state !== states.ASCII) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.ASCII;\n      return [0x1b, 0x28, 0x42];\n    }\n\n    // 2. If code point is end-of-stream and iso-2022-jp encoder\n    // state is ASCII, return finished.\n    if (code_point === end_of_stream && iso2022jp_state === states.ASCII) return finished;\n\n    // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n    // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n    if (\n      (iso2022jp_state === states.ASCII || iso2022jp_state === states.Roman) &&\n      (code_point === 0x000e || code_point === 0x000f || code_point === 0x001b)\n    ) {\n      return encoderError(0xfffd);\n    }\n\n    // 4. If iso-2022-jp encoder state is ASCII and code point is an\n    // ASCII code point, return a byte whose value is code point.\n    if (iso2022jp_state === states.ASCII && isASCIICodePoint(code_point)) return code_point;\n\n    // 5. If iso-2022-jp encoder state is Roman and code point is an\n    // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n    // or U+203E, run these substeps:\n    if (\n      iso2022jp_state === states.Roman &&\n      ((isASCIICodePoint(code_point) && code_point !== 0x005c && code_point !== 0x007e) ||\n        (code_point == 0x00a5 || code_point == 0x203e))\n    ) {\n      // 1. If code point is an ASCII code point, return a byte\n      // whose value is code point.\n      if (isASCIICodePoint(code_point)) return code_point;\n\n      // 2. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00a5) return 0x5c;\n\n      // 3. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203e) return 0x7e;\n    }\n\n    // 6. If code point is an ASCII code point, and iso-2022-jp\n    // encoder state is not ASCII, prepend code point to stream, set\n    // iso-2022-jp encoder state to ASCII, and return three bytes\n    // 0x1B 0x28 0x42.\n    if (isASCIICodePoint(code_point) && iso2022jp_state !== states.ASCII) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.ASCII;\n      return [0x1b, 0x28, 0x42];\n    }\n\n    // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n    // encoder state is not Roman, prepend code point to stream, set\n    // iso-2022-jp encoder state to Roman, and return three bytes\n    // 0x1B 0x28 0x4A.\n    if ((code_point === 0x00a5 || code_point === 0x203e) && iso2022jp_state !== states.Roman) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.Roman;\n      return [0x1b, 0x28, 0x4a];\n    }\n\n    // 8. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xff0d;\n\n    // 9. Let pointer be the index pointer for code point in index\n    // jis0208.\n    var pointer = indexPointerFor(code_point, index('jis0208'));\n\n    // 10. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n    // point to stream, set iso-2022-jp encoder state to jis0208,\n    // and return three bytes 0x1B 0x24 0x42.\n    if (iso2022jp_state !== states.jis0208) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.jis0208;\n      return [0x1b, 0x24, 0x42];\n    }\n\n    // 12. Let lead be floor(pointer / 94) + 0x21.\n    var lead = floor(pointer / 94) + 0x21;\n\n    // 13. Let trail be pointer % 94 + 0x21.\n    var trail = (pointer % 94) + 0x21;\n\n    // 14. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['ISO-2022-JP'] = function(options) {\n  return new ISO2022JPEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['ISO-2022-JP'] = function(options) {\n  return new ISO2022JPDecoder(options);\n};\n\n// 13.3 Shift_JIS\n\n// 13.3.1 Shift_JIS decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction ShiftJISDecoder(options) {\n  var fatal = options.fatal;\n  // Shift_JIS's decoder has an associated Shift_JIS lead (initially\n  // 0x00).\n  var /** @type {number} */ Shift_JIS_lead = 0x00;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,\n    // set Shift_JIS lead to 0x00 and return error.\n    if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {\n      Shift_JIS_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,\n    // return finished.\n    if (bite === end_of_stream && Shift_JIS_lead === 0x00) return finished;\n\n    // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,\n    // let pointer be null, set Shift_JIS lead to 0x00, and then run\n    // these substeps:\n    if (Shift_JIS_lead !== 0x00) {\n      var lead = Shift_JIS_lead;\n      var pointer = null;\n      Shift_JIS_lead = 0x00;\n\n      // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n      // otherwise.\n      var offset = bite < 0x7f ? 0x40 : 0x41;\n\n      // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n      // 0xC1 otherwise.\n      var lead_offset = lead < 0xa0 ? 0x81 : 0xc1;\n\n      // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n      // to 0xFC, inclusive, set pointer to (lead − lead offset) ×\n      // 188 + byte − offset.\n      if (inRange(bite, 0x40, 0x7e) || inRange(bite, 0x80, 0xfc))\n        pointer = (lead - lead_offset) * 188 + bite - offset;\n\n      // 4. If pointer is in the range 8836 to 10715, inclusive,\n      // return a code point whose value is 0xE000 − 8836 + pointer.\n      if (inRange(pointer, 8836, 10715)) return 0xe000 - 8836 + pointer;\n\n      // 5. Let code point be null, if pointer is null, and the\n      // index code point for pointer in index jis0208 otherwise.\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, index('jis0208'));\n\n      // 6. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 7. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 8. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte or 0x80, return a code point\n    // whose value is byte.\n    if (isASCIIByte(bite) || bite === 0x80) return bite;\n\n    // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a\n    // code point whose value is 0xFF61 − 0xA1 + byte.\n    if (inRange(bite, 0xa1, 0xdf)) return 0xff61 - 0xa1 + bite;\n\n    // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0\n    // to 0xFC, inclusive, set Shift_JIS lead to byte and return\n    // continue.\n    if (inRange(bite, 0x81, 0x9f) || inRange(bite, 0xe0, 0xfc)) {\n      Shift_JIS_lead = bite;\n      return null;\n    }\n\n    // 7. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 13.3.2 Shift_JIS encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction ShiftJISEncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point or U+0080, return a\n    // byte whose value is code point.\n    if (isASCIICodePoint(code_point) || code_point === 0x0080) return code_point;\n\n    // 3. If code point is U+00A5, return byte 0x5C.\n    if (code_point === 0x00a5) return 0x5c;\n\n    // 4. If code point is U+203E, return byte 0x7E.\n    if (code_point === 0x203e) return 0x7e;\n\n    // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n    // return a byte whose value is code point − 0xFF61 + 0xA1.\n    if (inRange(code_point, 0xff61, 0xff9f)) return code_point - 0xff61 + 0xa1;\n\n    // 6. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xff0d;\n\n    // 7. Let pointer be the index Shift_JIS pointer for code point.\n    var pointer = indexShiftJISPointerFor(code_point);\n\n    // 8. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 9. Let lead be floor(pointer / 188).\n    var lead = floor(pointer / 188);\n\n    // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n    // 0xC1 otherwise.\n    var lead_offset = lead < 0x1f ? 0x81 : 0xc1;\n\n    // 11. Let trail be pointer % 188.\n    var trail = pointer % 188;\n\n    // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n    // otherwise.\n    var offset = trail < 0x3f ? 0x40 : 0x41;\n\n    // 13. Return two bytes whose values are lead + lead offset and\n    // trail + offset.\n    return [lead + lead_offset, trail + offset];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['Shift_JIS'] = function(options) {\n  return new ShiftJISEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['Shift_JIS'] = function(options) {\n  return new ShiftJISDecoder(options);\n};\n\n//\n// 14. Legacy multi-byte Korean encodings\n//\n\n// 14.1 euc-kr\n\n// 14.1.1 euc-kr decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCKRDecoder(options) {\n  var fatal = options.fatal;\n\n  // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\n  var /** @type {number} */ euckr_lead = 0x00;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n    // euc-kr lead to 0x00 and return error.\n    if (bite === end_of_stream && euckr_lead !== 0) {\n      euckr_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && euckr_lead === 0) return finished;\n\n    // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n    // pointer be null, set euc-kr lead to 0x00, and then run these\n    // substeps:\n    if (euckr_lead !== 0x00) {\n      var lead = euckr_lead;\n      var pointer = null;\n      euckr_lead = 0x00;\n\n      // 1. If byte is in the range 0x41 to 0xFE, inclusive, set\n      // pointer to (lead − 0x81) × 190 + (byte − 0x41).\n      if (inRange(bite, 0x41, 0xfe)) pointer = (lead - 0x81) * 190 + (bite - 0x41);\n\n      // 2. Let code point be null, if pointer is null, and the\n      // index code point for pointer in index euc-kr otherwise.\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, index('euc-kr'));\n\n      // 3. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (pointer === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 4. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 5. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 5. If byte is in the range 0x81 to 0xFE, inclusive, set\n    // euc-kr lead to byte and return continue.\n    if (inRange(bite, 0x81, 0xfe)) {\n      euckr_lead = bite;\n      return null;\n    }\n\n    // 6. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 14.1.2 euc-kr encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCKREncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Let pointer be the index pointer for code point in index\n    // euc-kr.\n    var pointer = indexPointerFor(code_point, index('euc-kr'));\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 5. Let lead be floor(pointer / 190) + 0x81.\n    var lead = floor(pointer / 190) + 0x81;\n\n    // 6. Let trail be pointer % 190 + 0x41.\n    var trail = (pointer % 190) + 0x41;\n\n    // 7. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['EUC-KR'] = function(options) {\n  return new EUCKREncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['EUC-KR'] = function(options) {\n  return new EUCKRDecoder(options);\n};\n\n//\n// 15. Legacy miscellaneous encodings\n//\n\n// 15.1 replacement\n\n// Not needed - API throws RangeError\n\n// 15.2 Common infrastructure for utf-16be and utf-16le\n\n/**\n * @param {number} code_unit\n * @param {boolean} utf16be\n * @return {!Array.<number>} bytes\n */\nfunction convertCodeUnitToBytes(code_unit, utf16be) {\n  // 1. Let byte1 be code unit >> 8.\n  var byte1 = code_unit >> 8;\n\n  // 2. Let byte2 be code unit & 0x00FF.\n  var byte2 = code_unit & 0x00ff;\n\n  // 3. Then return the bytes in order:\n  // utf-16be flag is set: byte1, then byte2.\n  if (utf16be) return [byte1, byte2];\n  // utf-16be flag is unset: byte2, then byte1.\n  return [byte2, byte1];\n}\n\n// 15.2.1 shared utf-16 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {boolean} utf16_be True if big-endian, false if little-endian.\n * @param {{fatal: boolean}} options\n */\nfunction UTF16Decoder(utf16_be, options) {\n  var fatal = options.fatal;\n  var /** @type {?number} */ utf16_lead_byte = null,\n    /** @type {?number} */ utf16_lead_surrogate = null;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and either utf-16 lead byte or\n    // utf-16 lead surrogate is not null, set utf-16 lead byte and\n    // utf-16 lead surrogate to null, and return error.\n    if (bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and utf-16 lead byte and utf-16\n    // lead surrogate are null, return finished.\n    if (bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {\n      return finished;\n    }\n\n    // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte\n    // and return continue.\n    if (utf16_lead_byte === null) {\n      utf16_lead_byte = bite;\n      return null;\n    }\n\n    // 4. Let code unit be the result of:\n    var code_unit;\n    if (utf16_be) {\n      // utf-16be decoder flag is set\n      //   (utf-16 lead byte << 8) + byte.\n      code_unit = (utf16_lead_byte << 8) + bite;\n    } else {\n      // utf-16be decoder flag is unset\n      //   (byte << 8) + utf-16 lead byte.\n      code_unit = (bite << 8) + utf16_lead_byte;\n    }\n    // Then set utf-16 lead byte to null.\n    utf16_lead_byte = null;\n\n    // 5. If utf-16 lead surrogate is not null, let lead surrogate\n    // be utf-16 lead surrogate, set utf-16 lead surrogate to null,\n    // and then run these substeps:\n    if (utf16_lead_surrogate !== null) {\n      var lead_surrogate = utf16_lead_surrogate;\n      utf16_lead_surrogate = null;\n\n      // 1. If code unit is in the range U+DC00 to U+DFFF,\n      // inclusive, return a code point whose value is 0x10000 +\n      // ((lead surrogate − 0xD800) << 10) + (code unit − 0xDC00).\n      if (inRange(code_unit, 0xdc00, 0xdfff)) {\n        return 0x10000 + (lead_surrogate - 0xd800) * 0x400 + (code_unit - 0xdc00);\n      }\n\n      // 2. Prepend the sequence resulting of converting code unit\n      // to bytes using utf-16be decoder flag to stream and return\n      // error.\n      stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));\n      return decoderError(fatal);\n    }\n\n    // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,\n    // set utf-16 lead surrogate to code unit and return continue.\n    if (inRange(code_unit, 0xd800, 0xdbff)) {\n      utf16_lead_surrogate = code_unit;\n      return null;\n    }\n\n    // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,\n    // return error.\n    if (inRange(code_unit, 0xdc00, 0xdfff)) return decoderError(fatal);\n\n    // 8. Return code point code unit.\n    return code_unit;\n  };\n}\n\n// 15.2.2 shared utf-16 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {boolean} utf16_be True if big-endian, false if little-endian.\n * @param {{fatal: boolean}} options\n */\nfunction UTF16Encoder(utf16_be, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is in the range U+0000 to U+FFFF, inclusive,\n    // return the sequence resulting of converting code point to\n    // bytes using utf-16be encoder flag.\n    if (inRange(code_point, 0x0000, 0xffff)) return convertCodeUnitToBytes(code_point, utf16_be);\n\n    // 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,\n    // converted to bytes using utf-16be encoder flag.\n    var lead = convertCodeUnitToBytes(((code_point - 0x10000) >> 10) + 0xd800, utf16_be);\n\n    // 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,\n    // converted to bytes using utf-16be encoder flag.\n    var trail = convertCodeUnitToBytes(((code_point - 0x10000) & 0x3ff) + 0xdc00, utf16_be);\n\n    // 5. Return a byte sequence of lead followed by trail.\n    return lead.concat(trail);\n  };\n}\n\n// 15.3 utf-16be\n// 15.3.1 utf-16be decoder\n/** @param {{fatal: boolean}} options */\nencoders['UTF-16BE'] = function(options) {\n  return new UTF16Encoder(true, options);\n};\n// 15.3.2 utf-16be encoder\n/** @param {{fatal: boolean}} options */\ndecoders['UTF-16BE'] = function(options) {\n  return new UTF16Decoder(true, options);\n};\n\n// 15.4 utf-16le\n// 15.4.1 utf-16le decoder\n/** @param {{fatal: boolean}} options */\nencoders['UTF-16LE'] = function(options) {\n  return new UTF16Encoder(false, options);\n};\n// 15.4.2 utf-16le encoder\n/** @param {{fatal: boolean}} options */\ndecoders['UTF-16LE'] = function(options) {\n  return new UTF16Decoder(false, options);\n};\n\n// 15.5 x-user-defined\n\n// 15.5.1 x-user-defined decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction XUserDefinedDecoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream) return finished;\n\n    // 2. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 3. Return a code point whose value is 0xF780 + byte − 0x80.\n    return 0xf780 + bite - 0x80;\n  };\n}\n\n// 15.5.2 x-user-defined encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction XUserDefinedEncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1.If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. If code point is in the range U+F780 to U+F7FF, inclusive,\n    // return a byte whose value is code point − 0xF780 + 0x80.\n    if (inRange(code_point, 0xf780, 0xf7ff)) return code_point - 0xf780 + 0x80;\n\n    // 4. Return error with code point.\n    return encoderError(code_point);\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['x-user-defined'] = function(options) {\n  return new XUserDefinedEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['x-user-defined'] = function(options) {\n  return new XUserDefinedDecoder(options);\n};\n\n// FORK\n// if (!global['TextEncoder']) global['TextEncoder'] = TextEncoder;\n// if (!global['TextDecoder']) global['TextDecoder'] = TextDecoder;\n// babel.config.js skip transpiling files in `libs/`\nmodule.exports = {TextEncoder, TextDecoder};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}