{"ast":null,"code":"import _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Vector3 } from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\nimport { INTERSECTION } from '../../constants';\nvar scratchVector = new Vector3();\nvar scratchVector2 = new Vector3();\nvar BoundingSphere = /*#__PURE__*/function () {\n  function BoundingSphere() {\n    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;\n    _classCallCheck(this, BoundingSphere);\n    _defineProperty(this, \"center\", void 0);\n    _defineProperty(this, \"radius\", void 0);\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n  _createClass(BoundingSphere, [{\n    key: \"fromCenterRadius\",\n    value: function fromCenterRadius(center, radius) {\n      this.center.from(center);\n      this.radius = radius;\n      return this;\n    }\n  }, {\n    key: \"fromCornerPoints\",\n    value: function fromCornerPoints(corner, oppositeCorner) {\n      oppositeCorner = scratchVector.from(oppositeCorner);\n      this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);\n      this.radius = this.center.distance(oppositeCorner);\n      return this;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new BoundingSphere(this.center, this.radius);\n    }\n  }, {\n    key: \"union\",\n    value: function union(boundingSphere) {\n      var leftCenter = this.center;\n      var leftRadius = this.radius;\n      var rightCenter = boundingSphere.center;\n      var rightRadius = boundingSphere.radius;\n      var toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n      var centerSeparation = toRightCenter.magnitude();\n      if (leftRadius >= centerSeparation + rightRadius) {\n        return this.clone();\n      }\n      if (rightRadius >= centerSeparation + leftRadius) {\n        return boundingSphere.clone();\n      }\n      var halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n      scratchVector2.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);\n      this.center.copy(scratchVector2);\n      this.radius = halfDistanceBetweenTangentPoints;\n      return this;\n    }\n  }, {\n    key: \"expand\",\n    value: function expand(point) {\n      var scratchPoint = scratchVector.from(point);\n      var radius = scratchPoint.subtract(this.center).magnitude();\n      if (radius > this.radius) {\n        this.radius = radius;\n      }\n      return this;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(_transform) {\n      this.center.transform(_transform);\n      var scale = mat4.getScaling(scratchVector, _transform);\n      this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n      return this;\n    }\n  }, {\n    key: \"distanceSquaredTo\",\n    value: function distanceSquaredTo(point) {\n      var d = this.distanceTo(point);\n      return d * d;\n    }\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(point) {\n      var scratchPoint = scratchVector.from(point);\n      var delta = scratchPoint.subtract(this.center);\n      return Math.max(0, delta.len() - this.radius);\n    }\n  }, {\n    key: \"intersectPlane\",\n    value: function intersectPlane(plane) {\n      var center = this.center;\n      var radius = this.radius;\n      var normal = plane.normal;\n      var distanceToPlane = normal.dot(center) + plane.distance;\n      if (distanceToPlane < -radius) {\n        return INTERSECTION.OUTSIDE;\n      }\n      if (distanceToPlane < radius) {\n        return INTERSECTION.INTERSECTING;\n      }\n      return INTERSECTION.INSIDE;\n    }\n  }]);\n  return BoundingSphere;\n}();\nexport { BoundingSphere as default };","map":{"version":3,"names":["Vector3","mat4","INTERSECTION","scratchVector","scratchVector2","BoundingSphere","center","arguments","length","undefined","radius","_classCallCheck","_defineProperty","fromCenterRadius","_createClass","key","value","from","fromCornerPoints","corner","oppositeCorner","add","scale","distance","equals","right","Boolean","clone","union","boundingSphere","leftCenter","leftRadius","rightCenter","rightRadius","toRightCenter","copy","subtract","centerSeparation","magnitude","halfDistanceBetweenTangentPoints","expand","point","scratchPoint","transform","getScaling","Math","max","distanceSquaredTo","d","distanceTo","delta","len","intersectPlane","plane","normal","distanceToPlane","dot","OUTSIDE","INTERSECTING","INSIDE","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@math.gl/culling/src/lib/bounding-volumes/bounding-sphere.ts"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {NumericArray, Vector3} from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\nimport {INTERSECTION} from '../../constants';\nimport {BoundingVolume} from './bounding-volume';\nimport Plane from '../plane';\n\nconst scratchVector = new Vector3();\nconst scratchVector2 = new Vector3();\n\n/** A BoundingSphere */\nexport default class BoundingSphere implements BoundingVolume {\n  center: Vector3;\n  radius: number;\n\n  /** Creates a bounding sphere */\n  constructor(center: readonly number[] = [0, 0, 0], radius: number = 0.0) {\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n\n  /** Sets the bounding sphere from `center` and `radius`. */\n  fromCenterRadius(center: readonly number[], radius: number): this {\n    this.center.from(center);\n    this.radius = radius;\n    return this;\n  }\n\n  /**\n   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n   * tightly and fully encompasses the box.\n   */\n  fromCornerPoints(corner: readonly number[], oppositeCorner: readonly number[]): this {\n    oppositeCorner = scratchVector.from(oppositeCorner);\n    this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);\n    this.radius = this.center.distance(oppositeCorner);\n    return this;\n  }\n\n  /** Compares the provided BoundingSphere component wise */\n  equals(right: BoundingSphere): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.radius === right.radius)\n    );\n  }\n\n  /** Duplicates a BoundingSphere instance. */\n  clone(): BoundingSphere {\n    return new BoundingSphere(this.center, this.radius);\n  }\n\n  /** Computes a bounding sphere that contains both the left and right bounding spheres. */\n  union(boundingSphere: BoundingSphere): BoundingSphere {\n    const leftCenter = this.center;\n    const leftRadius = this.radius;\n    const rightCenter = boundingSphere.center;\n    const rightRadius = boundingSphere.radius;\n\n    const toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n    const centerSeparation = toRightCenter.magnitude();\n\n    if (leftRadius >= centerSeparation + rightRadius) {\n      // Left sphere wins.\n      return this.clone();\n    }\n\n    if (rightRadius >= centerSeparation + leftRadius) {\n      // Right sphere wins.\n      return boundingSphere.clone();\n    }\n\n    // There are two tangent points, one on far side of each sphere.\n    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n    // Compute the center point halfway between the two tangent points.\n    scratchVector2\n      .copy(toRightCenter)\n      .scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation)\n      .add(leftCenter);\n\n    this.center.copy(scratchVector2);\n    this.radius = halfDistanceBetweenTangentPoints;\n\n    return this;\n  }\n\n  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */\n  expand(point: readonly number[]): this {\n    const scratchPoint = scratchVector.from(point);\n    const radius = scratchPoint.subtract(this.center).magnitude();\n    if (radius > this.radius) {\n      this.radius = radius;\n    }\n    return this;\n  }\n\n  // BoundingVolume interface\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param sphere The bounding sphere to apply the transformation to.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns self.\n   */\n  transform(transform: readonly number[]): this {\n    this.center.transform(transform);\n    const scale = mat4.getScaling(scratchVector, transform);\n    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n    return this;\n  }\n\n  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */\n  distanceSquaredTo(point: Readonly<NumericArray>): number {\n    const d = this.distanceTo(point);\n    return d * d;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */\n  distanceTo(point: Readonly<NumericArray>): number {\n    const scratchPoint = scratchVector.from(point);\n    const delta = scratchPoint.subtract(this.center);\n    return Math.max(0, delta.len() - this.radius);\n  }\n\n  /** Determines which side of a plane a sphere is located. */\n  intersectPlane(plane: Plane): number {\n    const center = this.center;\n    const radius = this.radius;\n    const normal = plane.normal;\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    // The center point is negative side of the plane normal\n    if (distanceToPlane < -radius) {\n      return INTERSECTION.OUTSIDE;\n    }\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    if (distanceToPlane < radius) {\n      return INTERSECTION.INTERSECTING;\n    }\n    // The center point and radius is positive side of the plane\n    return INTERSECTION.INSIDE;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}