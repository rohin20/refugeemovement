{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar defaultGetValue = function defaultGetValue(points) {\n  return points.length;\n};\nimport { clamp, getQuantileDomain, getOrdinalDomain } from './scale-utils';\nvar MAX_32_BIT_FLOAT = 3.402823466e38;\nvar defaultGetPoints = function defaultGetPoints(bin) {\n  return bin.points;\n};\nvar defaultGetIndex = function defaultGetIndex(bin) {\n  return bin.index;\n};\nvar ascending = function ascending(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n};\nvar defaultProps = {\n  getValue: defaultGetValue,\n  getPoints: defaultGetPoints,\n  getIndex: defaultGetIndex,\n  filterData: null\n};\nvar BinSorter = /*#__PURE__*/function () {\n  function BinSorter() {\n    var bins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultProps;\n    _classCallCheck(this, BinSorter);\n    this.aggregatedBins = this.getAggregatedBins(bins, props);\n    this._updateMinMaxValues();\n    this.binMap = this.getBinMap();\n  }\n  _createClass(BinSorter, [{\n    key: \"getAggregatedBins\",\n    value: function getAggregatedBins(bins, props) {\n      var _props$getValue = props.getValue,\n        getValue = _props$getValue === void 0 ? defaultGetValue : _props$getValue,\n        _props$getPoints = props.getPoints,\n        getPoints = _props$getPoints === void 0 ? defaultGetPoints : _props$getPoints,\n        _props$getIndex = props.getIndex,\n        getIndex = _props$getIndex === void 0 ? defaultGetIndex : _props$getIndex,\n        filterData = props.filterData;\n      var hasFilter = typeof filterData === 'function';\n      var binCount = bins.length;\n      var aggregatedBins = [];\n      var index = 0;\n      for (var binIndex = 0; binIndex < binCount; binIndex++) {\n        var bin = bins[binIndex];\n        var points = getPoints(bin);\n        var i = getIndex(bin);\n        var filteredPoints = hasFilter ? points.filter(filterData) : points;\n        bin.filteredPoints = hasFilter ? filteredPoints : null;\n        var value = filteredPoints.length ? getValue(filteredPoints) : null;\n        if (value !== null && value !== undefined) {\n          aggregatedBins[index] = {\n            i: Number.isFinite(i) ? i : binIndex,\n            value: value,\n            counts: filteredPoints.length\n          };\n          index++;\n        }\n      }\n      return aggregatedBins;\n    }\n  }, {\n    key: \"_percentileToIndex\",\n    value: function _percentileToIndex(percentileRange) {\n      var len = this.sortedBins.length;\n      if (len < 2) {\n        return [0, 0];\n      }\n      var _percentileRange$map = percentileRange.map(function (n) {\n          return clamp(n, 0, 100);\n        }),\n        _percentileRange$map2 = _slicedToArray(_percentileRange$map, 2),\n        lower = _percentileRange$map2[0],\n        upper = _percentileRange$map2[1];\n      var lowerIdx = Math.ceil(lower / 100 * (len - 1));\n      var upperIdx = Math.floor(upper / 100 * (len - 1));\n      return [lowerIdx, upperIdx];\n    }\n  }, {\n    key: \"getBinMap\",\n    value: function getBinMap() {\n      var binMap = {};\n      var _iterator = _createForOfIteratorHelper(this.aggregatedBins),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var bin = _step.value;\n          binMap[bin.i] = bin;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return binMap;\n    }\n  }, {\n    key: \"_updateMinMaxValues\",\n    value: function _updateMinMaxValues() {\n      var maxCount = 0;\n      var maxValue = 0;\n      var minValue = MAX_32_BIT_FLOAT;\n      var totalCount = 0;\n      var _iterator2 = _createForOfIteratorHelper(this.aggregatedBins),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var x = _step2.value;\n          maxCount = maxCount > x.counts ? maxCount : x.counts;\n          maxValue = maxValue > x.value ? maxValue : x.value;\n          minValue = minValue < x.value ? minValue : x.value;\n          totalCount += x.counts;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      this.maxCount = maxCount;\n      this.maxValue = maxValue;\n      this.minValue = minValue;\n      this.totalCount = totalCount;\n    }\n  }, {\n    key: \"getValueRange\",\n    value: function getValueRange(percentileRange) {\n      if (!this.sortedBins) {\n        this.sortedBins = this.aggregatedBins.sort(function (a, b) {\n          return ascending(a.value, b.value);\n        });\n      }\n      if (!this.sortedBins.length) {\n        return [];\n      }\n      var lowerIdx = 0;\n      var upperIdx = this.sortedBins.length - 1;\n      if (Array.isArray(percentileRange)) {\n        var idxRange = this._percentileToIndex(percentileRange);\n        lowerIdx = idxRange[0];\n        upperIdx = idxRange[1];\n      }\n      return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];\n    }\n  }, {\n    key: \"getValueDomainByScale\",\n    value: function getValueDomainByScale(scale) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [],\n        _ref2 = _slicedToArray(_ref, 2),\n        _ref2$ = _ref2[0],\n        lower = _ref2$ === void 0 ? 0 : _ref2$,\n        _ref2$2 = _ref2[1],\n        upper = _ref2$2 === void 0 ? 100 : _ref2$2;\n      if (!this.sortedBins) {\n        this.sortedBins = this.aggregatedBins.sort(function (a, b) {\n          return ascending(a.value, b.value);\n        });\n      }\n      if (!this.sortedBins.length) {\n        return [];\n      }\n      var indexEdge = this._percentileToIndex([lower, upper]);\n      return this._getScaleDomain(scale, indexEdge);\n    }\n  }, {\n    key: \"_getScaleDomain\",\n    value: function _getScaleDomain(scaleType, _ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n        lowerIdx = _ref4[0],\n        upperIdx = _ref4[1];\n      var bins = this.sortedBins;\n      switch (scaleType) {\n        case 'quantize':\n        case 'linear':\n          return [bins[lowerIdx].value, bins[upperIdx].value];\n        case 'quantile':\n          return getQuantileDomain(bins.slice(lowerIdx, upperIdx + 1), function (d) {\n            return d.value;\n          });\n        case 'ordinal':\n          return getOrdinalDomain(bins, function (d) {\n            return d.value;\n          });\n        default:\n          return [bins[lowerIdx].value, bins[upperIdx].value];\n      }\n    }\n  }]);\n  return BinSorter;\n}();\nexport { BinSorter as default };","map":{"version":3,"names":["defaultGetValue","points","length","clamp","getQuantileDomain","getOrdinalDomain","MAX_32_BIT_FLOAT","defaultGetPoints","bin","defaultGetIndex","index","ascending","a","b","NaN","defaultProps","getValue","getPoints","getIndex","filterData","BinSorter","bins","arguments","undefined","props","_classCallCheck","aggregatedBins","getAggregatedBins","_updateMinMaxValues","binMap","getBinMap","_createClass","key","value","_props$getValue","_props$getPoints","_props$getIndex","hasFilter","binCount","binIndex","i","filteredPoints","filter","Number","isFinite","counts","_percentileToIndex","percentileRange","len","sortedBins","_percentileRange$map","map","n","_percentileRange$map2","_slicedToArray","lower","upper","lowerIdx","Math","ceil","upperIdx","floor","_iterator","_createForOfIteratorHelper","_step","s","done","err","e","f","maxCount","maxValue","minValue","totalCount","_iterator2","_step2","x","getValueRange","sort","Array","isArray","idxRange","getValueDomainByScale","scale","_ref","_ref2","_ref2$","_ref2$2","indexEdge","_getScaleDomain","scaleType","_ref3","_ref4","slice","d","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/aggregation-layers/src/utils/bin-sorter.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// getValue takes an array of points returns a value to sort the bins on.\n// by default it returns the number of points\n// this is where to pass in a function to color the bins by\n// avg/mean/max of specific value of the point\nconst defaultGetValue = points => points.length;\n\nimport {clamp, getQuantileDomain, getOrdinalDomain} from './scale-utils';\n\nconst MAX_32_BIT_FLOAT = 3.402823466e38;\n\n// access array of points in each bin\nconst defaultGetPoints = bin => bin.points;\n// access index of each bin\nconst defaultGetIndex = bin => bin.index;\n\n// d3-scending\nconst ascending = (a, b) => (a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN);\n\nconst defaultProps = {\n  getValue: defaultGetValue,\n  getPoints: defaultGetPoints,\n  getIndex: defaultGetIndex,\n  filterData: null\n};\n\nexport default class BinSorter {\n  constructor(bins = [], props = defaultProps) {\n    this.aggregatedBins = this.getAggregatedBins(bins, props);\n    this._updateMinMaxValues();\n    this.binMap = this.getBinMap();\n  }\n\n  /**\n   * Get an array of object with aggregated values and index of bins\n   * Array object will be sorted by value optionally.\n   * @param {Array} bins\n   * @param {Function} getValue\n   * @return {Array} array of values and index lookup\n   */\n  getAggregatedBins(bins, props) {\n    const {\n      getValue = defaultGetValue,\n      getPoints = defaultGetPoints,\n      getIndex = defaultGetIndex,\n      filterData\n    } = props;\n\n    const hasFilter = typeof filterData === 'function';\n    const binCount = bins.length;\n    const aggregatedBins = [];\n    let index = 0;\n\n    for (let binIndex = 0; binIndex < binCount; binIndex++) {\n      const bin = bins[binIndex];\n      const points = getPoints(bin);\n      const i = getIndex(bin);\n\n      const filteredPoints = hasFilter ? points.filter(filterData) : points;\n\n      bin.filteredPoints = hasFilter ? filteredPoints : null;\n\n      const value = filteredPoints.length ? getValue(filteredPoints) : null;\n\n      if (value !== null && value !== undefined) {\n        // filter bins if value is null or undefined\n        aggregatedBins[index] = {\n          i: Number.isFinite(i) ? i : binIndex,\n          value,\n          counts: filteredPoints.length\n        };\n        index++;\n      }\n    }\n    return aggregatedBins;\n  }\n\n  _percentileToIndex(percentileRange) {\n    const len = this.sortedBins.length;\n    if (len < 2) {\n      return [0, 0];\n    }\n\n    const [lower, upper] = percentileRange.map(n => clamp(n, 0, 100));\n\n    const lowerIdx = Math.ceil((lower / 100) * (len - 1));\n    const upperIdx = Math.floor((upper / 100) * (len - 1));\n\n    return [lowerIdx, upperIdx];\n  }\n\n  /**\n   * Get a mapping from cell/hexagon index to sorted bin\n   * This is used to retrieve bin value for color calculation\n   * @return {Object} bin index to aggregatedBins\n   */\n  getBinMap() {\n    const binMap = {};\n    for (const bin of this.aggregatedBins) {\n      binMap[bin.i] = bin;\n    }\n    return binMap;\n  }\n\n  // Private\n\n  /**\n   * Get ths max count of all bins\n   * @return {Number | Boolean} max count\n   */\n  _updateMinMaxValues() {\n    let maxCount = 0;\n    let maxValue = 0;\n    let minValue = MAX_32_BIT_FLOAT;\n    let totalCount = 0;\n    for (const x of this.aggregatedBins) {\n      maxCount = maxCount > x.counts ? maxCount : x.counts;\n      maxValue = maxValue > x.value ? maxValue : x.value;\n      minValue = minValue < x.value ? minValue : x.value;\n      totalCount += x.counts;\n    }\n    this.maxCount = maxCount;\n    this.maxValue = maxValue;\n    this.minValue = minValue;\n    this.totalCount = totalCount;\n  }\n\n  /**\n   * Get range of values of all bins\n   * @param {Number[]} range\n   * @param {Number} range[0] - lower bound\n   * @param {Number} range[1] - upper bound\n   * @return {Array} array of new value range\n   */\n  getValueRange(percentileRange) {\n    if (!this.sortedBins) {\n      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n    }\n    if (!this.sortedBins.length) {\n      return [];\n    }\n    let lowerIdx = 0;\n    let upperIdx = this.sortedBins.length - 1;\n\n    if (Array.isArray(percentileRange)) {\n      const idxRange = this._percentileToIndex(percentileRange);\n      lowerIdx = idxRange[0];\n      upperIdx = idxRange[1];\n    }\n\n    return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];\n  }\n\n  getValueDomainByScale(scale, [lower = 0, upper = 100] = []) {\n    if (!this.sortedBins) {\n      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n    }\n    if (!this.sortedBins.length) {\n      return [];\n    }\n    const indexEdge = this._percentileToIndex([lower, upper]);\n\n    return this._getScaleDomain(scale, indexEdge);\n  }\n\n  _getScaleDomain(scaleType, [lowerIdx, upperIdx]) {\n    const bins = this.sortedBins;\n\n    switch (scaleType) {\n      case 'quantize':\n      case 'linear':\n        return [bins[lowerIdx].value, bins[upperIdx].value];\n\n      case 'quantile':\n        return getQuantileDomain(bins.slice(lowerIdx, upperIdx + 1), d => d.value);\n\n      case 'ordinal':\n        return getOrdinalDomain(bins, d => d.value);\n\n      default:\n        return [bins[lowerIdx].value, bins[upperIdx].value];\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}