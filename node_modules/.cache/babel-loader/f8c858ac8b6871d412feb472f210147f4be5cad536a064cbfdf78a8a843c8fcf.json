{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty2 from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Framebuffer, Texture2D, isWebGL2, readPixelsToArray, cssToDeviceRatio, cssToDevicePixels } from '@luma.gl/core';\nimport PickLayersPass from '../passes/pick-layers-pass';\nimport { getClosestObject, getUniqueObjects } from './picking/query-object';\nimport { processPickInfo, getLayerPickingInfo, getEmptyPickingInfo } from './picking/pick-info';\nvar DeckPicker = /*#__PURE__*/function () {\n  function DeckPicker(gl) {\n    _classCallCheck(this, DeckPicker);\n    _defineProperty(this, \"gl\", void 0);\n    _defineProperty(this, \"pickingFBO\", void 0);\n    _defineProperty(this, \"depthFBO\", void 0);\n    _defineProperty(this, \"pickLayersPass\", void 0);\n    _defineProperty(this, \"layerFilter\", void 0);\n    _defineProperty(this, \"lastPickedInfo\", void 0);\n    _defineProperty(this, \"_pickable\", true);\n    this.gl = gl;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.lastPickedInfo = {\n      index: -1,\n      layerId: null,\n      info: null\n    };\n  }\n  _createClass(DeckPicker, [{\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('layerFilter' in props) {\n        this.layerFilter = props.layerFilter;\n      }\n      if ('_pickable' in props) {\n        this._pickable = props._pickable;\n      }\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      if (this.pickingFBO) {\n        this.pickingFBO.delete();\n      }\n      if (this.depthFBO) {\n        this.depthFBO.color.delete();\n        this.depthFBO.delete();\n      }\n    }\n  }, {\n    key: \"pickObject\",\n    value: function pickObject(opts) {\n      return this._pickClosestObject(opts);\n    }\n  }, {\n    key: \"pickObjects\",\n    value: function pickObjects(opts) {\n      return this._pickVisibleObjects(opts);\n    }\n  }, {\n    key: \"getLastPickedObject\",\n    value: function getLastPickedObject(_ref) {\n      var x = _ref.x,\n        y = _ref.y,\n        layers = _ref.layers,\n        viewports = _ref.viewports;\n      var lastPickedInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.lastPickedInfo.info;\n      var lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n      var lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n      var layer = lastPickedLayerId ? layers.find(function (l) {\n        return l.id === lastPickedLayerId;\n      }) : null;\n      var viewport = lastPickedViewportId && viewports.find(function (v) {\n        return v.id === lastPickedViewportId;\n      }) || viewports[0];\n      var coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n      var info = {\n        x: x,\n        y: y,\n        viewport: viewport,\n        coordinate: coordinate,\n        layer: layer\n      };\n      return _objectSpread(_objectSpread({}, lastPickedInfo), info);\n    }\n  }, {\n    key: \"_resizeBuffer\",\n    value: function _resizeBuffer() {\n      var _this$pickingFBO, _this$depthFBO;\n      var gl = this.gl;\n      if (!this.pickingFBO) {\n        this.pickingFBO = new Framebuffer(gl);\n        if (Framebuffer.isSupported(gl, {\n          colorBufferFloat: true\n        })) {\n          var depthFBO = new Framebuffer(gl);\n          depthFBO.attach(_defineProperty2({}, 36064, new Texture2D(gl, {\n            format: isWebGL2(gl) ? 34836 : 6408,\n            type: 5126\n          })));\n          this.depthFBO = depthFBO;\n        }\n      }\n      (_this$pickingFBO = this.pickingFBO) === null || _this$pickingFBO === void 0 ? void 0 : _this$pickingFBO.resize({\n        width: gl.canvas.width,\n        height: gl.canvas.height\n      });\n      (_this$depthFBO = this.depthFBO) === null || _this$depthFBO === void 0 ? void 0 : _this$depthFBO.resize({\n        width: gl.canvas.width,\n        height: gl.canvas.height\n      });\n    }\n  }, {\n    key: \"_getPickable\",\n    value: function _getPickable(layers) {\n      if (this._pickable === false) {\n        return null;\n      }\n      var pickableLayers = layers.filter(function (layer) {\n        return layer.isPickable() && !layer.isComposite;\n      });\n      return pickableLayers.length ? pickableLayers : null;\n    }\n  }, {\n    key: \"_pickClosestObject\",\n    value: function _pickClosestObject(_ref2) {\n      var layers = _ref2.layers,\n        views = _ref2.views,\n        viewports = _ref2.viewports,\n        x = _ref2.x,\n        y = _ref2.y,\n        _ref2$radius = _ref2.radius,\n        radius = _ref2$radius === void 0 ? 0 : _ref2$radius,\n        _ref2$depth = _ref2.depth,\n        depth = _ref2$depth === void 0 ? 1 : _ref2$depth,\n        _ref2$mode = _ref2.mode,\n        mode = _ref2$mode === void 0 ? 'query' : _ref2$mode,\n        unproject3D = _ref2.unproject3D,\n        onViewportActive = _ref2.onViewportActive,\n        effects = _ref2.effects;\n      var pickableLayers = this._getPickable(layers);\n      var pixelRatio = cssToDeviceRatio(this.gl);\n      if (!pickableLayers) {\n        return {\n          result: [],\n          emptyInfo: getEmptyPickingInfo({\n            viewports: viewports,\n            x: x,\n            y: y,\n            pixelRatio: pixelRatio\n          })\n        };\n      }\n      this._resizeBuffer();\n      var devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n      var devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];\n      var deviceRadius = Math.round(radius * pixelRatio);\n      var _this$pickingFBO2 = this.pickingFBO,\n        width = _this$pickingFBO2.width,\n        height = _this$pickingFBO2.height;\n      var deviceRect = this._getPickingRect({\n        deviceX: devicePixel[0],\n        deviceY: devicePixel[1],\n        deviceRadius: deviceRadius,\n        deviceWidth: width,\n        deviceHeight: height\n      });\n      var cullRect = {\n        x: x - radius,\n        y: y - radius,\n        width: radius * 2 + 1,\n        height: radius * 2 + 1\n      };\n      var infos;\n      var result = [];\n      var affectedLayers = new Set();\n      for (var i = 0; i < depth; i++) {\n        var pickInfo = void 0;\n        if (deviceRect) {\n          var pickedResult = this._drawAndSample({\n            layers: pickableLayers,\n            views: views,\n            viewports: viewports,\n            onViewportActive: onViewportActive,\n            deviceRect: deviceRect,\n            cullRect: cullRect,\n            effects: effects,\n            pass: \"picking:\".concat(mode)\n          });\n          pickInfo = getClosestObject(_objectSpread(_objectSpread({}, pickedResult), {}, {\n            deviceX: devicePixel[0],\n            deviceY: devicePixel[1],\n            deviceRadius: deviceRadius,\n            deviceRect: deviceRect\n          }));\n        } else {\n          pickInfo = {\n            pickedColor: null,\n            pickedObjectIndex: -1\n          };\n        }\n        var z = void 0;\n        if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n          var pickedResultPass2 = this._drawAndSample({\n            layers: [pickInfo.pickedLayer],\n            views: views,\n            viewports: viewports,\n            onViewportActive: onViewportActive,\n            deviceRect: {\n              x: pickInfo.pickedX,\n              y: pickInfo.pickedY,\n              width: 1,\n              height: 1\n            },\n            cullRect: cullRect,\n            effects: effects,\n            pass: \"picking:\".concat(mode, \":z\")\n          }, true);\n          z = pickedResultPass2.pickedColors[0];\n        }\n        if (pickInfo.pickedLayer && i + 1 < depth) {\n          affectedLayers.add(pickInfo.pickedLayer);\n          pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n        }\n        infos = processPickInfo({\n          pickInfo: pickInfo,\n          lastPickedInfo: this.lastPickedInfo,\n          mode: mode,\n          layers: pickableLayers,\n          viewports: viewports,\n          x: x,\n          y: y,\n          z: z,\n          pixelRatio: pixelRatio\n        });\n        var _iterator = _createForOfIteratorHelper(infos.values()),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var info = _step.value;\n            if (info.layer) {\n              result.push(info);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        if (!pickInfo.pickedColor) {\n          break;\n        }\n      }\n      var _iterator2 = _createForOfIteratorHelper(affectedLayers),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var layer = _step2.value;\n          layer.restorePickingColors();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return {\n        result: result,\n        emptyInfo: infos.get(null)\n      };\n    }\n  }, {\n    key: \"_pickVisibleObjects\",\n    value: function _pickVisibleObjects(_ref3) {\n      var layers = _ref3.layers,\n        views = _ref3.views,\n        viewports = _ref3.viewports,\n        x = _ref3.x,\n        y = _ref3.y,\n        _ref3$width = _ref3.width,\n        width = _ref3$width === void 0 ? 1 : _ref3$width,\n        _ref3$height = _ref3.height,\n        height = _ref3$height === void 0 ? 1 : _ref3$height,\n        _ref3$mode = _ref3.mode,\n        mode = _ref3$mode === void 0 ? 'query' : _ref3$mode,\n        _ref3$maxObjects = _ref3.maxObjects,\n        maxObjects = _ref3$maxObjects === void 0 ? null : _ref3$maxObjects,\n        onViewportActive = _ref3.onViewportActive,\n        effects = _ref3.effects;\n      var pickableLayers = this._getPickable(layers);\n      if (!pickableLayers) {\n        return [];\n      }\n      this._resizeBuffer();\n      var pixelRatio = cssToDeviceRatio(this.gl);\n      var leftTop = cssToDevicePixels(this.gl, [x, y], true);\n      var deviceLeft = leftTop.x;\n      var deviceTop = leftTop.y + leftTop.height;\n      var rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n      var deviceRight = rightBottom.x + rightBottom.width;\n      var deviceBottom = rightBottom.y;\n      var deviceRect = {\n        x: deviceLeft,\n        y: deviceBottom,\n        width: deviceRight - deviceLeft,\n        height: deviceTop - deviceBottom\n      };\n      var pickedResult = this._drawAndSample({\n        layers: pickableLayers,\n        views: views,\n        viewports: viewports,\n        onViewportActive: onViewportActive,\n        deviceRect: deviceRect,\n        cullRect: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        effects: effects,\n        pass: \"picking:\".concat(mode)\n      });\n      var pickInfos = getUniqueObjects(pickedResult);\n      var uniqueInfos = new Map();\n      var isMaxObjects = Number.isFinite(maxObjects);\n      for (var i = 0; i < pickInfos.length; i++) {\n        if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {\n          break;\n        }\n        var pickInfo = pickInfos[i];\n        var info = {\n          color: pickInfo.pickedColor,\n          layer: null,\n          index: pickInfo.pickedObjectIndex,\n          picked: true,\n          x: x,\n          y: y,\n          pixelRatio: pixelRatio\n        };\n        info = getLayerPickingInfo({\n          layer: pickInfo.pickedLayer,\n          info: info,\n          mode: mode\n        });\n        if (!uniqueInfos.has(info.object)) {\n          uniqueInfos.set(info.object, info);\n        }\n      }\n      return Array.from(uniqueInfos.values());\n    }\n  }, {\n    key: \"_drawAndSample\",\n    value: function _drawAndSample(_ref4) {\n      var layers = _ref4.layers,\n        views = _ref4.views,\n        viewports = _ref4.viewports,\n        onViewportActive = _ref4.onViewportActive,\n        deviceRect = _ref4.deviceRect,\n        cullRect = _ref4.cullRect,\n        effects = _ref4.effects,\n        pass = _ref4.pass;\n      var pickZ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n      var _this$pickLayersPass$ = this.pickLayersPass.render({\n          layers: layers,\n          layerFilter: this.layerFilter,\n          views: views,\n          viewports: viewports,\n          onViewportActive: onViewportActive,\n          pickingFBO: pickingFBO,\n          deviceRect: deviceRect,\n          cullRect: cullRect,\n          effects: effects,\n          pass: pass,\n          pickZ: pickZ\n        }),\n        decodePickingColor = _this$pickLayersPass$.decodePickingColor;\n      var x = deviceRect.x,\n        y = deviceRect.y,\n        width = deviceRect.width,\n        height = deviceRect.height;\n      var pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n      readPixelsToArray(pickingFBO, {\n        sourceX: x,\n        sourceY: y,\n        sourceWidth: width,\n        sourceHeight: height,\n        target: pickedColors\n      });\n      return {\n        pickedColors: pickedColors,\n        decodePickingColor: decodePickingColor\n      };\n    }\n  }, {\n    key: \"_getPickingRect\",\n    value: function _getPickingRect(_ref5) {\n      var deviceX = _ref5.deviceX,\n        deviceY = _ref5.deviceY,\n        deviceRadius = _ref5.deviceRadius,\n        deviceWidth = _ref5.deviceWidth,\n        deviceHeight = _ref5.deviceHeight;\n      var x = Math.max(0, deviceX - deviceRadius);\n      var y = Math.max(0, deviceY - deviceRadius);\n      var width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n      var height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n      if (width <= 0 || height <= 0) {\n        return null;\n      }\n      return {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      };\n    }\n  }]);\n  return DeckPicker;\n}();\nexport { DeckPicker as default };","map":{"version":3,"names":["Framebuffer","Texture2D","isWebGL2","readPixelsToArray","cssToDeviceRatio","cssToDevicePixels","PickLayersPass","getClosestObject","getUniqueObjects","processPickInfo","getLayerPickingInfo","getEmptyPickingInfo","DeckPicker","gl","_classCallCheck","_defineProperty","pickLayersPass","lastPickedInfo","index","layerId","info","_createClass","key","value","setProps","props","layerFilter","_pickable","finalize","pickingFBO","delete","depthFBO","color","pickObject","opts","_pickClosestObject","pickObjects","_pickVisibleObjects","getLastPickedObject","_ref","x","y","layers","viewports","arguments","length","undefined","lastPickedLayerId","layer","id","lastPickedViewportId","viewport","find","l","v","coordinate","unproject","_objectSpread","_resizeBuffer","_this$pickingFBO","_this$depthFBO","isSupported","colorBufferFloat","attach","_defineProperty2","format","type","resize","width","canvas","height","_getPickable","pickableLayers","filter","isPickable","isComposite","_ref2","views","_ref2$radius","radius","_ref2$depth","depth","_ref2$mode","mode","unproject3D","onViewportActive","effects","pixelRatio","result","emptyInfo","devicePixelRange","devicePixel","Math","floor","deviceRadius","round","_this$pickingFBO2","deviceRect","_getPickingRect","deviceX","deviceY","deviceWidth","deviceHeight","cullRect","infos","affectedLayers","Set","i","pickInfo","pickedResult","_drawAndSample","pass","concat","pickedColor","pickedObjectIndex","z","pickedLayer","pickedResultPass2","pickedX","pickedY","pickedColors","add","disablePickingIndex","_iterator","_createForOfIteratorHelper","values","_step","s","n","done","push","err","e","f","_iterator2","_step2","restorePickingColors","get","_ref3","_ref3$width","_ref3$height","_ref3$mode","_ref3$maxObjects","maxObjects","leftTop","deviceLeft","deviceTop","rightBottom","deviceRight","deviceBottom","pickInfos","uniqueInfos","Map","isMaxObjects","Number","isFinite","size","picked","has","object","set","Array","from","_ref4","pickZ","_this$pickLayersPass$","render","decodePickingColor","Float32Array","Uint8Array","sourceX","sourceY","sourceWidth","sourceHeight","target","_ref5","max","min","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/core/src/lib/deck-picker.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Framebuffer,\n  Texture2D,\n  isWebGL2,\n  readPixelsToArray,\n  cssToDeviceRatio,\n  cssToDevicePixels\n} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport PickLayersPass, {PickingColorDecoder} from '../passes/pick-layers-pass';\nimport {getClosestObject, getUniqueObjects, PickedPixel} from './picking/query-object';\nimport {\n  processPickInfo,\n  getLayerPickingInfo,\n  getEmptyPickingInfo,\n  PickingInfo\n} from './picking/pick-info';\n\nimport type {Framebuffer as LumaFramebuffer} from '@luma.gl/webgl';\nimport type {FilterContext, Rect} from '../passes/layers-pass';\nimport type Layer from './layer';\nimport type {Effect} from './effect';\nimport type View from '../views/view';\nimport type Viewport from '../viewports/viewport';\n\nexport type PickByPointOptions = {\n  x: number;\n  y: number;\n  radius?: number;\n  depth?: number;\n  mode?: string;\n  unproject3D?: boolean;\n};\n\nexport type PickByRectOptions = {\n  x: number;\n  y: number;\n  width?: number;\n  height?: number;\n  mode?: string;\n  maxObjects?: number | null;\n};\n\ntype PickOperationContext = {\n  layers: Layer[];\n  views: Record<string, View>;\n  viewports: Viewport[];\n  onViewportActive: (viewport: Viewport) => void;\n  effects: Effect[];\n};\n\n/** Manages picking in a Deck context */\nexport default class DeckPicker {\n  gl: WebGLRenderingContext;\n  pickingFBO?: LumaFramebuffer;\n  depthFBO?: LumaFramebuffer;\n  pickLayersPass: PickLayersPass;\n  layerFilter?: (context: FilterContext) => boolean;\n\n  /** Identifiers of the previously picked object, for callback tracking and auto highlight */\n  lastPickedInfo: {\n    index: number;\n    layerId: string | null;\n    info: PickingInfo | null;\n  };\n\n  _pickable: boolean = true;\n\n  constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.lastPickedInfo = {\n      index: -1,\n      layerId: null,\n      info: null\n    };\n  }\n\n  setProps(props: any): void {\n    if ('layerFilter' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n\n    if ('_pickable' in props) {\n      this._pickable = props._pickable;\n    }\n  }\n\n  finalize() {\n    if (this.pickingFBO) {\n      this.pickingFBO.delete();\n    }\n    if (this.depthFBO) {\n      this.depthFBO.color.delete();\n      this.depthFBO.delete();\n    }\n  }\n\n  /** Pick the closest info at given coordinate */\n  pickObject(opts: PickByPointOptions & PickOperationContext) {\n    return this._pickClosestObject(opts);\n  }\n\n  /** Get all unique infos within a bounding box */\n  pickObjects(opts: PickByRectOptions & PickOperationContext) {\n    return this._pickVisibleObjects(opts);\n  }\n\n  // Returns a new picking info object by assuming the last picked object is still picked\n  getLastPickedObject({x, y, layers, viewports}, lastPickedInfo = this.lastPickedInfo.info) {\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const lastPickedViewportId =\n      lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const viewport =\n      (lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId)) || viewports[0];\n    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n\n    const info = {\n      x,\n      y,\n      viewport,\n      coordinate,\n      layer\n    };\n\n    return {...lastPickedInfo, ...info};\n  }\n\n  // Private\n\n  /** Ensures that picking framebuffer exists and matches the canvas size */\n  _resizeBuffer() {\n    const {gl} = this;\n\n    // Create a frame buffer if not already available\n    if (!this.pickingFBO) {\n      this.pickingFBO = new Framebuffer(gl);\n\n      if (Framebuffer.isSupported(gl, {colorBufferFloat: true})) {\n        const depthFBO = new Framebuffer(gl);\n        depthFBO.attach({\n          [GL.COLOR_ATTACHMENT0]: new Texture2D(gl, {\n            format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n            type: GL.FLOAT\n          })\n        });\n        this.depthFBO = depthFBO;\n      }\n    }\n    // Resize it to current canvas size (this is a noop if size hasn't changed)\n    this.pickingFBO?.resize({width: gl.canvas.width, height: gl.canvas.height});\n    this.depthFBO?.resize({width: gl.canvas.width, height: gl.canvas.height});\n  }\n\n  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */\n  _getPickable(layers: Layer[]): Layer[] | null {\n    if (this._pickable === false) {\n      return null;\n    }\n    const pickableLayers = layers.filter(layer => layer.isPickable() && !layer.isComposite);\n    return pickableLayers.length ? pickableLayers : null;\n  }\n\n  // eslint-disable-next-line max-statements,complexity\n  /** Pick the closest object at the given coordinate */\n  _pickClosestObject({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    radius = 0,\n    depth = 1,\n    mode = 'query',\n    unproject3D,\n    onViewportActive,\n    effects\n  }: PickByPointOptions & PickOperationContext): {\n    result: PickingInfo[];\n    emptyInfo: PickingInfo;\n  } {\n    const pickableLayers = this._getPickable(layers);\n    const pixelRatio = cssToDeviceRatio(this.gl);\n\n    if (!pickableLayers) {\n      return {\n        result: [],\n        emptyInfo: getEmptyPickingInfo({viewports, x, y, pixelRatio})\n      };\n    }\n\n    this._resizeBuffer();\n\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // Top-left coordinates [x, y] to bottom-left coordinates [deviceX, deviceY]\n    // And compensate for pixelRatio\n    const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n    const devicePixel = [\n      devicePixelRange.x + Math.floor(devicePixelRange.width / 2),\n      devicePixelRange.y + Math.floor(devicePixelRange.height / 2)\n    ];\n\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {width, height} = this.pickingFBO as LumaFramebuffer;\n    const deviceRect = this._getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n\n    const cullRect: Rect = {\n      x: x - radius,\n      y: y - radius,\n      width: radius * 2 + 1,\n      height: radius * 2 + 1\n    };\n\n    let infos: Map<string | null, PickingInfo>;\n    const result: PickingInfo[] = [];\n    const affectedLayers = new Set<Layer>();\n\n    for (let i = 0; i < depth; i++) {\n      let pickInfo: PickedPixel;\n\n      if (deviceRect) {\n        const pickedResult = this._drawAndSample({\n          layers: pickableLayers,\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          cullRect,\n          effects,\n          pass: `picking:${mode}`\n        });\n\n        pickInfo = getClosestObject({\n          ...pickedResult,\n          deviceX: devicePixel[0],\n          deviceY: devicePixel[1],\n          deviceRadius,\n          deviceRect\n        });\n      } else {\n        pickInfo = {\n          pickedColor: null,\n          pickedObjectIndex: -1\n        };\n      }\n\n      let z;\n      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n        const pickedResultPass2 = this._drawAndSample(\n          {\n            layers: [pickInfo.pickedLayer],\n            views,\n            viewports,\n            onViewportActive,\n            deviceRect: {\n              x: pickInfo.pickedX as number,\n              y: pickInfo.pickedY as number,\n              width: 1,\n              height: 1\n            },\n            cullRect,\n            effects,\n            pass: `picking:${mode}:z`\n          },\n          true\n        );\n        // picked value is in common space (pixels) from the camera target (viewport.position)\n        // convert it to meters from the ground\n        z = pickedResultPass2.pickedColors[0];\n      }\n\n      // Only exclude if we need to run picking again.\n      // We need to run picking again if an object is detected AND\n      // we have not exhausted the requested depth.\n      if (pickInfo.pickedLayer && i + 1 < depth) {\n        affectedLayers.add(pickInfo.pickedLayer);\n        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n      }\n\n      // This logic needs to run even if no object is picked.\n      infos = processPickInfo({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers: pickableLayers,\n        viewports,\n        x,\n        y,\n        z,\n        pixelRatio\n      });\n\n      for (const info of infos.values()) {\n        if (info.layer) {\n          result.push(info);\n        }\n      }\n\n      // If no object is picked stop.\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n\n    // reset only affected buffers\n    for (const layer of affectedLayers) {\n      layer.restorePickingColors();\n    }\n\n    return {result, emptyInfo: infos!.get(null) as PickingInfo};\n  }\n\n  /** Pick all objects within the given bounding box */\n  _pickVisibleObjects({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    width = 1,\n    height = 1,\n    mode = 'query',\n    maxObjects = null,\n    onViewportActive,\n    effects\n  }: PickByRectOptions & PickOperationContext): PickingInfo[] {\n    const pickableLayers = this._getPickable(layers);\n\n    if (!pickableLayers) {\n      return [];\n    }\n\n    this._resizeBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // And compensate for pixelRatio\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const leftTop = cssToDevicePixels(this.gl, [x, y], true);\n\n    // take left and top (y inverted in device pixels) from start location\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n\n    // take right and bottom (y inverted in device pixels) from end location\n    const rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      // deviceTop and deviceRight represent the first pixel outside the desired rect\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n\n    const pickedResult = this._drawAndSample({\n      layers: pickableLayers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect: {x, y, width, height},\n      effects,\n      pass: `picking:${mode}`\n    });\n\n    const pickInfos = getUniqueObjects(pickedResult);\n\n    // Only return unique infos, identified by info.object\n    const uniqueInfos = new Map();\n\n    const isMaxObjects = Number.isFinite(maxObjects);\n\n    for (let i = 0; i < pickInfos.length; i++) {\n      if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {\n        break;\n      }\n      const pickInfo = pickInfos[i];\n      let info: PickingInfo = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        pixelRatio\n      };\n\n      info = getLayerPickingInfo({layer: pickInfo.pickedLayer as Layer, info, mode});\n      if (!uniqueInfos.has(info.object)) {\n        uniqueInfos.set(info.object, info);\n      }\n    }\n\n    return Array.from(uniqueInfos.values());\n  }\n\n  /** Renders layers into the picking buffer with picking colors and read the pixels. */\n  _drawAndSample(params: {\n    deviceRect: Rect;\n    pass: string;\n    layers: Layer[];\n    views: Record<string, View>;\n    viewports: Viewport[];\n    onViewportActive: (viewport: Viewport) => void;\n    cullRect?: Rect;\n    effects: Effect[];\n  }): {\n    pickedColors: Uint8Array;\n    decodePickingColor: PickingColorDecoder;\n  };\n\n  /** Renders layers into the picking buffer with encoded z values and read the pixels. */\n  _drawAndSample(\n    params: {\n      deviceRect: Rect;\n      pass: string;\n      layers: Layer[];\n      views: Record<string, View>;\n      viewports: Viewport[];\n      onViewportActive: (viewport: Viewport) => void;\n      cullRect?: Rect;\n      effects: Effect[];\n    },\n    pickZ: true\n  ): {\n    pickedColors: Float32Array;\n    decodePickingColor: null;\n  };\n\n  _drawAndSample(\n    {\n      layers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect,\n      effects,\n      pass\n    }: {\n      deviceRect: Rect;\n      pass: string;\n      layers: Layer[];\n      views: Record<string, View>;\n      viewports: Viewport[];\n      onViewportActive: (viewport: Viewport) => void;\n      cullRect?: Rect;\n      effects: Effect[];\n    },\n    pickZ: boolean = false\n  ): {\n    pickedColors: Uint8Array | Float32Array;\n    decodePickingColor: PickingColorDecoder | null;\n  } {\n    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n\n    const {decodePickingColor} = this.pickLayersPass.render({\n      layers,\n      layerFilter: this.layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      cullRect,\n      effects,\n      pass,\n      pickZ\n    });\n\n    // Read from an already rendered picking buffer\n    // Returns an Uint8ClampedArray of picked pixels\n    const {x, y, width, height} = deviceRect;\n    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n    readPixelsToArray(pickingFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n\n    return {pickedColors, decodePickingColor};\n  }\n\n  // Calculate a picking rect centered on deviceX and deviceY and clipped to device\n  // Returns null if pixel is outside of device\n  _getPickingRect({\n    deviceX,\n    deviceY,\n    deviceRadius,\n    deviceWidth,\n    deviceHeight\n  }: {\n    deviceX: number;\n    deviceY: number;\n    deviceRadius: number;\n    deviceWidth: number;\n    deviceHeight: number;\n  }): Rect | null {\n    // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n\n    // x, y out of bounds.\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n\n    return {x, y, width, height};\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}