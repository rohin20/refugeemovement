{"ast":null,"code":"import _defineProperty2 from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport DataColumn from './data-column';\nimport assert from '../../utils/assert';\nimport { createIterable, getAccessorFromBuffer } from '../../utils/iterable-utils';\nimport { fillArray } from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport { normalizeTransitionSettings } from './attribute-transition-utils';\nvar Attribute = /*#__PURE__*/function (_DataColumn) {\n  _inherits(Attribute, _DataColumn);\n  var _super = _createSuper(Attribute);\n  function Attribute(gl, opts) {\n    var _this;\n    _classCallCheck(this, Attribute);\n    _this = _super.call(this, gl, opts, {\n      startIndices: null,\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL\n    });\n    _defineProperty(_assertThisInitialized(_this), \"constant\", false);\n    _this.settings.update = opts.update || (opts.accessor ? _this._autoUpdater : undefined);\n    Object.seal(_this.settings);\n    Object.seal(_this.state);\n    _this._validateAttributeUpdaters();\n    return _this;\n  }\n  _createClass(Attribute, [{\n    key: \"startIndices\",\n    get: function get() {\n      return this.state.startIndices;\n    },\n    set: function set(layout) {\n      this.state.startIndices = layout;\n    }\n  }, {\n    key: \"needsUpdate\",\n    value: function needsUpdate() {\n      return this.state.needsUpdate;\n    }\n  }, {\n    key: \"needsRedraw\",\n    value: function needsRedraw() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$clearChangedFlag = _ref.clearChangedFlags,\n        clearChangedFlags = _ref$clearChangedFlag === void 0 ? false : _ref$clearChangedFlag;\n      var needsRedraw = this.state.needsRedraw;\n      this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n      return needsRedraw;\n    }\n  }, {\n    key: \"getUpdateTriggers\",\n    value: function getUpdateTriggers() {\n      var accessor = this.settings.accessor;\n      return [this.id].concat(typeof accessor !== 'function' && accessor || []);\n    }\n  }, {\n    key: \"supportsTransition\",\n    value: function supportsTransition() {\n      return Boolean(this.settings.transition);\n    }\n  }, {\n    key: \"getTransitionSetting\",\n    value: function getTransitionSetting(opts) {\n      if (!opts || !this.supportsTransition()) {\n        return null;\n      }\n      var accessor = this.settings.accessor;\n      var layerSettings = this.settings.transition;\n      var userSettings = Array.isArray(accessor) ? opts[accessor.find(function (a) {\n        return opts[a];\n      })] : opts[accessor];\n      return normalizeTransitionSettings(userSettings, layerSettings);\n    }\n  }, {\n    key: \"setNeedsUpdate\",\n    value: function setNeedsUpdate() {\n      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n      var dataRange = arguments.length > 1 ? arguments[1] : undefined;\n      this.state.needsUpdate = this.state.needsUpdate || reason;\n      this.setNeedsRedraw(reason);\n      if (dataRange) {\n        var _dataRange$startRow = dataRange.startRow,\n          startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow,\n          _dataRange$endRow = dataRange.endRow,\n          endRow = _dataRange$endRow === void 0 ? Infinity : _dataRange$endRow;\n        this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n      } else {\n        this.state.updateRanges = range.FULL;\n      }\n    }\n  }, {\n    key: \"clearNeedsUpdate\",\n    value: function clearNeedsUpdate() {\n      this.state.needsUpdate = false;\n      this.state.updateRanges = range.EMPTY;\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n      this.state.needsRedraw = this.state.needsRedraw || reason;\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(numInstances) {\n      var state = this.state,\n        settings = this.settings;\n      if (settings.noAlloc) {\n        return false;\n      }\n      if (settings.update) {\n        _get(_getPrototypeOf(Attribute.prototype), \"allocate\", this).call(this, numInstances, state.updateRanges !== range.FULL);\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(_ref2) {\n      var numInstances = _ref2.numInstances,\n        data = _ref2.data,\n        props = _ref2.props,\n        context = _ref2.context;\n      if (!this.needsUpdate()) {\n        return false;\n      }\n      var updateRanges = this.state.updateRanges,\n        _this$settings = this.settings,\n        update = _this$settings.update,\n        noAlloc = _this$settings.noAlloc;\n      var updated = true;\n      if (update) {\n        var _iterator = _createForOfIteratorHelper(updateRanges),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              _startRow = _step$value[0],\n              _endRow = _step$value[1];\n            update.call(context, this, {\n              data: data,\n              startRow: _startRow,\n              endRow: _endRow,\n              props: props,\n              numInstances: numInstances\n            });\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        if (!this.value) {} else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {\n          this.setData({\n            value: this.value,\n            constant: this.constant\n          });\n          this.constant = false;\n        } else {\n          var _iterator2 = _createForOfIteratorHelper(updateRanges),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                startRow = _step2$value[0],\n                endRow = _step2$value[1];\n              var startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n              var endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;\n              _get(_getPrototypeOf(Attribute.prototype), \"updateSubBuffer\", this).call(this, {\n                startOffset: startOffset,\n                endOffset: endOffset\n              });\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n        this._checkAttributeArray();\n      } else {\n        updated = false;\n      }\n      this.clearNeedsUpdate();\n      this.setNeedsRedraw();\n      return updated;\n    }\n  }, {\n    key: \"setConstantValue\",\n    value: function setConstantValue(value) {\n      if (value === undefined || typeof value === 'function') {\n        return false;\n      }\n      var hasChanged = this.setData({\n        constant: true,\n        value: value\n      });\n      if (hasChanged) {\n        this.setNeedsRedraw();\n      }\n      this.clearNeedsUpdate();\n      return true;\n    }\n  }, {\n    key: \"setExternalBuffer\",\n    value: function setExternalBuffer(buffer) {\n      var state = this.state;\n      if (!buffer) {\n        state.lastExternalBuffer = null;\n        return false;\n      }\n      this.clearNeedsUpdate();\n      if (state.lastExternalBuffer === buffer) {\n        return true;\n      }\n      state.lastExternalBuffer = buffer;\n      this.setNeedsRedraw();\n      this.setData(buffer);\n      return true;\n    }\n  }, {\n    key: \"setBinaryValue\",\n    value: function setBinaryValue(buffer) {\n      var startIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var state = this.state,\n        settings = this.settings;\n      if (!buffer) {\n        state.binaryValue = null;\n        state.binaryAccessor = null;\n        return false;\n      }\n      if (settings.noAlloc) {\n        return false;\n      }\n      if (state.binaryValue === buffer) {\n        this.clearNeedsUpdate();\n        return true;\n      }\n      state.binaryValue = buffer;\n      this.setNeedsRedraw();\n      var needsUpdate = settings.transform || startIndices !== this.startIndices;\n      if (needsUpdate) {\n        if (ArrayBuffer.isView(buffer)) {\n          buffer = {\n            value: buffer\n          };\n        }\n        var binaryValue = buffer;\n        assert(ArrayBuffer.isView(binaryValue.value), \"invalid \".concat(settings.accessor));\n        var needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;\n        state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {\n          size: binaryValue.size || this.size,\n          stride: binaryValue.stride,\n          offset: binaryValue.offset,\n          startIndices: startIndices,\n          nested: needsNormalize\n        });\n        return false;\n      }\n      this.clearNeedsUpdate();\n      this.setData(buffer);\n      return true;\n    }\n  }, {\n    key: \"getVertexOffset\",\n    value: function getVertexOffset(row) {\n      var startIndices = this.startIndices;\n      var vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;\n      return vertexIndex * this.size;\n    }\n  }, {\n    key: \"getShaderAttributes\",\n    value: function getShaderAttributes() {\n      var shaderAttributeDefs = this.settings.shaderAttributes || _defineProperty2({}, this.id, null);\n      var shaderAttributes = {};\n      for (var shaderAttributeName in shaderAttributeDefs) {\n        Object.assign(shaderAttributes, _get(_getPrototypeOf(Attribute.prototype), \"getShaderAttributes\", this).call(this, shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));\n      }\n      return shaderAttributes;\n    }\n  }, {\n    key: \"_autoUpdater\",\n    value: function _autoUpdater(attribute, _ref4) {\n      var data = _ref4.data,\n        startRow = _ref4.startRow,\n        endRow = _ref4.endRow,\n        props = _ref4.props,\n        numInstances = _ref4.numInstances;\n      if (attribute.constant) {\n        return;\n      }\n      var settings = attribute.settings,\n        state = attribute.state,\n        value = attribute.value,\n        size = attribute.size,\n        startIndices = attribute.startIndices;\n      var accessor = settings.accessor,\n        transform = settings.transform;\n      var accessorFunc = state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);\n      assert(typeof accessorFunc === 'function', \"accessor \\\"\".concat(accessor, \"\\\" is not a function\"));\n      var i = attribute.getVertexOffset(startRow);\n      var _createIterable = createIterable(data, startRow, endRow),\n        iterable = _createIterable.iterable,\n        objectInfo = _createIterable.objectInfo;\n      var _iterator3 = _createForOfIteratorHelper(iterable),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var object = _step3.value;\n          objectInfo.index++;\n          var objectValue = accessorFunc(object, objectInfo);\n          if (transform) {\n            objectValue = transform.call(this, objectValue);\n          }\n          if (startIndices) {\n            var numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];\n            if (objectValue && Array.isArray(objectValue[0])) {\n              var startIndex = i;\n              var _iterator4 = _createForOfIteratorHelper(objectValue),\n                _step4;\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  var item = _step4.value;\n                  attribute._normalizeValue(item, value, startIndex);\n                  startIndex += size;\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n            } else if (objectValue && objectValue.length > size) {\n              value.set(objectValue, i);\n            } else {\n              attribute._normalizeValue(objectValue, objectInfo.target, 0);\n              fillArray({\n                target: value,\n                source: objectInfo.target,\n                start: i,\n                count: numVertices\n              });\n            }\n            i += numVertices * size;\n          } else {\n            attribute._normalizeValue(objectValue, value, i);\n            i += size;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"_validateAttributeUpdaters\",\n    value: function _validateAttributeUpdaters() {\n      var settings = this.settings;\n      var hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n      if (!hasUpdater) {\n        throw new Error(\"Attribute \".concat(this.id, \" missing update or accessor\"));\n      }\n    }\n  }, {\n    key: \"_checkAttributeArray\",\n    value: function _checkAttributeArray() {\n      var value = this.value;\n      var limit = Math.min(4, this.size);\n      if (value && value.length >= limit) {\n        var valid = true;\n        switch (limit) {\n          case 4:\n            valid = valid && Number.isFinite(value[3]);\n          case 3:\n            valid = valid && Number.isFinite(value[2]);\n          case 2:\n            valid = valid && Number.isFinite(value[1]);\n          case 1:\n            valid = valid && Number.isFinite(value[0]);\n            break;\n          default:\n            valid = false;\n        }\n        if (!valid) {\n          throw new Error(\"Illegal attribute generated for \".concat(this.id));\n        }\n      }\n    }\n  }]);\n  return Attribute;\n}(DataColumn);\nexport { Attribute as default };","map":{"version":3,"names":["DataColumn","assert","createIterable","getAccessorFromBuffer","fillArray","range","normalizeTransitionSettings","Attribute","_DataColumn","_inherits","_super","_createSuper","gl","opts","_this","_classCallCheck","call","startIndices","lastExternalBuffer","binaryValue","binaryAccessor","needsUpdate","needsRedraw","updateRanges","FULL","_defineProperty","_assertThisInitialized","settings","update","accessor","_autoUpdater","undefined","Object","seal","state","_validateAttributeUpdaters","_createClass","key","get","set","layout","value","_ref","arguments","length","_ref$clearChangedFlag","clearChangedFlags","getUpdateTriggers","id","concat","supportsTransition","Boolean","transition","getTransitionSetting","layerSettings","userSettings","Array","isArray","find","a","setNeedsUpdate","reason","dataRange","setNeedsRedraw","_dataRange$startRow","startRow","_dataRange$endRow","endRow","Infinity","add","clearNeedsUpdate","EMPTY","allocate","numInstances","noAlloc","_get","_getPrototypeOf","prototype","updateBuffer","_ref2","data","props","context","_this$settings","updated","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","err","e","f","constant","buffer","byteLength","byteOffset","setData","_iterator2","_step2","_step2$value","startOffset","Number","isFinite","getVertexOffset","endOffset","size","_checkAttributeArray","setConstantValue","hasChanged","setExternalBuffer","setBinaryValue","transform","ArrayBuffer","isView","needsNormalize","stride","offset","nested","row","vertexIndex","getShaderAttributes","shaderAttributeDefs","shaderAttributes","_defineProperty2","shaderAttributeName","assign","attribute","_ref4","accessorFunc","i","_createIterable","iterable","objectInfo","_iterator3","_step3","object","index","objectValue","numVertices","startIndex","_iterator4","_step4","item","_normalizeValue","target","source","start","count","hasUpdater","Error","limit","Math","min","valid","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/core/src/lib/attribute/attribute.ts"],"sourcesContent":["/* eslint-disable complexity */\nimport DataColumn, {DataColumnOptions, ShaderAttributeOptions, BufferAccessor} from './data-column';\nimport {IShaderAttribute} from './shader-attribute';\nimport assert from '../../utils/assert';\nimport {createIterable, getAccessorFromBuffer} from '../../utils/iterable-utils';\nimport {fillArray} from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport {normalizeTransitionSettings, TransitionSettings} from './attribute-transition-utils';\nimport type {Buffer} from '@luma.gl/webgl';\n\nimport type {NumericArray, TypedArray} from '../../types/types';\n\nexport type Accessor<DataType, ReturnType> = (\n  object: DataType,\n  context: {\n    data: any;\n    index: number;\n    target: number[];\n  }\n) => ReturnType;\n\nexport type Updater = (\n  attribute: Attribute,\n  {\n    data,\n    startRow,\n    endRow,\n    props,\n    numInstances\n  }: {\n    data: any;\n    startRow: number;\n    endRow: number;\n    props: any;\n    numInstances: number;\n  }\n) => void;\n\nexport type AttributeOptions = DataColumnOptions<{\n  transition?: boolean | Partial<TransitionSettings>;\n  noAlloc?: boolean;\n  update?: Updater;\n  accessor?: Accessor<any, any> | string | string[];\n  transform?: (value: any) => any;\n  shaderAttributes?: Record<string, Partial<ShaderAttributeOptions>>;\n}>;\n\nexport type BinaryAttribute = Partial<BufferAccessor> & {value?: TypedArray; buffer?: Buffer};\n\ntype AttributeInternalState = {\n  startIndices: NumericArray | null;\n  /** Legacy: external binary supplied via attribute name */\n  lastExternalBuffer: TypedArray | Buffer | BinaryAttribute | null;\n  /** External binary supplied via accessor name */\n  binaryValue: TypedArray | Buffer | BinaryAttribute | null;\n  binaryAccessor: Accessor<any, any> | null;\n  needsUpdate: string | boolean;\n  needsRedraw: string | boolean;\n  updateRanges: number[][];\n};\n\nexport default class Attribute extends DataColumn<AttributeOptions, AttributeInternalState> {\n  /** Legacy approach to set attribute value - read `isConstant` instead for attribute state */\n  constant: boolean = false;\n\n  constructor(gl: WebGLRenderingContext, opts: AttributeOptions) {\n    super(gl, opts, {\n      startIndices: null,\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL\n    });\n\n    // eslint-disable-next-line\n    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);\n\n    Object.seal(this.settings);\n    Object.seal(this.state);\n\n    // Check all fields and generate helpful error messages\n    this._validateAttributeUpdaters();\n  }\n\n  get startIndices(): NumericArray | null {\n    return this.state.startIndices;\n  }\n\n  set startIndices(layout: NumericArray | null) {\n    this.state.startIndices = layout;\n  }\n\n  needsUpdate(): string | boolean {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw({clearChangedFlags = false}: {clearChangedFlags?: boolean} = {}): string | boolean {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  getUpdateTriggers(): string[] {\n    const {accessor} = this.settings;\n\n    // Backards compatibility: allow attribute name to be used as update trigger key\n    return [this.id].concat((typeof accessor !== 'function' && accessor) || []);\n  }\n\n  supportsTransition(): boolean {\n    return Boolean(this.settings.transition);\n  }\n\n  // Resolve transition settings object if transition is enabled, otherwise `null`\n  getTransitionSetting(opts: Record<string, any>): TransitionSettings | null {\n    if (!opts || !this.supportsTransition()) {\n      return null;\n    }\n    const {accessor} = this.settings;\n    // TODO: have the layer resolve these transition settings itself?\n    const layerSettings = this.settings.transition;\n    // these are the transition settings passed in by the user\n    const userSettings = Array.isArray(accessor)\n      ? // @ts-ignore\n        opts[accessor.find(a => opts[a])]\n      : // @ts-ignore\n        opts[accessor];\n\n    // Shorthand: use duration instead of parameter object\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n\n  setNeedsUpdate(reason: string = this.id, dataRange?: {startRow?: number; endRow?: number}): void {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n    if (dataRange) {\n      const {startRow = 0, endRow = Infinity} = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n\n  clearNeedsUpdate(): void {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n\n  setNeedsRedraw(reason: string = this.id): void {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  allocate(numInstances: number): boolean {\n    const {state, settings} = this;\n\n    if (settings.noAlloc) {\n      // Data is provided through a Buffer object.\n      return false;\n    }\n\n    if (settings.update) {\n      super.allocate(numInstances, state.updateRanges !== range.FULL);\n      return true;\n    }\n\n    return false;\n  }\n\n  updateBuffer({\n    numInstances,\n    data,\n    props,\n    context\n  }: {\n    numInstances: number;\n    data: any;\n    props: any;\n    context: any;\n  }): boolean {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const {\n      state: {updateRanges},\n      settings: {update, noAlloc}\n    } = this;\n\n    let updated = true;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {data, startRow, endRow, props, numInstances});\n      }\n      if (!this.value) {\n        // no value was assigned during update\n      } else if (\n        this.constant ||\n        this.buffer.byteLength < (this.value as TypedArray).byteLength + this.byteOffset\n      ) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n        // Setting attribute.constant in updater is a legacy approach that interferes with allocation in the next cycle\n        // Respect it here but reset after use\n        this.constant = false;\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow)\n            ? this.getVertexOffset(endRow)\n            : noAlloc || !Number.isFinite(numInstances)\n            ? this.value.length\n            : numInstances * this.size;\n\n          super.updateSubBuffer({startOffset, endOffset});\n        }\n      }\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n\n    return updated;\n  }\n\n  // Use generic value\n  // Returns true if successful\n  setConstantValue(value?: NumericArray): boolean {\n    if (value === undefined || typeof value === 'function') {\n      return false;\n    }\n\n    const hasChanged = this.setData({constant: true, value});\n\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n    this.clearNeedsUpdate();\n    return true;\n  }\n\n  // Use external buffer\n  // Returns true if successful\n  // eslint-disable-next-line max-statements\n  setExternalBuffer(buffer?: TypedArray | Buffer | BinaryAttribute): boolean {\n    const {state} = this;\n\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n\n  // Binary value is a typed array packed from mapping the source data with the accessor\n  // If the returned value from the accessor is the same as the attribute value, set it directly\n  // Otherwise use the auto updater for transform/normalization\n  setBinaryValue(\n    buffer?: TypedArray | Buffer | BinaryAttribute,\n    startIndices: NumericArray | null = null\n  ): boolean {\n    const {state, settings} = this;\n\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n\n    if (settings.noAlloc) {\n      // Let the layer handle this\n      return false;\n    }\n\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n    if (needsUpdate) {\n      if (ArrayBuffer.isView(buffer)) {\n        buffer = {value: buffer};\n      }\n      const binaryValue = buffer as BinaryAttribute;\n      assert(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);\n      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;\n\n      state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {\n        size: binaryValue.size || this.size,\n        stride: binaryValue.stride,\n        offset: binaryValue.offset,\n        startIndices: startIndices as NumericArray,\n        nested: needsNormalize\n      });\n      // Fall through to auto updater\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n\n  getVertexOffset(row: number): number {\n    const {startIndices} = this;\n    const vertexIndex = startIndices\n      ? row < startIndices.length\n        ? startIndices[row]\n        : this.numInstances\n      : row;\n    return vertexIndex * this.size;\n  }\n\n  getShaderAttributes(): Record<string, IShaderAttribute> {\n    const shaderAttributeDefs = this.settings.shaderAttributes || {[this.id]: null};\n    const shaderAttributes: Record<string, IShaderAttribute> = {};\n\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(\n        shaderAttributes,\n        super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName])\n      );\n    }\n\n    return shaderAttributes;\n  }\n\n  /* eslint-disable max-depth, max-statements */\n  private _autoUpdater(\n    attribute: Attribute,\n    {\n      data,\n      startRow,\n      endRow,\n      props,\n      numInstances\n    }: {\n      data: any;\n      startRow: number;\n      endRow: number;\n      props: any;\n      numInstances: number;\n    }\n  ): void {\n    if (attribute.constant) {\n      return;\n    }\n    const {settings, state, value, size, startIndices} = attribute;\n\n    const {accessor, transform} = settings;\n    const accessorFunc: Accessor<any, any> =\n      state.binaryAccessor ||\n      // @ts-ignore\n      (typeof accessor === 'function' ? accessor : props[accessor]);\n\n    assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n\n    let i = attribute.getVertexOffset(startRow);\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n\n      let objectValue = accessorFunc(object, objectInfo);\n      if (transform) {\n        // transform callbacks could be bound to a particular layer instance.\n        // always point `this` to the current layer.\n        objectValue = transform.call(this, objectValue);\n      }\n\n      if (startIndices) {\n        const numVertices =\n          (objectInfo.index < startIndices.length - 1\n            ? startIndices[objectInfo.index + 1]\n            : numInstances) - startIndices[objectInfo.index];\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value as TypedArray, startIndex);\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          (value as TypedArray).set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value as TypedArray, i);\n        i += size;\n      }\n    }\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  // Validate deck.gl level fields\n  private _validateAttributeUpdaters() {\n    const {settings} = this;\n\n    // Check that 'update' is a valid function\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${this.id} missing update or accessor`);\n    }\n  }\n\n  // check that the first few elements of the attribute are reasonable\n  /* eslint-disable no-fallthrough */\n  private _checkAttributeArray() {\n    const {value} = this;\n    const limit = Math.min(4, this.size);\n    if (value && value.length >= limit) {\n      let valid = true;\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n        default:\n          valid = false;\n      }\n\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${this.id}`);\n      }\n    }\n  }\n  /* eslint-enable no-fallthrough */\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}