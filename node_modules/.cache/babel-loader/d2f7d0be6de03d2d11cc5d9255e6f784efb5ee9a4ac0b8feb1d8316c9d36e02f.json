{"ast":null,"code":"/*\n * Copyright 2015, Yahoo Inc.\n * Copyrights licensed under the New BSD License.\n * See the accompanying LICENSE file for terms.\n */\nimport { createError, filterProps, getNamedFormat } from '../utils';\nvar DATE_TIME_FORMAT_OPTIONS = ['localeMatcher', 'formatMatcher', 'timeZone', 'hour12', 'weekday', 'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName'];\nexport function getFormatter(_ref, type, getDateTimeFormat) {\n  var locale = _ref.locale,\n    formats = _ref.formats,\n    onError = _ref.onError,\n    timeZone = _ref.timeZone;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var format = options.format;\n  var defaults = Object.assign(Object.assign({}, timeZone && {\n    timeZone: timeZone\n  }), format && getNamedFormat(formats, type, format, onError));\n  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);\n  if (type === 'time' && !filteredOptions.hour && !filteredOptions.minute && !filteredOptions.second) {\n    // Add default formatting options if hour, minute, or second isn't defined.\n    filteredOptions = Object.assign(Object.assign({}, filteredOptions), {\n      hour: 'numeric',\n      minute: 'numeric'\n    });\n  }\n  return getDateTimeFormat(locale, filteredOptions);\n}\nexport function formatDate(config, getDateTimeFormat, value) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var date = typeof value === 'string' ? new Date(value || 0) : value;\n  try {\n    return getFormatter(config, 'date', getDateTimeFormat, options).format(date);\n  } catch (e) {\n    config.onError(createError('Error formatting date.', e));\n  }\n  return String(date);\n}\nexport function formatTime(config, getDateTimeFormat, value) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var date = typeof value === 'string' ? new Date(value || 0) : value;\n  try {\n    return getFormatter(config, 'time', getDateTimeFormat, options).format(date);\n  } catch (e) {\n    config.onError(createError('Error formatting time.', e));\n  }\n  return String(date);\n}\nexport function formatDateToParts(config, getDateTimeFormat, value) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var date = typeof value === 'string' ? new Date(value || 0) : value;\n  try {\n    return getFormatter(config, 'date', getDateTimeFormat, options).formatToParts(date);\n  } catch (e) {\n    config.onError(createError('Error formatting date.', e));\n  }\n  return [];\n}\nexport function formatTimeToParts(config, getDateTimeFormat, value) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var date = typeof value === 'string' ? new Date(value || 0) : value;\n  try {\n    return getFormatter(config, 'time', getDateTimeFormat, options).formatToParts(date);\n  } catch (e) {\n    config.onError(createError('Error formatting time.', e));\n  }\n  return [];\n}","map":{"version":3,"names":["createError","filterProps","getNamedFormat","DATE_TIME_FORMAT_OPTIONS","getFormatter","_ref","type","getDateTimeFormat","locale","formats","onError","timeZone","options","arguments","length","undefined","format","defaults","Object","assign","filteredOptions","hour","minute","second","formatDate","config","value","date","Date","e","String","formatTime","formatDateToParts","formatToParts","formatTimeToParts"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/react-intl/lib/formatters/dateTime.js"],"sourcesContent":["/*\n * Copyright 2015, Yahoo Inc.\n * Copyrights licensed under the New BSD License.\n * See the accompanying LICENSE file for terms.\n */\nimport { createError, filterProps, getNamedFormat } from '../utils';\nconst DATE_TIME_FORMAT_OPTIONS = [\n    'localeMatcher',\n    'formatMatcher',\n    'timeZone',\n    'hour12',\n    'weekday',\n    'era',\n    'year',\n    'month',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'timeZoneName',\n];\nexport function getFormatter({ locale, formats, onError, timeZone, }, type, getDateTimeFormat, options = {}) {\n    const { format } = options;\n    const defaults = Object.assign(Object.assign({}, (timeZone && { timeZone })), (format && getNamedFormat(formats, type, format, onError)));\n    let filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);\n    if (type === 'time' &&\n        !filteredOptions.hour &&\n        !filteredOptions.minute &&\n        !filteredOptions.second) {\n        // Add default formatting options if hour, minute, or second isn't defined.\n        filteredOptions = Object.assign(Object.assign({}, filteredOptions), { hour: 'numeric', minute: 'numeric' });\n    }\n    return getDateTimeFormat(locale, filteredOptions);\n}\nexport function formatDate(config, getDateTimeFormat, value, options = {}) {\n    const date = typeof value === 'string' ? new Date(value || 0) : value;\n    try {\n        return getFormatter(config, 'date', getDateTimeFormat, options).format(date);\n    }\n    catch (e) {\n        config.onError(createError('Error formatting date.', e));\n    }\n    return String(date);\n}\nexport function formatTime(config, getDateTimeFormat, value, options = {}) {\n    const date = typeof value === 'string' ? new Date(value || 0) : value;\n    try {\n        return getFormatter(config, 'time', getDateTimeFormat, options).format(date);\n    }\n    catch (e) {\n        config.onError(createError('Error formatting time.', e));\n    }\n    return String(date);\n}\nexport function formatDateToParts(config, getDateTimeFormat, value, options = {}) {\n    const date = typeof value === 'string' ? new Date(value || 0) : value;\n    try {\n        return getFormatter(config, 'date', getDateTimeFormat, options).formatToParts(date);\n    }\n    catch (e) {\n        config.onError(createError('Error formatting date.', e));\n    }\n    return [];\n}\nexport function formatTimeToParts(config, getDateTimeFormat, value, options = {}) {\n    const date = typeof value === 'string' ? new Date(value || 0) : value;\n    try {\n        return getFormatter(config, 'time', getDateTimeFormat, options).formatToParts(date);\n    }\n    catch (e) {\n        config.onError(createError('Error formatting time.', e));\n    }\n    return [];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}