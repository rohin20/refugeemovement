{"ast":null,"code":"import _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty2 from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _DEFAULT_SAMPLER;\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { assert } from '../utils/assert';\nimport { getAccessorArrayTypeAndLength } from '../gltf-utils/gltf-utils';\nvar COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nvar BYTES = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\nvar GL_SAMPLER = {\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\nvar SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\nvar DEFAULT_SAMPLER = (_DEFAULT_SAMPLER = {}, _defineProperty2(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_MAG_FILTER, GL_SAMPLER.LINEAR), _defineProperty2(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_MIN_FILTER, GL_SAMPLER.NEAREST_MIPMAP_LINEAR), _defineProperty2(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_WRAP_S, GL_SAMPLER.REPEAT), _defineProperty2(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_WRAP_T, GL_SAMPLER.REPEAT), _DEFAULT_SAMPLER);\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\nvar GLTFPostProcessor = /*#__PURE__*/function () {\n  function GLTFPostProcessor() {\n    _classCallCheck(this, GLTFPostProcessor);\n    _defineProperty(this, \"baseUri\", '');\n    _defineProperty(this, \"json\", {});\n    _defineProperty(this, \"buffers\", []);\n    _defineProperty(this, \"images\", []);\n  }\n  _createClass(GLTFPostProcessor, [{\n    key: \"postProcess\",\n    value: function postProcess(gltf) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var json = gltf.json,\n        _gltf$buffers = gltf.buffers,\n        buffers = _gltf$buffers === void 0 ? [] : _gltf$buffers,\n        _gltf$images = gltf.images,\n        images = _gltf$images === void 0 ? [] : _gltf$images,\n        _gltf$baseUri = gltf.baseUri,\n        baseUri = _gltf$baseUri === void 0 ? '' : _gltf$baseUri;\n      assert(json);\n      this.baseUri = baseUri;\n      this.json = json;\n      this.buffers = buffers;\n      this.images = images;\n      this._resolveTree(this.json, options);\n      return this.json;\n    }\n  }, {\n    key: \"_resolveTree\",\n    value: function _resolveTree(json) {\n      var _this = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (json.bufferViews) {\n        json.bufferViews = json.bufferViews.map(function (bufView, i) {\n          return _this._resolveBufferView(bufView, i);\n        });\n      }\n      if (json.images) {\n        json.images = json.images.map(function (image, i) {\n          return _this._resolveImage(image, i);\n        });\n      }\n      if (json.samplers) {\n        json.samplers = json.samplers.map(function (sampler, i) {\n          return _this._resolveSampler(sampler, i);\n        });\n      }\n      if (json.textures) {\n        json.textures = json.textures.map(function (texture, i) {\n          return _this._resolveTexture(texture, i);\n        });\n      }\n      if (json.accessors) {\n        json.accessors = json.accessors.map(function (accessor, i) {\n          return _this._resolveAccessor(accessor, i);\n        });\n      }\n      if (json.materials) {\n        json.materials = json.materials.map(function (material, i) {\n          return _this._resolveMaterial(material, i);\n        });\n      }\n      if (json.meshes) {\n        json.meshes = json.meshes.map(function (mesh, i) {\n          return _this._resolveMesh(mesh, i);\n        });\n      }\n      if (json.nodes) {\n        json.nodes = json.nodes.map(function (node, i) {\n          return _this._resolveNode(node, i);\n        });\n      }\n      if (json.skins) {\n        json.skins = json.skins.map(function (skin, i) {\n          return _this._resolveSkin(skin, i);\n        });\n      }\n      if (json.scenes) {\n        json.scenes = json.scenes.map(function (scene, i) {\n          return _this._resolveScene(scene, i);\n        });\n      }\n      if (json.scene !== undefined) {\n        json.scene = json.scenes[this.json.scene];\n      }\n    }\n  }, {\n    key: \"getScene\",\n    value: function getScene(index) {\n      return this._get('scenes', index);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(index) {\n      return this._get('nodes', index);\n    }\n  }, {\n    key: \"getSkin\",\n    value: function getSkin(index) {\n      return this._get('skins', index);\n    }\n  }, {\n    key: \"getMesh\",\n    value: function getMesh(index) {\n      return this._get('meshes', index);\n    }\n  }, {\n    key: \"getMaterial\",\n    value: function getMaterial(index) {\n      return this._get('materials', index);\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor(index) {\n      return this._get('accessors', index);\n    }\n  }, {\n    key: \"getCamera\",\n    value: function getCamera(index) {\n      return null;\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture(index) {\n      return this._get('textures', index);\n    }\n  }, {\n    key: \"getSampler\",\n    value: function getSampler(index) {\n      return this._get('samplers', index);\n    }\n  }, {\n    key: \"getImage\",\n    value: function getImage(index) {\n      return this._get('images', index);\n    }\n  }, {\n    key: \"getBufferView\",\n    value: function getBufferView(index) {\n      return this._get('bufferViews', index);\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer(index) {\n      return this._get('buffers', index);\n    }\n  }, {\n    key: \"_get\",\n    value: function _get(array, index) {\n      if (typeof index === 'object') {\n        return index;\n      }\n      var object = this.json[array] && this.json[array][index];\n      if (!object) {\n        console.warn(\"glTF file error: Could not find \".concat(array, \"[\").concat(index, \"]\"));\n      }\n      return object;\n    }\n  }, {\n    key: \"_resolveScene\",\n    value: function _resolveScene(scene, index) {\n      var _this2 = this;\n      scene.id = scene.id || \"scene-\".concat(index);\n      scene.nodes = (scene.nodes || []).map(function (node) {\n        return _this2.getNode(node);\n      });\n      return scene;\n    }\n  }, {\n    key: \"_resolveNode\",\n    value: function _resolveNode(node, index) {\n      var _this3 = this;\n      node.id = node.id || \"node-\".concat(index);\n      if (node.children) {\n        node.children = node.children.map(function (child) {\n          return _this3.getNode(child);\n        });\n      }\n      if (node.mesh !== undefined) {\n        node.mesh = this.getMesh(node.mesh);\n      } else if (node.meshes !== undefined && node.meshes.length) {\n        node.mesh = node.meshes.reduce(function (accum, meshIndex) {\n          var mesh = _this3.getMesh(meshIndex);\n          accum.id = mesh.id;\n          accum.primitives = accum.primitives.concat(mesh.primitives);\n          return accum;\n        }, {\n          primitives: []\n        });\n      }\n      if (node.camera !== undefined) {\n        node.camera = this.getCamera(node.camera);\n      }\n      if (node.skin !== undefined) {\n        node.skin = this.getSkin(node.skin);\n      }\n      return node;\n    }\n  }, {\n    key: \"_resolveSkin\",\n    value: function _resolveSkin(skin, index) {\n      skin.id = skin.id || \"skin-\".concat(index);\n      skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n      return skin;\n    }\n  }, {\n    key: \"_resolveMesh\",\n    value: function _resolveMesh(mesh, index) {\n      var _this4 = this;\n      mesh.id = mesh.id || \"mesh-\".concat(index);\n      if (mesh.primitives) {\n        mesh.primitives = mesh.primitives.map(function (primitive) {\n          primitive = _objectSpread({}, primitive);\n          var attributes = primitive.attributes;\n          primitive.attributes = {};\n          for (var attribute in attributes) {\n            primitive.attributes[attribute] = _this4.getAccessor(attributes[attribute]);\n          }\n          if (primitive.indices !== undefined) {\n            primitive.indices = _this4.getAccessor(primitive.indices);\n          }\n          if (primitive.material !== undefined) {\n            primitive.material = _this4.getMaterial(primitive.material);\n          }\n          return primitive;\n        });\n      }\n      return mesh;\n    }\n  }, {\n    key: \"_resolveMaterial\",\n    value: function _resolveMaterial(material, index) {\n      material.id = material.id || \"material-\".concat(index);\n      if (material.normalTexture) {\n        material.normalTexture = _objectSpread({}, material.normalTexture);\n        material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n      }\n      if (material.occlusionTexture) {\n        material.occlustionTexture = _objectSpread({}, material.occlustionTexture);\n        material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n      }\n      if (material.emissiveTexture) {\n        material.emmisiveTexture = _objectSpread({}, material.emmisiveTexture);\n        material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n      }\n      if (!material.emissiveFactor) {\n        material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n      }\n      if (material.pbrMetallicRoughness) {\n        material.pbrMetallicRoughness = _objectSpread({}, material.pbrMetallicRoughness);\n        var mr = material.pbrMetallicRoughness;\n        if (mr.baseColorTexture) {\n          mr.baseColorTexture = _objectSpread({}, mr.baseColorTexture);\n          mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n        }\n        if (mr.metallicRoughnessTexture) {\n          mr.metallicRoughnessTexture = _objectSpread({}, mr.metallicRoughnessTexture);\n          mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n        }\n      }\n      return material;\n    }\n  }, {\n    key: \"_resolveAccessor\",\n    value: function _resolveAccessor(accessor, index) {\n      accessor.id = accessor.id || \"accessor-\".concat(index);\n      if (accessor.bufferView !== undefined) {\n        accessor.bufferView = this.getBufferView(accessor.bufferView);\n      }\n      accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n      accessor.components = getSizeFromAccessorType(accessor.type);\n      accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n      if (accessor.bufferView) {\n        var buffer = accessor.bufferView.buffer;\n        var _getAccessorArrayType = getAccessorArrayTypeAndLength(accessor, accessor.bufferView),\n          ArrayType = _getAccessorArrayType.ArrayType,\n          byteLength = _getAccessorArrayType.byteLength;\n        var byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n        var cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n        if (accessor.bufferView.byteStride) {\n          cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);\n        }\n        accessor.value = new ArrayType(cutBuffer);\n      }\n      return accessor;\n    }\n  }, {\n    key: \"_getValueFromInterleavedBuffer\",\n    value: function _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n      var result = new Uint8Array(count * bytesPerElement);\n      for (var i = 0; i < count; i++) {\n        var elementOffset = byteOffset + i * byteStride;\n        result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i * bytesPerElement);\n      }\n      return result.buffer;\n    }\n  }, {\n    key: \"_resolveTexture\",\n    value: function _resolveTexture(texture, index) {\n      texture.id = texture.id || \"texture-\".concat(index);\n      texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n      texture.source = this.getImage(texture.source);\n      return texture;\n    }\n  }, {\n    key: \"_resolveSampler\",\n    value: function _resolveSampler(sampler, index) {\n      sampler.id = sampler.id || \"sampler-\".concat(index);\n      sampler.parameters = {};\n      for (var key in sampler) {\n        var glEnum = this._enumSamplerParameter(key);\n        if (glEnum !== undefined) {\n          sampler.parameters[glEnum] = sampler[key];\n        }\n      }\n      return sampler;\n    }\n  }, {\n    key: \"_enumSamplerParameter\",\n    value: function _enumSamplerParameter(key) {\n      return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n    }\n  }, {\n    key: \"_resolveImage\",\n    value: function _resolveImage(image, index) {\n      image.id = image.id || \"image-\".concat(index);\n      if (image.bufferView !== undefined) {\n        image.bufferView = this.getBufferView(image.bufferView);\n      }\n      var preloadedImage = this.images[index];\n      if (preloadedImage) {\n        image.image = preloadedImage;\n      }\n      return image;\n    }\n  }, {\n    key: \"_resolveBufferView\",\n    value: function _resolveBufferView(bufferView, index) {\n      var bufferIndex = bufferView.buffer;\n      var result = _objectSpread(_objectSpread({\n        id: \"bufferView-\".concat(index)\n      }, bufferView), {}, {\n        buffer: this.buffers[bufferIndex]\n      });\n      var arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n      var byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n      if ('byteOffset' in bufferView) {\n        byteOffset += bufferView.byteOffset;\n      }\n      result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n      return result;\n    }\n  }, {\n    key: \"_resolveCamera\",\n    value: function _resolveCamera(camera, index) {\n      camera.id = camera.id || \"camera-\".concat(index);\n      if (camera.perspective) {}\n      if (camera.orthographic) {}\n      return camera;\n    }\n  }]);\n  return GLTFPostProcessor;\n}();\nexport function postProcessGLTF(gltf, options) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}","map":{"version":3,"names":["assert","getAccessorArrayTypeAndLength","COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","BYTES","GL_SAMPLER","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","REPEAT","LINEAR","NEAREST_MIPMAP_LINEAR","SAMPLER_PARAMETER_GLTF_TO_GL","magFilter","minFilter","wrapS","wrapT","DEFAULT_SAMPLER","_DEFAULT_SAMPLER","_defineProperty2","getBytesFromComponentType","componentType","getSizeFromAccessorType","type","GLTFPostProcessor","_classCallCheck","_defineProperty","_createClass","key","value","postProcess","gltf","options","arguments","length","undefined","json","_gltf$buffers","buffers","_gltf$images","images","_gltf$baseUri","baseUri","_resolveTree","_this","bufferViews","map","bufView","i","_resolveBufferView","image","_resolveImage","samplers","sampler","_resolveSampler","textures","texture","_resolveTexture","accessors","accessor","_resolveAccessor","materials","material","_resolveMaterial","meshes","mesh","_resolveMesh","nodes","node","_resolveNode","skins","skin","_resolveSkin","scenes","scene","_resolveScene","getScene","index","_get","getNode","getSkin","getMesh","getMaterial","getAccessor","getCamera","getTexture","getSampler","getImage","getBufferView","getBuffer","array","object","console","warn","concat","_this2","id","_this3","children","child","reduce","accum","meshIndex","primitives","camera","inverseBindMatrices","_this4","primitive","_objectSpread","attributes","attribute","indices","normalTexture","occlusionTexture","occlustionTexture","emissiveTexture","emmisiveTexture","emissiveFactor","pbrMetallicRoughness","mr","baseColorTexture","metallicRoughnessTexture","bufferView","bytesPerComponent","components","bytesPerElement","buffer","_getAccessorArrayType","ArrayType","byteLength","byteOffset","cutBuffer","arrayBuffer","slice","byteStride","_getValueFromInterleavedBuffer","count","result","Uint8Array","elementOffset","set","source","parameters","glEnum","_enumSamplerParameter","preloadedImage","bufferIndex","data","_resolveCamera","perspective","orthographic","postProcessGLTF"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/gltf/src/lib/api/post-process-gltf.ts"],"sourcesContent":["import {assert} from '../utils/assert';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\nimport {BufferView} from '../types/gltf-json-schema';\nimport {BufferView as BufferViewPostprocessed} from '../types/gltf-postprocessed-schema';\n\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n\n// ENUM LOOKUP\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\nconst GL_SAMPLER = {\n  // Sampler parameters\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n\n  // Sampler default values\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\n\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nclass GLTFPostProcessor {\n  baseUri: string = '';\n  json: Record<string, any> = {};\n  buffers: [] = [];\n  images: [] = [];\n\n  postProcess(gltf, options = {}) {\n    const {json, buffers = [], images = [], baseUri = ''} = gltf;\n    assert(json);\n\n    this.baseUri = baseUri;\n    this.json = json;\n    this.buffers = buffers;\n    this.images = images;\n\n    this._resolveTree(this.json, options);\n\n    return this.json;\n  }\n\n  // Convert indexed glTF structure into tree structure\n  // cross-link index resolution, enum lookup, convenience calculations\n  // eslint-disable-next-line complexity\n  _resolveTree(json, options = {}) {\n    if (json.bufferViews) {\n      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n    if (json.images) {\n      json.images = json.images.map((image, i) => this._resolveImage(image, i));\n    }\n    if (json.samplers) {\n      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n    if (json.textures) {\n      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n    if (json.accessors) {\n      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n    if (json.materials) {\n      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n    if (json.meshes) {\n      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n    if (json.nodes) {\n      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));\n    }\n    if (json.skins) {\n      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n    if (json.scenes) {\n      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n    if (json.scene !== undefined) {\n      json.scene = json.scenes[this.json.scene];\n    }\n  }\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null; // TODO: fix this\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  // PARSING HELPERS\n\n  _resolveScene(scene, index) {\n    // scene = {...scene};\n    scene.id = scene.id || `scene-${index}`;\n    scene.nodes = (scene.nodes || []).map((node) => this.getNode(node));\n    return scene;\n  }\n\n  _resolveNode(node, index) {\n    // node = {...node};\n    node.id = node.id || `node-${index}`;\n    if (node.children) {\n      node.children = node.children.map((child) => this.getNode(child));\n    }\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    } else if (node.meshes !== undefined && node.meshes.length) {\n      node.mesh = node.meshes.reduce(\n        (accum, meshIndex) => {\n          const mesh = this.getMesh(meshIndex);\n          accum.id = mesh.id;\n          accum.primitives = accum.primitives.concat(mesh.primitives);\n          return accum;\n        },\n        {primitives: []}\n      );\n    }\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n    return node;\n  }\n\n  _resolveSkin(skin, index) {\n    // skin = {...skin};\n    skin.id = skin.id || `skin-${index}`;\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n    return skin;\n  }\n\n  _resolveMesh(mesh, index) {\n    // mesh = {...mesh};\n    mesh.id = mesh.id || `mesh-${index}`;\n    if (mesh.primitives) {\n      mesh.primitives = mesh.primitives.map((primitive) => {\n        primitive = {...primitive};\n        const attributes = primitive.attributes;\n        primitive.attributes = {};\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n        if (primitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(primitive.indices);\n        }\n        if (primitive.material !== undefined) {\n          primitive.material = this.getMaterial(primitive.material);\n        }\n        return primitive;\n      });\n    }\n    return mesh;\n  }\n\n  _resolveMaterial(material, index) {\n    // material = {...material};\n    material.id = material.id || `material-${index}`;\n    if (material.normalTexture) {\n      material.normalTexture = {...material.normalTexture};\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlustionTexture = {...material.occlustionTexture};\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emmisiveTexture = {...material.emmisiveTexture};\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = {...material.pbrMetallicRoughness};\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = {...mr.baseColorTexture};\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = {...mr.metallicRoughnessTexture};\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n    return material;\n  }\n\n  _resolveAccessor(accessor, index) {\n    // accessor = {...accessor};\n    accessor.id = accessor.id || `accessor-${index}`;\n    if (accessor.bufferView !== undefined) {\n      // Draco encoded meshes don't have bufferView\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    // Look up enums\n    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n    accessor.components = getSizeFromAccessorType(accessor.type);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n    // Create TypedArray for the accessor\n    // Note: The canonical way to instantiate is to ignore this array and create\n    // WebGLBuffer's using the bufferViews.\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {ArrayType, byteLength} = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset =\n        (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n      if (accessor.bufferView.byteStride) {\n        cutBuffer = this._getValueFromInterleavedBuffer(\n          buffer,\n          byteOffset,\n          accessor.bufferView.byteStride,\n          accessor.bytesPerElement,\n          accessor.count\n        );\n      }\n      accessor.value = new ArrayType(cutBuffer);\n    }\n\n    return accessor;\n  }\n\n  /**\n   * Take values of particular accessor from interleaved buffer\n   * various parts of the buffer\n   * @param buffer\n   * @param byteOffset\n   * @param byteStride\n   * @param bytesPerElement\n   * @param count\n   * @returns\n   */\n  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n    const result = new Uint8Array(count * bytesPerElement);\n    for (let i = 0; i < count; i++) {\n      const elementOffset = byteOffset + i * byteStride;\n      result.set(\n        new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)),\n        i * bytesPerElement\n      );\n    }\n    return result.buffer;\n  }\n\n  _resolveTexture(texture, index) {\n    // texture = {...texture};\n    texture.id = texture.id || `texture-${index}`;\n    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n    texture.source = this.getImage(texture.source);\n    return texture;\n  }\n\n  _resolveSampler(sampler, index) {\n    // sampler = {...sampler};\n    sampler.id = sampler.id || `sampler-${index}`;\n    // Map textual parameters to GL parameter values\n    sampler.parameters = {};\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n    return sampler;\n  }\n\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n\n  _resolveImage(image, index) {\n    // image = {...image};\n    image.id = image.id || `image-${index}`;\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    // Check if image has been preloaded by the GLTFLoader\n    // If so, link it into the JSON and drop the URI\n    const preloadedImage = this.images[index];\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n\n    return image;\n  }\n\n  _resolveBufferView(bufferView: BufferView, index: number): BufferViewPostprocessed {\n    // bufferView = {...bufferView};\n    const bufferIndex = bufferView.buffer;\n    const result: BufferViewPostprocessed = {\n      id: `bufferView-${index}`,\n      ...bufferView,\n      buffer: this.buffers[bufferIndex]\n    };\n\n    // @ts-expect-error\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    // @ts-expect-error\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n    if ('byteOffset' in bufferView) {\n      byteOffset += bufferView.byteOffset;\n    }\n\n    result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    return result;\n  }\n\n  _resolveCamera(camera, index) {\n    camera.id = camera.id || `camera-${index}`;\n    // TODO - create 4x4 matrices\n    if (camera.perspective) {\n      // camera.matrix = createPerspectiveMatrix(camera.perspective);\n    }\n    if (camera.orthographic) {\n      // camera.matrix = createOrthographicMatrix(camera.orthographic);\n    }\n    return camera;\n  }\n}\n\nexport function postProcessGLTF(gltf, options?) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}\n"],"mappings":";;;;;;AAAA,SAAQA,MAAM,QAAO,iBAAiB;AACtC,SAAQC,6BAA6B,QAAO,0BAA0B;AActE,IAAMC,UAAU,GAAG;EACjBC,MAAM,EAAE,CAAC;EACTC,IAAI,EAAE,CAAC;EACPC,IAAI,EAAE,CAAC;EACPC,IAAI,EAAE,CAAC;EACPC,IAAI,EAAE,CAAC;EACPC,IAAI,EAAE,CAAC;EACPC,IAAI,EAAE;AACR,CAAC;AAED,IAAMC,KAAK,GAAG;EACZ,IAAI,EAAE,CAAC;EACP,IAAI,EAAE,CAAC;EACP,IAAI,EAAE,CAAC;EACP,IAAI,EAAE,CAAC;EACP,IAAI,EAAE,CAAC;EACP,IAAI,EAAE;AACR,CAAC;AAED,IAAMC,UAAU,GAAG;EAEjBC,kBAAkB,EAAE,MAAM;EAC1BC,kBAAkB,EAAE,MAAM;EAC1BC,cAAc,EAAE,MAAM;EACtBC,cAAc,EAAE,MAAM;EAGtBC,MAAM,EAAE,MAAM;EACdC,MAAM,EAAE,MAAM;EACdC,qBAAqB,EAAE;AACzB,CAAC;AAED,IAAMC,4BAA4B,GAAG;EACnCC,SAAS,EAAET,UAAU,CAACC,kBAAkB;EACxCS,SAAS,EAAEV,UAAU,CAACE,kBAAkB;EACxCS,KAAK,EAAEX,UAAU,CAACG,cAAc;EAChCS,KAAK,EAAEZ,UAAU,CAACI;AACpB,CAAC;AAID,IAAMS,eAAe,IAAAC,gBAAA,OAAAC,gBAAA,CAAAD,gBAAA,EAClBd,UAAU,CAACC,kBAAkB,EAAGD,UAAU,CAACM,MAAM,GAAAS,gBAAA,CAAAD,gBAAA,EACjDd,UAAU,CAACE,kBAAkB,EAAGF,UAAU,CAACO,qBAAqB,GAAAQ,gBAAA,CAAAD,gBAAA,EAChEd,UAAU,CAACG,cAAc,EAAGH,UAAU,CAACK,MAAM,GAAAU,gBAAA,CAAAD,gBAAA,EAC7Cd,UAAU,CAACI,cAAc,EAAGJ,UAAU,CAACK,MAAA,GAAAS,gBAAA,CACzC;AAED,SAASE,yBAAyBA,CAACC,aAAa,EAAE;EAChD,OAAOlB,KAAK,CAACkB,aAAa,CAAC;AAC7B;AAEA,SAASC,uBAAuBA,CAACC,IAAI,EAAE;EACrC,OAAO5B,UAAU,CAAC4B,IAAI,CAAC;AACzB;AAAA,IAEMC,iBAAiB;EAAC,SAAAA,kBAAA;IAAAC,eAAA,OAAAD,iBAAA;IAAAE,eAAA,kBACJ,EAAE;IAAAA,eAAA,eACQ,CAAC,CAAC;IAAAA,eAAA,kBAChB,EAAE;IAAAA,eAAA,iBACH,EAAE;EAAA;EAAAC,YAAA,CAAAH,iBAAA;IAAAI,GAAA;IAAAC,KAAA,EAEf,SAAAC,YAAYC,IAAI,EAAgB;MAAA,IAAdC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;MAC5B,IAAOG,IAAI,GAA6CL,IAAI,CAArDK,IAAI;QAAAC,aAAA,GAA6CN,IAAI,CAA/CO,OAAO;QAAPA,OAAO,GAAAD,aAAA,cAAG,EAAE,GAAAA,aAAA;QAAAE,YAAA,GAA+BR,IAAI,CAAjCS,MAAM;QAANA,MAAM,GAAAD,YAAA,cAAG,EAAE,GAAAA,YAAA;QAAAE,aAAA,GAAkBV,IAAI,CAApBW,OAAO;QAAPA,OAAO,GAAAD,aAAA,cAAG,KAAAA,aAAA;MAClDhD,MAAM,CAAC2C,IAAI,CAAC;MAEZ,IAAI,CAACM,OAAO,GAAGA,OAAO;MACtB,IAAI,CAACN,IAAI,GAAGA,IAAI;MAChB,IAAI,CAACE,OAAO,GAAGA,OAAO;MACtB,IAAI,CAACE,MAAM,GAAGA,MAAM;MAEpB,IAAI,CAACG,YAAY,CAAC,IAAI,CAACP,IAAI,EAAEJ,OAAO,CAAC;MAErC,OAAO,IAAI,CAACI,IAAI;IAClB;EAAA;IAAAR,GAAA;IAAAC,KAAA,EAKA,SAAAc,aAAaP,IAAI,EAAgB;MAAA,IAAAQ,KAAA;MAAA,IAAdZ,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;MAC7B,IAAIG,IAAI,CAACS,WAAW,EAAE;QACpBT,IAAI,CAACS,WAAW,GAAGT,IAAI,CAACS,WAAW,CAACC,GAAG,CAAC,UAACC,OAAO,EAAEC,CAAC;UAAA,OAAKJ,KAAI,CAACK,kBAAkB,CAACF,OAAO,EAAEC,CAAC,CAAC;QAAA,EAAC;MAC9F;MACA,IAAIZ,IAAI,CAACI,MAAM,EAAE;QACfJ,IAAI,CAACI,MAAM,GAAGJ,IAAI,CAACI,MAAM,CAACM,GAAG,CAAC,UAACI,KAAK,EAAEF,CAAC;UAAA,OAAKJ,KAAI,CAACO,aAAa,CAACD,KAAK,EAAEF,CAAC,CAAC;QAAA,EAAC;MAC3E;MACA,IAAIZ,IAAI,CAACgB,QAAQ,EAAE;QACjBhB,IAAI,CAACgB,QAAQ,GAAGhB,IAAI,CAACgB,QAAQ,CAACN,GAAG,CAAC,UAACO,OAAO,EAAEL,CAAC;UAAA,OAAKJ,KAAI,CAACU,eAAe,CAACD,OAAO,EAAEL,CAAC,CAAC;QAAA,EAAC;MACrF;MACA,IAAIZ,IAAI,CAACmB,QAAQ,EAAE;QACjBnB,IAAI,CAACmB,QAAQ,GAAGnB,IAAI,CAACmB,QAAQ,CAACT,GAAG,CAAC,UAACU,OAAO,EAAER,CAAC;UAAA,OAAKJ,KAAI,CAACa,eAAe,CAACD,OAAO,EAAER,CAAC,CAAC;QAAA,EAAC;MACrF;MACA,IAAIZ,IAAI,CAACsB,SAAS,EAAE;QAClBtB,IAAI,CAACsB,SAAS,GAAGtB,IAAI,CAACsB,SAAS,CAACZ,GAAG,CAAC,UAACa,QAAQ,EAAEX,CAAC;UAAA,OAAKJ,KAAI,CAACgB,gBAAgB,CAACD,QAAQ,EAAEX,CAAC,CAAC;QAAA,EAAC;MAC1F;MACA,IAAIZ,IAAI,CAACyB,SAAS,EAAE;QAClBzB,IAAI,CAACyB,SAAS,GAAGzB,IAAI,CAACyB,SAAS,CAACf,GAAG,CAAC,UAACgB,QAAQ,EAAEd,CAAC;UAAA,OAAKJ,KAAI,CAACmB,gBAAgB,CAACD,QAAQ,EAAEd,CAAC,CAAC;QAAA,EAAC;MAC1F;MACA,IAAIZ,IAAI,CAAC4B,MAAM,EAAE;QACf5B,IAAI,CAAC4B,MAAM,GAAG5B,IAAI,CAAC4B,MAAM,CAAClB,GAAG,CAAC,UAACmB,IAAI,EAAEjB,CAAC;UAAA,OAAKJ,KAAI,CAACsB,YAAY,CAACD,IAAI,EAAEjB,CAAC,CAAC;QAAA,EAAC;MACxE;MACA,IAAIZ,IAAI,CAAC+B,KAAK,EAAE;QACd/B,IAAI,CAAC+B,KAAK,GAAG/B,IAAI,CAAC+B,KAAK,CAACrB,GAAG,CAAC,UAACsB,IAAI,EAAEpB,CAAC;UAAA,OAAKJ,KAAI,CAACyB,YAAY,CAACD,IAAI,EAAEpB,CAAC,CAAC;QAAA,EAAC;MACtE;MACA,IAAIZ,IAAI,CAACkC,KAAK,EAAE;QACdlC,IAAI,CAACkC,KAAK,GAAGlC,IAAI,CAACkC,KAAK,CAACxB,GAAG,CAAC,UAACyB,IAAI,EAAEvB,CAAC;UAAA,OAAKJ,KAAI,CAAC4B,YAAY,CAACD,IAAI,EAAEvB,CAAC,CAAC;QAAA,EAAC;MACtE;MACA,IAAIZ,IAAI,CAACqC,MAAM,EAAE;QACfrC,IAAI,CAACqC,MAAM,GAAGrC,IAAI,CAACqC,MAAM,CAAC3B,GAAG,CAAC,UAAC4B,KAAK,EAAE1B,CAAC;UAAA,OAAKJ,KAAI,CAAC+B,aAAa,CAACD,KAAK,EAAE1B,CAAC,CAAC;QAAA,EAAC;MAC3E;MACA,IAAIZ,IAAI,CAACsC,KAAK,KAAKvC,SAAS,EAAE;QAC5BC,IAAI,CAACsC,KAAK,GAAGtC,IAAI,CAACqC,MAAM,CAAC,IAAI,CAACrC,IAAI,CAACsC,KAAK,CAAC;MAC3C;IACF;EAAA;IAAA9C,GAAA;IAAAC,KAAA,EAEA,SAAA+C,SAASC,KAAK,EAAE;MACd,OAAO,IAAI,CAACC,IAAI,CAAC,QAAQ,EAAED,KAAK,CAAC;IACnC;EAAA;IAAAjD,GAAA;IAAAC,KAAA,EAEA,SAAAkD,QAAQF,KAAK,EAAE;MACb,OAAO,IAAI,CAACC,IAAI,CAAC,OAAO,EAAED,KAAK,CAAC;IAClC;EAAA;IAAAjD,GAAA;IAAAC,KAAA,EAEA,SAAAmD,QAAQH,KAAK,EAAE;MACb,OAAO,IAAI,CAACC,IAAI,CAAC,OAAO,EAAED,KAAK,CAAC;IAClC;EAAA;IAAAjD,GAAA;IAAAC,KAAA,EAEA,SAAAoD,QAAQJ,KAAK,EAAE;MACb,OAAO,IAAI,CAACC,IAAI,CAAC,QAAQ,EAAED,KAAK,CAAC;IACnC;EAAA;IAAAjD,GAAA;IAAAC,KAAA,EAEA,SAAAqD,YAAYL,KAAK,EAAE;MACjB,OAAO,IAAI,CAACC,IAAI,CAAC,WAAW,EAAED,KAAK,CAAC;IACtC;EAAA;IAAAjD,GAAA;IAAAC,KAAA,EAEA,SAAAsD,YAAYN,KAAK,EAAE;MACjB,OAAO,IAAI,CAACC,IAAI,CAAC,WAAW,EAAED,KAAK,CAAC;IACtC;EAAA;IAAAjD,GAAA;IAAAC,KAAA,EAEA,SAAAuD,UAAUP,KAAK,EAAE;MACf,OAAO,IAAI;IACb;EAAA;IAAAjD,GAAA;IAAAC,KAAA,EAEA,SAAAwD,WAAWR,KAAK,EAAE;MAChB,OAAO,IAAI,CAACC,IAAI,CAAC,UAAU,EAAED,KAAK,CAAC;IACrC;EAAA;IAAAjD,GAAA;IAAAC,KAAA,EAEA,SAAAyD,WAAWT,KAAK,EAAE;MAChB,OAAO,IAAI,CAACC,IAAI,CAAC,UAAU,EAAED,KAAK,CAAC;IACrC;EAAA;IAAAjD,GAAA;IAAAC,KAAA,EAEA,SAAA0D,SAASV,KAAK,EAAE;MACd,OAAO,IAAI,CAACC,IAAI,CAAC,QAAQ,EAAED,KAAK,CAAC;IACnC;EAAA;IAAAjD,GAAA;IAAAC,KAAA,EAEA,SAAA2D,cAAcX,KAAK,EAAE;MACnB,OAAO,IAAI,CAACC,IAAI,CAAC,aAAa,EAAED,KAAK,CAAC;IACxC;EAAA;IAAAjD,GAAA;IAAAC,KAAA,EAEA,SAAA4D,UAAUZ,KAAK,EAAE;MACf,OAAO,IAAI,CAACC,IAAI,CAAC,SAAS,EAAED,KAAK,CAAC;IACpC;EAAA;IAAAjD,GAAA;IAAAC,KAAA,EAEA,SAAAiD,KAAKY,KAAK,EAAEb,KAAK,EAAE;MAEjB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;QAC7B,OAAOA,KAAK;MACd;MACA,IAAMc,MAAM,GAAG,IAAI,CAACvD,IAAI,CAACsD,KAAK,CAAC,IAAI,IAAI,CAACtD,IAAI,CAACsD,KAAK,CAAC,CAACb,KAAK,CAAC;MAC1D,IAAI,CAACc,MAAM,EAAE;QACXC,OAAO,CAACC,IAAI,oCAAAC,MAAA,CAAoCJ,KAAK,OAAAI,MAAA,CAAIjB,KAAK,OAAI;MACpE;MACA,OAAOc,MAAM;IACf;EAAA;IAAA/D,GAAA;IAAAC,KAAA,EAIA,SAAA8C,cAAcD,KAAK,EAAEG,KAAK,EAAE;MAAA,IAAAkB,MAAA;MAE1BrB,KAAK,CAACsB,EAAE,GAAGtB,KAAK,CAACsB,EAAE,aAAAF,MAAA,CAAajB,KAAK,CAAE;MACvCH,KAAK,CAACP,KAAK,GAAG,CAACO,KAAK,CAACP,KAAK,IAAI,EAAE,EAAErB,GAAG,CAAE,UAAAsB,IAAI;QAAA,OAAK2B,MAAI,CAAChB,OAAO,CAACX,IAAI,CAAC;MAAA,EAAC;MACnE,OAAOM,KAAK;IACd;EAAA;IAAA9C,GAAA;IAAAC,KAAA,EAEA,SAAAwC,aAAaD,IAAI,EAAES,KAAK,EAAE;MAAA,IAAAoB,MAAA;MAExB7B,IAAI,CAAC4B,EAAE,GAAG5B,IAAI,CAAC4B,EAAE,YAAAF,MAAA,CAAYjB,KAAK,CAAE;MACpC,IAAIT,IAAI,CAAC8B,QAAQ,EAAE;QACjB9B,IAAI,CAAC8B,QAAQ,GAAG9B,IAAI,CAAC8B,QAAQ,CAACpD,GAAG,CAAE,UAAAqD,KAAK;UAAA,OAAKF,MAAI,CAAClB,OAAO,CAACoB,KAAK,CAAC;QAAA,EAAC;MACnE;MACA,IAAI/B,IAAI,CAACH,IAAI,KAAK9B,SAAS,EAAE;QAC3BiC,IAAI,CAACH,IAAI,GAAG,IAAI,CAACgB,OAAO,CAACb,IAAI,CAACH,IAAI,CAAC;MACrC,CAAC,MAAM,IAAIG,IAAI,CAACJ,MAAM,KAAK7B,SAAS,IAAIiC,IAAI,CAACJ,MAAM,CAAC9B,MAAM,EAAE;QAC1DkC,IAAI,CAACH,IAAI,GAAGG,IAAI,CAACJ,MAAM,CAACoC,MAAM,CAC5B,UAACC,KAAK,EAAEC,SAAS,EAAK;UACpB,IAAMrC,IAAI,GAAGgC,MAAI,CAAChB,OAAO,CAACqB,SAAS,CAAC;UACpCD,KAAK,CAACL,EAAE,GAAG/B,IAAI,CAAC+B,EAAE;UAClBK,KAAK,CAACE,UAAU,GAAGF,KAAK,CAACE,UAAU,CAACT,MAAM,CAAC7B,IAAI,CAACsC,UAAU,CAAC;UAC3D,OAAOF,KAAK;QACd,CAAC,EACD;UAACE,UAAU,EAAE;QAAE,CAAC,CACjB;MACH;MACA,IAAInC,IAAI,CAACoC,MAAM,KAAKrE,SAAS,EAAE;QAC7BiC,IAAI,CAACoC,MAAM,GAAG,IAAI,CAACpB,SAAS,CAAChB,IAAI,CAACoC,MAAM,CAAC;MAC3C;MACA,IAAIpC,IAAI,CAACG,IAAI,KAAKpC,SAAS,EAAE;QAC3BiC,IAAI,CAACG,IAAI,GAAG,IAAI,CAACS,OAAO,CAACZ,IAAI,CAACG,IAAI,CAAC;MACrC;MACA,OAAOH,IAAI;IACb;EAAA;IAAAxC,GAAA;IAAAC,KAAA,EAEA,SAAA2C,aAAaD,IAAI,EAAEM,KAAK,EAAE;MAExBN,IAAI,CAACyB,EAAE,GAAGzB,IAAI,CAACyB,EAAE,YAAAF,MAAA,CAAYjB,KAAK,CAAE;MACpCN,IAAI,CAACkC,mBAAmB,GAAG,IAAI,CAACtB,WAAW,CAACZ,IAAI,CAACkC,mBAAmB,CAAC;MACrE,OAAOlC,IAAI;IACb;EAAA;IAAA3C,GAAA;IAAAC,KAAA,EAEA,SAAAqC,aAAaD,IAAI,EAAEY,KAAK,EAAE;MAAA,IAAA6B,MAAA;MAExBzC,IAAI,CAAC+B,EAAE,GAAG/B,IAAI,CAAC+B,EAAE,YAAAF,MAAA,CAAYjB,KAAK,CAAE;MACpC,IAAIZ,IAAI,CAACsC,UAAU,EAAE;QACnBtC,IAAI,CAACsC,UAAU,GAAGtC,IAAI,CAACsC,UAAU,CAACzD,GAAG,CAAE,UAAA6D,SAAS,EAAK;UACnDA,SAAS,GAAAC,aAAA,KAAOD,SAAA,CAAU;UAC1B,IAAME,UAAU,GAAGF,SAAS,CAACE,UAAU;UACvCF,SAAS,CAACE,UAAU,GAAG,CAAC,CAAC;UACzB,KAAK,IAAMC,SAAS,IAAID,UAAU,EAAE;YAClCF,SAAS,CAACE,UAAU,CAACC,SAAS,CAAC,GAAGJ,MAAI,CAACvB,WAAW,CAAC0B,UAAU,CAACC,SAAS,CAAC,CAAC;UAC3E;UACA,IAAIH,SAAS,CAACI,OAAO,KAAK5E,SAAS,EAAE;YACnCwE,SAAS,CAACI,OAAO,GAAGL,MAAI,CAACvB,WAAW,CAACwB,SAAS,CAACI,OAAO,CAAC;UACzD;UACA,IAAIJ,SAAS,CAAC7C,QAAQ,KAAK3B,SAAS,EAAE;YACpCwE,SAAS,CAAC7C,QAAQ,GAAG4C,MAAI,CAACxB,WAAW,CAACyB,SAAS,CAAC7C,QAAQ,CAAC;UAC3D;UACA,OAAO6C,SAAS;QAClB,CAAC,CAAC;MACJ;MACA,OAAO1C,IAAI;IACb;EAAA;IAAArC,GAAA;IAAAC,KAAA,EAEA,SAAAkC,iBAAiBD,QAAQ,EAAEe,KAAK,EAAE;MAEhCf,QAAQ,CAACkC,EAAE,GAAGlC,QAAQ,CAACkC,EAAE,gBAAAF,MAAA,CAAgBjB,KAAK,CAAE;MAChD,IAAIf,QAAQ,CAACkD,aAAa,EAAE;QAC1BlD,QAAQ,CAACkD,aAAa,GAAAJ,aAAA,KAAO9C,QAAQ,CAACkD,aAAA,CAAc;QACpDlD,QAAQ,CAACkD,aAAa,CAACxD,OAAO,GAAG,IAAI,CAAC6B,UAAU,CAACvB,QAAQ,CAACkD,aAAa,CAACnC,KAAK,CAAC;MAChF;MACA,IAAIf,QAAQ,CAACmD,gBAAgB,EAAE;QAC7BnD,QAAQ,CAACoD,iBAAiB,GAAAN,aAAA,KAAO9C,QAAQ,CAACoD,iBAAA,CAAkB;QAC5DpD,QAAQ,CAACmD,gBAAgB,CAACzD,OAAO,GAAG,IAAI,CAAC6B,UAAU,CAACvB,QAAQ,CAACmD,gBAAgB,CAACpC,KAAK,CAAC;MACtF;MACA,IAAIf,QAAQ,CAACqD,eAAe,EAAE;QAC5BrD,QAAQ,CAACsD,eAAe,GAAAR,aAAA,KAAO9C,QAAQ,CAACsD,eAAA,CAAgB;QACxDtD,QAAQ,CAACqD,eAAe,CAAC3D,OAAO,GAAG,IAAI,CAAC6B,UAAU,CAACvB,QAAQ,CAACqD,eAAe,CAACtC,KAAK,CAAC;MACpF;MACA,IAAI,CAACf,QAAQ,CAACuD,cAAc,EAAE;QAC5BvD,QAAQ,CAACuD,cAAc,GAAGvD,QAAQ,CAACsD,eAAe,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC5E;MAEA,IAAItD,QAAQ,CAACwD,oBAAoB,EAAE;QACjCxD,QAAQ,CAACwD,oBAAoB,GAAAV,aAAA,KAAO9C,QAAQ,CAACwD,oBAAA,CAAqB;QAClE,IAAMC,EAAE,GAAGzD,QAAQ,CAACwD,oBAAoB;QACxC,IAAIC,EAAE,CAACC,gBAAgB,EAAE;UACvBD,EAAE,CAACC,gBAAgB,GAAAZ,aAAA,KAAOW,EAAE,CAACC,gBAAA,CAAiB;UAC9CD,EAAE,CAACC,gBAAgB,CAAChE,OAAO,GAAG,IAAI,CAAC6B,UAAU,CAACkC,EAAE,CAACC,gBAAgB,CAAC3C,KAAK,CAAC;QAC1E;QACA,IAAI0C,EAAE,CAACE,wBAAwB,EAAE;UAC/BF,EAAE,CAACE,wBAAwB,GAAAb,aAAA,KAAOW,EAAE,CAACE,wBAAA,CAAyB;UAC9DF,EAAE,CAACE,wBAAwB,CAACjE,OAAO,GAAG,IAAI,CAAC6B,UAAU,CAACkC,EAAE,CAACE,wBAAwB,CAAC5C,KAAK,CAAC;QAC1F;MACF;MACA,OAAOf,QAAQ;IACjB;EAAA;IAAAlC,GAAA;IAAAC,KAAA,EAEA,SAAA+B,iBAAiBD,QAAQ,EAAEkB,KAAK,EAAE;MAEhClB,QAAQ,CAACqC,EAAE,GAAGrC,QAAQ,CAACqC,EAAE,gBAAAF,MAAA,CAAgBjB,KAAK,CAAE;MAChD,IAAIlB,QAAQ,CAAC+D,UAAU,KAAKvF,SAAS,EAAE;QAErCwB,QAAQ,CAAC+D,UAAU,GAAG,IAAI,CAAClC,aAAa,CAAC7B,QAAQ,CAAC+D,UAAU,CAAC;MAC/D;MAGA/D,QAAQ,CAACgE,iBAAiB,GAAGvG,yBAAyB,CAACuC,QAAQ,CAACtC,aAAa,CAAC;MAC9EsC,QAAQ,CAACiE,UAAU,GAAGtG,uBAAuB,CAACqC,QAAQ,CAACpC,IAAI,CAAC;MAC5DoC,QAAQ,CAACkE,eAAe,GAAGlE,QAAQ,CAACgE,iBAAiB,GAAGhE,QAAQ,CAACiE,UAAU;MAK3E,IAAIjE,QAAQ,CAAC+D,UAAU,EAAE;QACvB,IAAMI,MAAM,GAAGnE,QAAQ,CAAC+D,UAAU,CAACI,MAAM;QACzC,IAAAC,qBAAA,GAAgCrI,6BAA6B,CAACiE,QAAQ,EAAEA,QAAQ,CAAC+D,UAAU,CAAC;UAArFM,SAAS,GAAAD,qBAAA,CAATC,SAAS;UAAEC,UAAA,GAAAF,qBAAA,CAAAE,UAAA;QAClB,IAAMC,UAAU,GACd,CAACvE,QAAQ,CAAC+D,UAAU,CAACQ,UAAU,IAAI,CAAC,KAAKvE,QAAQ,CAACuE,UAAU,IAAI,CAAC,CAAC,GAAGJ,MAAM,CAACI,UAAU;QACxF,IAAIC,SAAS,GAAGL,MAAM,CAACM,WAAW,CAACC,KAAK,CAACH,UAAU,EAAEA,UAAU,GAAGD,UAAU,CAAC;QAC7E,IAAItE,QAAQ,CAAC+D,UAAU,CAACY,UAAU,EAAE;UAClCH,SAAS,GAAG,IAAI,CAACI,8BAA8B,CAC7CT,MAAM,EACNI,UAAU,EACVvE,QAAQ,CAAC+D,UAAU,CAACY,UAAU,EAC9B3E,QAAQ,CAACkE,eAAe,EACxBlE,QAAQ,CAAC6E,KAAK,CACf;QACH;QACA7E,QAAQ,CAAC9B,KAAK,GAAG,IAAImG,SAAS,CAACG,SAAS,CAAC;MAC3C;MAEA,OAAOxE,QAAQ;IACjB;EAAA;IAAA/B,GAAA;IAAAC,KAAA,EAYA,SAAA0G,+BAA+BT,MAAM,EAAEI,UAAU,EAAEI,UAAU,EAAET,eAAe,EAAEW,KAAK,EAAE;MACrF,IAAMC,MAAM,GAAG,IAAIC,UAAU,CAACF,KAAK,GAAGX,eAAe,CAAC;MACtD,KAAK,IAAI7E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwF,KAAK,EAAExF,CAAC,EAAE,EAAE;QAC9B,IAAM2F,aAAa,GAAGT,UAAU,GAAGlF,CAAC,GAAGsF,UAAU;QACjDG,MAAM,CAACG,GAAG,CACR,IAAIF,UAAU,CAACZ,MAAM,CAACM,WAAW,CAACC,KAAK,CAACM,aAAa,EAAEA,aAAa,GAAGd,eAAe,CAAC,CAAC,EACxF7E,CAAC,GAAG6E,eAAe,CACpB;MACH;MACA,OAAOY,MAAM,CAACX,MAAM;IACtB;EAAA;IAAAlG,GAAA;IAAAC,KAAA,EAEA,SAAA4B,gBAAgBD,OAAO,EAAEqB,KAAK,EAAE;MAE9BrB,OAAO,CAACwC,EAAE,GAAGxC,OAAO,CAACwC,EAAE,eAAAF,MAAA,CAAejB,KAAK,CAAE;MAC7CrB,OAAO,CAACH,OAAO,GAAG,SAAS,IAAIG,OAAO,GAAG,IAAI,CAAC8B,UAAU,CAAC9B,OAAO,CAACH,OAAO,CAAC,GAAGpC,eAAe;MAC3FuC,OAAO,CAACqF,MAAM,GAAG,IAAI,CAACtD,QAAQ,CAAC/B,OAAO,CAACqF,MAAM,CAAC;MAC9C,OAAOrF,OAAO;IAChB;EAAA;IAAA5B,GAAA;IAAAC,KAAA,EAEA,SAAAyB,gBAAgBD,OAAO,EAAEwB,KAAK,EAAE;MAE9BxB,OAAO,CAAC2C,EAAE,GAAG3C,OAAO,CAAC2C,EAAE,eAAAF,MAAA,CAAejB,KAAK,CAAE;MAE7CxB,OAAO,CAACyF,UAAU,GAAG,CAAC,CAAC;MACvB,KAAK,IAAMlH,GAAG,IAAIyB,OAAO,EAAE;QACzB,IAAM0F,MAAM,GAAG,IAAI,CAACC,qBAAqB,CAACpH,GAAG,CAAC;QAC9C,IAAImH,MAAM,KAAK5G,SAAS,EAAE;UACxBkB,OAAO,CAACyF,UAAU,CAACC,MAAM,CAAC,GAAG1F,OAAO,CAACzB,GAAG,CAAC;QAC3C;MACF;MACA,OAAOyB,OAAO;IAChB;EAAA;IAAAzB,GAAA;IAAAC,KAAA,EAEA,SAAAmH,sBAAsBpH,GAAG,EAAE;MACzB,OAAOhB,4BAA4B,CAACgB,GAAG,CAAC;IAC1C;EAAA;IAAAA,GAAA;IAAAC,KAAA,EAEA,SAAAsB,cAAcD,KAAK,EAAE2B,KAAK,EAAE;MAE1B3B,KAAK,CAAC8C,EAAE,GAAG9C,KAAK,CAAC8C,EAAE,aAAAF,MAAA,CAAajB,KAAK,CAAE;MACvC,IAAI3B,KAAK,CAACwE,UAAU,KAAKvF,SAAS,EAAE;QAClCe,KAAK,CAACwE,UAAU,GAAG,IAAI,CAAClC,aAAa,CAACtC,KAAK,CAACwE,UAAU,CAAC;MACzD;MAIA,IAAMuB,cAAc,GAAG,IAAI,CAACzG,MAAM,CAACqC,KAAK,CAAC;MACzC,IAAIoE,cAAc,EAAE;QAClB/F,KAAK,CAACA,KAAK,GAAG+F,cAAc;MAC9B;MAEA,OAAO/F,KAAK;IACd;EAAA;IAAAtB,GAAA;IAAAC,KAAA,EAEA,SAAAoB,mBAAmByE,UAAsB,EAAE7C,KAAa,EAA2B;MAEjF,IAAMqE,WAAW,GAAGxB,UAAU,CAACI,MAAM;MACrC,IAAMW,MAA+B,GAAA7B,aAAA,CAAAA,aAAA;QACnCZ,EAAE,gBAAAF,MAAA,CAAgBjB,KAAK;MAAE,GACtB6C,UAAU;QACbI,MAAM,EAAE,IAAI,CAACxF,OAAO,CAAC4G,WAAW;MAAA,EACjC;MAGD,IAAMd,WAAW,GAAG,IAAI,CAAC9F,OAAO,CAAC4G,WAAW,CAAC,CAACd,WAAW;MAEzD,IAAIF,UAAU,GAAG,IAAI,CAAC5F,OAAO,CAAC4G,WAAW,CAAC,CAAChB,UAAU,IAAI,CAAC;MAE1D,IAAI,YAAY,IAAIR,UAAU,EAAE;QAC9BQ,UAAU,IAAIR,UAAU,CAACQ,UAAU;MACrC;MAEAO,MAAM,CAACU,IAAI,GAAG,IAAIT,UAAU,CAACN,WAAW,EAAEF,UAAU,EAAER,UAAU,CAACO,UAAU,CAAC;MAC5E,OAAOQ,MAAM;IACf;EAAA;IAAA7G,GAAA;IAAAC,KAAA,EAEA,SAAAuH,eAAe5C,MAAM,EAAE3B,KAAK,EAAE;MAC5B2B,MAAM,CAACR,EAAE,GAAGQ,MAAM,CAACR,EAAE,cAAAF,MAAA,CAAcjB,KAAK,CAAE;MAE1C,IAAI2B,MAAM,CAAC6C,WAAW,EAAE,CAExB;MACA,IAAI7C,MAAM,CAAC8C,YAAY,EAAE,CAEzB;MACA,OAAO9C,MAAM;IACf;EAAA;EAAA,OAAAhF,iBAAA;AAAA;AAGF,OAAO,SAAS+H,eAAeA,CAACxH,IAAI,EAAEC,OAAQ,EAAE;EAC9C,OAAO,IAAIR,iBAAiB,EAAE,CAACM,WAAW,CAACC,IAAI,EAAEC,OAAO,CAAC;AAC3D"},"metadata":{},"sourceType":"module","externalDependencies":[]}