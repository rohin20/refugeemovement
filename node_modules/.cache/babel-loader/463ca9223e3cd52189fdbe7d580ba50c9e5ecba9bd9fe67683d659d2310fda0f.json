{"ast":null,"code":"import _defineProperty from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport BinSorter from './bin-sorter';\nimport { getScaleFunctionByScaleType } from './scale-utils';\nimport { getValueFunc, wrapGetValueFunc } from './aggregation-operation-utils';\nfunction nop() {}\nvar dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nvar _defaultDimensions = [{\n  key: 'fillColor',\n  accessor: 'getFillColor',\n  pickingInfo: 'colorValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getColorValue',\n        updateTrigger: 'getColorValue'\n      },\n      weight: {\n        prop: 'getColorWeight',\n        updateTrigger: 'getColorWeight'\n      },\n      aggregation: {\n        prop: 'colorAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'lowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'upperPercentile'\n      },\n      scaleType: {\n        prop: 'colorScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'colorDomain'\n      },\n      range: {\n        prop: 'colorRange'\n      }\n    },\n    onSet: {\n      props: 'onSetColorDomain'\n    }\n  },\n  nullValue: [0, 0, 0, 0]\n}, {\n  key: 'elevation',\n  accessor: 'getElevation',\n  pickingInfo: 'elevationValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getElevationValue',\n        updateTrigger: 'getElevationValue'\n      },\n      weight: {\n        prop: 'getElevationWeight',\n        updateTrigger: 'getElevationWeight'\n      },\n      aggregation: {\n        prop: 'elevationAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'elevationLowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'elevationUpperPercentile'\n      },\n      scaleType: {\n        prop: 'elevationScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'elevationDomain'\n      },\n      range: {\n        prop: 'elevationRange'\n      }\n    },\n    onSet: {\n      props: 'onSetElevationDomain'\n    }\n  },\n  nullValue: -1\n}];\nvar defaultGetCellSize = function defaultGetCellSize(props) {\n  return props.cellSize;\n};\nvar CPUAggregator = /*#__PURE__*/function () {\n  function CPUAggregator(opts) {\n    _classCallCheck(this, CPUAggregator);\n    this.state = {\n      layerData: {},\n      dimensions: {}\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n    this._addDimension(opts.dimensions || _defaultDimensions);\n  }\n  _createClass(CPUAggregator, [{\n    key: \"updateState\",\n    value: function updateState(opts, aggregationParams) {\n      var oldProps = opts.oldProps,\n        props = opts.props,\n        changeFlags = opts.changeFlags;\n      this.updateGetValueFuncs(oldProps, props, changeFlags);\n      var reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n      var aggregationDirty = false;\n      if (changeFlags.dataChanged || reprojectNeeded) {\n        this.getAggregatedData(props, aggregationParams);\n        aggregationDirty = true;\n      } else {\n        var dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n        dimensionChanges.forEach(function (f) {\n          return typeof f === 'function' && f();\n        });\n        aggregationDirty = true;\n      }\n      this.setState({\n        aggregationDirty: aggregationDirty\n      });\n      return this.state;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(updateObject) {\n      this.state = _objectSpread(_objectSpread({}, this.state), updateObject);\n    }\n  }, {\n    key: \"setDimensionState\",\n    value: function setDimensionState(key, updateObject) {\n      this.setState({\n        dimensions: _objectSpread(_objectSpread({}, this.state.dimensions), {}, _defineProperty({}, key, _objectSpread(_objectSpread({}, this.state.dimensions[key]), updateObject)))\n      });\n    }\n  }, {\n    key: \"normalizeResult\",\n    value: function normalizeResult() {\n      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (result.hexagons) {\n        return _objectSpread({\n          data: result.hexagons\n        }, result);\n      } else if (result.layerData) {\n        return _objectSpread({\n          data: result.layerData\n        }, result);\n      }\n      return result;\n    }\n  }, {\n    key: \"getAggregatedData\",\n    value: function getAggregatedData(props, aggregationParams) {\n      var aggregator = this._getAggregator(props);\n      var result = aggregator(props, aggregationParams);\n      this.setState({\n        layerData: this.normalizeResult(result)\n      });\n      this.changeFlags = {\n        layerData: true\n      };\n      this.getSortedBins(props);\n    }\n  }, {\n    key: \"updateGetValueFuncs\",\n    value: function updateGetValueFuncs(oldProps, props, changeFlags) {\n      for (var key in this.dimensionUpdaters) {\n        var _this$dimensionUpdate = this.dimensionUpdaters[key].getBins.triggers,\n          value = _this$dimensionUpdate.value,\n          weight = _this$dimensionUpdate.weight,\n          aggregation = _this$dimensionUpdate.aggregation;\n        var getValue = props[value.prop];\n        var getValueChanged = this.needUpdateDimensionStep(this.dimensionUpdaters[key].getBins, oldProps, props, changeFlags);\n        if (getValueChanged) {\n          if (getValue) {\n            getValue = wrapGetValueFunc(getValue, {\n              data: props.data\n            });\n          } else {\n            getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {\n              data: props.data\n            });\n          }\n        }\n        if (getValue) {\n          this.setDimensionState(key, {\n            getValue: getValue\n          });\n        }\n      }\n    }\n  }, {\n    key: \"needsReProjectPoints\",\n    value: function needsReProjectPoints(oldProps, props, changeFlags) {\n      return this._getCellSize(oldProps) !== this._getCellSize(props) || this._getAggregator(oldProps) !== this._getAggregator(props) || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition);\n    }\n  }, {\n    key: \"addDimension\",\n    value: function addDimension(dimensions) {\n      this._addDimension(dimensions);\n    }\n  }, {\n    key: \"_addDimension\",\n    value: function _addDimension() {\n      var _this = this;\n      var dimensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      dimensions.forEach(function (dimension) {\n        var key = dimension.key;\n        _this.dimensionUpdaters[key] = _this.getDimensionUpdaters(dimension);\n        _this.state.dimensions[key] = {\n          getValue: null,\n          domain: null,\n          sortedBins: null,\n          scaleFunc: nop\n        };\n      });\n    }\n  }, {\n    key: \"getDimensionUpdaters\",\n    value: function getDimensionUpdaters(_ref) {\n      var key = _ref.key,\n        accessor = _ref.accessor,\n        pickingInfo = _ref.pickingInfo,\n        getBins = _ref.getBins,\n        getDomain = _ref.getDomain,\n        getScaleFunc = _ref.getScaleFunc,\n        nullValue = _ref.nullValue;\n      return {\n        key: key,\n        accessor: accessor,\n        pickingInfo: pickingInfo,\n        getBins: _objectSpread({\n          updater: this.getDimensionSortedBins\n        }, getBins),\n        getDomain: _objectSpread({\n          updater: this.getDimensionValueDomain\n        }, getDomain),\n        getScaleFunc: _objectSpread({\n          updater: this.getDimensionScale\n        }, getScaleFunc),\n        attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n      };\n    }\n  }, {\n    key: \"needUpdateDimensionStep\",\n    value: function needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n      return Object.values(dimensionStep.triggers).some(function (item) {\n        if (item.updateTrigger) {\n          return changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);\n        }\n        return oldProps[item.prop] !== props[item.prop];\n      });\n    }\n  }, {\n    key: \"getDimensionChanges\",\n    value: function getDimensionChanges(oldProps, props, changeFlags) {\n      var _this2 = this;\n      var updaters = [];\n      var _loop = function _loop(key) {\n        var needUpdate = dimensionSteps.find(function (step) {\n          return _this2.needUpdateDimensionStep(_this2.dimensionUpdaters[key][step], oldProps, props, changeFlags);\n        });\n        if (needUpdate) {\n          updaters.push(_this2.dimensionUpdaters[key][needUpdate].updater.bind(_this2, props, _this2.dimensionUpdaters[key]));\n        }\n      };\n      for (var key in this.dimensionUpdaters) {\n        _loop(key);\n      }\n      return updaters.length ? updaters : null;\n    }\n  }, {\n    key: \"getUpdateTriggers\",\n    value: function getUpdateTriggers(props) {\n      var _this3 = this;\n      var _updateTriggers = props.updateTriggers || {};\n      var updateTriggers = {};\n      var _loop2 = function _loop2(key) {\n        var accessor = _this3.dimensionUpdaters[key].accessor;\n        updateTriggers[accessor] = {};\n        dimensionSteps.forEach(function (step) {\n          Object.values(_this3.dimensionUpdaters[key][step].triggers).forEach(function (_ref2) {\n            var prop = _ref2.prop,\n              updateTrigger = _ref2.updateTrigger;\n            if (updateTrigger) {\n              var fromProp = _updateTriggers[updateTrigger];\n              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          });\n        });\n      };\n      for (var key in this.dimensionUpdaters) {\n        _loop2(key);\n      }\n      return updateTriggers;\n    }\n  }, {\n    key: \"getSortedBins\",\n    value: function getSortedBins(props) {\n      for (var key in this.dimensionUpdaters) {\n        this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n      }\n    }\n  }, {\n    key: \"getDimensionSortedBins\",\n    value: function getDimensionSortedBins(props, dimensionUpdater) {\n      var key = dimensionUpdater.key;\n      var getValue = this.state.dimensions[key].getValue;\n      var sortedBins = new BinSorter(this.state.layerData.data || [], {\n        getValue: getValue,\n        filterData: props._filterData\n      });\n      this.setDimensionState(key, {\n        sortedBins: sortedBins\n      });\n      this.getDimensionValueDomain(props, dimensionUpdater);\n    }\n  }, {\n    key: \"getDimensionValueDomain\",\n    value: function getDimensionValueDomain(props, dimensionUpdater) {\n      var getDomain = dimensionUpdater.getDomain,\n        key = dimensionUpdater.key;\n      var _getDomain$triggers = getDomain.triggers,\n        lowerPercentile = _getDomain$triggers.lowerPercentile,\n        upperPercentile = _getDomain$triggers.upperPercentile,\n        scaleType = _getDomain$triggers.scaleType;\n      var valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);\n      this.setDimensionState(key, {\n        valueDomain: valueDomain\n      });\n      this.getDimensionScale(props, dimensionUpdater);\n    }\n  }, {\n    key: \"getDimensionScale\",\n    value: function getDimensionScale(props, dimensionUpdater) {\n      var key = dimensionUpdater.key,\n        getScaleFunc = dimensionUpdater.getScaleFunc,\n        getDomain = dimensionUpdater.getDomain;\n      var _getScaleFunc$trigger = getScaleFunc.triggers,\n        domain = _getScaleFunc$trigger.domain,\n        range = _getScaleFunc$trigger.range;\n      var scaleType = getDomain.triggers.scaleType;\n      var onSet = getScaleFunc.onSet;\n      var dimensionRange = props[range.prop];\n      var dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n      var getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n      var scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n      if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n        props[onSet.props](scaleFunc.domain());\n      }\n      this.setDimensionState(key, {\n        scaleFunc: scaleFunc\n      });\n    }\n  }, {\n    key: \"getSubLayerDimensionAttribute\",\n    value: function getSubLayerDimensionAttribute(key, nullValue) {\n      var _this4 = this;\n      return function (cell) {\n        var _this4$state$dimensio = _this4.state.dimensions[key],\n          sortedBins = _this4$state$dimensio.sortedBins,\n          scaleFunc = _this4$state$dimensio.scaleFunc;\n        var bin = sortedBins.binMap[cell.index];\n        if (bin && bin.counts === 0) {\n          return nullValue;\n        }\n        var cv = bin && bin.value;\n        var domain = scaleFunc.domain();\n        var isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n        return isValueInDomain ? scaleFunc(cv) : nullValue;\n      };\n    }\n  }, {\n    key: \"getSubLayerAccessors\",\n    value: function getSubLayerAccessors(props) {\n      var accessors = {};\n      for (var key in this.dimensionUpdaters) {\n        var accessor = this.dimensionUpdaters[key].accessor;\n        accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n      }\n      return accessors;\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info;\n      var isPicked = info.picked && info.index > -1;\n      var object = null;\n      if (isPicked) {\n        var cell = this.state.layerData.data[info.index];\n        var binInfo = {};\n        for (var key in this.dimensionUpdaters) {\n          var pickingInfo = this.dimensionUpdaters[key].pickingInfo;\n          var sortedBins = this.state.dimensions[key].sortedBins;\n          var value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n          binInfo[pickingInfo] = value;\n        }\n        object = Object.assign(binInfo, cell, {\n          points: cell.filteredPoints || cell.points\n        });\n      }\n      info.picked = Boolean(object);\n      info.object = object;\n      return info;\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor(dimensionKey) {\n      if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n        return nop;\n      }\n      return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n    }\n  }], [{\n    key: \"defaultDimensions\",\n    value: function defaultDimensions() {\n      return _defaultDimensions;\n    }\n  }]);\n  return CPUAggregator;\n}();\nexport { CPUAggregator as default };","map":{"version":3,"names":["BinSorter","getScaleFunctionByScaleType","getValueFunc","wrapGetValueFunc","nop","dimensionSteps","defaultDimensions","key","accessor","pickingInfo","getBins","triggers","value","prop","updateTrigger","weight","aggregation","filterData","getDomain","lowerPercentile","upperPercentile","scaleType","getScaleFunc","domain","range","onSet","props","nullValue","defaultGetCellSize","cellSize","CPUAggregator","opts","_classCallCheck","state","layerData","dimensions","changeFlags","dimensionUpdaters","_getCellSize","getCellSize","_getAggregator","getAggregator","_addDimension","_createClass","updateState","aggregationParams","oldProps","updateGetValueFuncs","reprojectNeeded","needsReProjectPoints","aggregationDirty","dataChanged","getAggregatedData","dimensionChanges","getDimensionChanges","forEach","f","setState","updateObject","_objectSpread","setDimensionState","_defineProperty","normalizeResult","result","arguments","length","undefined","hexagons","data","aggregator","getSortedBins","_this$dimensionUpdate","getValue","getValueChanged","needUpdateDimensionStep","updateTriggersChanged","all","getPosition","addDimension","_this","dimension","getDimensionUpdaters","sortedBins","scaleFunc","_ref","updater","getDimensionSortedBins","getDimensionValueDomain","getDimensionScale","attributeAccessor","getSubLayerDimensionAttribute","dimensionStep","Object","values","some","item","_this2","updaters","_loop","needUpdate","find","step","push","bind","getUpdateTriggers","_this3","_updateTriggers","updateTriggers","_loop2","_ref2","fromProp","Array","isArray","assign","dimensionUpdater","_filterData","_getDomain$triggers","valueDomain","getValueDomainByScale","_getScaleFunc$trigger","dimensionRange","dimensionDomain","getScaleFunction","_this4","cell","_this4$state$dimensio","bin","binMap","index","counts","cv","isValueInDomain","getSubLayerAccessors","accessors","getPickingInfo","_ref3","info","isPicked","picked","object","binInfo","points","filteredPoints","Boolean","getAccessor","dimensionKey","hasOwnProperty","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/aggregation-layers/src/utils/cpu-aggregator.js"],"sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport BinSorter from './bin-sorter';\nimport {getScaleFunctionByScaleType} from './scale-utils';\nimport {getValueFunc, wrapGetValueFunc} from './aggregation-operation-utils';\n\nfunction nop() {}\n\nconst dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nconst defaultDimensions = [\n  {\n    key: 'fillColor',\n    accessor: 'getFillColor',\n    pickingInfo: 'colorValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getColorValue',\n          updateTrigger: 'getColorValue'\n        },\n        weight: {\n          prop: 'getColorWeight',\n          updateTrigger: 'getColorWeight'\n        },\n        aggregation: {\n          prop: 'colorAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'lowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'upperPercentile'\n        },\n        scaleType: {\n          prop: 'colorScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'colorDomain'},\n        range: {prop: 'colorRange'}\n      },\n      onSet: {\n        props: 'onSetColorDomain'\n      }\n    },\n    nullValue: [0, 0, 0, 0]\n  },\n  {\n    key: 'elevation',\n    accessor: 'getElevation',\n    pickingInfo: 'elevationValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getElevationValue',\n          updateTrigger: 'getElevationValue'\n        },\n        weight: {\n          prop: 'getElevationWeight',\n          updateTrigger: 'getElevationWeight'\n        },\n        aggregation: {\n          prop: 'elevationAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'elevationLowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'elevationUpperPercentile'\n        },\n        scaleType: {\n          prop: 'elevationScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'elevationDomain'},\n        range: {prop: 'elevationRange'}\n      },\n      onSet: {\n        props: 'onSetElevationDomain'\n      }\n    },\n    nullValue: -1\n  }\n];\nconst defaultGetCellSize = props => props.cellSize;\nexport default class CPUAggregator {\n  constructor(opts) {\n    this.state = {\n      layerData: {},\n      dimensions: {\n        // color: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // },\n        // elevation: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // }\n      }\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n    this._addDimension(opts.dimensions || defaultDimensions);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateState(opts, aggregationParams) {\n    const {oldProps, props, changeFlags} = opts;\n    this.updateGetValueFuncs(oldProps, props, changeFlags);\n    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n    let aggregationDirty = false;\n    if (changeFlags.dataChanged || reprojectNeeded) {\n      // project data into bin and aggregate wegiths per bin\n      this.getAggregatedData(props, aggregationParams);\n      aggregationDirty = true;\n    } else {\n      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n      // this here is layer\n      dimensionChanges.forEach(f => typeof f === 'function' && f());\n      aggregationDirty = true;\n    }\n    this.setState({aggregationDirty});\n\n    return this.state;\n  }\n\n  // Update private state\n  setState(updateObject) {\n    this.state = {...this.state, ...updateObject};\n  }\n\n  // Update private state.dimensions\n  setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: {\n        ...this.state.dimensions,\n        [key]: {...this.state.dimensions[key], ...updateObject}\n      }\n    });\n  }\n\n  normalizeResult(result = {}) {\n    // support previous hexagonAggregator API\n    if (result.hexagons) {\n      return {data: result.hexagons, ...result};\n    } else if (result.layerData) {\n      return {data: result.layerData, ...result};\n    }\n\n    return result;\n  }\n\n  getAggregatedData(props, aggregationParams) {\n    const aggregator = this._getAggregator(props);\n\n    const result = aggregator(props, aggregationParams);\n    this.setState({\n      layerData: this.normalizeResult(result)\n    });\n    this.changeFlags = {\n      layerData: true\n    };\n    this.getSortedBins(props);\n  }\n\n  updateGetValueFuncs(oldProps, props, changeFlags) {\n    for (const key in this.dimensionUpdaters) {\n      const {value, weight, aggregation} = this.dimensionUpdaters[key].getBins.triggers;\n      let getValue = props[value.prop];\n      const getValueChanged = this.needUpdateDimensionStep(\n        this.dimensionUpdaters[key].getBins,\n        oldProps,\n        props,\n        changeFlags\n      );\n\n      if (getValueChanged) {\n        if (getValue) {\n          getValue = wrapGetValueFunc(getValue, {data: props.data});\n        } else {\n          // If `getValue` is not provided from props, build it with aggregation and weight.\n          getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {data: props.data});\n        }\n      }\n\n      if (getValue) {\n        this.setDimensionState(key, {getValue});\n      }\n    }\n  }\n\n  needsReProjectPoints(oldProps, props, changeFlags) {\n    return (\n      this._getCellSize(oldProps) !== this._getCellSize(props) ||\n      this._getAggregator(oldProps) !== this._getAggregator(props) ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition))\n    );\n  }\n\n  // Adds dimensions\n  addDimension(dimensions) {\n    this._addDimension(dimensions);\n  }\n\n  _addDimension(dimensions = []) {\n    dimensions.forEach(dimension => {\n      const {key} = dimension;\n      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);\n      this.state.dimensions[key] = {\n        getValue: null,\n        domain: null,\n        sortedBins: null,\n        scaleFunc: nop\n      };\n    });\n  }\n\n  getDimensionUpdaters({key, accessor, pickingInfo, getBins, getDomain, getScaleFunc, nullValue}) {\n    return {\n      key,\n      accessor,\n      pickingInfo,\n      getBins: {updater: this.getDimensionSortedBins, ...getBins},\n      getDomain: {updater: this.getDimensionValueDomain, ...getDomain},\n      getScaleFunc: {updater: this.getDimensionScale, ...getScaleFunc},\n      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n    };\n  }\n\n  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n    // whether need to update current dimension step\n    // dimension step is the value, domain, scaleFunction of each dimension\n    // each step is an object with properties links to layer prop and whether the prop is\n    // controlled by updateTriggers\n    // getBins: {\n    //   value: {\n    //     prop: 'getElevationValue',\n    //     updateTrigger: 'getElevationValue'\n    //   },\n    //   weight: {\n    //     prop: 'getElevationWeight',\n    //     updateTrigger: 'getElevationWeight'\n    //   },\n    //   aggregation: {\n    //     prop: 'elevationAggregation'\n    //   }\n    // }\n    return Object.values(dimensionStep.triggers).some(item => {\n      if (item.updateTrigger) {\n        // check based on updateTriggers change first\n        // if data has changed, always update value\n        return (\n          changeFlags.dataChanged ||\n          (changeFlags.updateTriggersChanged &&\n            (changeFlags.updateTriggersChanged.all ||\n              changeFlags.updateTriggersChanged[item.updateTrigger]))\n        );\n      }\n      // fallback to direct comparison\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  getDimensionChanges(oldProps, props, changeFlags) {\n    // const {dimensionUpdaters} = this.state;\n    const updaters = [];\n\n    // get dimension to be updated\n    for (const key in this.dimensionUpdaters) {\n      // return the first triggered updater for each dimension\n      const needUpdate = dimensionSteps.find(step =>\n        this.needUpdateDimensionStep(\n          this.dimensionUpdaters[key][step],\n          oldProps,\n          props,\n          changeFlags\n        )\n      );\n\n      if (needUpdate) {\n        updaters.push(\n          this.dimensionUpdaters[key][needUpdate].updater.bind(\n            this,\n            props,\n            this.dimensionUpdaters[key]\n          )\n        );\n      }\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      // fold dimension triggers into each accessor\n      updateTriggers[accessor] = {};\n\n      dimensionSteps.forEach(step => {\n        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(\n          ({prop, updateTrigger}) => {\n            if (updateTrigger) {\n              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n              // and updateTriggers is passed in from layer prop\n              // fold the updateTriggers into accessor\n              const fromProp = _updateTriggers[updateTrigger];\n              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                // if updateTrigger is an object spread it\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              // if prop is not based on updateTrigger\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          }\n        );\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getSortedBins(props) {\n    for (const key in this.dimensionUpdaters) {\n      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n    }\n  }\n\n  getDimensionSortedBins(props, dimensionUpdater) {\n    const {key} = dimensionUpdater;\n    const {getValue} = this.state.dimensions[key];\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue,\n      filterData: props._filterData\n    });\n    this.setDimensionState(key, {sortedBins});\n    this.getDimensionValueDomain(props, dimensionUpdater);\n  }\n\n  getDimensionValueDomain(props, dimensionUpdater) {\n    const {getDomain, key} = dimensionUpdater;\n    const {\n      triggers: {lowerPercentile, upperPercentile, scaleType}\n    } = getDomain;\n    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(\n      props[scaleType.prop],\n      [props[lowerPercentile.prop], props[upperPercentile.prop]]\n    );\n\n    this.setDimensionState(key, {valueDomain});\n    this.getDimensionScale(props, dimensionUpdater);\n  }\n\n  getDimensionScale(props, dimensionUpdater) {\n    const {key, getScaleFunc, getDomain} = dimensionUpdater;\n    const {domain, range} = getScaleFunc.triggers;\n    const {scaleType} = getDomain.triggers;\n    const {onSet} = getScaleFunc;\n    const dimensionRange = props[range.prop];\n    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n    const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n    if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n      props[onSet.props](scaleFunc.domain());\n    }\n\n    this.setDimensionState(key, {scaleFunc});\n  }\n\n  getSubLayerDimensionAttribute(key, nullValue) {\n    return cell => {\n      const {sortedBins, scaleFunc} = this.state.dimensions[key];\n      const bin = sortedBins.binMap[cell.index];\n\n      if (bin && bin.counts === 0) {\n        // no points left in bin after filtering\n        return nullValue;\n      }\n      const cv = bin && bin.value;\n      const domain = scaleFunc.domain();\n\n      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n\n      // if cell value is outside domain, set alpha to 0\n      return isValueInDomain ? scaleFunc(cv) : nullValue;\n    };\n  }\n\n  getSubLayerAccessors(props) {\n    const accessors = {};\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n    }\n\n    return accessors;\n  }\n\n  getPickingInfo({info}) {\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n\n    if (isPicked) {\n      // const {sortedColorBins, sortedElevationBins} = this.state;\n\n      const cell = this.state.layerData.data[info.index];\n\n      const binInfo = {};\n      for (const key in this.dimensionUpdaters) {\n        const {pickingInfo} = this.dimensionUpdaters[key];\n        const {sortedBins} = this.state.dimensions[key];\n        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n        binInfo[pickingInfo] = value;\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    // override object with picked cell\n    info.picked = Boolean(object);\n    info.object = object;\n\n    return info;\n  }\n\n  getAccessor(dimensionKey) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n    return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}