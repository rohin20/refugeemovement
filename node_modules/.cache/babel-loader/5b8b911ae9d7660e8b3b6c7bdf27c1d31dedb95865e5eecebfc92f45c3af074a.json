{"ast":null,"code":"'use strict';\n\nvar invariant = require('../../vendor/invariant');\nvar makeService = require('../make_service');\n\n/**\n * @class MapboxGeocoding\n */\nvar MapboxGeocoding = makeService('MapboxGeocoding');\nvar API_GEOCODING_FORWARD = '/geocoding/v5/{dataset}/{query}.json{?access_token,proximity,country,types,bbox,limit,autocomplete,language}';\nvar API_GEOCODING_REVERSE = '/geocoding/v5/{dataset}/{longitude},{latitude}.json{?access_token,types,limit,language}';\nvar REVERSE_GEOCODING_PRECISION = 5;\nvar FORWARD_GEOCODING_PROXIMITY_PRECISION = 3;\nfunction roundTo(value, places) {\n  var mult = Math.pow(10, places);\n  return Math.round(value * mult) / mult;\n}\n\n/**\n * Search for a location with a string, using the\n * [Mapbox Geocoding API](https://www.mapbox.com/api-documentation/#geocoding).\n *\n * The `query` parmeter can be an array of strings only if batch geocoding\n * is used by specifying `mapbox.places-permanent` as the `dataset` option.\n *\n * @param {string|Array<string>} query desired location\n * @param {Object} [options={}] additional options meant to tune\n * the request\n * @param {Object} options.proximity a proximity argument: this is\n * a geographical point given as an object with latitude and longitude\n * properties. Search results closer to this point will be given\n * higher priority.\n * @param {Array} options.bbox a bounding box argument: this is\n * a bounding box given as an array in the format [minX, minY, maxX, maxY].\n * Search results will be limited to the bounding box.\n * @param {Array<string>|string} options.language Specify the language to use for response text and, for forward geocoding, query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, as an array or separated by commas.\n * @param {Array<string>|string} options.types an array or comma seperated list of types that filter\n * results to match those specified. See https://www.mapbox.com/developers/api/geocoding/#filter-type\n * for available types.\n * @param {number} [options.limit=5] is the maximum number of results to return, between 1 and 10 inclusive.\n * Some very specific queries may return fewer results than the limit.\n * @param {Array<string>|string} options.country an array or comma separated list of country codes to\n * limit results to specified country or countries.\n * @param {boolean} [options.autocomplete=true] whether to include results that include\n * the query only as a prefix. This is useful for UIs where users type\n * values, but if you have complete addresses as input, you'll want to turn it off\n * @param {string} [options.dataset=mapbox.places] the desired data to be\n * geocoded against. The default, mapbox.places, does not permit unlimited\n * caching. `mapbox.places-permanent` is available on request and does\n * permit permanent caching.\n * @param {Function} callback called with (err, results)\n * @returns {Promise} response\n * @example\n * var mapboxClient = new MapboxClient('ACCESSTOKEN');\n * mapboxClient.geocodeForward('Paris, France', function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n * // using the proximity option to weight results closer to texas\n * mapboxClient.geocodeForward('Paris, France', {\n *   proximity: { latitude: 33.6875431, longitude: -95.4431142 }\n * }, function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n * // using the bbox option to limit results to a portion of Washington, D.C.\n * mapboxClient.geocodeForward('Starbucks', {\n *   bbox: [-77.083056,38.908611,-76.997778,38.959167]\n * }, function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n */\nMapboxGeocoding.prototype.geocodeForward = function (query, options, callback) {\n  // permit the options argument to be omitted, or the options + callback args to be omitted if using promise syntax\n  if (callback === undefined && (options === undefined || typeof options === 'function')) {\n    callback = options;\n    options = {};\n  }\n\n  // typecheck arguments\n  if (Array.isArray(query)) {\n    if (options.dataset !== 'mapbox.places-permanent') {\n      throw new Error('Batch geocoding is only available with the mapbox.places-permanent endpoint. See https://mapbox.com/api-documentation/#batch-requests for details');\n    } else {\n      query = query.join(';');\n    }\n  }\n  invariant(typeof query === 'string', 'query must be a string');\n  invariant(typeof options === 'object', 'options must be an object');\n  var queryOptions = {\n    query: query,\n    dataset: 'mapbox.places'\n  };\n  var precision = FORWARD_GEOCODING_PROXIMITY_PRECISION;\n  if (options.precision) {\n    invariant(typeof options.precision === 'number', 'precision option must be number');\n    precision = options.precision;\n  }\n  if (options.proximity) {\n    invariant(typeof options.proximity.latitude === 'number' && typeof options.proximity.longitude === 'number', 'proximity must be an object with numeric latitude & longitude properties');\n    queryOptions.proximity = roundTo(options.proximity.longitude, precision) + ',' + roundTo(options.proximity.latitude, precision);\n  }\n  if (options.bbox) {\n    invariant(typeof options.bbox[0] === 'number' && typeof options.bbox[1] === 'number' && typeof options.bbox[2] === 'number' && typeof options.bbox[3] === 'number' && options.bbox.length === 4, 'bbox must be an array with numeric values in the form [minX, minY, maxX, maxY]');\n    queryOptions.bbox = options.bbox[0] + ',' + options.bbox[1] + ',' + options.bbox[2] + ',' + options.bbox[3];\n  }\n  if (options.limit) {\n    invariant(typeof options.limit === 'number', 'limit must be a number');\n    queryOptions.limit = options.limit;\n  }\n  if (options.dataset) {\n    invariant(typeof options.dataset === 'string', 'dataset option must be string');\n    queryOptions.dataset = options.dataset;\n  }\n  if (options.country) {\n    if (Array.isArray(options.country)) {\n      queryOptions.country = options.country.join(',');\n    } else {\n      invariant(typeof options.country === 'string', 'country option must be an array or string');\n      queryOptions.country = options.country;\n    }\n  }\n  if (options.language) {\n    if (Array.isArray(options.language)) {\n      queryOptions.language = options.language.join(',');\n    } else {\n      invariant(typeof options.language === 'string', 'language option must be an array or string');\n      queryOptions.language = options.language;\n    }\n  }\n  if (options.types) {\n    if (Array.isArray(options.types)) {\n      queryOptions.types = options.types.join(',');\n    } else {\n      invariant(typeof options.types === 'string', 'types option must be an array or string');\n      queryOptions.types = options.types;\n    }\n  }\n  if (typeof options.autocomplete === 'boolean') {\n    invariant(typeof options.autocomplete === 'boolean', 'autocomplete must be a boolean');\n    queryOptions.autocomplete = options.autocomplete;\n  }\n  return this.client({\n    path: API_GEOCODING_FORWARD,\n    params: queryOptions,\n    callback: callback\n  });\n};\n\n/**\n * Given a location, determine what geographical features are located\n * there. This uses the [Mapbox Geocoding API](https://www.mapbox.com/api-documentation/#geocoding).\n *\n * @param {Object} location the geographical point to search\n * @param {number} location.latitude decimal degrees latitude, in range -90 to 90\n * @param {number} location.longitude decimal degrees longitude, in range -180 to 180\n * @param {Object} [options={}] additional options meant to tune\n * the request.\n * @param {Array<string>|string} options.language Specify the language to use for response text and, for forward geocoding, query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas or as an array.\n * @param {Array<string>|string} options.types an array or comma seperated list of types that filter\n * results to match those specified. See\n * https://www.mapbox.com/api-documentation/#retrieve-places-near-a-location\n * for available types.\n * @param {number} [options.limit=1] is the maximum number of results to return, between 1 and 5\n * inclusive. Requires a single options.types to be specified (see example).\n * @param {string} [options.dataset=mapbox.places] the desired data to be\n * geocoded against. The default, mapbox.places, does not permit unlimited\n * caching. `mapbox.places-permanent` is available on request and does\n * permit permanent caching.\n * @param {Function} callback called with (err, results)\n * @returns {Promise} response\n * @example\n * var mapboxClient = new MapboxClient('ACCESSTOKEN');\n * mapboxClient.geocodeReverse(\n *   { latitude: 33.6875431, longitude: -95.4431142 },\n *   function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n * @example\n * var mapboxClient = new MapboxClient('ACCESSTOKEN');\n * mapboxClient.geocodeReverse(\n *   { latitude: 33.6875431, longitude: -95.4431142, options: { types: 'address', limit: 3 } },\n *   function(err, res) {\n *   // res is a GeoJSON document with up to 3 geocoding matches\n * });\n */\nMapboxGeocoding.prototype.geocodeReverse = function (location, options, callback) {\n  // permit the options argument to be omitted, or the options + callback args to be omitted if using promise syntax\n  if (callback === undefined && (options === undefined || typeof options === 'function')) {\n    callback = options;\n    options = {};\n  }\n\n  // typecheck arguments\n  invariant(typeof location === 'object' && location !== null, 'location must be an object');\n  invariant(typeof options === 'object', 'options must be an object');\n  invariant(typeof location.latitude === 'number' && typeof location.longitude === 'number', 'location must be an object with numeric latitude & longitude properties');\n  var queryOptions = {\n    dataset: 'mapbox.places'\n  };\n  if (options.dataset) {\n    invariant(typeof options.dataset === 'string', 'dataset option must be string');\n    queryOptions.dataset = options.dataset;\n  }\n  var precision = REVERSE_GEOCODING_PRECISION;\n  if (options.precision) {\n    invariant(typeof options.precision === 'number', 'precision option must be number');\n    precision = options.precision;\n  }\n  if (options.language) {\n    if (Array.isArray(options.language)) {\n      queryOptions.language = options.language.join(',');\n    } else {\n      invariant(typeof options.language === 'string', 'language option must be an array or string');\n      queryOptions.language = options.language;\n    }\n  }\n  if (options.types) {\n    if (Array.isArray(options.types)) {\n      queryOptions.types = options.types.join(',');\n    } else {\n      invariant(typeof options.types === 'string', 'types option must be an array or string');\n      queryOptions.types = options.types;\n    }\n  }\n  if (options.limit) {\n    invariant(typeof options.limit === 'number', 'limit option must be a number');\n    invariant(options.types.split(',').length === 1, 'a single type must be specified to use the limit option');\n    queryOptions.limit = options.limit;\n  }\n  queryOptions.longitude = roundTo(location.longitude, precision);\n  queryOptions.latitude = roundTo(location.latitude, precision);\n  return this.client({\n    path: API_GEOCODING_REVERSE,\n    params: queryOptions,\n    callback: callback\n  });\n};\nmodule.exports = MapboxGeocoding;","map":{"version":3,"names":["invariant","require","makeService","MapboxGeocoding","API_GEOCODING_FORWARD","API_GEOCODING_REVERSE","REVERSE_GEOCODING_PRECISION","FORWARD_GEOCODING_PROXIMITY_PRECISION","roundTo","value","places","mult","Math","pow","round","prototype","geocodeForward","query","options","callback","undefined","Array","isArray","dataset","Error","join","queryOptions","precision","proximity","latitude","longitude","bbox","length","limit","country","language","types","autocomplete","client","path","params","geocodeReverse","location","split","module","exports"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/mapbox/lib/services/geocoding.js"],"sourcesContent":["'use strict';\n\nvar invariant = require('../../vendor/invariant');\nvar makeService = require('../make_service');\n\n/**\n * @class MapboxGeocoding\n */\nvar MapboxGeocoding = makeService('MapboxGeocoding');\n\nvar API_GEOCODING_FORWARD = '/geocoding/v5/{dataset}/{query}.json{?access_token,proximity,country,types,bbox,limit,autocomplete,language}';\nvar API_GEOCODING_REVERSE = '/geocoding/v5/{dataset}/{longitude},{latitude}.json{?access_token,types,limit,language}';\n\nvar REVERSE_GEOCODING_PRECISION = 5;\nvar FORWARD_GEOCODING_PROXIMITY_PRECISION = 3;\n\nfunction roundTo(value, places) {\n  var mult = Math.pow(10, places);\n  return Math.round(value * mult) / mult;\n}\n\n/**\n * Search for a location with a string, using the\n * [Mapbox Geocoding API](https://www.mapbox.com/api-documentation/#geocoding).\n *\n * The `query` parmeter can be an array of strings only if batch geocoding\n * is used by specifying `mapbox.places-permanent` as the `dataset` option.\n *\n * @param {string|Array<string>} query desired location\n * @param {Object} [options={}] additional options meant to tune\n * the request\n * @param {Object} options.proximity a proximity argument: this is\n * a geographical point given as an object with latitude and longitude\n * properties. Search results closer to this point will be given\n * higher priority.\n * @param {Array} options.bbox a bounding box argument: this is\n * a bounding box given as an array in the format [minX, minY, maxX, maxY].\n * Search results will be limited to the bounding box.\n * @param {Array<string>|string} options.language Specify the language to use for response text and, for forward geocoding, query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, as an array or separated by commas.\n * @param {Array<string>|string} options.types an array or comma seperated list of types that filter\n * results to match those specified. See https://www.mapbox.com/developers/api/geocoding/#filter-type\n * for available types.\n * @param {number} [options.limit=5] is the maximum number of results to return, between 1 and 10 inclusive.\n * Some very specific queries may return fewer results than the limit.\n * @param {Array<string>|string} options.country an array or comma separated list of country codes to\n * limit results to specified country or countries.\n * @param {boolean} [options.autocomplete=true] whether to include results that include\n * the query only as a prefix. This is useful for UIs where users type\n * values, but if you have complete addresses as input, you'll want to turn it off\n * @param {string} [options.dataset=mapbox.places] the desired data to be\n * geocoded against. The default, mapbox.places, does not permit unlimited\n * caching. `mapbox.places-permanent` is available on request and does\n * permit permanent caching.\n * @param {Function} callback called with (err, results)\n * @returns {Promise} response\n * @example\n * var mapboxClient = new MapboxClient('ACCESSTOKEN');\n * mapboxClient.geocodeForward('Paris, France', function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n * // using the proximity option to weight results closer to texas\n * mapboxClient.geocodeForward('Paris, France', {\n *   proximity: { latitude: 33.6875431, longitude: -95.4431142 }\n * }, function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n * // using the bbox option to limit results to a portion of Washington, D.C.\n * mapboxClient.geocodeForward('Starbucks', {\n *   bbox: [-77.083056,38.908611,-76.997778,38.959167]\n * }, function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n */\nMapboxGeocoding.prototype.geocodeForward = function(query, options, callback) {\n  // permit the options argument to be omitted, or the options + callback args to be omitted if using promise syntax\n  if (callback === undefined && (options === undefined || typeof options === 'function')) {\n    callback = options;\n    options = {};\n  }\n\n  // typecheck arguments\n  if (Array.isArray(query)) {\n    if (options.dataset !== 'mapbox.places-permanent') {\n      throw new Error('Batch geocoding is only available with the mapbox.places-permanent endpoint. See https://mapbox.com/api-documentation/#batch-requests for details');\n    } else {\n      query = query.join(';');\n    }\n  }\n  invariant(typeof query === 'string', 'query must be a string');\n  invariant(typeof options === 'object', 'options must be an object');\n\n  var queryOptions = {\n    query: query,\n    dataset: 'mapbox.places'\n  };\n\n  var precision = FORWARD_GEOCODING_PROXIMITY_PRECISION;\n  if (options.precision) {\n    invariant(typeof options.precision === 'number', 'precision option must be number');\n    precision = options.precision;\n  }\n\n  if (options.proximity) {\n    invariant(typeof options.proximity.latitude === 'number' &&\n      typeof options.proximity.longitude === 'number',\n      'proximity must be an object with numeric latitude & longitude properties');\n    queryOptions.proximity = roundTo(options.proximity.longitude, precision) + ',' + roundTo(options.proximity.latitude, precision);\n  }\n\n  if (options.bbox) {\n    invariant(typeof options.bbox[0] === 'number' &&\n      typeof options.bbox[1] === 'number' &&\n      typeof options.bbox[2] === 'number' &&\n      typeof options.bbox[3] === 'number' &&\n      options.bbox.length === 4,\n      'bbox must be an array with numeric values in the form [minX, minY, maxX, maxY]');\n    queryOptions.bbox = options.bbox[0] + ',' + options.bbox[1] + ',' + options.bbox[2] + ',' + options.bbox[3];\n  }\n\n  if (options.limit) {\n    invariant(typeof options.limit === 'number',\n      'limit must be a number');\n    queryOptions.limit = options.limit;\n  }\n\n  if (options.dataset) {\n    invariant(typeof options.dataset === 'string', 'dataset option must be string');\n    queryOptions.dataset = options.dataset;\n  }\n\n  if (options.country) {\n    if (Array.isArray(options.country)) {\n      queryOptions.country = options.country.join(',');\n    } else {\n      invariant(typeof options.country === 'string', 'country option must be an array or string');\n      queryOptions.country = options.country;\n    }\n  }\n\n  if (options.language) {\n    if (Array.isArray(options.language)) {\n      queryOptions.language = options.language.join(',');\n    } else {\n      invariant(typeof options.language === 'string', 'language option must be an array or string');\n      queryOptions.language = options.language;\n    }\n  }\n\n  if (options.types) {\n    if (Array.isArray(options.types)) {\n      queryOptions.types = options.types.join(',');\n    } else {\n      invariant(typeof options.types === 'string', 'types option must be an array or string');\n      queryOptions.types = options.types;\n    }\n  }\n\n  if (typeof options.autocomplete === 'boolean') {\n    invariant(typeof options.autocomplete === 'boolean', 'autocomplete must be a boolean');\n    queryOptions.autocomplete = options.autocomplete;\n  }\n\n  return this.client({\n    path: API_GEOCODING_FORWARD,\n    params: queryOptions,\n    callback: callback\n  });\n};\n\n/**\n * Given a location, determine what geographical features are located\n * there. This uses the [Mapbox Geocoding API](https://www.mapbox.com/api-documentation/#geocoding).\n *\n * @param {Object} location the geographical point to search\n * @param {number} location.latitude decimal degrees latitude, in range -90 to 90\n * @param {number} location.longitude decimal degrees longitude, in range -180 to 180\n * @param {Object} [options={}] additional options meant to tune\n * the request.\n * @param {Array<string>|string} options.language Specify the language to use for response text and, for forward geocoding, query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas or as an array.\n * @param {Array<string>|string} options.types an array or comma seperated list of types that filter\n * results to match those specified. See\n * https://www.mapbox.com/api-documentation/#retrieve-places-near-a-location\n * for available types.\n * @param {number} [options.limit=1] is the maximum number of results to return, between 1 and 5\n * inclusive. Requires a single options.types to be specified (see example).\n * @param {string} [options.dataset=mapbox.places] the desired data to be\n * geocoded against. The default, mapbox.places, does not permit unlimited\n * caching. `mapbox.places-permanent` is available on request and does\n * permit permanent caching.\n * @param {Function} callback called with (err, results)\n * @returns {Promise} response\n * @example\n * var mapboxClient = new MapboxClient('ACCESSTOKEN');\n * mapboxClient.geocodeReverse(\n *   { latitude: 33.6875431, longitude: -95.4431142 },\n *   function(err, res) {\n *   // res is a GeoJSON document with geocoding matches\n * });\n * @example\n * var mapboxClient = new MapboxClient('ACCESSTOKEN');\n * mapboxClient.geocodeReverse(\n *   { latitude: 33.6875431, longitude: -95.4431142, options: { types: 'address', limit: 3 } },\n *   function(err, res) {\n *   // res is a GeoJSON document with up to 3 geocoding matches\n * });\n */\nMapboxGeocoding.prototype.geocodeReverse = function(location, options, callback) {\n  // permit the options argument to be omitted, or the options + callback args to be omitted if using promise syntax\n  if (callback === undefined && (options === undefined || typeof options === 'function')) {\n    callback = options;\n    options = {};\n  }\n\n  // typecheck arguments\n  invariant((typeof location === 'object' && location !== null), 'location must be an object');\n  invariant(typeof options === 'object', 'options must be an object');\n\n  invariant(typeof location.latitude === 'number' &&\n    typeof location.longitude === 'number',\n    'location must be an object with numeric latitude & longitude properties');\n\n  var queryOptions = {\n    dataset: 'mapbox.places'\n  };\n\n  if (options.dataset) {\n    invariant(typeof options.dataset === 'string', 'dataset option must be string');\n    queryOptions.dataset = options.dataset;\n  }\n\n  var precision = REVERSE_GEOCODING_PRECISION;\n  if (options.precision) {\n    invariant(typeof options.precision === 'number', 'precision option must be number');\n    precision = options.precision;\n  }\n\n  if (options.language) {\n    if (Array.isArray(options.language)) {\n      queryOptions.language = options.language.join(',');\n    } else {\n      invariant(typeof options.language === 'string', 'language option must be an array or string');\n      queryOptions.language = options.language;\n    }\n  }\n\n  if (options.types) {\n    if (Array.isArray(options.types)) {\n      queryOptions.types = options.types.join(',');\n    } else {\n      invariant(typeof options.types === 'string', 'types option must be an array or string');\n      queryOptions.types = options.types;\n    }\n  }\n\n  if (options.limit) {\n    invariant(typeof options.limit === 'number', 'limit option must be a number');\n    invariant(options.types.split(',').length === 1, 'a single type must be specified to use the limit option');\n    queryOptions.limit = options.limit;\n  }\n\n  queryOptions.longitude = roundTo(location.longitude, precision);\n  queryOptions.latitude = roundTo(location.latitude, precision);\n\n  return this.client({\n    path: API_GEOCODING_REVERSE,\n    params: queryOptions,\n    callback: callback\n  });\n};\n\nmodule.exports = MapboxGeocoding;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}