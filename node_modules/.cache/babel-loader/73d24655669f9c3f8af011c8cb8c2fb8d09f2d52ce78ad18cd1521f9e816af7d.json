{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport earcut from 'earcut';\nvar PI_4 = Math.PI / 4;\nvar DEGREES_TO_RADIANS_HALF = Math.PI / 360;\nfunction validate(polygon) {\n  polygon = polygon && polygon.positions || polygon;\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\nfunction isNestedRingClosed(simplePolygon) {\n  var p0 = simplePolygon[0];\n  var p1 = simplePolygon[simplePolygon.length - 1];\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (var i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size) {\n  var targetIndex = targetStartIndex;\n  var len = simplePolygon.length;\n  for (var i = 0; i < len; i++) {\n    for (var j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (var _j = 0; _j < size; _j++) {\n      target[targetIndex++] = simplePolygon[0][_j] || 0;\n    }\n  }\n  return targetIndex;\n}\nfunction copyFlatRing(target, targetStartIndex, positions, size) {\n  var srcStartIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var srcEndIndex = arguments.length > 5 ? arguments[5] : undefined;\n  srcEndIndex = srcEndIndex || positions.length;\n  var srcLength = srcEndIndex - srcStartIndex;\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n  var targetIndex = targetStartIndex;\n  for (var i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (var _i = 0; _i < size; _i++) {\n      target[targetIndex++] = positions[srcStartIndex + _i];\n    }\n  }\n  return targetIndex;\n}\nfunction getNestedVertexCount(simplePolygon) {\n  return (isNestedRingClosed(simplePolygon) ? 0 : 1) + simplePolygon.length;\n}\nfunction getFlatVertexCount(positions, size) {\n  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var endIndex = arguments.length > 3 ? arguments[3] : undefined;\n  endIndex = endIndex || positions.length;\n  if (startIndex >= endIndex) {\n    return 0;\n  }\n  return (isFlatRingClosed(positions, size, startIndex, endIndex) ? 0 : 1) + (endIndex - startIndex) / size;\n}\nexport function getVertexCount(polygon, positionSize) {\n  var normalization = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!normalization) {\n    polygon = polygon.positions || polygon;\n    return polygon.length / positionSize;\n  }\n  validate(polygon);\n  if (polygon.positions) {\n    var _polygon = polygon,\n      positions = _polygon.positions,\n      holeIndices = _polygon.holeIndices;\n    if (holeIndices) {\n      var vertexCount = 0;\n      for (var i = 0; i <= holeIndices.length; i++) {\n        vertexCount += getFlatVertexCount(polygon.positions, positionSize, holeIndices[i - 1], holeIndices[i]);\n      }\n      return vertexCount;\n    }\n    polygon = positions;\n  }\n  if (Number.isFinite(polygon[0])) {\n    return getFlatVertexCount(polygon, positionSize);\n  }\n  if (!isSimple(polygon)) {\n    var _vertexCount = 0;\n    var _iterator = _createForOfIteratorHelper(polygon),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var simplePolygon = _step.value;\n        _vertexCount += getNestedVertexCount(simplePolygon);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return _vertexCount;\n  }\n  return getNestedVertexCount(polygon);\n}\nexport function normalize(polygon, positionSize, vertexCount) {\n  validate(polygon);\n  vertexCount = vertexCount || getVertexCount(polygon, positionSize);\n  var positions = new Float64Array(vertexCount * positionSize);\n  var holeIndices = [];\n  if (polygon.positions) {\n    var _polygon2 = polygon,\n      srcPositions = _polygon2.positions,\n      srcHoleIndices = _polygon2.holeIndices;\n    if (srcHoleIndices) {\n      var targetIndex = 0;\n      for (var i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i]);\n        holeIndices.push(targetIndex);\n      }\n      holeIndices.pop();\n      return {\n        positions: positions,\n        holeIndices: holeIndices\n      };\n    }\n    polygon = srcPositions;\n  }\n  if (Number.isFinite(polygon[0])) {\n    copyFlatRing(positions, 0, polygon, positionSize);\n    return positions;\n  }\n  if (!isSimple(polygon)) {\n    var _targetIndex = 0;\n    var _iterator2 = _createForOfIteratorHelper(polygon),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var simplePolygon = _step2.value;\n        _targetIndex = copyNestedRing(positions, _targetIndex, simplePolygon, positionSize);\n        holeIndices.push(_targetIndex);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    holeIndices.pop();\n    return {\n      positions: positions,\n      holeIndices: holeIndices\n    };\n  }\n  copyNestedRing(positions, 0, polygon, positionSize);\n  return positions;\n}\nexport function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {\n  var holeIndices = null;\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(function (positionIndex) {\n      return positionIndex / positionSize;\n    });\n  }\n  var positions = normalizedPolygon.positions || normalizedPolygon;\n  if (preproject) {\n    var n = positions.length;\n    positions = positions.slice();\n    for (var i = 0; i < n; i += positionSize) {\n      var y = positions[i + 1];\n      positions[i + 1] = Math.log(Math.tan(PI_4 + y * DEGREES_TO_RADIANS_HALF));\n    }\n  }\n  return earcut(positions, holeIndices, positionSize);\n}","map":{"version":3,"names":["earcut","PI_4","Math","PI","DEGREES_TO_RADIANS_HALF","validate","polygon","positions","Array","isArray","ArrayBuffer","isView","Error","isSimple","length","Number","isFinite","isNestedRingClosed","simplePolygon","p0","p1","isFlatRingClosed","size","startIndex","endIndex","i","copyNestedRing","target","targetStartIndex","targetIndex","len","j","copyFlatRing","srcStartIndex","arguments","undefined","srcEndIndex","srcLength","getNestedVertexCount","getFlatVertexCount","getVertexCount","positionSize","normalization","_polygon","holeIndices","vertexCount","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","err","e","f","normalize","Float64Array","_polygon2","srcPositions","srcHoleIndices","push","pop","_iterator2","_step2","getSurfaceIndices","normalizedPolygon","preproject","map","positionIndex","slice","y","log","tan"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@luma.gl/experimental/src/gpgpu/point-in-polygon/polygon.js"],"sourcesContent":["// => COPIED FROM  deck.gl\n\n// Copyright (c) 2015 - 2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable max-params */\nimport earcut from 'earcut';\n\n// For Web Mercator projection\nconst PI_4 = Math.PI / 4;\nconst DEGREES_TO_RADIANS_HALF = Math.PI / 360;\n\n// 4 data formats are supported:\n// Simple Polygon: an array of points\n// Complex Polygon: an array of array of points (array of rings)\n//   with the first ring representing the outer hull and other rings representing holes\n// Simple Flat: an array of numbers (flattened \"simple polygon\")\n// Complex Flat: {position: array<number>, holeIndices: array<number>}\n//   (flattened \"complex polygon\")\n\n/**\n * Ensure a polygon is valid format\n * @param {Array|Object} polygon\n */\nfunction validate(polygon) {\n  polygon = (polygon && polygon.positions) || polygon;\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\n/**\n * Check if a polygon is simple or complex\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\n/**\n * Check if a simple polygon is a closed ring\n * @param {Array} simplePolygon - array of points\n * @return {Boolean} - true if the simple polygon is a closed ring\n */\nfunction isNestedRingClosed(simplePolygon) {\n  // check if first and last vertex are the same\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\n/**\n * Check if a simple flat array is a closed ring\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} startIndex - start index of the path in the positions array\n * @param {Number} endIndex - end index of the path in the positions array\n * @return {Boolean} - true if the simple flat array is a closed ring\n */\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Copy a simple polygon coordinates into a flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} simplePolygon - array of points\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n  return targetIndex;\n}\n\n/**\n * Copy a simple flat array into another flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [srcStartIndex] - start index of the path in the positions array\n * @param {Number} [srcEndIndex] - end index of the path in the positions array\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex) {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n  return targetIndex;\n}\n\n/**\n * Counts the number of vertices in a simple polygon, closes the polygon if needed.\n * @param {Array} simplePolygon - array of points\n * @returns {Number} vertex count\n */\nfunction getNestedVertexCount(simplePolygon) {\n  return (isNestedRingClosed(simplePolygon) ? 0 : 1) + simplePolygon.length;\n}\n\n/**\n * Counts the number of vertices in a simple flat array, closes the polygon if needed.\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [startIndex] - start index of the path in the positions array\n * @param {Number} [endIndex] - end index of the path in the positions array\n * @returns {Number} vertex count\n */\nfunction getFlatVertexCount(positions, size, startIndex = 0, endIndex) {\n  endIndex = endIndex || positions.length;\n  if (startIndex >= endIndex) {\n    return 0;\n  }\n  return (\n    (isFlatRingClosed(positions, size, startIndex, endIndex) ? 0 : 1) +\n    (endIndex - startIndex) / size\n  );\n}\n\n/**\n * Counts the number of vertices in any polygon representation.\n * @param {Array|Object} polygon\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Number} vertex count\n */\nexport function getVertexCount(polygon, positionSize, normalization = true) {\n  if (!normalization) {\n    polygon = polygon.positions || polygon;\n    return polygon.length / positionSize;\n  }\n\n  validate(polygon);\n\n  if (polygon.positions) {\n    // complex flat\n    const {positions, holeIndices} = polygon;\n\n    if (holeIndices) {\n      let vertexCount = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= holeIndices.length; i++) {\n        vertexCount += getFlatVertexCount(\n          polygon.positions,\n          positionSize,\n          holeIndices[i - 1],\n          holeIndices[i]\n        );\n      }\n      return vertexCount;\n    }\n    polygon = positions;\n  }\n  if (Number.isFinite(polygon[0])) {\n    // simple flat\n    return getFlatVertexCount(polygon, positionSize);\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let vertexCount = 0;\n    for (const simplePolygon of polygon) {\n      vertexCount += getNestedVertexCount(simplePolygon);\n    }\n    return vertexCount;\n  }\n  // simple polygon\n  return getNestedVertexCount(polygon);\n}\n\n/**\n * Normalize any polygon representation into the \"complex flat\" format\n * @param {Array|Object} polygon\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [vertexCount] - pre-computed vertex count in the polygon.\n *   If provided, will skip counting.\n * @return {Object} - {positions: <Float64Array>, holeIndices: <Array|null>}\n */\n/* eslint-disable max-statements */\nexport function normalize(polygon, positionSize, vertexCount) {\n  validate(polygon);\n\n  vertexCount = vertexCount || getVertexCount(polygon, positionSize);\n\n  const positions = new Float64Array(vertexCount * positionSize);\n  const holeIndices = [];\n\n  if (polygon.positions) {\n    // complex flat\n    const {positions: srcPositions, holeIndices: srcHoleIndices} = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(\n          positions,\n          targetIndex,\n          srcPositions,\n          positionSize,\n          srcHoleIndices[i - 1],\n          srcHoleIndices[i]\n        );\n        holeIndices.push(targetIndex);\n      }\n      // The last one is not a starting index of a hole, remove\n      holeIndices.pop();\n\n      return {positions, holeIndices};\n    }\n    polygon = srcPositions;\n  }\n  if (Number.isFinite(polygon[0])) {\n    // simple flat\n    copyFlatRing(positions, 0, polygon, positionSize);\n    return positions;\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let targetIndex = 0;\n\n    for (const simplePolygon of polygon) {\n      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize);\n      holeIndices.push(targetIndex);\n    }\n    // The last one is not a starting index of a hole, remove\n    holeIndices.pop();\n    // last index points to the end of the array, remove it\n    return {positions, holeIndices};\n  }\n  // simple polygon\n  copyNestedRing(positions, 0, polygon, positionSize);\n  return positions;\n}\n/* eslint-enable max-statements */\n\n/*\n * Get vertex indices for drawing polygon mesh\n * @param {Object} normalizedPolygon - {positions, holeIndices}\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Array} array of indices\n */\nexport function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {\n  let holeIndices = null;\n\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n  let positions = normalizedPolygon.positions || normalizedPolygon;\n\n  // TODO - handle other coordinate systems and projection modes\n  if (preproject) {\n    // When tesselating lnglat coordinates, project them to the Web Mercator plane for accuracy\n    const n = positions.length;\n    // Clone the array\n    positions = positions.slice();\n    for (let i = 0; i < n; i += positionSize) {\n      // project points to a scaled version of the web-mercator plane\n      // It doesn't matter if x and y are scaled/translated, but the relationship must be linear\n      const y = positions[i + 1];\n      positions[i + 1] = Math.log(Math.tan(PI_4 + y * DEGREES_TO_RADIANS_HALF));\n    }\n  }\n\n  // Let earcut triangulate the polygon\n  return earcut(positions, holeIndices, positionSize);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}