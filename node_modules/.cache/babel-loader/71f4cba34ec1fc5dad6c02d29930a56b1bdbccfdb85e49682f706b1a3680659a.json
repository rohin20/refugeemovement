{"ast":null,"code":"import _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Vector3, Matrix4, assert, equals, _MathUtils } from '@math.gl/core';\nimport * as vec3 from 'gl-matrix/vec3';\nimport { WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z } from '../constants';\nimport { fromCartographicToRadians, toCartographicFromRadians } from '../type-utils';\nimport _scaleToGeodeticSurface from './helpers/scale-to-geodetic-surface';\nimport _localFrameToFixedFrame from './helpers/ellipsoid-transform';\nvar scratchVector = new Vector3();\nvar scratchNormal = new Vector3();\nvar scratchK = new Vector3();\nvar scratchPosition = new Vector3();\nvar scratchHeight = new Vector3();\nvar scratchCartesian = new Vector3();\nvar wgs84;\nvar Ellipsoid = /*#__PURE__*/function () {\n  function Ellipsoid() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0;\n    _classCallCheck(this, Ellipsoid);\n    _defineProperty(this, \"radii\", void 0);\n    _defineProperty(this, \"radiiSquared\", void 0);\n    _defineProperty(this, \"radiiToTheFourth\", void 0);\n    _defineProperty(this, \"oneOverRadii\", void 0);\n    _defineProperty(this, \"oneOverRadiiSquared\", void 0);\n    _defineProperty(this, \"minimumRadius\", void 0);\n    _defineProperty(this, \"maximumRadius\", void 0);\n    _defineProperty(this, \"centerToleranceSquared\", _MathUtils.EPSILON1);\n    _defineProperty(this, \"squaredXOverSquaredZ\", void 0);\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n    this.radii = new Vector3(x, y, z);\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n    this.oneOverRadii = new Vector3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);\n    this.oneOverRadiiSquared = new Vector3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));\n    this.minimumRadius = Math.min(x, y, z);\n    this.maximumRadius = Math.max(x, y, z);\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n    Object.freeze(this);\n  }\n  _createClass(Ellipsoid, [{\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right && this.radii.equals(right.radii));\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.radii.toString();\n    }\n  }, {\n    key: \"cartographicToCartesian\",\n    value: function cartographicToCartesian(cartographic) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      var normal = scratchNormal;\n      var k = scratchK;\n      var _cartographic = _slicedToArray(cartographic, 3),\n        height = _cartographic[2];\n      this.geodeticSurfaceNormalCartographic(cartographic, normal);\n      k.copy(this.radiiSquared).scale(normal);\n      var gamma = Math.sqrt(normal.dot(k));\n      k.scale(1 / gamma);\n      normal.scale(height);\n      k.add(normal);\n      return k.to(result);\n    }\n  }, {\n    key: \"cartesianToCartographic\",\n    value: function cartesianToCartographic(cartesian) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      scratchCartesian.from(cartesian);\n      var point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n      if (!point) {\n        return undefined;\n      }\n      var normal = this.geodeticSurfaceNormal(point, scratchNormal);\n      var h = scratchHeight;\n      h.copy(scratchCartesian).subtract(point);\n      var longitude = Math.atan2(normal.y, normal.x);\n      var latitude = Math.asin(normal.z);\n      var height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n      return toCartographicFromRadians([longitude, latitude, height], result);\n    }\n  }, {\n    key: \"eastNorthUpToFixedFrame\",\n    value: function eastNorthUpToFixedFrame(origin) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Matrix4();\n      return _localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n    }\n  }, {\n    key: \"localFrameToFixedFrame\",\n    value: function localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin) {\n      var result = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Matrix4();\n      return _localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n    }\n  }, {\n    key: \"geocentricSurfaceNormal\",\n    value: function geocentricSurfaceNormal(cartesian) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      return scratchVector.from(cartesian).normalize().to(result);\n    }\n  }, {\n    key: \"geodeticSurfaceNormalCartographic\",\n    value: function geodeticSurfaceNormalCartographic(cartographic) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      var cartographicVectorRadians = fromCartographicToRadians(cartographic);\n      var longitude = cartographicVectorRadians[0];\n      var latitude = cartographicVectorRadians[1];\n      var cosLatitude = Math.cos(latitude);\n      scratchVector.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();\n      return scratchVector.to(result);\n    }\n  }, {\n    key: \"geodeticSurfaceNormal\",\n    value: function geodeticSurfaceNormal(cartesian) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n    }\n  }, {\n    key: \"scaleToGeodeticSurface\",\n    value: function scaleToGeodeticSurface(cartesian, result) {\n      return _scaleToGeodeticSurface(cartesian, this, result);\n    }\n  }, {\n    key: \"scaleToGeocentricSurface\",\n    value: function scaleToGeocentricSurface(cartesian) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      scratchPosition.from(cartesian);\n      var positionX = scratchPosition.x;\n      var positionY = scratchPosition.y;\n      var positionZ = scratchPosition.z;\n      var oneOverRadiiSquared = this.oneOverRadiiSquared;\n      var beta = 1.0 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);\n      return scratchPosition.multiplyScalar(beta).to(result);\n    }\n  }, {\n    key: \"transformPositionToScaledSpace\",\n    value: function transformPositionToScaledSpace(position) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      return scratchPosition.from(position).scale(this.oneOverRadii).to(result);\n    }\n  }, {\n    key: \"transformPositionFromScaledSpace\",\n    value: function transformPositionFromScaledSpace(position) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      return scratchPosition.from(position).scale(this.radii).to(result);\n    }\n  }, {\n    key: \"getSurfaceNormalIntersectionWithZAxis\",\n    value: function getSurfaceNormalIntersectionWithZAxis(position) {\n      var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0, 0];\n      assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n      assert(this.radii.z > 0);\n      scratchPosition.from(position);\n      var z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n      if (Math.abs(z) >= this.radii.z - buffer) {\n        return undefined;\n      }\n      return scratchPosition.set(0.0, 0.0, z).to(result);\n    }\n  }]);\n  return Ellipsoid;\n}();\nexport { Ellipsoid as default };\n_defineProperty(Ellipsoid, \"WGS84\", new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z));","map":{"version":3,"names":["Vector3","Matrix4","assert","equals","_MathUtils","vec3","WGS84_RADIUS_X","WGS84_RADIUS_Y","WGS84_RADIUS_Z","fromCartographicToRadians","toCartographicFromRadians","scaleToGeodeticSurface","localFrameToFixedFrame","scratchVector","scratchNormal","scratchK","scratchPosition","scratchHeight","scratchCartesian","wgs84","Ellipsoid","x","arguments","length","undefined","y","z","_classCallCheck","_defineProperty","EPSILON1","radii","radiiSquared","radiiToTheFourth","oneOverRadii","oneOverRadiiSquared","minimumRadius","Math","min","maximumRadius","max","squaredXOverSquaredZ","Object","freeze","_createClass","key","value","right","Boolean","toString","cartographicToCartesian","cartographic","result","normal","k","_cartographic","_slicedToArray","height","geodeticSurfaceNormalCartographic","copy","scale","gamma","sqrt","dot","add","to","cartesianToCartographic","cartesian","from","point","geodeticSurfaceNormal","h","subtract","longitude","atan2","latitude","asin","sign","eastNorthUpToFixedFrame","origin","firstAxis","secondAxis","thirdAxis","geocentricSurfaceNormal","normalize","cartographicVectorRadians","cosLatitude","cos","set","sin","scaleToGeocentricSurface","positionX","positionY","positionZ","beta","multiplyScalar","transformPositionToScaledSpace","position","transformPositionFromScaledSpace","getSurfaceNormalIntersectionWithZAxis","buffer","EPSILON15","abs","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@math.gl/geospatial/src/ellipsoid/ellipsoid.ts"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {\n  Vector3,\n  Matrix4,\n  toRadians,\n  toDegrees,\n  assert,\n  equals,\n  _MathUtils,\n  NumericArray\n} from '@math.gl/core';\nimport * as vec3 from 'gl-matrix/vec3';\n\nimport {WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z} from '../constants';\nimport {fromCartographicToRadians, toCartographicFromRadians} from '../type-utils';\n\nimport scaleToGeodeticSurface from './helpers/scale-to-geodetic-surface';\nimport localFrameToFixedFrame from './helpers/ellipsoid-transform';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\nconst scratchK = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchHeight = new Vector3();\nconst scratchCartesian = new Vector3();\n\nlet wgs84;\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * `(x / a)^2 + (y / b)^2 + (z / c)^2 = 1`.  Primarily used\n * to represent the shape of planetary bodies.\n */\nexport default class Ellipsoid {\n  /** An Ellipsoid instance initialized to the WGS84 standard. */\n  static readonly WGS84: Ellipsoid = new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);\n\n  readonly radii: Vector3;\n  readonly radiiSquared: Vector3;\n  readonly radiiToTheFourth: Vector3;\n  readonly oneOverRadii: Vector3;\n  readonly oneOverRadiiSquared: Vector3;\n  readonly minimumRadius: number;\n  readonly maximumRadius: number;\n  readonly centerToleranceSquared: number = _MathUtils.EPSILON1;\n  readonly squaredXOverSquaredZ: number;\n\n  /** Creates an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions. */\n  constructor(x: number, y: number, z: number);\n  constructor();\n\n  constructor(x = 0.0, y = 0.0, z = 0.0) {\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n\n    this.radii = new Vector3(x, y, z);\n\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n\n    this.oneOverRadii = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / x,\n      y === 0.0 ? 0.0 : 1.0 / y,\n      z === 0.0 ? 0.0 : 1.0 / z\n    );\n\n    this.oneOverRadiiSquared = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / (x * x),\n      y === 0.0 ? 0.0 : 1.0 / (y * y),\n      z === 0.0 ? 0.0 : 1.0 / (z * z)\n    );\n\n    this.minimumRadius = Math.min(x, y, z);\n\n    this.maximumRadius = Math.max(x, y, z);\n\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n\n    Object.freeze(this);\n  }\n\n  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */\n  equals(right: Ellipsoid): boolean {\n    return this === right || Boolean(right && this.radii.equals(right.radii));\n  }\n\n  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */\n  toString(): string {\n    return this.radii.toString();\n  }\n\n  /** Converts the provided cartographic to Cartesian representation. */\n  cartographicToCartesian(cartographic: number[], result: Vector3): Vector3;\n  cartographicToCartesian(cartographic: number[], result?: number[]): number[];\n\n  cartographicToCartesian(cartographic, result = [0, 0, 0]) {\n    const normal = scratchNormal;\n    const k = scratchK;\n\n    const [, , height] = cartographic;\n    this.geodeticSurfaceNormalCartographic(cartographic, normal);\n    k.copy(this.radiiSquared).scale(normal);\n\n    const gamma = Math.sqrt(normal.dot(k));\n    k.scale(1 / gamma);\n\n    normal.scale(height);\n\n    k.add(normal);\n\n    return k.to(result);\n  }\n\n  /** Converts the provided cartesian to cartographic (lng/lat/z) representation.\n   * The cartesian is undefined at the center of the ellipsoid. */\n  cartesianToCartographic(cartesian: number[], result: Vector3): Vector3;\n  cartesianToCartographic(cartesian: number[], result?: number[]): number[];\n\n  cartesianToCartographic(cartesian, result = [0, 0, 0]) {\n    scratchCartesian.from(cartesian);\n    const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n\n    if (!point) {\n      return undefined;\n    }\n\n    const normal = this.geodeticSurfaceNormal(point, scratchNormal);\n\n    const h = scratchHeight;\n    h.copy(scratchCartesian).subtract(point);\n\n    const longitude = Math.atan2(normal.y, normal.x);\n    const latitude = Math.asin(normal.z);\n    const height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n\n    return toCartographicFromRadians([longitude, latitude, height], result);\n  }\n\n  /** Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n   * centered at the provided origin to the provided ellipsoid's fixed reference frame. */\n  eastNorthUpToFixedFrame(origin: number[], result?: Matrix4): Matrix4;\n  eastNorthUpToFixedFrame(origin: number[], result: number[]): number[];\n\n  eastNorthUpToFixedFrame(origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n  }\n\n  /** Computes a 4x4 transformation matrix from a reference frame centered at\n   * the provided origin to the ellipsoid's fixed reference frame.\n   */\n  localFrameToFixedFrame(\n    firstAxis: string,\n    secondAxis: string,\n    thirdAxis: string,\n    origin: Readonly<NumericArray>,\n    result?: Matrix4\n  ): Matrix4;\n  localFrameToFixedFrame<Matrix4T>(\n    firstAxis: string,\n    secondAxis: string,\n    thirdAxis: string,\n    origin: Readonly<NumericArray>,\n    result: number[]\n  ): number[];\n\n  // Computes a 4x4 transformation matrix from a reference frame centered at\n  // the provided origin to the ellipsoid's fixed reference frame.\n  localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n  }\n\n  /** Computes the unit vector directed from the center of this ellipsoid toward\n   * the provided Cartesian position. */\n  geocentricSurfaceNormal(cartesian: number[], result?: number[]): number[];\n  geocentricSurfaceNormal<NumArray>(cartesian: number[], result: NumArray): NumArray;\n  geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).normalize().to(result);\n  }\n\n  /** Computes the normal of the plane tangent to the surface of the ellipsoid at provided position. */\n  geodeticSurfaceNormalCartographic<NumArray>(cartographic: number[], result: NumArray): NumArray;\n  geodeticSurfaceNormalCartographic(cartographic: number[]): number[];\n  geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {\n    const cartographicVectorRadians = fromCartographicToRadians(cartographic);\n\n    const longitude = cartographicVectorRadians[0];\n    const latitude = cartographicVectorRadians[1];\n\n    const cosLatitude = Math.cos(latitude);\n\n    scratchVector\n      .set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude))\n      .normalize();\n\n    return scratchVector.to(result);\n  }\n\n  /** Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position. */\n  geodeticSurfaceNormal<NumArrayT>(cartesian: number[], result: NumArrayT): NumArrayT;\n  geodeticSurfaceNormal(cartesian: number[]): number[];\n  geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n  }\n\n  /** Scales the provided Cartesian position along the geodetic surface normal\n   * so that it is on the surface of this ellipsoid.  If the position is\n   * at the center of the ellipsoid, this function returns undefined. */\n  scaleToGeodeticSurface(cartesian: number[], result?: number[]): number[] {\n    return scaleToGeodeticSurface(cartesian, this, result);\n  }\n\n  /** Scales the provided Cartesian position along the geocentric surface normal\n   * so that it is on the surface of this ellipsoid. */\n  scaleToGeocentricSurface(cartesian: number[], result: number[] = [0, 0, 0]): number[] {\n    scratchPosition.from(cartesian);\n\n    const positionX = scratchPosition.x;\n    const positionY = scratchPosition.y;\n    const positionZ = scratchPosition.z;\n    const oneOverRadiiSquared = this.oneOverRadiiSquared;\n\n    const beta =\n      1.0 /\n      Math.sqrt(\n        positionX * positionX * oneOverRadiiSquared.x +\n          positionY * positionY * oneOverRadiiSquared.y +\n          positionZ * positionZ * oneOverRadiiSquared.z\n      );\n\n    return scratchPosition.multiplyScalar(beta).to(result);\n  }\n\n  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#oneOverRadii` */\n  transformPositionToScaledSpace(position: number[], result: number[] = [0, 0, 0]): number[] {\n    return scratchPosition.from(position).scale(this.oneOverRadii).to(result);\n  }\n\n  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#radii`. */\n  transformPositionFromScaledSpace(position: number[], result: number[] = [0, 0, 0]): number[] {\n    return scratchPosition.from(position).scale(this.radii).to(result);\n  }\n\n  /** Computes a point which is the intersection of the surface normal with the z-axis. */\n  getSurfaceNormalIntersectionWithZAxis(\n    position: number[],\n    buffer: number = 0,\n    result: number[] = [0, 0, 0]\n  ): number[] {\n    // Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\n    assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n    assert(this.radii.z > 0);\n\n    scratchPosition.from(position);\n    const z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n\n    if (Math.abs(z) >= this.radii.z - buffer) {\n      return undefined;\n    }\n\n    return scratchPosition.set(0.0, 0.0, z).to(result);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}