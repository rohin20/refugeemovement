{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nexport default function fetchProgress(_x, _x2) {\n  return _fetchProgress.apply(this, arguments);\n}\nfunction _fetchProgress() {\n  _fetchProgress = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(response, onProgress) {\n    var onDone,\n      onError,\n      body,\n      contentLength,\n      totalBytes,\n      progressStream,\n      _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            onDone = _args.length > 2 && _args[2] !== undefined ? _args[2] : function () {};\n            onError = _args.length > 3 && _args[3] !== undefined ? _args[3] : function () {};\n            _context.next = 4;\n            return response;\n          case 4:\n            response = _context.sent;\n            if (response.ok) {\n              _context.next = 7;\n              break;\n            }\n            return _context.abrupt(\"return\", response);\n          case 7:\n            body = response.body;\n            if (body) {\n              _context.next = 10;\n              break;\n            }\n            return _context.abrupt(\"return\", response);\n          case 10:\n            contentLength = response.headers.get('content-length');\n            totalBytes = contentLength && parseInt(contentLength, 10);\n            if (contentLength > 0) {\n              _context.next = 14;\n              break;\n            }\n            return _context.abrupt(\"return\", response);\n          case 14:\n            if (!(typeof ReadableStream === 'undefined' || !body.getReader)) {\n              _context.next = 16;\n              break;\n            }\n            return _context.abrupt(\"return\", response);\n          case 16:\n            progressStream = new ReadableStream({\n              start: function start(controller) {\n                var reader = body.getReader();\n                read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n              }\n            });\n            return _context.abrupt(\"return\", new Response(progressStream));\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _fetchProgress.apply(this, arguments);\n}\nfunction read(_x3, _x4, _x5, _x6, _x7, _x8, _x9) {\n  return _read.apply(this, arguments);\n}\nfunction _read() {\n  _read = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n    var _yield$reader$read, done, value, percent;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return reader.read();\n          case 3:\n            _yield$reader$read = _context2.sent;\n            done = _yield$reader$read.done;\n            value = _yield$reader$read.value;\n            if (!done) {\n              _context2.next = 10;\n              break;\n            }\n            onDone();\n            controller.close();\n            return _context2.abrupt(\"return\");\n          case 10:\n            loadedBytes += value.byteLength;\n            percent = Math.round(loadedBytes / totalBytes * 100);\n            onProgress(percent, {\n              loadedBytes: loadedBytes,\n              totalBytes: totalBytes\n            });\n            controller.enqueue(value);\n            _context2.next = 16;\n            return read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n          case 16:\n            _context2.next = 22;\n            break;\n          case 18:\n            _context2.prev = 18;\n            _context2.t0 = _context2[\"catch\"](0);\n            controller.error(_context2.t0);\n            onError(_context2.t0);\n          case 22:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 18]]);\n  }));\n  return _read.apply(this, arguments);\n}","map":{"version":3,"names":["fetchProgress","_x","_x2","_fetchProgress","apply","arguments","_callee","response","onProgress","onDone","onError","body","contentLength","totalBytes","progressStream","_args","_regeneratorRuntime","wrap","_callee$","_context","prev","next","length","undefined","sent","ok","abrupt","headers","get","parseInt","ReadableStream","getReader","start","controller","reader","read","Response","stop","_callee2","loadedBytes","_yield$reader$read","done","value","percent","_callee2$","_context2","close","byteLength","Math","round","enqueue","t0","error"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/kepler.gl/node_modules/@loaders.gl/core/src/lib/progress/fetch-progress.js"],"sourcesContent":["// Forked from github AnthumChris/fetch-progress-indicators under MIT license\n/* global Response, ReadableStream */\n\n// Intercepts the Response stream and creates a new Response\nexport default async function fetchProgress(\n  response,\n  onProgress,\n  onDone = () => {},\n  onError = () => {}\n) {\n  response = await response;\n  if (!response.ok) {\n    // ERROR checking needs to be done separately\n    return response;\n  }\n  const body = response.body;\n  if (!body) {\n    // 'ReadableStream not yet supported in this browser.\n    return response;\n  }\n  const contentLength = response.headers.get('content-length');\n  const totalBytes = contentLength && parseInt(contentLength, 10);\n  if (!(contentLength > 0)) {\n    return response;\n  }\n  // Currently override only implemented in browser\n  if (typeof ReadableStream === 'undefined' || !body.getReader) {\n    return response;\n  }\n\n  // Create a new stream that invisbly wraps original stream\n  const progressStream = new ReadableStream({\n    start(controller) {\n      const reader = body.getReader();\n      read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n    }\n  });\n\n  return new Response(progressStream);\n}\n\n// Forward to original streams controller\n// TODO - this causes a crazy deep \"async stack\"... rewrite as async iterator?\n// eslint-disable-next-line max-params\nasync function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n  try {\n    const {done, value} = await reader.read();\n    if (done) {\n      onDone();\n      controller.close();\n      return;\n    }\n    loadedBytes += value.byteLength;\n    const percent = Math.round((loadedBytes / totalBytes) * 100);\n    onProgress(percent, {loadedBytes, totalBytes});\n    controller.enqueue(value);\n    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n  } catch (error) {\n    controller.error(error);\n    onError(error);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}