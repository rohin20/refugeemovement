{"ast":null,"code":"import _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport log from '../../utils/log';\nvar NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedObjectIndex: -1\n};\nexport function getClosestObject(_ref) {\n  var pickedColors = _ref.pickedColors,\n    decodePickingColor = _ref.decodePickingColor,\n    deviceX = _ref.deviceX,\n    deviceY = _ref.deviceY,\n    deviceRadius = _ref.deviceRadius,\n    deviceRect = _ref.deviceRect;\n  var x = deviceRect.x,\n    y = deviceRect.y,\n    width = deviceRect.width,\n    height = deviceRect.height;\n  var minSquareDistanceToCenter = deviceRadius * deviceRadius;\n  var closestPixelIndex = -1;\n  var i = 0;\n  for (var row = 0; row < height; row++) {\n    var dy = row + y - deviceY;\n    var dy2 = dy * dy;\n    if (dy2 > minSquareDistanceToCenter) {\n      i += 4 * width;\n    } else {\n      for (var col = 0; col < width; col++) {\n        var pickedLayerIndex = pickedColors[i + 3] - 1;\n        if (pickedLayerIndex >= 0) {\n          var dx = col + x - deviceX;\n          var d2 = dx * dx + dy2;\n          if (d2 <= minSquareDistanceToCenter) {\n            minSquareDistanceToCenter = d2;\n            closestPixelIndex = i;\n          }\n        }\n        i += 4;\n      }\n    }\n  }\n  if (closestPixelIndex >= 0) {\n    var pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n    var pickedObject = decodePickingColor(pickedColor);\n    if (pickedObject) {\n      var _dy = Math.floor(closestPixelIndex / 4 / width);\n      var _dx = closestPixelIndex / 4 - _dy * width;\n      return _objectSpread(_objectSpread({}, pickedObject), {}, {\n        pickedColor: pickedColor,\n        pickedX: x + _dx,\n        pickedY: y + _dy\n      });\n    }\n    log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n  }\n  return NO_PICKED_OBJECT;\n}\nexport function getUniqueObjects(_ref2) {\n  var pickedColors = _ref2.pickedColors,\n    decodePickingColor = _ref2.decodePickingColor;\n  var uniqueColors = new Map();\n  if (pickedColors) {\n    for (var i = 0; i < pickedColors.length; i += 4) {\n      var pickedLayerIndex = pickedColors[i + 3] - 1;\n      if (pickedLayerIndex >= 0) {\n        var pickedColor = pickedColors.slice(i, i + 4);\n        var colorKey = pickedColor.join(',');\n        if (!uniqueColors.has(colorKey)) {\n          var pickedObject = decodePickingColor(pickedColor);\n          if (pickedObject) {\n            uniqueColors.set(colorKey, _objectSpread(_objectSpread({}, pickedObject), {}, {\n              color: pickedColor\n            }));\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n          }\n        }\n      }\n    }\n  }\n  return Array.from(uniqueColors.values());\n}","map":{"version":3,"names":["log","NO_PICKED_OBJECT","pickedColor","pickedObjectIndex","getClosestObject","_ref","pickedColors","decodePickingColor","deviceX","deviceY","deviceRadius","deviceRect","x","y","width","height","minSquareDistanceToCenter","closestPixelIndex","i","row","dy","dy2","col","pickedLayerIndex","dx","d2","slice","pickedObject","Math","floor","_objectSpread","pickedX","pickedY","error","getUniqueObjects","_ref2","uniqueColors","Map","length","colorKey","join","has","set","color","Array","from","values"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/core/src/lib/picking/query-object.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport log from '../../utils/log';\nimport type Layer from '../layer';\nimport type Viewport from '../../viewports/viewport';\nimport type {PickingColorDecoder} from '../../passes/pick-layers-pass';\n\nexport type PickedPixel = {\n  pickedColor: Uint8Array | null;\n  pickedLayer?: Layer;\n  pickedViewports?: Viewport[];\n  pickedX?: number;\n  pickedY?: number;\n  pickedObjectIndex: number;\n};\n\nconst NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedObjectIndex: -1\n};\n\n/* eslint-disable max-depth, max-statements */\n/**\n * Pick at a specified pixel with a tolerance radius\n * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getClosestObject({\n  pickedColors,\n  decodePickingColor,\n  deviceX,\n  deviceY,\n  deviceRadius,\n  deviceRect\n}: {\n  pickedColors: Uint8Array;\n  decodePickingColor: PickingColorDecoder;\n  deviceX: number;\n  deviceY: number;\n  deviceRadius: number;\n  deviceRect: {x: number; y: number; width: number; height: number};\n}): PickedPixel {\n  // Traverse all pixels in picking results and find the one closest to the supplied\n  // [deviceX, deviceY]\n  const {x, y, width, height} = deviceRect;\n  let minSquareDistanceToCenter = deviceRadius * deviceRadius;\n  let closestPixelIndex = -1;\n  let i = 0;\n\n  for (let row = 0; row < height; row++) {\n    const dy = row + y - deviceY;\n    const dy2 = dy * dy;\n\n    if (dy2 > minSquareDistanceToCenter) {\n      // skip this row\n      i += 4 * width;\n    } else {\n      for (let col = 0; col < width; col++) {\n        // Decode picked layer from color\n        const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n        if (pickedLayerIndex >= 0) {\n          const dx = col + x - deviceX;\n          const d2 = dx * dx + dy2;\n\n          if (d2 <= minSquareDistanceToCenter) {\n            minSquareDistanceToCenter = d2;\n            closestPixelIndex = i;\n          }\n        }\n        i += 4;\n      }\n    }\n  }\n\n  if (closestPixelIndex >= 0) {\n    // Decode picked object index from color\n    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n    const pickedObject = decodePickingColor(pickedColor);\n    if (pickedObject) {\n      const dy = Math.floor(closestPixelIndex / 4 / width);\n      const dx = closestPixelIndex / 4 - dy * width;\n      return {\n        ...pickedObject,\n        pickedColor,\n        pickedX: x + dx,\n        pickedY: y + dy\n      };\n    }\n    log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n  }\n  return NO_PICKED_OBJECT;\n}\n\n/**\n * Examines a picking buffer for unique colors\n * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getUniqueObjects({\n  pickedColors,\n  decodePickingColor\n}: {\n  pickedColors: Uint8Array;\n  decodePickingColor: PickingColorDecoder;\n}): PickedPixel[] {\n  const uniqueColors = new Map();\n\n  // Traverse all pixels in picking results and get unique colors\n  if (pickedColors) {\n    for (let i = 0; i < pickedColors.length; i += 4) {\n      // Decode picked layer from color\n      const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n      if (pickedLayerIndex >= 0) {\n        const pickedColor = pickedColors.slice(i, i + 4);\n        const colorKey = pickedColor.join(',');\n        // eslint-disable-next-line\n        if (!uniqueColors.has(colorKey)) {\n          const pickedObject = decodePickingColor(pickedColor);\n          // eslint-disable-next-line\n          if (pickedObject) {\n            uniqueColors.set(colorKey, {\n              ...pickedObject,\n              color: pickedColor\n            });\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n          }\n        }\n      }\n    }\n  }\n\n  return Array.from(uniqueColors.values());\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}