{"ast":null,"code":"import { equals } from '@math.gl/core';\nexport var WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n};\nexport function modifyPolygonWindingDirection(points, direction) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var windingDirection = getPolygonWindingDirection(points, options);\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n  return false;\n}\nexport function getPolygonWindingDirection(points) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Math.sign(getPolygonSignedArea(points, options));\n}\nexport function getPolygonSignedArea(points) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$start = options.start,\n    start = _options$start === void 0 ? 0 : _options$start,\n    _options$end = options.end,\n    end = _options$end === void 0 ? points.length : _options$end;\n  var dim = options.size || 2;\n  var area = 0;\n  for (var i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n  return area / 2;\n}\nexport function forEachSegmentInPolygon(points, visitor) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$start2 = options.start,\n    start = _options$start2 === void 0 ? 0 : _options$start2,\n    _options$end2 = options.end,\n    end = _options$end2 === void 0 ? points.length : _options$end2,\n    _options$size = options.size,\n    size = _options$size === void 0 ? 2 : _options$size,\n    isClosed = options.isClosed;\n  var numPoints = (end - start) / size;\n  for (var i = 0; i < numPoints - 1; ++i) {\n    visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);\n  }\n  var endPointIndex = start + (numPoints - 1) * size;\n  var isClosedEx = isClosed || equals(points[start], points[endPointIndex]) && equals(points[start + 1], points[endPointIndex + 1]);\n  if (!isClosedEx) {\n    visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);\n  }\n}\nfunction reversePolygon(points, options) {\n  var _options$start3 = options.start,\n    start = _options$start3 === void 0 ? 0 : _options$start3,\n    _options$end3 = options.end,\n    end = _options$end3 === void 0 ? points.length : _options$end3,\n    _options$size2 = options.size,\n    size = _options$size2 === void 0 ? 2 : _options$size2;\n  var numPoints = (end - start) / size;\n  var numSwaps = Math.floor(numPoints / 2);\n  for (var i = 0; i < numSwaps; ++i) {\n    var b1 = start + i * size;\n    var b2 = start + (numPoints - 1 - i) * size;\n    for (var j = 0; j < size; ++j) {\n      var tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\nexport function modifyPolygonWindingDirectionPoints(points, direction) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var currentDirection = getPolygonWindingDirectionPoints(points, options);\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n  return false;\n}\nexport function getPolygonWindingDirectionPoints(points) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\nexport function getPolygonSignedAreaPoints(points) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$start4 = options.start,\n    start = _options$start4 === void 0 ? 0 : _options$start4,\n    _options$end4 = options.end,\n    end = _options$end4 === void 0 ? points.length : _options$end4;\n  var area = 0;\n  for (var i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n  return area / 2;\n}\nexport function forEachSegmentInPolygonPoints(points, visitor) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$start5 = options.start,\n    start = _options$start5 === void 0 ? 0 : _options$start5,\n    _options$end5 = options.end,\n    end = _options$end5 === void 0 ? points.length : _options$end5,\n    isClosed = options.isClosed;\n  for (var i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n  var isClosedEx = isClosed || equals(points[end - 1], points[0]);\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}","map":{"version":3,"names":["equals","WINDING","CLOCKWISE","COUNTER_CLOCKWISE","modifyPolygonWindingDirection","points","direction","options","arguments","length","undefined","windingDirection","getPolygonWindingDirection","reversePolygon","Math","sign","getPolygonSignedArea","_options$start","start","_options$end","end","dim","size","area","i","j","forEachSegmentInPolygon","visitor","_options$start2","_options$end2","_options$size","isClosed","numPoints","endPointIndex","isClosedEx","_options$start3","_options$end3","_options$size2","numSwaps","floor","b1","b2","tmp","modifyPolygonWindingDirectionPoints","currentDirection","getPolygonWindingDirectionPoints","reverse","getPolygonSignedAreaPoints","_options$start4","_options$end4","forEachSegmentInPolygonPoints","_options$start5","_options$end5"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@math.gl/polygon/src/polygon-utils.ts"],"sourcesContent":["/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\n\nimport {equals} from '@math.gl/core';\nimport type {NumericArray} from '@math.gl/core';\n\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n} as const;\n\n/** Polygon representation where each point is represented as a separate array of positions. */\ntype PointsArray = NumericArray[];\n\n/** Segment visitor callback type for polygons defined with flat arrays, */\ntype SegmentVisitorFlat = (\n  p1x: number,\n  p1y: number,\n  p2x: number,\n  p2y: number,\n  i1: number,\n  i2: number\n) => void;\n\n/** Segment visitor callback type for polygons defined with array of points. */\nexport type SegmentVisitorPoints = (\n  p1: NumericArray,\n  p2: NumericArray,\n  i1: number,\n  i2: number\n) => void;\n\n/** Parameters of a polygon. */\ntype PolygonParams = {\n  start?: number; // Start index of the polygon in the array of positions. Defaults to 0.\n  end?: number; // End index of the polygon in the array of positions. Defaults to number of positions.\n  size?: number; // Size of a point, 2 (XZ) or 3 (XYZ). Defaults to 2. Affects only polygons stored in flat arrays.\n  isClosed?: boolean; // Indicates that the first point of the polygon is equal to the last point, and additional checks should be ommited.\n};\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points An array that represents points of the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirection(\n  points: NumericArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const windingDirection = getPolygonWindingDirection(points, options);\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirection(\n  points: NumericArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\n\n/**\n * Returns signed area of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n * https://en.wikipedia.org/wiki/Shoelace_formula\n */\nexport function getPolygonSignedArea(points: NumericArray, options: PolygonParams = {}): number {\n  const {start = 0, end = points.length} = options;\n  const dim = options.size || 2;\n  let area = 0;\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls the visitor callback for each segment in the polygon.\n * @param points An array that represents points of the polygon\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygon(\n  points: NumericArray,\n  visitor: SegmentVisitorFlat,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, size = 2, isClosed} = options;\n\n  const numPoints = (end - start) / size;\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(\n      points[start + i * size],\n      points[start + i * size + 1],\n      points[start + (i + 1) * size],\n      points[start + (i + 1) * size + 1],\n      i,\n      i + 1\n    );\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx =\n    isClosed ||\n    (equals(points[start], points[endPointIndex]) &&\n      equals(points[start + 1], points[endPointIndex + 1]));\n\n  if (!isClosedEx) {\n    visitor(\n      points[endPointIndex],\n      points[endPointIndex + 1],\n      points[start],\n      points[start + 1],\n      numPoints - 1,\n      0\n    );\n  }\n}\n\nfunction reversePolygon(\n  points: NumericArray,\n  options: {start?: number; end?: number; size?: number}\n): void {\n  const {start = 0, end = points.length, size = 2} = options;\n\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points Array of points that represent the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirectionPoints(\n  points: PointsArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirectionPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\n\n/**\n * Returns signed area of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n */\nexport function getPolygonSignedAreaPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  // https://en.wikipedia.org/wiki/Shoelace_formula\n  const {start = 0, end = points.length} = options;\n  let area = 0;\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls visitor callback for each segment in the polygon.\n * @param points Array of points that represent the polygon.\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygonPoints(\n  points: PointsArray,\n  visitor: SegmentVisitorPoints,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, isClosed} = options;\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}