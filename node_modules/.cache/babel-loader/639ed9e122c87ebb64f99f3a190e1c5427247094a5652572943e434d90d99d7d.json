{"ast":null,"code":"import _defineProperty from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Buffer, copyToTexture, cloneTextureFrom } from '@luma.gl/webgl';\nimport { Transform } from '@luma.gl/engine';\nimport { HISTOPYRAMID_BUILD_VS_UTILS, HISTOPYRAMID_TRAVERSAL_UTILS, HISTOPYRAMID_BASE_BUILD_VS, HISTOPYRAMID_BUILD_VS, HISTOPYRAMID_TRAVERSAL_VS } from './histopyramid-shaders';\nfunction nextPowerOfTwo(x) {\n  var p = Math.ceil(Math.log2(x));\n  return Math.pow(2, p);\n}\nvar channelToIndexMap = {\n  r: 0,\n  x: 0,\n  g: 1,\n  y: 1,\n  b: 2,\n  z: 2,\n  a: 3,\n  w: 3\n};\nexport function buildHistopyramidBaseLevel(gl, opts) {\n  var _parameters;\n  var texture = opts.texture,\n    _opts$channel = opts.channel,\n    channel = _opts$channel === void 0 ? 'r' : _opts$channel,\n    _opts$_readData = opts._readData,\n    _readData = _opts$_readData === void 0 ? false : _opts$_readData;\n  var width = texture.width,\n    height = texture.height;\n  width = nextPowerOfTwo(width);\n  height = nextPowerOfTwo(height);\n  var size = (width > height ? width : height) / 2;\n  var baseTexture = cloneTextureFrom(texture, {\n    width: size,\n    height: size\n  });\n  var transform = new Transform(gl, {\n    _sourceTextures: {\n      inTexture: texture\n    },\n    _targetTexture: baseTexture,\n    _targetTextureVarying: 'outTexture',\n    vs: \"\".concat(HISTOPYRAMID_BUILD_VS_UTILS).concat(HISTOPYRAMID_BASE_BUILD_VS),\n    elementCount: baseTexture.width * baseTexture.height\n  });\n  transform.run({\n    uniforms: {\n      channel: channelToIndexMap[channel] || 0,\n      padingPixelValue: [0, 0, 0, 0]\n    }\n  });\n  var textureData;\n  if (_readData || size === 1) {\n    textureData = transform.getData({\n      packed: true\n    });\n  }\n  var flatPyramidSize = size * 2;\n  var flatPyramidTexture = cloneTextureFrom(texture, {\n    width: flatPyramidSize,\n    height: flatPyramidSize,\n    parameters: (_parameters = {}, _defineProperty(_parameters, 10240, 9728), _defineProperty(_parameters, 10241, 9728), _parameters)\n  });\n  var framebuffer = transform.getFramebuffer();\n  copyToTexture(framebuffer, flatPyramidTexture, {\n    targetX: 0,\n    width: size,\n    height: size\n  });\n  return {\n    textureData: textureData,\n    baseTexture: baseTexture,\n    flatPyramidTexture: flatPyramidTexture\n  };\n}\nexport function getHistoPyramid(gl, opts) {\n  var _buildHistopyramidBas = buildHistopyramidBaseLevel(gl, opts),\n    textureData = _buildHistopyramidBas.textureData,\n    baseTexture = _buildHistopyramidBas.baseTexture,\n    flatPyramidTexture = _buildHistopyramidBas.flatPyramidTexture;\n  var width = baseTexture.width;\n  var levelCount = Math.log2(width) + 1;\n  var pyramidTextures = [baseTexture];\n  var topLevelData = textureData;\n  if (levelCount > 1) {\n    for (var i = 1; i < levelCount; i++) {\n      var size = width / Math.pow(2, i);\n      pyramidTextures.push(cloneTextureFrom(baseTexture, {\n        width: size,\n        height: size\n      }));\n    }\n    var transform = new Transform(gl, {\n      _sourceTextures: {\n        inTexture: pyramidTextures[0]\n      },\n      _targetTexture: pyramidTextures[1],\n      _targetTextureVarying: 'outTexture',\n      vs: \"\".concat(HISTOPYRAMID_BUILD_VS_UTILS).concat(HISTOPYRAMID_BUILD_VS),\n      elementCount: pyramidTextures[1].width * pyramidTextures[1].height\n    });\n    var flatOffset = width;\n    for (var _i = 1; _i < levelCount; _i++) {\n      var outSize = [pyramidTextures[_i].width, pyramidTextures[_i].height];\n      transform.update({\n        _sourceTextures: {\n          inTexture: pyramidTextures[_i - 1]\n        },\n        _targetTexture: pyramidTextures[_i],\n        elementCount: pyramidTextures[_i].width * pyramidTextures[_i].height\n      });\n      transform.run();\n      var framebuffer = transform.getFramebuffer();\n      copyToTexture(framebuffer, flatPyramidTexture, {\n        targetX: flatOffset,\n        width: outSize[0],\n        height: outSize[1]\n      });\n      flatOffset += outSize[0];\n    }\n    topLevelData = transform.getData();\n  }\n  return {\n    pyramidTextures: pyramidTextures,\n    flatPyramidTexture: flatPyramidTexture,\n    levelCount: levelCount,\n    topLevelData: topLevelData\n  };\n}\nexport function histoPyramidGenerateIndices(gl, opts) {\n  var _getHistoPyramid = getHistoPyramid(gl, opts),\n    flatPyramidTexture = _getHistoPyramid.flatPyramidTexture,\n    levelCount = _getHistoPyramid.levelCount,\n    topLevelData = _getHistoPyramid.topLevelData;\n  var keyIndexCount = topLevelData[0] + topLevelData[1] + topLevelData[2] + topLevelData[3];\n  var keyIndex = new Buffer(gl, new Float32Array(keyIndexCount).map(function (_, index) {\n    return index;\n  }));\n  var locationAndIndex = new Buffer(gl, keyIndexCount * 4 * 4);\n  var transform = new Transform(gl, {\n    sourceBuffers: {\n      keyIndex: keyIndex\n    },\n    _sourceTextures: {\n      flatPyramidTexture: flatPyramidTexture\n    },\n    feedbackBuffers: {\n      locationAndIndex: locationAndIndex\n    },\n    varyings: ['locationAndIndex'],\n    vs: \"\".concat(HISTOPYRAMID_TRAVERSAL_UTILS).concat(HISTOPYRAMID_TRAVERSAL_VS),\n    elementCount: keyIndexCount\n  });\n  transform.run({\n    uniforms: {\n      numLevels: levelCount\n    }\n  });\n  return {\n    locationAndIndexBuffer: locationAndIndex\n  };\n}","map":{"version":3,"names":["Buffer","copyToTexture","cloneTextureFrom","Transform","HISTOPYRAMID_BUILD_VS_UTILS","HISTOPYRAMID_TRAVERSAL_UTILS","HISTOPYRAMID_BASE_BUILD_VS","HISTOPYRAMID_BUILD_VS","HISTOPYRAMID_TRAVERSAL_VS","nextPowerOfTwo","x","p","Math","ceil","log2","pow","channelToIndexMap","r","g","y","b","z","a","w","buildHistopyramidBaseLevel","gl","opts","_parameters","texture","_opts$channel","channel","_opts$_readData","_readData","width","height","size","baseTexture","transform","_sourceTextures","inTexture","_targetTexture","_targetTextureVarying","vs","concat","elementCount","run","uniforms","padingPixelValue","textureData","getData","packed","flatPyramidSize","flatPyramidTexture","parameters","_defineProperty","framebuffer","getFramebuffer","targetX","getHistoPyramid","_buildHistopyramidBas","levelCount","pyramidTextures","topLevelData","i","push","flatOffset","outSize","update","histoPyramidGenerateIndices","_getHistoPyramid","keyIndexCount","keyIndex","Float32Array","map","_","index","locationAndIndex","sourceBuffers","feedbackBuffers","varyings","numLevels","locationAndIndexBuffer"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@luma.gl/experimental/src/gpgpu/histopyramid/histopyramid.js"],"sourcesContent":["import {Buffer, copyToTexture, cloneTextureFrom} from '@luma.gl/webgl';\nimport {Transform} from '@luma.gl/engine';\nimport GL from '@luma.gl/constants';\nimport {\n  HISTOPYRAMID_BUILD_VS_UTILS,\n  HISTOPYRAMID_TRAVERSAL_UTILS,\n  HISTOPYRAMID_BASE_BUILD_VS,\n  HISTOPYRAMID_BUILD_VS,\n  HISTOPYRAMID_TRAVERSAL_VS\n} from './histopyramid-shaders';\n\n// Following methods implement Histopyramid operations as described in 'High‐speed marching cubes using histopyramids' by Dyken C, Ziegler G, Theobalt C and Seidel H\n// Link to the paper: http://olmozavala.com/Custom/OpenGL/Tutorials/OpenGL4_Examples/MarchingCubes_Dyken/Dyken_et_al-2008-Computer_Graphics_Forum.pdf\n\n// TODO: enable to assert on texture dimension\n// function isPowerOfTwo(x) {\n//     return ((x !== 0) && !(x & (x - 1)));\n// }\n\nfunction nextPowerOfTwo(x) {\n  const p = Math.ceil(Math.log2(x));\n  return Math.pow(2, p);\n}\n\nconst channelToIndexMap = {\n  r: 0,\n  x: 0,\n  g: 1,\n  y: 1,\n  b: 2,\n  z: 2,\n  a: 3,\n  w: 3\n};\n\n// returns a base level texture that packs given weight into a texture\n// each 2X2 region is mapped into RGBA channels of single pixel\n// returned texture is a squred power of two sized texture\n// R -> lower left, G -> lower right B -> upper left A -> upper right\nexport function buildHistopyramidBaseLevel(gl, opts) {\n  const {texture, channel = 'r', _readData = false} = opts;\n  let {width, height} = texture;\n  width = nextPowerOfTwo(width);\n  height = nextPowerOfTwo(height);\n  // Use sqaured next power of two size, then use half of it since we are packing 2X2 group into a single RGBA pixel\n  const size = (width > height ? width : height) / 2;\n  const baseTexture = cloneTextureFrom(texture, {\n    width: size,\n    height: size\n  });\n\n  // build individual pyramid textures\n  const transform = new Transform(gl, {\n    _sourceTextures: {\n      inTexture: texture\n    },\n    _targetTexture: baseTexture,\n    _targetTextureVarying: 'outTexture',\n    vs: `${HISTOPYRAMID_BUILD_VS_UTILS}${HISTOPYRAMID_BASE_BUILD_VS}`,\n    elementCount: baseTexture.width * baseTexture.height\n  });\n  transform.run({\n    uniforms: {\n      channel: channelToIndexMap[channel] || 0,\n      padingPixelValue: [0, 0, 0, 0]\n    }\n  });\n  // _readData is debug only option\n  let textureData;\n  // when base textuer size is 1X1, there are no more level to be generated\n  // so read the texture data to be provided as base level data.\n  if (_readData || size === 1) {\n    textureData = transform.getData({packed: true});\n  }\n  const flatPyramidSize = size * 2;\n  const flatPyramidTexture = cloneTextureFrom(texture, {\n    width: flatPyramidSize,\n    height: flatPyramidSize,\n    parameters: {\n      [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n      [GL.TEXTURE_MIN_FILTER]: GL.NEAREST\n    }\n  });\n  const framebuffer = transform.getFramebuffer();\n  copyToTexture(framebuffer, flatPyramidTexture, {\n    targetX: 0,\n    width: size,\n    height: size\n  });\n\n  return {textureData, baseTexture, flatPyramidTexture};\n}\n\n// builds histopyramid for a given texture and returns individual levels and flatended pyramid texture\n// Returns object\n// * pyramidTextures: Array with all individual mip levels\n// * flatPyramidTexture: Texture with all mip levels laid out horizontally\nexport function getHistoPyramid(gl, opts) {\n  const {textureData, baseTexture, flatPyramidTexture} = buildHistopyramidBaseLevel(gl, opts);\n  const {width} = baseTexture;\n  // assert(width === height && isPowerOfTwo(width));\n  const levelCount = Math.log2(width) + 1;\n  const pyramidTextures = [baseTexture];\n\n  let topLevelData = textureData;\n  if (levelCount > 1) {\n    // build empty textures for rest of the pyramid\n    for (let i = 1; i < levelCount; i++) {\n      const size = width / Math.pow(2, i);\n      pyramidTextures.push(\n        cloneTextureFrom(baseTexture, {\n          width: size,\n          height: size\n        })\n      );\n    }\n\n    // build individual pyramid textures\n    const transform = new Transform(gl, {\n      _sourceTextures: {\n        inTexture: pyramidTextures[0]\n      },\n      _targetTexture: pyramidTextures[1],\n      _targetTextureVarying: 'outTexture',\n      vs: `${HISTOPYRAMID_BUILD_VS_UTILS}${HISTOPYRAMID_BUILD_VS}`,\n      elementCount: pyramidTextures[1].width * pyramidTextures[1].height\n    });\n\n    let flatOffset = width;\n    for (let i = 1; i < levelCount; i++) {\n      const outSize = [pyramidTextures[i].width, pyramidTextures[i].height];\n      transform.update({\n        _sourceTextures: {inTexture: pyramidTextures[i - 1]},\n        _targetTexture: pyramidTextures[i],\n        elementCount: pyramidTextures[i].width * pyramidTextures[i].height\n      });\n      transform.run();\n\n      // copy the result to the flaten pyramid texture\n      const framebuffer = transform.getFramebuffer();\n      copyToTexture(framebuffer, flatPyramidTexture, {\n        targetX: flatOffset,\n        width: outSize[0],\n        height: outSize[1]\n      });\n\n      flatOffset += outSize[0];\n    }\n    topLevelData = transform.getData();\n  }\n\n  return {pyramidTextures, flatPyramidTexture, levelCount, topLevelData};\n}\n\n// builds and traverses a histopyramid for a given texture and returns pixel locations and local-key index for each non zero weight in input texture\n// Returns object\n// *locationAndIndexBuffer : Buffer contains one vec4 for each non zero weight. XY represent loation, Z represents local-key index and W represent key-index\nexport function histoPyramidGenerateIndices(gl, opts) {\n  const {flatPyramidTexture, levelCount, topLevelData} = getHistoPyramid(gl, opts);\n\n  const keyIndexCount = topLevelData[0] + topLevelData[1] + topLevelData[2] + topLevelData[3];\n  const keyIndex = new Buffer(gl, new Float32Array(keyIndexCount).map((_, index) => index));\n  const locationAndIndex = new Buffer(gl, keyIndexCount * 4 * 4); // 4 floats for each key index\n\n  const transform = new Transform(gl, {\n    sourceBuffers: {\n      keyIndex\n    },\n    _sourceTextures: {\n      flatPyramidTexture\n    },\n    feedbackBuffers: {\n      locationAndIndex\n    },\n    varyings: ['locationAndIndex'],\n    vs: `${HISTOPYRAMID_TRAVERSAL_UTILS}${HISTOPYRAMID_TRAVERSAL_VS}`,\n    elementCount: keyIndexCount\n  });\n  transform.run({\n    uniforms: {\n      numLevels: levelCount\n    }\n  });\n\n  return {locationAndIndexBuffer: locationAndIndex};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}