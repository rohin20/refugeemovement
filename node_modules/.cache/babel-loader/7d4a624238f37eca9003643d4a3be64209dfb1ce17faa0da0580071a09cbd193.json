{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.clusterAggregation = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _layers = require(\"@deck.gl/layers\");\nvar _aggregationLayers = require(\"@deck.gl/aggregation-layers\");\nvar _geoViewport = _interopRequireDefault(require(\"@mapbox/geo-viewport\"));\nvar _cpuAggregator = _interopRequireWildcard(require(\"../layer-utils/cpu-aggregator\"));\nvar _viewportMercatorProject = require(\"viewport-mercator-project\");\nvar _d3Array = require(\"d3-array\");\nvar _constants = require(\"@kepler.gl/constants\");\nvar _clusterUtils = _interopRequireWildcard(require(\"../layer-utils/cluster-utils\"));\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar defaultRadius = _constants.LAYER_VIS_CONFIGS.clusterRadius.defaultValue;\nvar defaultRadiusRange = _constants.LAYER_VIS_CONFIGS.clusterRadiusRange.defaultValue;\nvar defaultGetColorValue = function defaultGetColorValue(points) {\n  return points.length;\n};\nvar defaultGetRadiusValue = function defaultGetRadiusValue(cell) {\n  return cell.filteredPoints ? cell.filteredPoints.length : cell.points.length;\n};\nfunction processGeoJSON(step, props, aggregation, _ref) {\n  var viewport = _ref.viewport;\n  var data = props.data,\n    getPosition = props.getPosition,\n    filterData = props.filterData;\n  var geoJSON = (0, _clusterUtils.getGeoJSON)(data, getPosition, filterData);\n  var clusterBuilder = new _clusterUtils[\"default\"]();\n  this.setState({\n    geoJSON: geoJSON,\n    clusterBuilder: clusterBuilder\n  });\n}\nfunction getClusters(step, props, aggregation, _ref2) {\n  var viewport = _ref2.viewport;\n  var _this$state = this.state,\n    geoJSON = _this$state.geoJSON,\n    clusterBuilder = _this$state.clusterBuilder;\n  var clusterRadius = props.clusterRadius,\n    zoom = props.zoom,\n    width = props.width,\n    height = props.height;\n  var longitude = viewport.longitude,\n    latitude = viewport.latitude; // zoom needs to be an integer for the different map utils. Also helps with cache key.\n\n  var bbox = _geoViewport[\"default\"].bounds([longitude, latitude], zoom, [width, height]);\n  var clusters = clusterBuilder.clustersAtZoom({\n    bbox: bbox,\n    clusterRadius: clusterRadius,\n    geoJSON: geoJSON,\n    zoom: zoom\n  });\n  this.setState({\n    layerData: {\n      data: clusters\n    }\n  });\n}\nfunction getSubLayerRadius(dimensionState, dimension, layerProps) {\n  return function (cell) {\n    var getRadiusValue = layerProps.getRadiusValue;\n    var scaleFunc = dimensionState.scaleFunc;\n    return scaleFunc(getRadiusValue(cell));\n  };\n}\nvar clusterAggregation = {\n  key: 'position',\n  updateSteps: [{\n    key: 'geojson',\n    triggers: {\n      position: {\n        prop: 'getPosition',\n        updateTrigger: 'getPosition'\n      },\n      filterData: {\n        prop: 'filterData',\n        updateTrigger: 'filterData'\n      }\n    },\n    updater: processGeoJSON\n  }, {\n    key: 'clustering',\n    triggers: {\n      clusterRadius: {\n        prop: 'clusterRadius'\n      },\n      zoom: {\n        prop: 'zoom'\n      },\n      width: {\n        prop: 'width'\n      },\n      height: {\n        prop: 'height'\n      }\n    },\n    updater: getClusters\n  }]\n};\nexports.clusterAggregation = clusterAggregation;\nfunction getRadiusValueDomain(step, props, dimensionUpdater) {\n  var key = dimensionUpdater.key;\n  var getRadiusValue = props.getRadiusValue;\n  var layerData = this.state.layerData;\n  var valueDomain = [0, (0, _d3Array.max)(layerData.data, getRadiusValue)];\n  this._setDimensionState(key, {\n    valueDomain: valueDomain\n  });\n}\nvar clusterLayerDimensions = [_cpuAggregator.defaultColorDimension, {\n  key: 'radius',\n  accessor: 'getRadius',\n  nullValue: 0,\n  updateSteps: [{\n    key: 'getDomain',\n    triggers: {\n      value: {\n        prop: 'getRadiusValue',\n        updateTrigger: 'getRadiusValue'\n      }\n    },\n    updater: getRadiusValueDomain\n  }, {\n    key: 'getScaleFunc',\n    triggers: {\n      domain: {\n        prop: 'radiusDomain'\n      },\n      range: {\n        prop: 'radiusRange'\n      },\n      scaleType: {\n        prop: 'radiusScaleType'\n      }\n    },\n    updater: _cpuAggregator.getDimensionScale\n  }],\n  getSubLayerAccessor: getSubLayerRadius,\n  getPickingInfo: function getPickingInfo(dimensionState, cell, layerProps) {\n    var radiusValue = layerProps.getRadiusValue(cell);\n    return {\n      radiusValue: radiusValue\n    };\n  }\n}];\nvar defaultProps = {\n  clusterRadius: defaultRadius,\n  colorDomain: null,\n  colorRange: _constants.DEFAULT_COLOR_RANGE,\n  colorScaleType: _constants.SCALE_TYPES.quantize,\n  radiusScaleType: _constants.SCALE_TYPES.sqrt,\n  radiusRange: defaultRadiusRange,\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  getColorValue: {\n    type: 'accessor',\n    value: defaultGetColorValue\n  },\n  getRadiusValue: {\n    type: 'accessor',\n    value: defaultGetRadiusValue\n  }\n};\nvar ClusterLayer = /*#__PURE__*/function (_AggregationLayer) {\n  (0, _inherits2[\"default\"])(ClusterLayer, _AggregationLayer);\n  var _super = _createSuper(ClusterLayer);\n  function ClusterLayer() {\n    (0, _classCallCheck2[\"default\"])(this, ClusterLayer);\n    return _super.apply(this, arguments);\n  }\n  (0, _createClass2[\"default\"])(ClusterLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      var cpuAggregator = new _cpuAggregator[\"default\"]({\n        aggregation: clusterAggregation,\n        dimensions: clusterLayerDimensions\n      });\n      this.state = {\n        cpuAggregator: cpuAggregator,\n        aggregatorState: cpuAggregator.state\n      };\n      var attributeManager = this.getAttributeManager();\n      attributeManager.add({\n        positions: {\n          size: 3,\n          accessor: 'getPosition'\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref3) {\n      var oldProps = _ref3.oldProps,\n        props = _ref3.props,\n        changeFlags = _ref3.changeFlags;\n      this.setState({\n        // make a copy of the internal state of cpuAggregator for testing\n        aggregatorState: this.state.cpuAggregator.updateState({\n          oldProps: oldProps,\n          props: props,\n          changeFlags: changeFlags\n        }, {\n          viewport: this.context.viewport,\n          attributes: this.getAttributes(),\n          numInstances: this.getNumInstances(props)\n        })\n      });\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref4) {\n      var info = _ref4.info;\n      return this.state.cpuAggregator.getPickingInfo({\n        info: info\n      }, this.props);\n    }\n  }, {\n    key: \"_getSublayerUpdateTriggers\",\n    value: function _getSublayerUpdateTriggers() {\n      return this.state.cpuAggregator.getUpdateTriggers(this.props);\n    }\n  }, {\n    key: \"_getSubLayerAccessors\",\n    value: function _getSubLayerAccessors() {\n      return {\n        getRadius: this.state.cpuAggregator.getAccessor('radius', this.props),\n        getFillColor: this.state.cpuAggregator.getAccessor('fillColor', this.props)\n      };\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      // for subclassing, override this method to return\n      // customized sub layer props\n      var _this$props = this.props,\n        id = _this$props.id,\n        radiusScale = _this$props.radiusScale;\n      var cpuAggregator = this.state.cpuAggregator; // base layer props\n\n      var _this$props2 = this.props,\n        visible = _this$props2.visible,\n        opacity = _this$props2.opacity,\n        pickable = _this$props2.pickable,\n        autoHighlight = _this$props2.autoHighlight,\n        highlightColor = _this$props2.highlightColor;\n      var updateTriggers = this._getSublayerUpdateTriggers();\n      var accessors = this._getSubLayerAccessors(); // @ts-expect-error\n\n      var distanceScale = (0, _viewportMercatorProject.getDistanceScales)(this.context.viewport);\n      var metersPerPixel = distanceScale.metersPerPixel[0]; // return props to the sublayer constructor\n\n      return new _layers.ScatterplotLayer(_objectSpread({\n        id: \"\".concat(id, \"-cluster\"),\n        data: cpuAggregator.state.layerData.data,\n        radiusScale: metersPerPixel * radiusScale,\n        visible: visible,\n        opacity: opacity,\n        pickable: pickable,\n        autoHighlight: autoHighlight,\n        highlightColor: highlightColor,\n        updateTriggers: updateTriggers,\n        parameters: {\n          depthMask: false\n        }\n      }, accessors));\n    }\n  }]);\n  return ClusterLayer;\n}(_aggregationLayers._AggregationLayer);\nexports[\"default\"] = ClusterLayer;\nClusterLayer.layerName = 'ClusterLayer';\nClusterLayer.defaultProps = defaultProps;","map":{"version":3,"names":["value","exports","clusterAggregation","_defineProperty2","_interopRequireDefault","require","_classCallCheck2","_createClass2","_inherits2","_geoViewport","_viewportMercatorProject","_constants","ownKeys","viewport","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","_createSuper","geoJSON","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","_getPrototypeOf2","result","NewTarget","constructor","Reflect","construct","_possibleConstructorReturn2","setState","sham","Proxy","Boolean","prototype","valueOf","call","e","defaultRadius","LAYER_VIS_CONFIGS","clusterRadius","defaultValue","defaultRadiusRange","clusterRadiusRange","points","defaultGetRadiusValue","cell","filteredPoints","processGeoJSON","step","props","aggregation","_ref","data","getPosition","_clusterUtils","getGeoJSON","filterData","clusterBuilder","getClusters","_ref2","_this$state","state","width","height","longitude","latitude","bbox","bounds","zoom","layerData","clusters","getSubLayerRadius","dimensionState","dimension","layerProps","getRadiusValue","scaleFunc","updateSteps","triggers","position","prop","updateTrigger","updater","getRadiusValueDomain","dimensionUpdater","valueDomain","_d3Array","max","_setDimensionState","clusterLayerDimensions","_cpuAggregator","defaultColorDimension","accessor","nullValue","domain","range","scaleType","getDimensionScale","getSubLayerAccessor","getPickingInfo","radiusValue","defaultProps","defaultGetColorValue","type","ClusterLayer","_AggregationLayer","_super","initializeState","cpuAggregator","dimensions","aggregatorState","attributeManager","getAttributeManager","add","positions","size","updateState","_ref3","oldProps","changeFlags","getAttributes","numInstances","getNumInstances","_ref4","info","getUpdateTriggers","_getSubLayerAccessors","getFillColor","getAccessor","renderLayers","distanceScale","_this$props","id","radiusScale","_this$props2","visible","opacity","pickable","autoHighlight","highlightColor","updateTriggers","_getSublayerUpdateTriggers","accessors","_layers","ScatterplotLayer","concat"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/deckgl-layers/src/cluster-layer/cluster-layer.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {ScatterplotLayer} from '@deck.gl/layers';\nimport {_AggregationLayer as AggregationLayer} from '@deck.gl/aggregation-layers';\n\nimport geoViewport from '@mapbox/geo-viewport';\nimport CPUAggregator, {\n  AggregationType,\n  defaultColorDimension,\n  DimensionType,\n  getDimensionScale\n} from '../layer-utils/cpu-aggregator';\nimport {getDistanceScales} from 'viewport-mercator-project';\nimport {max} from 'd3-array';\n\nimport {SCALE_TYPES, DEFAULT_COLOR_RANGE, LAYER_VIS_CONFIGS} from '@kepler.gl/constants';\nimport ClusterBuilder, {getGeoJSON} from '../layer-utils/cluster-utils';\nimport {RGBAColor} from '@kepler.gl/types';\nimport {AggregationLayerProps} from '@deck.gl/aggregation-layers/aggregation-layer';\n\nconst defaultRadius = LAYER_VIS_CONFIGS.clusterRadius.defaultValue;\nconst defaultRadiusRange = LAYER_VIS_CONFIGS.clusterRadiusRange.defaultValue;\n\nconst defaultGetColorValue = points => points.length;\nconst defaultGetRadiusValue = cell =>\n  cell.filteredPoints ? cell.filteredPoints.length : cell.points.length;\n\nfunction processGeoJSON(this: CPUAggregator, step, props, aggregation, {viewport}) {\n  const {data, getPosition, filterData} = props;\n  const geoJSON = getGeoJSON(data, getPosition, filterData);\n  const clusterBuilder = new ClusterBuilder();\n\n  this.setState({geoJSON, clusterBuilder});\n}\n\nfunction getClusters(this: CPUAggregator, step, props, aggregation, {viewport}) {\n  const {geoJSON, clusterBuilder} = this.state;\n  const {clusterRadius, zoom, width, height} = props;\n  const {longitude, latitude} = viewport;\n\n  // zoom needs to be an integer for the different map utils. Also helps with cache key.\n  const bbox = geoViewport.bounds([longitude, latitude], zoom, [width, height]);\n  const clusters = clusterBuilder.clustersAtZoom({bbox, clusterRadius, geoJSON, zoom});\n\n  this.setState({\n    layerData: {data: clusters}\n  });\n}\n\nfunction getSubLayerRadius(dimensionState, dimension, layerProps) {\n  return cell => {\n    const {getRadiusValue} = layerProps;\n    const {scaleFunc} = dimensionState;\n    return scaleFunc(getRadiusValue(cell));\n  };\n}\n\nexport const clusterAggregation: AggregationType = {\n  key: 'position',\n  updateSteps: [\n    {\n      key: 'geojson',\n      triggers: {\n        position: {\n          prop: 'getPosition',\n          updateTrigger: 'getPosition'\n        },\n        filterData: {\n          prop: 'filterData',\n          updateTrigger: 'filterData'\n        }\n      },\n      updater: processGeoJSON\n    },\n    {\n      key: 'clustering',\n      triggers: {\n        clusterRadius: {\n          prop: 'clusterRadius'\n        },\n        zoom: {\n          prop: 'zoom'\n        },\n        width: {\n          prop: 'width'\n        },\n        height: {\n          prop: 'height'\n        }\n      },\n      updater: getClusters\n    }\n  ]\n};\n\nfunction getRadiusValueDomain(this: CPUAggregator, step, props, dimensionUpdater) {\n  const {key} = dimensionUpdater;\n  const {getRadiusValue} = props;\n  const {layerData} = this.state;\n\n  const valueDomain = [0, max(layerData.data, getRadiusValue)];\n  this._setDimensionState(key, {valueDomain});\n}\n\nconst clusterLayerDimensions: [DimensionType<RGBAColor>, DimensionType<number>] = [\n  defaultColorDimension,\n  {\n    key: 'radius',\n    accessor: 'getRadius',\n    nullValue: 0,\n    updateSteps: [\n      {\n        key: 'getDomain',\n        triggers: {\n          value: {\n            prop: 'getRadiusValue',\n            updateTrigger: 'getRadiusValue'\n          }\n        },\n        updater: getRadiusValueDomain\n      },\n      {\n        key: 'getScaleFunc',\n        triggers: {\n          domain: {prop: 'radiusDomain'},\n          range: {prop: 'radiusRange'},\n          scaleType: {prop: 'radiusScaleType'}\n        },\n        updater: getDimensionScale\n      }\n    ],\n    getSubLayerAccessor: getSubLayerRadius,\n    getPickingInfo: (dimensionState, cell, layerProps) => {\n      const radiusValue = layerProps.getRadiusValue(cell);\n      return {radiusValue};\n    }\n  }\n];\n\nconst defaultProps = {\n  clusterRadius: defaultRadius,\n  colorDomain: null,\n  colorRange: DEFAULT_COLOR_RANGE,\n  colorScaleType: SCALE_TYPES.quantize,\n  radiusScaleType: SCALE_TYPES.sqrt,\n  radiusRange: defaultRadiusRange,\n  getPosition: {type: 'accessor', value: x => x.position},\n  getColorValue: {type: 'accessor', value: defaultGetColorValue},\n  getRadiusValue: {type: 'accessor', value: defaultGetRadiusValue}\n};\n\nexport default class ClusterLayer extends AggregationLayer<\n  any,\n  AggregationLayerProps<any> & {radiusScale: number}\n> {\n  initializeState() {\n    const cpuAggregator = new CPUAggregator({\n      aggregation: clusterAggregation,\n      dimensions: clusterLayerDimensions\n    });\n\n    this.state = {\n      cpuAggregator,\n      aggregatorState: cpuAggregator.state\n    };\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {size: 3, accessor: 'getPosition'}\n    });\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    this.setState({\n      // make a copy of the internal state of cpuAggregator for testing\n      aggregatorState: this.state.cpuAggregator.updateState(\n        {oldProps, props, changeFlags},\n        {\n          viewport: this.context.viewport,\n          attributes: this.getAttributes(),\n          numInstances: this.getNumInstances(props)\n        }\n      )\n    });\n  }\n\n  getPickingInfo({info}) {\n    return this.state.cpuAggregator.getPickingInfo({info}, this.props);\n  }\n\n  _getSublayerUpdateTriggers() {\n    return this.state.cpuAggregator.getUpdateTriggers(this.props);\n  }\n\n  _getSubLayerAccessors() {\n    return {\n      getRadius: this.state.cpuAggregator.getAccessor('radius', this.props),\n      getFillColor: this.state.cpuAggregator.getAccessor('fillColor', this.props)\n    };\n  }\n\n  renderLayers() {\n    // for subclassing, override this method to return\n    // customized sub layer props\n    const {id, radiusScale} = this.props;\n    const {cpuAggregator} = this.state;\n\n    // base layer props\n    const {visible, opacity, pickable, autoHighlight, highlightColor} = this.props;\n    const updateTriggers = this._getSublayerUpdateTriggers();\n    const accessors = this._getSubLayerAccessors();\n\n    // @ts-expect-error\n    const distanceScale = getDistanceScales(this.context.viewport);\n    const metersPerPixel = distanceScale.metersPerPixel[0];\n\n    // return props to the sublayer constructor\n    return new ScatterplotLayer({\n      id: `${id}-cluster`,\n      data: cpuAggregator.state.layerData.data,\n      radiusScale: metersPerPixel * radiusScale,\n      visible,\n      opacity,\n      pickable,\n      autoHighlight,\n      highlightColor,\n      updateTriggers,\n      parameters: {\n        depthMask: false\n      },\n      ...accessors\n    });\n  }\n}\n\nClusterLayer.layerName = 'ClusterLayer';\nClusterLayer.defaultProps = defaultProps;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}