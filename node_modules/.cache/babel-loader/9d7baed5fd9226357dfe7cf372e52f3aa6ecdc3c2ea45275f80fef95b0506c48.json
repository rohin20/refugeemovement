{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport { compareArrayBuffers } from '@loaders.gl/loader-utils';\nimport { normalizeLoader } from '../loader-utils/normalize-loader';\nimport { getResourceUrlAndType } from '../utils/resource-utils';\nimport { getRegisteredLoaders } from './register-loaders';\nimport { readFileSlice } from '../../iterator-utils/make-iterator/blob-iterator';\nimport { isBlob } from '../../javascript-utils/is-type';\nvar EXT_PATTERN = /\\.([^.]+)$/;\nexport function selectLoader(_x) {\n  return _selectLoader.apply(this, arguments);\n}\nfunction _selectLoader() {\n  _selectLoader = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(data) {\n    var loaders,\n      options,\n      context,\n      loader,\n      _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            loaders = _args.length > 1 && _args[1] !== undefined ? _args[1] : [];\n            options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n            context = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n            loader = selectLoaderSync(data, loaders, _objectSpread(_objectSpread({}, options), {}, {\n              nothrow: true\n            }), context);\n            if (!loader) {\n              _context.next = 6;\n              break;\n            }\n            return _context.abrupt(\"return\", loader);\n          case 6:\n            if (!isBlob(data)) {\n              _context.next = 11;\n              break;\n            }\n            _context.next = 9;\n            return readFileSlice(data, 0, 10);\n          case 9:\n            data = _context.sent;\n            loader = selectLoaderSync(data, loaders, options, context);\n          case 11:\n            if (!(!loader && !options.nothrow)) {\n              _context.next = 13;\n              break;\n            }\n            throw new Error(getNoValidLoaderMessage(data));\n          case 13:\n            return _context.abrupt(\"return\", loader);\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _selectLoader.apply(this, arguments);\n}\nexport function selectLoaderSync(data) {\n  var loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (loaders && !Array.isArray(loaders)) {\n    return normalizeLoader(loaders);\n  }\n  loaders = [].concat(_toConsumableArray(loaders || []), _toConsumableArray(getRegisteredLoaders()));\n  normalizeLoaders(loaders);\n  var _getResourceUrlAndTyp = getResourceUrlAndType(data),\n    url = _getResourceUrlAndTyp.url,\n    type = _getResourceUrlAndTyp.type;\n  var loader = findLoaderByUrl(loaders, url || context.url);\n  loader = loader || findLoaderByContentType(loaders, type);\n  loader = loader || findLoaderByExamingInitialData(loaders, data);\n  if (!loader && !options.nothrow) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n  return loader;\n}\nfunction getNoValidLoaderMessage(data) {\n  var _getResourceUrlAndTyp2 = getResourceUrlAndType(data),\n    url = _getResourceUrlAndTyp2.url,\n    type = _getResourceUrlAndTyp2.type;\n  var message = 'No valid loader found';\n  if (data) {\n    message += \" data: \\\"\".concat(getFirstCharacters(data), \"\\\", contentType: \\\"\").concat(type, \"\\\"\");\n  }\n  if (url) {\n    message += \" url: \".concat(url);\n  }\n  return message;\n}\nfunction normalizeLoaders(loaders) {\n  var _iterator = _createForOfIteratorHelper(loaders),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var loader = _step.value;\n      normalizeLoader(loader);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nfunction findLoaderByUrl(loaders, url) {\n  var match = url && url.match(EXT_PATTERN);\n  var extension = match && match[1];\n  return extension && findLoaderByExtension(loaders, extension);\n}\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n  var _iterator2 = _createForOfIteratorHelper(loaders),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var loader = _step2.value;\n      var _iterator3 = _createForOfIteratorHelper(loader.extensions),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var loaderExtension = _step3.value;\n          if (loaderExtension.toLowerCase() === extension) {\n            return loader;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return null;\n}\nfunction findLoaderByContentType(loaders, mimeType) {\n  var _iterator4 = _createForOfIteratorHelper(loaders),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var loader = _step4.value;\n      if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {\n        return loader;\n      }\n      if (mimeType === \"application/x.\".concat(loader.id)) {\n        return loader;\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return null;\n}\nfunction findLoaderByExamingInitialData(loaders, data) {\n  if (!data) {\n    return null;\n  }\n  var _iterator5 = _createForOfIteratorHelper(loaders),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var loader = _step5.value;\n      if (typeof data === 'string') {\n        if (testDataAgainstText(data, loader)) {\n          return loader;\n        }\n      } else if (ArrayBuffer.isView(data)) {\n        if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {\n          return loader;\n        }\n      } else if (data instanceof ArrayBuffer) {\n        var byteOffset = 0;\n        if (testDataAgainstBinary(data, byteOffset, loader)) {\n          return loader;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return null;\n}\nfunction testDataAgainstText(data, loader) {\n  return loader.testText && loader.testText(data);\n}\nfunction testDataAgainstBinary(data, byteOffset, loader) {\n  var tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some(function (test) {\n    return testBinary(data, byteOffset, loader, test);\n  });\n}\nfunction testBinary(data, byteOffset, loader, test) {\n  if (test instanceof ArrayBuffer) {\n    return compareArrayBuffers(test, data, test.byteLength);\n  }\n  switch (_typeof(test)) {\n    case 'function':\n      return test(data, loader);\n    case 'string':\n      var magic = getMagicString(data, byteOffset, test.length);\n      return test === magic;\n    default:\n      return false;\n  }\n}\nfunction getFirstCharacters(data) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    var byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength < byteOffset + length) {\n    return '';\n  }\n  var dataView = new DataView(arrayBuffer);\n  var magic = '';\n  for (var i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}","map":{"version":3,"names":["compareArrayBuffers","normalizeLoader","getResourceUrlAndType","getRegisteredLoaders","readFileSlice","isBlob","EXT_PATTERN","selectLoader","_x","_selectLoader","apply","arguments","_callee","data","loaders","options","context","loader","_args","_regeneratorRuntime","wrap","_callee$","_context","prev","next","length","undefined","selectLoaderSync","_objectSpread","nothrow","abrupt","sent","Error","getNoValidLoaderMessage","stop","Array","isArray","concat","_toConsumableArray","normalizeLoaders","_getResourceUrlAndTyp","url","type","findLoaderByUrl","findLoaderByContentType","findLoaderByExamingInitialData","_getResourceUrlAndTyp2","message","getFirstCharacters","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","err","e","f","match","extension","findLoaderByExtension","toLowerCase","_iterator2","_step2","_iterator3","extensions","_step3","loaderExtension","mimeType","_iterator4","_step4","mimeTypes","includes","id","_iterator5","_step5","testDataAgainstText","ArrayBuffer","isView","testDataAgainstBinary","buffer","byteOffset","testText","tests","some","test","testBinary","byteLength","_typeof","magic","getMagicString","slice","arrayBuffer","dataView","DataView","i","String","fromCharCode","getUint8"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/kepler.gl/node_modules/@loaders.gl/core/src/lib/api/select-loader.js"],"sourcesContent":["import {compareArrayBuffers} from '@loaders.gl/loader-utils';\nimport {normalizeLoader} from '../loader-utils/normalize-loader';\nimport {getResourceUrlAndType} from '../utils/resource-utils';\nimport {getRegisteredLoaders} from './register-loaders';\nimport {readFileSlice} from '../../iterator-utils/make-iterator/blob-iterator';\nimport {isBlob} from '../../javascript-utils/is-type';\nconst EXT_PATTERN = /\\.([^.]+)$/;\n\n// TODO - Need a variant that peeks at streams for parseInBatches\n// TODO - Detect multiple matching loaders? Use heuristics to grade matches?\n// TODO - Allow apps to pass context to disambiguate between multiple matches (e.g. multiple .json formats)?\n\nexport async function selectLoader(data, loaders = [], options = {}, context = {}) {\n  // First make a sync attempt, disabling exceptions\n  let loader = selectLoaderSync(data, loaders, {...options, nothrow: true}, context);\n  if (loader) {\n    return loader;\n  }\n\n  // For Blobs and Files, try to asynchronously read a small initial slice and test again with that\n  // to see if we can detect by initial content\n  if (isBlob(data)) {\n    data = await readFileSlice(data, 0, 10);\n    loader = selectLoaderSync(data, loaders, options, context);\n  }\n\n  // no loader available\n  if (!loader && !options.nothrow) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n\n  return loader;\n}\n\n// eslint-disable-next-line complexity\nexport function selectLoaderSync(data, loaders = [], options = {}, context = {}) {\n  // if only a single loader was provided (not as array), force its use\n  // TODO - Should this behaviour be kept and documented?\n  if (loaders && !Array.isArray(loaders)) {\n    return normalizeLoader(loaders);\n  }\n\n  // Add registered loaders\n  loaders = [...(loaders || []), ...getRegisteredLoaders()];\n  normalizeLoaders(loaders);\n\n  const {url, type} = getResourceUrlAndType(data);\n\n  let loader = findLoaderByUrl(loaders, url || context.url);\n  loader = loader || findLoaderByContentType(loaders, type);\n  // NOTE: Initial data is not always available (e.g. Response, stream, async iterator)\n  loader = loader || findLoaderByExamingInitialData(loaders, data);\n\n  // no loader available\n  if (!loader && !options.nothrow) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n\n  return loader;\n}\n\nfunction getNoValidLoaderMessage(data) {\n  const {url, type} = getResourceUrlAndType(data);\n\n  let message = 'No valid loader found';\n  if (data) {\n    message += ` data: \"${getFirstCharacters(data)}\", contentType: \"${type}\"`;\n  }\n  if (url) {\n    message += ` url: ${url}`;\n  }\n  return message;\n}\n\nfunction normalizeLoaders(loaders) {\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n  }\n}\n\n// TODO - Would be nice to support http://example.com/file.glb?parameter=1\n// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname\nfunction findLoaderByUrl(loaders, url) {\n  // Get extension\n  const match = url && url.match(EXT_PATTERN);\n  const extension = match && match[1];\n  return extension && findLoaderByExtension(loaders, extension);\n}\n\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n\n  for (const loader of loaders) {\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByContentType(loaders, mimeType) {\n  for (const loader of loaders) {\n    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {\n      return loader;\n    }\n\n    // Support referring to loaders using the \"unregistered tree\"\n    // https://en.wikipedia.org/wiki/Media_type#Unregistered_tree\n    if (mimeType === `application/x.${loader.id}`) {\n      return loader;\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByExamingInitialData(loaders, data) {\n  if (!data) {\n    return null;\n  }\n\n  for (const loader of loaders) {\n    if (typeof data === 'string') {\n      if (testDataAgainstText(data, loader)) {\n        return loader;\n      }\n    } else if (ArrayBuffer.isView(data)) {\n      // Typed Arrays can have offsets into underlying buffer\n      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {\n        return loader;\n      }\n    } else if (data instanceof ArrayBuffer) {\n      const byteOffset = 0;\n      if (testDataAgainstBinary(data, byteOffset, loader)) {\n        return loader;\n      }\n    }\n    // TODO Handle streaming case (requires creating a new AsyncIterator)\n  }\n  return null;\n}\n\nfunction testDataAgainstText(data, loader) {\n  return loader.testText && loader.testText(data);\n}\n\nfunction testDataAgainstBinary(data, byteOffset, loader) {\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some(test => testBinary(data, byteOffset, loader, test));\n}\n\nfunction testBinary(data, byteOffset, loader, test) {\n  if (test instanceof ArrayBuffer) {\n    return compareArrayBuffers(test, data, test.byteLength);\n  }\n  switch (typeof test) {\n    case 'function':\n      return test(data, loader);\n\n    case 'string':\n      // Magic bytes check: If `test` is a string, check if binary data starts with that strings\n      const magic = getMagicString(data, byteOffset, test.length);\n      return test === magic;\n\n    default:\n      return false;\n  }\n}\n\nfunction getFirstCharacters(data, length = 5) {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    // Typed Arrays can have offsets into underlying buffer\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\n\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength < byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}