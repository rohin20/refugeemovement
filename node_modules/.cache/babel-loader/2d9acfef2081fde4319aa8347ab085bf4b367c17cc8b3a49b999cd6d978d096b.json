{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport TinySDF from '@mapbox/tiny-sdf';\nimport { log } from '@deck.gl/core';\nimport { buildMapping } from './utils';\nimport LRUCache from './lru-cache';\nfunction getDefaultCharacterSet() {\n  var charSet = [];\n  for (var i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n  return charSet;\n}\nexport var DEFAULT_FONT_SETTINGS = {\n  fontFamily: 'Monaco, monospace',\n  fontWeight: 'normal',\n  characterSet: getDefaultCharacterSet(),\n  fontSize: 64,\n  buffer: 4,\n  sdf: false,\n  cutoff: 0.25,\n  radius: 12,\n  smoothing: 0.1\n};\nvar MAX_CANVAS_WIDTH = 1024;\nvar BASELINE_SCALE = 0.9;\nvar HEIGHT_SCALE = 1.2;\nvar CACHE_LIMIT = 3;\nvar cache = new LRUCache(CACHE_LIMIT);\nfunction getNewChars(cacheKey, characterSet) {\n  var newCharSet;\n  if (typeof characterSet === 'string') {\n    newCharSet = new Set(Array.from(characterSet));\n  } else {\n    newCharSet = new Set(characterSet);\n  }\n  var cachedFontAtlas = cache.get(cacheKey);\n  if (!cachedFontAtlas) {\n    return newCharSet;\n  }\n  for (var char in cachedFontAtlas.mapping) {\n    if (newCharSet.has(char)) {\n      newCharSet.delete(char);\n    }\n  }\n  return newCharSet;\n}\nfunction populateAlphaChannel(alphaChannel, imageData) {\n  for (var i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\nfunction setTextStyle(ctx, fontFamily, fontSize, fontWeight) {\n  ctx.font = \"\".concat(fontWeight, \" \").concat(fontSize, \"px \").concat(fontFamily);\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'alphabetic';\n  ctx.textAlign = 'left';\n}\nexport function setFontAtlasCacheLimit(limit) {\n  log.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');\n  cache = new LRUCache(limit);\n}\nvar FontAtlasManager = /*#__PURE__*/function () {\n  function FontAtlasManager() {\n    _classCallCheck(this, FontAtlasManager);\n    _defineProperty(this, \"props\", _objectSpread({}, DEFAULT_FONT_SETTINGS));\n    _defineProperty(this, \"_key\", void 0);\n    _defineProperty(this, \"_atlas\", void 0);\n  }\n  _createClass(FontAtlasManager, [{\n    key: \"texture\",\n    get: function get() {\n      return this._atlas;\n    }\n  }, {\n    key: \"mapping\",\n    get: function get() {\n      return this._atlas && this._atlas.mapping;\n    }\n  }, {\n    key: \"scale\",\n    get: function get() {\n      return HEIGHT_SCALE;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.assign(this.props, props);\n      var oldKey = this._key;\n      this._key = this._getKey();\n      var charSet = getNewChars(this._key, this.props.characterSet);\n      var cachedFontAtlas = cache.get(this._key);\n      if (cachedFontAtlas && charSet.size === 0) {\n        if (this._key !== oldKey) {\n          this._atlas = cachedFontAtlas;\n        }\n        return;\n      }\n      var fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);\n      this._atlas = fontAtlas;\n      cache.set(this._key, fontAtlas);\n    }\n  }, {\n    key: \"_generateFontAtlas\",\n    value: function _generateFontAtlas(key, characterSet, cachedFontAtlas) {\n      var _this$props = this.props,\n        fontFamily = _this$props.fontFamily,\n        fontWeight = _this$props.fontWeight,\n        fontSize = _this$props.fontSize,\n        buffer = _this$props.buffer,\n        sdf = _this$props.sdf,\n        radius = _this$props.radius,\n        cutoff = _this$props.cutoff;\n      var canvas = cachedFontAtlas && cachedFontAtlas.data;\n      if (!canvas) {\n        canvas = document.createElement('canvas');\n        canvas.width = MAX_CANVAS_WIDTH;\n      }\n      var ctx = canvas.getContext('2d');\n      setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n      var _buildMapping = buildMapping(_objectSpread({\n          getFontWidth: function getFontWidth(char) {\n            return ctx.measureText(char).width;\n          },\n          fontHeight: fontSize * HEIGHT_SCALE,\n          buffer: buffer,\n          characterSet: characterSet,\n          maxCanvasWidth: MAX_CANVAS_WIDTH\n        }, cachedFontAtlas && {\n          mapping: cachedFontAtlas.mapping,\n          xOffset: cachedFontAtlas.xOffset,\n          yOffset: cachedFontAtlas.yOffset\n        })),\n        mapping = _buildMapping.mapping,\n        canvasHeight = _buildMapping.canvasHeight,\n        xOffset = _buildMapping.xOffset,\n        yOffset = _buildMapping.yOffset;\n      if (canvas.height !== canvasHeight) {\n        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        canvas.height = canvasHeight;\n        ctx.putImageData(imageData, 0, 0);\n      }\n      setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n      if (sdf) {\n        var tinySDF = new TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);\n        var _imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);\n        var _iterator = _createForOfIteratorHelper(characterSet),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var char = _step.value;\n            populateAlphaChannel(tinySDF.draw(char), _imageData);\n            ctx.putImageData(_imageData, mapping[char].x - buffer, mapping[char].y + buffer);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(characterSet),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _char = _step2.value;\n            ctx.fillText(_char, mapping[_char].x, mapping[_char].y + fontSize * BASELINE_SCALE);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      return {\n        xOffset: xOffset,\n        yOffset: yOffset,\n        mapping: mapping,\n        data: canvas,\n        width: canvas.width,\n        height: canvas.height\n      };\n    }\n  }, {\n    key: \"_getKey\",\n    value: function _getKey() {\n      var _this$props2 = this.props,\n        fontFamily = _this$props2.fontFamily,\n        fontWeight = _this$props2.fontWeight,\n        fontSize = _this$props2.fontSize,\n        buffer = _this$props2.buffer,\n        sdf = _this$props2.sdf,\n        radius = _this$props2.radius,\n        cutoff = _this$props2.cutoff;\n      if (sdf) {\n        return \"\".concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer, \" \").concat(radius, \" \").concat(cutoff);\n      }\n      return \"\".concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer);\n    }\n  }]);\n  return FontAtlasManager;\n}();\nexport { FontAtlasManager as default };","map":{"version":3,"names":["TinySDF","log","buildMapping","LRUCache","getDefaultCharacterSet","charSet","i","push","String","fromCharCode","DEFAULT_FONT_SETTINGS","fontFamily","fontWeight","characterSet","fontSize","buffer","sdf","cutoff","radius","smoothing","MAX_CANVAS_WIDTH","BASELINE_SCALE","HEIGHT_SCALE","CACHE_LIMIT","cache","getNewChars","cacheKey","newCharSet","Set","Array","from","cachedFontAtlas","get","char","mapping","has","delete","populateAlphaChannel","alphaChannel","imageData","length","data","setTextStyle","ctx","font","concat","fillStyle","textBaseline","textAlign","setFontAtlasCacheLimit","limit","assert","Number","isFinite","FontAtlasManager","_classCallCheck","_defineProperty","_objectSpread","_createClass","key","_atlas","value","setProps","props","arguments","undefined","Object","assign","oldKey","_key","_getKey","size","fontAtlas","_generateFontAtlas","set","_this$props","canvas","document","createElement","width","getContext","_buildMapping","getFontWidth","measureText","fontHeight","maxCanvasWidth","xOffset","yOffset","canvasHeight","height","getImageData","putImageData","tinySDF","_iterator","_createForOfIteratorHelper","_step","s","n","done","draw","x","y","err","e","f","_iterator2","_step2","fillText","_this$props2","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/layers/src/text-layer/font-atlas-manager.ts"],"sourcesContent":["/* global document */\nimport TinySDF from '@mapbox/tiny-sdf';\n\nimport {log} from '@deck.gl/core';\n\nimport {buildMapping, CharacterMapping} from './utils';\nimport LRUCache from './lru-cache';\n\nimport type {Texture} from '@deck.gl/core';\n\nfunction getDefaultCharacterSet() {\n  const charSet: string[] = [];\n  for (let i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n  return charSet;\n}\n\nexport type FontSettings = {\n  /** CSS font family\n   * @default 'Monaco, monospace'\n   */\n  fontFamily?: string;\n  /** CSS font weight\n   * @default 'normal'\n   */\n  fontWeight?: string | number;\n  /** Specifies a list of characters to include in the font.\n   * @default (ASCII characters 32-128)\n   */\n  characterSet?: Set<string> | string[] | string;\n  /** Font size in pixels. This option is only applied for generating `fontAtlas`, it does not impact the size of displayed text labels. Larger `fontSize` will give you a sharper look when rendering text labels with very large font sizes. But larger `fontSize` requires more time and space to generate the `fontAtlas`.\n   * @default 64\n   */\n  fontSize?: number;\n  /** Whitespace buffer around each side of the character. In general, bigger `fontSize` requires bigger `buffer`. Increase `buffer` will add more space between each character when layout `characterSet` in `fontAtlas`. This option could be tuned to provide sufficient space for drawing each character and avoiding overlapping of neighboring characters.\n   * @default 4\n   */\n  buffer?: number;\n  /** Flag to enable / disable `sdf`. [`sdf` (Signed Distance Fields)](http://cs.brown.edu/people/pfelzens/papers/dt-final.pdf) will provide a sharper look when rendering with very large or small font sizes. `TextLayer` integrates with [`TinySDF`](https://github.com/mapbox/tiny-sdf) which implements the `sdf` algorithm.\n   * @default false\n   */\n  sdf?: boolean;\n  /** How much of the radius (relative) is used for the inside part the glyph. Bigger `cutoff` makes character thinner. Smaller `cutoff` makes character look thicker. Only applies when `sdf: true`.\n   * @default 0.25\n   */\n  cutoff?: number;\n  /** How many pixels around the glyph shape to use for encoding distance. Bigger radius yields higher quality outcome. Only applies when `sdf: true`.\n   * @default 12\n   */\n  radius?: number;\n  /** How much smoothing to apply to the text edges. Only applies when `sdf: true`.\n   * @default 0.1\n   */\n  smoothing?: number;\n};\n\nexport const DEFAULT_FONT_SETTINGS: Required<FontSettings> = {\n  fontFamily: 'Monaco, monospace',\n  fontWeight: 'normal',\n  characterSet: getDefaultCharacterSet(),\n  fontSize: 64,\n  buffer: 4,\n  sdf: false,\n  cutoff: 0.25,\n  radius: 12,\n  smoothing: 0.1\n};\n\nconst MAX_CANVAS_WIDTH = 1024;\n\nconst BASELINE_SCALE = 0.9;\nconst HEIGHT_SCALE = 1.2;\n\n// only preserve latest three fontAtlas\nconst CACHE_LIMIT = 3;\n\ntype FontAtlas = {\n  /** x position of last character in mapping */\n  xOffset: number;\n  /** y position of last character in mapping */\n  yOffset: number;\n  /** bounding box of each character in the texture */\n  mapping: CharacterMapping;\n  /** packed texture */\n  data: HTMLCanvasElement;\n  /** texture width */\n  width: number;\n  /** texture height */\n  height: number;\n};\n\nlet cache = new LRUCache<FontAtlas>(CACHE_LIMIT);\n\n/**\n * get all the chars not in cache\n * @returns chars not in cache\n */\nfunction getNewChars(cacheKey: string, characterSet: Set<string> | string[] | string): Set<string> {\n  let newCharSet: Set<string>;\n  if (typeof characterSet === 'string') {\n    newCharSet = new Set(Array.from(characterSet));\n  } else {\n    newCharSet = new Set(characterSet);\n  }\n\n  const cachedFontAtlas = cache.get(cacheKey);\n  if (!cachedFontAtlas) {\n    return newCharSet;\n  }\n\n  for (const char in cachedFontAtlas.mapping) {\n    if (newCharSet.has(char)) {\n      newCharSet.delete(char);\n    }\n  }\n  return newCharSet;\n}\n\nfunction populateAlphaChannel(alphaChannel: number[], imageData: ImageData): void {\n  // populate distance value from tinySDF to image alpha channel\n  for (let i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\nfunction setTextStyle(\n  ctx: CanvasRenderingContext2D,\n  fontFamily: string,\n  fontSize: number,\n  fontWeight: string | number\n): void {\n  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'alphabetic';\n  ctx.textAlign = 'left';\n}\n\n/**\n * Sets the Font Atlas LRU Cache Limit\n * @param {number} limit LRU Cache limit\n */\nexport function setFontAtlasCacheLimit(limit: number): void {\n  log.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');\n\n  cache = new LRUCache(limit);\n}\n\nexport default class FontAtlasManager {\n  /** Font settings */\n  props: Required<FontSettings> = {...DEFAULT_FONT_SETTINGS};\n\n  /** Cache key of the current font atlas */\n  private _key?: string;\n  /** The current font atlas */\n  private _atlas?: FontAtlas;\n\n  get texture(): Texture | undefined {\n    return this._atlas;\n  }\n\n  get mapping(): CharacterMapping | undefined {\n    return this._atlas && this._atlas.mapping;\n  }\n\n  get scale(): number {\n    return HEIGHT_SCALE;\n  }\n\n  setProps(props: FontSettings = {}) {\n    Object.assign(this.props, props);\n\n    // update cache key\n    const oldKey = this._key;\n    this._key = this._getKey();\n\n    const charSet = getNewChars(this._key, this.props.characterSet);\n    const cachedFontAtlas = cache.get(this._key);\n\n    // if a fontAtlas associated with the new settings is cached and\n    // there are no new chars\n    if (cachedFontAtlas && charSet.size === 0) {\n      // update texture with cached fontAtlas\n      if (this._key !== oldKey) {\n        this._atlas = cachedFontAtlas;\n      }\n      return;\n    }\n\n    // update fontAtlas with new settings\n    const fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);\n    this._atlas = fontAtlas;\n\n    // update cache\n    cache.set(this._key, fontAtlas);\n  }\n\n  private _generateFontAtlas(\n    key: string,\n    characterSet: Set<string>,\n    cachedFontAtlas?: FontAtlas\n  ): FontAtlas {\n    const {fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;\n    let canvas = cachedFontAtlas && cachedFontAtlas.data;\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.width = MAX_CANVAS_WIDTH;\n    }\n    const ctx = canvas.getContext('2d')!;\n\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 1. build mapping\n    const {mapping, canvasHeight, xOffset, yOffset} = buildMapping({\n      getFontWidth: char => ctx.measureText(char).width,\n      fontHeight: fontSize * HEIGHT_SCALE,\n      buffer,\n      characterSet,\n      maxCanvasWidth: MAX_CANVAS_WIDTH,\n      ...(cachedFontAtlas && {\n        mapping: cachedFontAtlas.mapping,\n        xOffset: cachedFontAtlas.xOffset,\n        yOffset: cachedFontAtlas.yOffset\n      })\n    });\n\n    // 2. update canvas\n    // copy old canvas data to new canvas only when height changed\n    if (canvas.height !== canvasHeight) {\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      canvas.height = canvasHeight;\n      ctx.putImageData(imageData, 0, 0);\n    }\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 3. layout characters\n    if (sdf) {\n      const tinySDF = new TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);\n      // used to store distance values from tinySDF\n      // tinySDF.size equals `fontSize + buffer * 2`\n      const imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);\n\n      for (const char of characterSet) {\n        populateAlphaChannel(tinySDF.draw(char), imageData);\n        ctx.putImageData(imageData, mapping[char].x - buffer, mapping[char].y + buffer);\n      }\n    } else {\n      for (const char of characterSet) {\n        ctx.fillText(char, mapping[char].x, mapping[char].y + fontSize * BASELINE_SCALE);\n      }\n    }\n\n    return {\n      xOffset,\n      yOffset,\n      mapping,\n      data: canvas,\n      width: canvas.width,\n      height: canvas.height\n    };\n  }\n\n  private _getKey(): string {\n    const {fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;\n    if (sdf) {\n      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;\n    }\n    return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}