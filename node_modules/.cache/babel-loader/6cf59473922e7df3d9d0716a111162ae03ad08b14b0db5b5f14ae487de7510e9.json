{"ast":null,"code":"/// S2 Geometry functions\n// the regional scoreboard is based on a level 6 S2 Cell\n// - https://docs.google.com/presentation/d/1Hl4KapfAENAOf4gv-pSngKwvS_jwNVHRPZTTDzXXn6Q/view?pli=1#slide=id.i22\n// at the time of writing there's no actual API for the intel map to retrieve scoreboard data,\n// but it's still useful to plot the score cells on the intel map\n\n// the S2 geometry is based on projecting the earth sphere onto a cube, with some scaling of face coordinates to\n// keep things close to approximate equal area for adjacent cells\n// to convert a lat,lng into a cell id:\n// - convert lat,lng to x,y,z\n// - convert x,y,z into face,u,v\n// - u,v scaled to s,t with quadratic formula\n// - s,t converted to integer i,j offsets\n// - i,j converted to a position along a Hubbert space-filling curve\n// - combine face,position to get the cell id\n\n//NOTE: compared to the google S2 geometry library, we vary from their code in the following ways\n// - cell IDs: they combine face and the hilbert curve position into a single 64 bit number. this gives efficient space\n//             and speed. javascript doesn't have appropriate data types, and speed is not cricical, so we use\n//             as [face,[bitpair,bitpair,...]] instead\n// - i,j: they always use 30 bits, adjusting as needed. we use 0 to (1<<level)-1 instead\n//        (so GetSizeIJ for a cell is always 1)\n\n(function (exports) {\n  'use strict';\n\n  var S2 = exports.S2 = {\n    L: {}\n  };\n  S2.L.LatLng = function ( /*Number*/rawLat, /*Number*/rawLng, /*Boolean*/noWrap) {\n    var lat = parseFloat(rawLat, 10);\n    var lng = parseFloat(rawLng, 10);\n    if (isNaN(lat) || isNaN(lng)) {\n      throw new Error('Invalid LatLng object: (' + rawLat + ', ' + rawLng + ')');\n    }\n    if (noWrap !== true) {\n      lat = Math.max(Math.min(lat, 90), -90); // clamp latitude into -90..90\n      lng = (lng + 180) % 360 + (lng < -180 || lng === 180 ? 180 : -180); // wrap longtitude into -180..180\n    }\n\n    return {\n      lat: lat,\n      lng: lng\n    };\n  };\n  S2.L.LatLng.DEG_TO_RAD = Math.PI / 180;\n  S2.L.LatLng.RAD_TO_DEG = 180 / Math.PI;\n\n  /*\n  S2.LatLngToXYZ = function(latLng) {\n    // http://stackoverflow.com/questions/8981943/lat-long-to-x-y-z-position-in-js-not-working\n    var lat = latLng.lat;\n    var lon = latLng.lng;\n    var DEG_TO_RAD = Math.PI / 180.0;\n  \n    var phi = lat * DEG_TO_RAD;\n    var theta = lon * DEG_TO_RAD;\n  \n    var cosLat = Math.cos(phi);\n    var sinLat = Math.sin(phi);\n    var cosLon = Math.cos(theta);\n    var sinLon = Math.sin(theta);\n    var rad = 500.0;\n  \n    return [\n      rad * cosLat * cosLon\n    , rad * cosLat * sinLon\n    , rad * sinLat\n    ];\n  };\n  */\n  S2.LatLngToXYZ = function (latLng) {\n    var d2r = S2.L.LatLng.DEG_TO_RAD;\n    var phi = latLng.lat * d2r;\n    var theta = latLng.lng * d2r;\n    var cosphi = Math.cos(phi);\n    return [Math.cos(theta) * cosphi, Math.sin(theta) * cosphi, Math.sin(phi)];\n  };\n  S2.XYZToLatLng = function (xyz) {\n    var r2d = S2.L.LatLng.RAD_TO_DEG;\n    var lat = Math.atan2(xyz[2], Math.sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1]));\n    var lng = Math.atan2(xyz[1], xyz[0]);\n    return S2.L.LatLng(lat * r2d, lng * r2d);\n  };\n  var largestAbsComponent = function largestAbsComponent(xyz) {\n    var temp = [Math.abs(xyz[0]), Math.abs(xyz[1]), Math.abs(xyz[2])];\n    if (temp[0] > temp[1]) {\n      if (temp[0] > temp[2]) {\n        return 0;\n      } else {\n        return 2;\n      }\n    } else {\n      if (temp[1] > temp[2]) {\n        return 1;\n      } else {\n        return 2;\n      }\n    }\n  };\n  var faceXYZToUV = function faceXYZToUV(face, xyz) {\n    var u, v;\n    switch (face) {\n      case 0:\n        u = xyz[1] / xyz[0];\n        v = xyz[2] / xyz[0];\n        break;\n      case 1:\n        u = -xyz[0] / xyz[1];\n        v = xyz[2] / xyz[1];\n        break;\n      case 2:\n        u = -xyz[0] / xyz[2];\n        v = -xyz[1] / xyz[2];\n        break;\n      case 3:\n        u = xyz[2] / xyz[0];\n        v = xyz[1] / xyz[0];\n        break;\n      case 4:\n        u = xyz[2] / xyz[1];\n        v = -xyz[0] / xyz[1];\n        break;\n      case 5:\n        u = -xyz[1] / xyz[2];\n        v = -xyz[0] / xyz[2];\n        break;\n      default:\n        throw {\n          error: 'Invalid face'\n        };\n    }\n    return [u, v];\n  };\n  S2.XYZToFaceUV = function (xyz) {\n    var face = largestAbsComponent(xyz);\n    if (xyz[face] < 0) {\n      face += 3;\n    }\n    var uv = faceXYZToUV(face, xyz);\n    return [face, uv];\n  };\n  S2.FaceUVToXYZ = function (face, uv) {\n    var u = uv[0];\n    var v = uv[1];\n    switch (face) {\n      case 0:\n        return [1, u, v];\n      case 1:\n        return [-u, 1, v];\n      case 2:\n        return [-u, -v, 1];\n      case 3:\n        return [-1, -v, -u];\n      case 4:\n        return [v, -1, -u];\n      case 5:\n        return [v, u, -1];\n      default:\n        throw {\n          error: 'Invalid face'\n        };\n    }\n  };\n  var singleSTtoUV = function singleSTtoUV(st) {\n    if (st >= 0.5) {\n      return 1 / 3.0 * (4 * st * st - 1);\n    } else {\n      return 1 / 3.0 * (1 - 4 * (1 - st) * (1 - st));\n    }\n  };\n  S2.STToUV = function (st) {\n    return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];\n  };\n  var singleUVtoST = function singleUVtoST(uv) {\n    if (uv >= 0) {\n      return 0.5 * Math.sqrt(1 + 3 * uv);\n    } else {\n      return 1 - 0.5 * Math.sqrt(1 - 3 * uv);\n    }\n  };\n  S2.UVToST = function (uv) {\n    return [singleUVtoST(uv[0]), singleUVtoST(uv[1])];\n  };\n  S2.STToIJ = function (st, order) {\n    var maxSize = 1 << order;\n    var singleSTtoIJ = function singleSTtoIJ(st) {\n      var ij = Math.floor(st * maxSize);\n      return Math.max(0, Math.min(maxSize - 1, ij));\n    };\n    return [singleSTtoIJ(st[0]), singleSTtoIJ(st[1])];\n  };\n  S2.IJToST = function (ij, order, offsets) {\n    var maxSize = 1 << order;\n    return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];\n  };\n  var rotateAndFlipQuadrant = function rotateAndFlipQuadrant(n, point, rx, ry) {\n    var newX, newY;\n    if (ry == 0) {\n      if (rx == 1) {\n        point.x = n - 1 - point.x;\n        point.y = n - 1 - point.y;\n      }\n      var x = point.x;\n      point.x = point.y;\n      point.y = x;\n    }\n  };\n\n  // hilbert space-filling curve\n  // based on http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves\n  // note: rather then calculating the final integer hilbert position, we just return the list of quads\n  // this ensures no precision issues whth large orders (S3 cell IDs use up to 30), and is more\n  // convenient for pulling out the individual bits as needed later\n  var pointToHilbertQuadList = function pointToHilbertQuadList(x, y, order, face) {\n    var hilbertMap = {\n      'a': [[0, 'd'], [1, 'a'], [3, 'b'], [2, 'a']],\n      'b': [[2, 'b'], [1, 'b'], [3, 'a'], [0, 'c']],\n      'c': [[2, 'c'], [3, 'd'], [1, 'c'], [0, 'b']],\n      'd': [[0, 'a'], [3, 'c'], [1, 'd'], [2, 'd']]\n    };\n    if ('number' !== typeof face) {\n      console.warn(new Error(\"called pointToHilbertQuadList without face value, defaulting to '0'\").stack);\n    }\n    var currentSquare = face % 2 ? 'd' : 'a';\n    var positions = [];\n    for (var i = order - 1; i >= 0; i--) {\n      var mask = 1 << i;\n      var quad_x = x & mask ? 1 : 0;\n      var quad_y = y & mask ? 1 : 0;\n      var t = hilbertMap[currentSquare][quad_x * 2 + quad_y];\n      positions.push(t[0]);\n      currentSquare = t[1];\n    }\n    return positions;\n  };\n\n  // S2Cell class\n\n  S2.S2Cell = function () {};\n  S2.S2Cell.FromHilbertQuadKey = function (hilbertQuadkey) {\n    var parts = hilbertQuadkey.split('/');\n    var face = parseInt(parts[0]);\n    var position = parts[1];\n    var maxLevel = position.length;\n    var point = {\n      x: 0,\n      y: 0\n    };\n    var i;\n    var level;\n    var bit;\n    var rx, ry;\n    var val;\n    for (i = maxLevel - 1; i >= 0; i--) {\n      level = maxLevel - i;\n      bit = position[i];\n      rx = 0;\n      ry = 0;\n      if (bit === '1') {\n        ry = 1;\n      } else if (bit === '2') {\n        rx = 1;\n        ry = 1;\n      } else if (bit === '3') {\n        rx = 1;\n      }\n      val = Math.pow(2, level - 1);\n      rotateAndFlipQuadrant(val, point, rx, ry);\n      point.x += val * rx;\n      point.y += val * ry;\n    }\n    if (face % 2 === 1) {\n      var t = point.x;\n      point.x = point.y;\n      point.y = t;\n    }\n    return S2.S2Cell.FromFaceIJ(parseInt(face), [point.x, point.y], level);\n  };\n\n  //static method to construct\n  S2.S2Cell.FromLatLng = function (latLng, level) {\n    if (!latLng.lat && latLng.lat !== 0 || !latLng.lng && latLng.lng !== 0) {\n      throw new Error(\"Pass { lat: lat, lng: lng } to S2.S2Cell.FromLatLng\");\n    }\n    var xyz = S2.LatLngToXYZ(latLng);\n    var faceuv = S2.XYZToFaceUV(xyz);\n    var st = S2.UVToST(faceuv[1]);\n    var ij = S2.STToIJ(st, level);\n    return S2.S2Cell.FromFaceIJ(faceuv[0], ij, level);\n  };\n\n  /*\n  S2.faceIjLevelToXyz = function (face, ij, level) {\n    var st = S2.IJToST(ij, level, [0.5, 0.5]);\n    var uv = S2.STToUV(st);\n    var xyz = S2.FaceUVToXYZ(face, uv);\n  \n    return S2.XYZToLatLng(xyz);\n    return xyz;\n  };\n  */\n\n  S2.S2Cell.FromFaceIJ = function (face, ij, level) {\n    var cell = new S2.S2Cell();\n    cell.face = face;\n    cell.ij = ij;\n    cell.level = level;\n    return cell;\n  };\n  S2.S2Cell.prototype.toString = function () {\n    return 'F' + this.face + 'ij[' + this.ij[0] + ',' + this.ij[1] + ']@' + this.level;\n  };\n  S2.S2Cell.prototype.getLatLng = function () {\n    var st = S2.IJToST(this.ij, this.level, [0.5, 0.5]);\n    var uv = S2.STToUV(st);\n    var xyz = S2.FaceUVToXYZ(this.face, uv);\n    return S2.XYZToLatLng(xyz);\n  };\n  S2.S2Cell.prototype.getCornerLatLngs = function () {\n    var result = [];\n    var offsets = [[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0]];\n    for (var i = 0; i < 4; i++) {\n      var st = S2.IJToST(this.ij, this.level, offsets[i]);\n      var uv = S2.STToUV(st);\n      var xyz = S2.FaceUVToXYZ(this.face, uv);\n      result.push(S2.XYZToLatLng(xyz));\n    }\n    return result;\n  };\n  S2.S2Cell.prototype.getFaceAndQuads = function () {\n    var quads = pointToHilbertQuadList(this.ij[0], this.ij[1], this.level, this.face);\n    return [this.face, quads];\n  };\n  S2.S2Cell.prototype.toHilbertQuadkey = function () {\n    var quads = pointToHilbertQuadList(this.ij[0], this.ij[1], this.level, this.face);\n    return this.face.toString(10) + '/' + quads.join('');\n  };\n  S2.latLngToNeighborKeys = S2.S2Cell.latLngToNeighborKeys = function (lat, lng, level) {\n    return S2.S2Cell.FromLatLng({\n      lat: lat,\n      lng: lng\n    }, level).getNeighbors().map(function (cell) {\n      return cell.toHilbertQuadkey();\n    });\n  };\n  S2.S2Cell.prototype.getNeighbors = function () {\n    var fromFaceIJWrap = function fromFaceIJWrap(face, ij, level) {\n      var maxSize = 1 << level;\n      if (ij[0] >= 0 && ij[1] >= 0 && ij[0] < maxSize && ij[1] < maxSize) {\n        // no wrapping out of bounds\n        return S2.S2Cell.FromFaceIJ(face, ij, level);\n      } else {\n        // the new i,j are out of range.\n        // with the assumption that they're only a little past the borders we can just take the points as\n        // just beyond the cube face, project to XYZ, then re-create FaceUV from the XYZ vector\n\n        var st = S2.IJToST(ij, level, [0.5, 0.5]);\n        var uv = S2.STToUV(st);\n        var xyz = S2.FaceUVToXYZ(face, uv);\n        var faceuv = S2.XYZToFaceUV(xyz);\n        face = faceuv[0];\n        uv = faceuv[1];\n        st = S2.UVToST(uv);\n        ij = S2.STToIJ(st, level);\n        return S2.S2Cell.FromFaceIJ(face, ij, level);\n      }\n    };\n    var face = this.face;\n    var i = this.ij[0];\n    var j = this.ij[1];\n    var level = this.level;\n    return [fromFaceIJWrap(face, [i - 1, j], level), fromFaceIJWrap(face, [i, j - 1], level), fromFaceIJWrap(face, [i + 1, j], level), fromFaceIJWrap(face, [i, j + 1], level)];\n  };\n\n  //\n  // Functional Style\n  //\n  S2.FACE_BITS = 3;\n  S2.MAX_LEVEL = 30;\n  S2.POS_BITS = 2 * S2.MAX_LEVEL + 1; // 61 (60 bits of data, 1 bit lsb marker)\n\n  S2.facePosLevelToId = S2.S2Cell.facePosLevelToId = S2.fromFacePosLevel = function (faceN, posS, levelN) {\n    var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n    var faceB;\n    var posB;\n    var bin;\n    if (!levelN) {\n      levelN = posS.length;\n    }\n    if (posS.length > levelN) {\n      posS = posS.substr(0, levelN);\n    }\n\n    // 3-bit face value\n    faceB = Long.fromString(faceN.toString(10), true, 10).toString(2);\n    while (faceB.length < S2.FACE_BITS) {\n      faceB = '0' + faceB;\n    }\n\n    // 60-bit position value\n    posB = Long.fromString(posS, true, 4).toString(2);\n    while (posB.length < 2 * levelN) {\n      posB = '0' + posB;\n    }\n    bin = faceB + posB;\n    // 1-bit lsb marker\n    bin += '1';\n    // n-bit padding to 64-bits\n    while (bin.length < S2.FACE_BITS + S2.POS_BITS) {\n      bin += '0';\n    }\n    return Long.fromString(bin, true, 2).toString(10);\n  };\n  S2.keyToId = S2.S2Cell.keyToId = S2.toId = S2.toCellId = S2.fromKey = function (key) {\n    var parts = key.split('/');\n    return S2.fromFacePosLevel(parts[0], parts[1], parts[1].length);\n  };\n  S2.idToKey = S2.S2Cell.idToKey = S2.S2Cell.toKey = S2.toKey = S2.fromId = S2.fromCellId = S2.S2Cell.toHilbertQuadkey = S2.toHilbertQuadkey = function (idS) {\n    var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n    var bin = Long.fromString(idS, true, 10).toString(2);\n    while (bin.length < S2.FACE_BITS + S2.POS_BITS) {\n      bin = '0' + bin;\n    }\n\n    // MUST come AFTER binstr has been left-padded with '0's\n    var lsbIndex = bin.lastIndexOf('1');\n    // substr(start, len)\n    // substring(start, end) // includes start, does not include end\n    var faceB = bin.substring(0, 3);\n    // posB will always be a multiple of 2 (or it's invalid)\n    var posB = bin.substring(3, lsbIndex);\n    var levelN = posB.length / 2;\n    var faceS = Long.fromString(faceB, true, 2).toString(10);\n    var posS = Long.fromString(posB, true, 2).toString(4);\n    while (posS.length < levelN) {\n      posS = '0' + posS;\n    }\n    return faceS + '/' + posS;\n  };\n  S2.keyToLatLng = S2.S2Cell.keyToLatLng = function (key) {\n    var cell2 = S2.S2Cell.FromHilbertQuadKey(key);\n    return cell2.getLatLng();\n  };\n  S2.idToLatLng = S2.S2Cell.idToLatLng = function (id) {\n    var key = S2.idToKey(id);\n    return S2.keyToLatLng(key);\n  };\n  S2.S2Cell.latLngToKey = S2.latLngToKey = S2.latLngToQuadkey = function (lat, lng, level) {\n    if (isNaN(level) || level < 1 || level > 30) {\n      throw new Error(\"'level' is not a number between 1 and 30 (but it should be)\");\n    }\n    // TODO\n    //\n    // S2.idToLatLng(id)\n    // S2.keyToLatLng(key)\n    // S2.nextFace(key)     // prevent wrapping on nextKey\n    // S2.prevFace(key)     // prevent wrapping on prevKey\n    //\n    // .toKeyArray(id)  // face,quadtree\n    // .toKey(id)       // hilbert\n    // .toPoint(id)     // ij\n    // .toId(key)       // uint64 (as string)\n    // .toLong(key)     // long.js\n    // .toLatLng(id)    // object? or array?, or string (with comma)?\n    //\n    // maybe S2.HQ.x, S2.GPS.x, S2.CI.x?\n    return S2.S2Cell.FromLatLng({\n      lat: lat,\n      lng: lng\n    }, level).toHilbertQuadkey();\n  };\n  S2.stepKey = function (key, num) {\n    var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n    var parts = key.split('/');\n    var faceS = parts[0];\n    var posS = parts[1];\n    var level = parts[1].length;\n    var posL = Long.fromString(posS, true, 4);\n    // TODO handle wrapping (0 === pos + 1)\n    // (only on the 12 edges of the globe)\n    var otherL;\n    if (num > 0) {\n      otherL = posL.add(Math.abs(num));\n    } else if (num < 0) {\n      otherL = posL.subtract(Math.abs(num));\n    }\n    var otherS = otherL.toString(4);\n    if ('0' === otherS) {\n      console.warning(new Error(\"face/position wrapping is not yet supported\"));\n    }\n    while (otherS.length < level) {\n      otherS = '0' + otherS;\n    }\n    return faceS + '/' + otherS;\n  };\n  S2.S2Cell.prevKey = S2.prevKey = function (key) {\n    return S2.stepKey(key, -1);\n  };\n  S2.S2Cell.nextKey = S2.nextKey = function (key) {\n    return S2.stepKey(key, 1);\n  };\n})('undefined' !== typeof module ? module.exports : window);","map":{"version":3,"names":["exports","S2","L","LatLng","rawLat","rawLng","noWrap","lat","parseFloat","lng","isNaN","Error","Math","max","min","DEG_TO_RAD","PI","RAD_TO_DEG","LatLngToXYZ","latLng","d2r","phi","theta","cosphi","cos","sin","XYZToLatLng","xyz","r2d","atan2","sqrt","largestAbsComponent","temp","abs","faceXYZToUV","face","u","v","error","XYZToFaceUV","uv","FaceUVToXYZ","singleSTtoUV","st","STToUV","singleUVtoST","UVToST","STToIJ","order","maxSize","singleSTtoIJ","ij","floor","IJToST","offsets","rotateAndFlipQuadrant","n","point","rx","ry","newX","newY","x","y","pointToHilbertQuadList","hilbertMap","console","warn","stack","currentSquare","positions","i","mask","quad_x","quad_y","t","push","S2Cell","FromHilbertQuadKey","hilbertQuadkey","parts","split","parseInt","position","maxLevel","length","level","bit","val","pow","FromFaceIJ","FromLatLng","faceuv","cell","prototype","toString","getLatLng","getCornerLatLngs","result","getFaceAndQuads","quads","toHilbertQuadkey","join","latLngToNeighborKeys","getNeighbors","map","fromFaceIJWrap","j","FACE_BITS","MAX_LEVEL","POS_BITS","facePosLevelToId","fromFacePosLevel","faceN","posS","levelN","Long","dcodeIO","require","faceB","posB","bin","substr","fromString","keyToId","toId","toCellId","fromKey","key","idToKey","toKey","fromId","fromCellId","idS","lsbIndex","lastIndexOf","substring","faceS","keyToLatLng","cell2","idToLatLng","id","latLngToKey","latLngToQuadkey","stepKey","num","posL","otherL","add","subtract","otherS","warning","prevKey","nextKey","module","window"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/s2-geometry/src/s2geometry.js"],"sourcesContent":["/// S2 Geometry functions\n// the regional scoreboard is based on a level 6 S2 Cell\n// - https://docs.google.com/presentation/d/1Hl4KapfAENAOf4gv-pSngKwvS_jwNVHRPZTTDzXXn6Q/view?pli=1#slide=id.i22\n// at the time of writing there's no actual API for the intel map to retrieve scoreboard data,\n// but it's still useful to plot the score cells on the intel map\n\n\n// the S2 geometry is based on projecting the earth sphere onto a cube, with some scaling of face coordinates to\n// keep things close to approximate equal area for adjacent cells\n// to convert a lat,lng into a cell id:\n// - convert lat,lng to x,y,z\n// - convert x,y,z into face,u,v\n// - u,v scaled to s,t with quadratic formula\n// - s,t converted to integer i,j offsets\n// - i,j converted to a position along a Hubbert space-filling curve\n// - combine face,position to get the cell id\n\n//NOTE: compared to the google S2 geometry library, we vary from their code in the following ways\n// - cell IDs: they combine face and the hilbert curve position into a single 64 bit number. this gives efficient space\n//             and speed. javascript doesn't have appropriate data types, and speed is not cricical, so we use\n//             as [face,[bitpair,bitpair,...]] instead\n// - i,j: they always use 30 bits, adjusting as needed. we use 0 to (1<<level)-1 instead\n//        (so GetSizeIJ for a cell is always 1)\n\n(function (exports) {\n'use strict';\n\nvar S2 = exports.S2 = { L: {} };\n\nS2.L.LatLng = function (/*Number*/ rawLat, /*Number*/ rawLng, /*Boolean*/ noWrap) {\n  var lat = parseFloat(rawLat, 10);\n  var lng = parseFloat(rawLng, 10);\n\n  if (isNaN(lat) || isNaN(lng)) {\n    throw new Error('Invalid LatLng object: (' + rawLat + ', ' + rawLng + ')');\n  }\n\n  if (noWrap !== true) {\n    lat = Math.max(Math.min(lat, 90), -90);                 // clamp latitude into -90..90\n    lng = (lng + 180) % 360 + ((lng < -180 || lng === 180) ? 180 : -180);   // wrap longtitude into -180..180\n  }\n\n  return { lat: lat, lng: lng };\n};\n\nS2.L.LatLng.DEG_TO_RAD = Math.PI / 180;\nS2.L.LatLng.RAD_TO_DEG = 180 / Math.PI;\n\n/*\nS2.LatLngToXYZ = function(latLng) {\n  // http://stackoverflow.com/questions/8981943/lat-long-to-x-y-z-position-in-js-not-working\n  var lat = latLng.lat;\n  var lon = latLng.lng;\n  var DEG_TO_RAD = Math.PI / 180.0;\n\n  var phi = lat * DEG_TO_RAD;\n  var theta = lon * DEG_TO_RAD;\n\n  var cosLat = Math.cos(phi);\n  var sinLat = Math.sin(phi);\n  var cosLon = Math.cos(theta);\n  var sinLon = Math.sin(theta);\n  var rad = 500.0;\n\n  return [\n    rad * cosLat * cosLon\n  , rad * cosLat * sinLon\n  , rad * sinLat\n  ];\n};\n*/\nS2.LatLngToXYZ = function(latLng) {\n  var d2r = S2.L.LatLng.DEG_TO_RAD;\n\n  var phi = latLng.lat*d2r;\n  var theta = latLng.lng*d2r;\n\n  var cosphi = Math.cos(phi);\n\n  return [Math.cos(theta)*cosphi, Math.sin(theta)*cosphi, Math.sin(phi)];\n};\n\nS2.XYZToLatLng = function(xyz) {\n  var r2d = S2.L.LatLng.RAD_TO_DEG;\n\n  var lat = Math.atan2(xyz[2], Math.sqrt(xyz[0]*xyz[0]+xyz[1]*xyz[1]));\n  var lng = Math.atan2(xyz[1], xyz[0]);\n\n  return S2.L.LatLng(lat*r2d, lng*r2d);\n};\n\nvar largestAbsComponent = function(xyz) {\n  var temp = [Math.abs(xyz[0]), Math.abs(xyz[1]), Math.abs(xyz[2])];\n\n  if (temp[0] > temp[1]) {\n    if (temp[0] > temp[2]) {\n      return 0;\n    } else {\n      return 2;\n    }\n  } else {\n    if (temp[1] > temp[2]) {\n      return 1;\n    } else {\n      return 2;\n    }\n  }\n\n};\n\nvar faceXYZToUV = function(face,xyz) {\n  var u,v;\n\n  switch (face) {\n    case 0: u =  xyz[1]/xyz[0]; v =  xyz[2]/xyz[0]; break;\n    case 1: u = -xyz[0]/xyz[1]; v =  xyz[2]/xyz[1]; break;\n    case 2: u = -xyz[0]/xyz[2]; v = -xyz[1]/xyz[2]; break;\n    case 3: u =  xyz[2]/xyz[0]; v =  xyz[1]/xyz[0]; break;\n    case 4: u =  xyz[2]/xyz[1]; v = -xyz[0]/xyz[1]; break;\n    case 5: u = -xyz[1]/xyz[2]; v = -xyz[0]/xyz[2]; break;\n    default: throw {error: 'Invalid face'};\n  }\n\n  return [u,v];\n};\n\n\n\n\nS2.XYZToFaceUV = function(xyz) {\n  var face = largestAbsComponent(xyz);\n\n  if (xyz[face] < 0) {\n    face += 3;\n  }\n\n  var uv = faceXYZToUV (face,xyz);\n\n  return [face, uv];\n};\n\nS2.FaceUVToXYZ = function(face,uv) {\n  var u = uv[0];\n  var v = uv[1];\n\n  switch (face) {\n    case 0: return [ 1, u, v];\n    case 1: return [-u, 1, v];\n    case 2: return [-u,-v, 1];\n    case 3: return [-1,-v,-u];\n    case 4: return [ v,-1,-u];\n    case 5: return [ v, u,-1];\n    default: throw {error: 'Invalid face'};\n  }\n};\n\nvar singleSTtoUV = function(st) {\n  if (st >= 0.5) {\n    return (1/3.0) * (4*st*st - 1);\n  } else {\n    return (1/3.0) * (1 - (4*(1-st)*(1-st)));\n  }\n};\n\nS2.STToUV = function(st) {\n  return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];\n};\n\n\nvar singleUVtoST = function(uv) {\n  if (uv >= 0) {\n    return 0.5 * Math.sqrt (1 + 3*uv);\n  } else {\n    return 1 - 0.5 * Math.sqrt (1 - 3*uv);\n  }\n};\nS2.UVToST = function(uv) {\n  return [singleUVtoST(uv[0]), singleUVtoST(uv[1])];\n};\n\n\nS2.STToIJ = function(st,order) {\n  var maxSize = (1<<order);\n\n  var singleSTtoIJ = function(st) {\n    var ij = Math.floor(st * maxSize);\n    return Math.max(0, Math.min(maxSize-1, ij));\n  };\n\n  return [singleSTtoIJ(st[0]), singleSTtoIJ(st[1])];\n};\n\n\nS2.IJToST = function(ij,order,offsets) {\n  var maxSize = (1<<order);\n\n  return [\n    (ij[0]+offsets[0])/maxSize,\n    (ij[1]+offsets[1])/maxSize\n  ];\n};\n\n\n\nvar rotateAndFlipQuadrant = function(n, point, rx, ry)\n{\n\tvar newX, newY;\n\tif(ry == 0)\n\t{\n\t\tif(rx == 1){\n\t\t\tpoint.x = n - 1 - point.x;\n\t\t\tpoint.y = n - 1 - point.y\n\n\t\t}\n\n    var x = point.x;\n\t\tpoint.x = point.y\n\t\tpoint.y = x;\n\t}\n\n}\n\n\n\n\n\n// hilbert space-filling curve\n// based on http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves\n// note: rather then calculating the final integer hilbert position, we just return the list of quads\n// this ensures no precision issues whth large orders (S3 cell IDs use up to 30), and is more\n// convenient for pulling out the individual bits as needed later\nvar pointToHilbertQuadList = function(x,y,order,face) {\n  var hilbertMap = {\n    'a': [ [0,'d'], [1,'a'], [3,'b'], [2,'a'] ],\n    'b': [ [2,'b'], [1,'b'], [3,'a'], [0,'c'] ],\n    'c': [ [2,'c'], [3,'d'], [1,'c'], [0,'b'] ],\n    'd': [ [0,'a'], [3,'c'], [1,'d'], [2,'d'] ]\n  };\n\n  if ('number' !== typeof face) {\n    console.warn(new Error(\"called pointToHilbertQuadList without face value, defaulting to '0'\").stack);\n  }\n  var currentSquare = (face % 2) ? 'd' : 'a';\n  var positions = [];\n\n  for (var i=order-1; i>=0; i--) {\n\n    var mask = 1<<i;\n\n    var quad_x = x&mask ? 1 : 0;\n    var quad_y = y&mask ? 1 : 0;\n\n    var t = hilbertMap[currentSquare][quad_x*2+quad_y];\n\n    positions.push(t[0]);\n\n    currentSquare = t[1];\n  }\n\n  return positions;\n};\n\n// S2Cell class\n\nS2.S2Cell = function(){};\n\nS2.S2Cell.FromHilbertQuadKey = function(hilbertQuadkey) {\n  var parts = hilbertQuadkey.split('/');\n  var face = parseInt(parts[0]);\n  var position = parts[1];\n  var maxLevel = position.length;\n  var point = {\n    x : 0,\n    y: 0\n  };\n  var i;\n  var level;\n  var bit;\n  var rx, ry;\n  var val;\n\n\tfor(i = maxLevel - 1; i >= 0; i--) {\n\n\t\tlevel = maxLevel - i;\n\t\tbit = position[i];\n\t\trx = 0;\n    ry = 0;\n\t\tif (bit === '1') {\n\t\t\try = 1;\n\t\t}\n\t\telse if (bit === '2') {\n\t\t\trx = 1;\n\t\t\try = 1;\n\t\t}\n\t\telse if (bit === '3') {\n\t\t\trx = 1;\n\t\t}\n\n\t\tval = Math.pow(2, level - 1);\n\t\trotateAndFlipQuadrant(val, point, rx, ry);\n\n\t\tpoint.x += val * rx;\n\t\tpoint.y += val * ry;\n\n\t}\n\n  if (face % 2 === 1) {\n    var t = point.x;\n    point.x = point.y;\n    point.y = t;\n  }\n\n\n  return S2.S2Cell.FromFaceIJ(parseInt(face), [point.x, point.y], level);\n};\n\n//static method to construct\nS2.S2Cell.FromLatLng = function(latLng, level) {\n  if ((!latLng.lat && latLng.lat !== 0) || (!latLng.lng && latLng.lng !== 0)) {\n    throw new Error(\"Pass { lat: lat, lng: lng } to S2.S2Cell.FromLatLng\");\n  }\n  var xyz = S2.LatLngToXYZ(latLng);\n\n  var faceuv = S2.XYZToFaceUV(xyz);\n  var st = S2.UVToST(faceuv[1]);\n\n  var ij = S2.STToIJ(st,level);\n\n  return S2.S2Cell.FromFaceIJ (faceuv[0], ij, level);\n};\n\n/*\nS2.faceIjLevelToXyz = function (face, ij, level) {\n  var st = S2.IJToST(ij, level, [0.5, 0.5]);\n  var uv = S2.STToUV(st);\n  var xyz = S2.FaceUVToXYZ(face, uv);\n\n  return S2.XYZToLatLng(xyz);\n  return xyz;\n};\n*/\n\nS2.S2Cell.FromFaceIJ = function(face,ij,level) {\n  var cell = new S2.S2Cell();\n  cell.face = face;\n  cell.ij = ij;\n  cell.level = level;\n\n  return cell;\n};\n\n\nS2.S2Cell.prototype.toString = function() {\n  return 'F'+this.face+'ij['+this.ij[0]+','+this.ij[1]+']@'+this.level;\n};\n\nS2.S2Cell.prototype.getLatLng = function() {\n  var st = S2.IJToST(this.ij,this.level, [0.5,0.5]);\n  var uv = S2.STToUV(st);\n  var xyz = S2.FaceUVToXYZ(this.face, uv);\n\n  return S2.XYZToLatLng(xyz);\n};\n\nS2.S2Cell.prototype.getCornerLatLngs = function() {\n  var result = [];\n  var offsets = [\n    [ 0.0, 0.0 ],\n    [ 0.0, 1.0 ],\n    [ 1.0, 1.0 ],\n    [ 1.0, 0.0 ]\n  ];\n\n  for (var i=0; i<4; i++) {\n    var st = S2.IJToST(this.ij, this.level, offsets[i]);\n    var uv = S2.STToUV(st);\n    var xyz = S2.FaceUVToXYZ(this.face, uv);\n\n    result.push ( S2.XYZToLatLng(xyz) );\n  }\n  return result;\n};\n\n\nS2.S2Cell.prototype.getFaceAndQuads = function () {\n  var quads = pointToHilbertQuadList(this.ij[0], this.ij[1], this.level, this.face);\n\n  return [this.face,quads];\n};\nS2.S2Cell.prototype.toHilbertQuadkey = function () {\n  var quads = pointToHilbertQuadList(this.ij[0], this.ij[1], this.level, this.face);\n\n  return this.face.toString(10) + '/' + quads.join('');\n};\n\nS2.latLngToNeighborKeys = S2.S2Cell.latLngToNeighborKeys = function (lat, lng, level) {\n  return S2.S2Cell.FromLatLng({ lat: lat, lng: lng }, level).getNeighbors().map(function (cell) {\n    return cell.toHilbertQuadkey();\n  });\n};\nS2.S2Cell.prototype.getNeighbors = function() {\n\n  var fromFaceIJWrap = function(face,ij,level) {\n    var maxSize = (1<<level);\n    if (ij[0]>=0 && ij[1]>=0 && ij[0]<maxSize && ij[1]<maxSize) {\n      // no wrapping out of bounds\n      return S2.S2Cell.FromFaceIJ(face,ij,level);\n    } else {\n      // the new i,j are out of range.\n      // with the assumption that they're only a little past the borders we can just take the points as\n      // just beyond the cube face, project to XYZ, then re-create FaceUV from the XYZ vector\n\n      var st = S2.IJToST(ij,level,[0.5,0.5]);\n      var uv = S2.STToUV(st);\n      var xyz = S2.FaceUVToXYZ(face,uv);\n      var faceuv = S2.XYZToFaceUV(xyz);\n      face = faceuv[0];\n      uv = faceuv[1];\n      st = S2.UVToST(uv);\n      ij = S2.STToIJ(st,level);\n      return S2.S2Cell.FromFaceIJ (face, ij, level);\n    }\n  };\n\n  var face = this.face;\n  var i = this.ij[0];\n  var j = this.ij[1];\n  var level = this.level;\n\n\n  return [\n    fromFaceIJWrap(face, [i-1,j], level),\n    fromFaceIJWrap(face, [i,j-1], level),\n    fromFaceIJWrap(face, [i+1,j], level),\n    fromFaceIJWrap(face, [i,j+1], level)\n  ];\n\n};\n\n//\n// Functional Style\n//\nS2.FACE_BITS = 3;\nS2.MAX_LEVEL = 30;\nS2.POS_BITS = (2 * S2.MAX_LEVEL) + 1; // 61 (60 bits of data, 1 bit lsb marker)\n\nS2.facePosLevelToId = S2.S2Cell.facePosLevelToId = S2.fromFacePosLevel = function (faceN, posS, levelN) {\n  var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n  var faceB;\n  var posB;\n  var bin;\n\n  if (!levelN) {\n    levelN = posS.length;\n  }\n  if (posS.length > levelN) {\n    posS = posS.substr(0, levelN);\n  }\n\n  // 3-bit face value\n  faceB = Long.fromString(faceN.toString(10), true, 10).toString(2);\n  while (faceB.length < S2.FACE_BITS) {\n    faceB = '0' + faceB;\n  }\n\n  // 60-bit position value\n  posB = Long.fromString(posS, true, 4).toString(2);\n  while (posB.length < (2 * levelN)) {\n    posB = '0' + posB;\n  }\n\n  bin = faceB + posB;\n  // 1-bit lsb marker\n  bin += '1';\n  // n-bit padding to 64-bits\n  while (bin.length < (S2.FACE_BITS + S2.POS_BITS)) {\n    bin += '0';\n  }\n\n  return Long.fromString(bin, true, 2).toString(10);\n};\n\nS2.keyToId = S2.S2Cell.keyToId\n= S2.toId = S2.toCellId = S2.fromKey\n= function (key) {\n  var parts = key.split('/');\n\n  return S2.fromFacePosLevel(parts[0], parts[1], parts[1].length);\n};\n\nS2.idToKey = S2.S2Cell.idToKey\n= S2.S2Cell.toKey = S2.toKey\n= S2.fromId = S2.fromCellId\n= S2.S2Cell.toHilbertQuadkey  = S2.toHilbertQuadkey\n= function (idS) {\n  var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n  var bin = Long.fromString(idS, true, 10).toString(2);\n\n  while (bin.length < (S2.FACE_BITS + S2.POS_BITS)) {\n    bin = '0' + bin;\n  }\n\n  // MUST come AFTER binstr has been left-padded with '0's\n  var lsbIndex = bin.lastIndexOf('1');\n  // substr(start, len)\n  // substring(start, end) // includes start, does not include end\n  var faceB = bin.substring(0, 3);\n  // posB will always be a multiple of 2 (or it's invalid)\n  var posB = bin.substring(3, lsbIndex);\n  var levelN = posB.length / 2;\n\n  var faceS = Long.fromString(faceB, true, 2).toString(10);\n  var posS = Long.fromString(posB, true, 2).toString(4);\n\n  while (posS.length < levelN) {\n    posS = '0' + posS;\n  }\n\n  return faceS + '/' + posS;\n};\n\nS2.keyToLatLng = S2.S2Cell.keyToLatLng = function (key) {\n  var cell2 = S2.S2Cell.FromHilbertQuadKey(key);\n  return cell2.getLatLng();\n};\n\nS2.idToLatLng = S2.S2Cell.idToLatLng = function (id) {\n  var key = S2.idToKey(id);\n  return S2.keyToLatLng(key);\n};\n\nS2.S2Cell.latLngToKey = S2.latLngToKey\n= S2.latLngToQuadkey = function (lat, lng, level) {\n  if (isNaN(level) || level < 1 || level > 30) {\n    throw new Error(\"'level' is not a number between 1 and 30 (but it should be)\");\n  }\n  // TODO\n  //\n  // S2.idToLatLng(id)\n  // S2.keyToLatLng(key)\n  // S2.nextFace(key)     // prevent wrapping on nextKey\n  // S2.prevFace(key)     // prevent wrapping on prevKey\n  //\n  // .toKeyArray(id)  // face,quadtree\n  // .toKey(id)       // hilbert\n  // .toPoint(id)     // ij\n  // .toId(key)       // uint64 (as string)\n  // .toLong(key)     // long.js\n  // .toLatLng(id)    // object? or array?, or string (with comma)?\n  //\n  // maybe S2.HQ.x, S2.GPS.x, S2.CI.x?\n  return S2.S2Cell.FromLatLng({ lat: lat, lng: lng }, level).toHilbertQuadkey();\n};\n\nS2.stepKey = function (key, num) {\n  var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n  var parts = key.split('/');\n\n  var faceS = parts[0];\n  var posS = parts[1];\n  var level = parts[1].length;\n\n  var posL = Long.fromString(posS, true, 4);\n  // TODO handle wrapping (0 === pos + 1)\n  // (only on the 12 edges of the globe)\n  var otherL;\n  if (num > 0) {\n    otherL = posL.add(Math.abs(num));\n  }\n  else if (num < 0) {\n    otherL = posL.subtract(Math.abs(num));\n  }\n  var otherS = otherL.toString(4);\n\n  if ('0' === otherS) {\n    console.warning(new Error(\"face/position wrapping is not yet supported\"));\n  }\n\n  while (otherS.length < level) {\n    otherS = '0' + otherS;\n  }\n\n  return faceS + '/' + otherS;\n};\n\nS2.S2Cell.prevKey = S2.prevKey = function (key) {\n  return S2.stepKey(key, -1);\n};\n\nS2.S2Cell.nextKey = S2.nextKey = function (key) {\n  return S2.stepKey(key, 1);\n};\n\n})('undefined' !== typeof module ? module.exports : window);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}