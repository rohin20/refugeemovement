{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport MultiIconLayer from './multi-icon-layer/multi-icon-layer';\nimport FontAtlasManager, { DEFAULT_FONT_SETTINGS, setFontAtlasCacheLimit } from './font-atlas-manager';\nimport { transformParagraph, getTextFromBuffer } from './utils';\nimport TextBackgroundLayer from './text-background-layer/text-background-layer';\nvar TEXT_ANCHOR = {\n  start: 1,\n  middle: 0,\n  end: -1\n};\nvar ALIGNMENT_BASELINE = {\n  top: 1,\n  center: 0,\n  bottom: -1\n};\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar DEFAULT_LINE_HEIGHT = 1.0;\nvar defaultProps = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n  background: false,\n  getBackgroundColor: {\n    type: 'accessor',\n    value: [255, 255, 255, 255]\n  },\n  getBorderColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getBorderWidth: {\n    type: 'accessor',\n    value: 0\n  },\n  backgroundPadding: {\n    type: 'array',\n    value: [0, 0, 0, 0]\n  },\n  characterSet: {\n    type: 'object',\n    value: DEFAULT_FONT_SETTINGS.characterSet\n  },\n  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,\n  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,\n  lineHeight: DEFAULT_LINE_HEIGHT,\n  outlineWidth: {\n    type: 'number',\n    value: 0,\n    min: 0\n  },\n  outlineColor: {\n    type: 'color',\n    value: DEFAULT_COLOR\n  },\n  fontSettings: {},\n  wordBreak: 'break-word',\n  maxWidth: {\n    type: 'number',\n    value: -1\n  },\n  getText: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.text;\n    }\n  },\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 32\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getTextAnchor: {\n    type: 'accessor',\n    value: 'middle'\n  },\n  getAlignmentBaseline: {\n    type: 'accessor',\n    value: 'center'\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  backgroundColor: {\n    deprecatedFor: ['background', 'getBackgroundColor']\n  }\n};\nvar TextLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(TextLayer, _CompositeLayer);\n  var _super = _createSuper(TextLayer);\n  function TextLayer() {\n    var _this;\n    _classCallCheck(this, TextLayer);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"state\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"getBoundingRect\", function (object, objectInfo) {\n      var iconMapping = _this.state.fontAtlasManager.mapping;\n      var getText = _this.state.getText;\n      var _this$props = _this.props,\n        wordBreak = _this$props.wordBreak,\n        maxWidth = _this$props.maxWidth,\n        lineHeight = _this$props.lineHeight,\n        getTextAnchor = _this$props.getTextAnchor,\n        getAlignmentBaseline = _this$props.getAlignmentBaseline;\n      var paragraph = getText(object, objectInfo) || '';\n      var _transformParagraph = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping),\n        _transformParagraph$s = _slicedToArray(_transformParagraph.size, 2),\n        width = _transformParagraph$s[0],\n        height = _transformParagraph$s[1];\n      var anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];\n      var anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];\n      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getIconOffsets\", function (object, objectInfo) {\n      var iconMapping = _this.state.fontAtlasManager.mapping;\n      var getText = _this.state.getText;\n      var _this$props2 = _this.props,\n        wordBreak = _this$props2.wordBreak,\n        maxWidth = _this$props2.maxWidth,\n        lineHeight = _this$props2.lineHeight,\n        getTextAnchor = _this$props2.getTextAnchor,\n        getAlignmentBaseline = _this$props2.getAlignmentBaseline;\n      var paragraph = getText(object, objectInfo) || '';\n      var _transformParagraph2 = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping),\n        x = _transformParagraph2.x,\n        y = _transformParagraph2.y,\n        rowWidth = _transformParagraph2.rowWidth,\n        _transformParagraph2$ = _slicedToArray(_transformParagraph2.size, 2),\n        width = _transformParagraph2$[0],\n        height = _transformParagraph2$[1];\n      var anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];\n      var anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];\n      var numCharacters = x.length;\n      var offsets = new Array(numCharacters * 2);\n      var index = 0;\n      for (var i = 0; i < numCharacters; i++) {\n        var rowOffset = (1 - anchorX) * (width - rowWidth[i]) / 2;\n        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x[i];\n        offsets[index++] = (anchorY - 1) * height / 2 + y[i];\n      }\n      return offsets;\n    });\n    return _this;\n  }\n  _createClass(TextLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        styleVersion: 0,\n        fontAtlasManager: new FontAtlasManager()\n      };\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(params) {\n      var props = params.props,\n        oldProps = params.oldProps,\n        changeFlags = params.changeFlags;\n      var textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);\n      if (textChanged) {\n        this._updateText();\n      }\n      var fontChanged = this._updateFontAtlas();\n      var styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;\n      if (styleChanged) {\n        this.setState({\n          styleVersion: this.state.styleVersion + 1\n        });\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref) {\n      var info = _ref.info;\n      info.object = info.index >= 0 ? this.props.data[info.index] : null;\n      return info;\n    }\n  }, {\n    key: \"_updateFontAtlas\",\n    value: function _updateFontAtlas() {\n      var _this$props3 = this.props,\n        fontSettings = _this$props3.fontSettings,\n        fontFamily = _this$props3.fontFamily,\n        fontWeight = _this$props3.fontWeight;\n      var _this$state = this.state,\n        fontAtlasManager = _this$state.fontAtlasManager,\n        characterSet = _this$state.characterSet;\n      var fontProps = _objectSpread(_objectSpread({}, fontSettings), {}, {\n        characterSet: characterSet,\n        fontFamily: fontFamily,\n        fontWeight: fontWeight\n      });\n      if (!fontAtlasManager.mapping) {\n        fontAtlasManager.setProps(fontProps);\n        return true;\n      }\n      for (var key in fontProps) {\n        if (fontProps[key] !== fontAtlasManager.props[key]) {\n          fontAtlasManager.setProps(fontProps);\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"_updateText\",\n    value: function _updateText() {\n      var _attributes;\n      var _this$props4 = this.props,\n        data = _this$props4.data,\n        characterSet = _this$props4.characterSet;\n      var textBuffer = (_attributes = data.attributes) === null || _attributes === void 0 ? void 0 : _attributes.getText;\n      var getText = this.props.getText;\n      var startIndices = data.startIndices;\n      var numInstances;\n      var autoCharacterSet = characterSet === 'auto' && new Set();\n      if (textBuffer && startIndices) {\n        var _getTextFromBuffer = getTextFromBuffer(_objectSpread(_objectSpread({}, ArrayBuffer.isView(textBuffer) ? {\n            value: textBuffer\n          } : textBuffer), {}, {\n            length: data.length,\n            startIndices: startIndices,\n            characterSet: autoCharacterSet\n          })),\n          texts = _getTextFromBuffer.texts,\n          characterCount = _getTextFromBuffer.characterCount;\n        numInstances = characterCount;\n        getText = function getText(_, _ref2) {\n          var index = _ref2.index;\n          return texts[index];\n        };\n      } else {\n        var _createIterable = createIterable(data),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n        startIndices = [0];\n        numInstances = 0;\n        var _iterator = _createForOfIteratorHelper(iterable),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var object = _step.value;\n            objectInfo.index++;\n            var text = Array.from(getText(object, objectInfo) || '');\n            if (autoCharacterSet) {\n              text.forEach(autoCharacterSet.add, autoCharacterSet);\n            }\n            numInstances += text.length;\n            startIndices.push(numInstances);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      this.setState({\n        getText: getText,\n        startIndices: startIndices,\n        numInstances: numInstances,\n        characterSet: autoCharacterSet || characterSet\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this$state2 = this.state,\n        startIndices = _this$state2.startIndices,\n        numInstances = _this$state2.numInstances,\n        getText = _this$state2.getText,\n        _this$state2$fontAtla = _this$state2.fontAtlasManager,\n        scale = _this$state2$fontAtla.scale,\n        texture = _this$state2$fontAtla.texture,\n        mapping = _this$state2$fontAtla.mapping,\n        styleVersion = _this$state2.styleVersion;\n      var _this$props5 = this.props,\n        data = _this$props5.data,\n        _dataDiff = _this$props5._dataDiff,\n        getPosition = _this$props5.getPosition,\n        getColor = _this$props5.getColor,\n        getSize = _this$props5.getSize,\n        getAngle = _this$props5.getAngle,\n        getPixelOffset = _this$props5.getPixelOffset,\n        getBackgroundColor = _this$props5.getBackgroundColor,\n        getBorderColor = _this$props5.getBorderColor,\n        getBorderWidth = _this$props5.getBorderWidth,\n        backgroundPadding = _this$props5.backgroundPadding,\n        background = _this$props5.background,\n        billboard = _this$props5.billboard,\n        fontSettings = _this$props5.fontSettings,\n        outlineWidth = _this$props5.outlineWidth,\n        outlineColor = _this$props5.outlineColor,\n        sizeScale = _this$props5.sizeScale,\n        sizeUnits = _this$props5.sizeUnits,\n        sizeMinPixels = _this$props5.sizeMinPixels,\n        sizeMaxPixels = _this$props5.sizeMaxPixels,\n        transitions = _this$props5.transitions,\n        updateTriggers = _this$props5.updateTriggers;\n      var CharactersLayerClass = this.getSubLayerClass('characters', MultiIconLayer);\n      var BackgroundLayerClass = this.getSubLayerClass('background', TextBackgroundLayer);\n      return [background && new BackgroundLayerClass({\n        getFillColor: getBackgroundColor,\n        getLineColor: getBorderColor,\n        getLineWidth: getBorderWidth,\n        padding: backgroundPadding,\n        getPosition: getPosition,\n        getSize: getSize,\n        getAngle: getAngle,\n        getPixelOffset: getPixelOffset,\n        billboard: billboard,\n        sizeScale: sizeScale / this.state.fontAtlasManager.props.fontSize,\n        sizeUnits: sizeUnits,\n        sizeMinPixels: sizeMinPixels,\n        sizeMaxPixels: sizeMaxPixels,\n        transitions: transitions && {\n          getPosition: transitions.getPosition,\n          getAngle: transitions.getAngle,\n          getSize: transitions.getSize,\n          getFillColor: transitions.getBackgroundColor,\n          getLineColor: transitions.getBorderColor,\n          getLineWidth: transitions.getBorderWidth,\n          getPixelOffset: transitions.getPixelOffset\n        }\n      }, this.getSubLayerProps({\n        id: 'background',\n        updateTriggers: {\n          getPosition: updateTriggers.getPosition,\n          getAngle: updateTriggers.getAngle,\n          getSize: updateTriggers.getSize,\n          getFillColor: updateTriggers.getBackgroundColor,\n          getLineColor: updateTriggers.getBorderColor,\n          getLineWidth: updateTriggers.getBorderWidth,\n          getPixelOffset: updateTriggers.getPixelOffset,\n          getBoundingRect: {\n            getText: updateTriggers.getText,\n            getTextAnchor: updateTriggers.getTextAnchor,\n            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n            styleVersion: styleVersion\n          }\n        }\n      }), {\n        data: data.attributes && data.attributes.background ? {\n          length: data.length,\n          attributes: data.attributes.background\n        } : data,\n        _dataDiff: _dataDiff,\n        autoHighlight: false,\n        getBoundingRect: this.getBoundingRect\n      }), new CharactersLayerClass({\n        sdf: fontSettings.sdf,\n        smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,\n        outlineWidth: outlineWidth,\n        outlineColor: outlineColor,\n        iconAtlas: texture,\n        iconMapping: mapping,\n        getPosition: getPosition,\n        getColor: getColor,\n        getSize: getSize,\n        getAngle: getAngle,\n        getPixelOffset: getPixelOffset,\n        billboard: billboard,\n        sizeScale: sizeScale * scale,\n        sizeUnits: sizeUnits,\n        sizeMinPixels: sizeMinPixels * scale,\n        sizeMaxPixels: sizeMaxPixels * scale,\n        transitions: transitions && {\n          getPosition: transitions.getPosition,\n          getAngle: transitions.getAngle,\n          getColor: transitions.getColor,\n          getSize: transitions.getSize,\n          getPixelOffset: transitions.getPixelOffset\n        }\n      }, this.getSubLayerProps({\n        id: 'characters',\n        updateTriggers: {\n          getIcon: updateTriggers.getText,\n          getPosition: updateTriggers.getPosition,\n          getAngle: updateTriggers.getAngle,\n          getColor: updateTriggers.getColor,\n          getSize: updateTriggers.getSize,\n          getPixelOffset: updateTriggers.getPixelOffset,\n          getIconOffsets: {\n            getText: updateTriggers.getText,\n            getTextAnchor: updateTriggers.getTextAnchor,\n            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n            styleVersion: styleVersion\n          }\n        }\n      }), {\n        data: data,\n        _dataDiff: _dataDiff,\n        startIndices: startIndices,\n        numInstances: numInstances,\n        getIconOffsets: this.getIconOffsets,\n        getIcon: getText\n      })];\n    }\n  }], [{\n    key: \"fontAtlasCacheLimit\",\n    set: function set(limit) {\n      setFontAtlasCacheLimit(limit);\n    }\n  }]);\n  return TextLayer;\n}(CompositeLayer);\nexport { TextLayer as default };\n_defineProperty(TextLayer, \"defaultProps\", defaultProps);\n_defineProperty(TextLayer, \"layerName\", 'TextLayer');","map":{"version":3,"names":["CompositeLayer","createIterable","MultiIconLayer","FontAtlasManager","DEFAULT_FONT_SETTINGS","setFontAtlasCacheLimit","transformParagraph","getTextFromBuffer","TextBackgroundLayer","TEXT_ANCHOR","start","middle","end","ALIGNMENT_BASELINE","top","center","bottom","DEFAULT_COLOR","DEFAULT_LINE_HEIGHT","defaultProps","billboard","sizeScale","sizeUnits","sizeMinPixels","sizeMaxPixels","Number","MAX_SAFE_INTEGER","background","getBackgroundColor","type","value","getBorderColor","getBorderWidth","backgroundPadding","characterSet","fontFamily","fontWeight","lineHeight","outlineWidth","min","outlineColor","fontSettings","wordBreak","maxWidth","getText","x","text","getPosition","position","getColor","getSize","getAngle","getTextAnchor","getAlignmentBaseline","getPixelOffset","backgroundColor","deprecatedFor","TextLayer","_CompositeLayer","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","_defineProperty","_assertThisInitialized","object","objectInfo","iconMapping","state","fontAtlasManager","mapping","_this$props","props","paragraph","_transformParagraph","_transformParagraph$s","_slicedToArray","size","width","height","anchorX","anchorY","_this$props2","_transformParagraph2","y","rowWidth","_transformParagraph2$","numCharacters","offsets","index","i","rowOffset","_createClass","key","initializeState","styleVersion","updateState","params","oldProps","changeFlags","textChanged","dataChanged","updateTriggersChanged","all","_updateText","fontChanged","_updateFontAtlas","styleChanged","setState","getPickingInfo","_ref","info","data","_this$props3","_this$state","fontProps","_objectSpread","setProps","_attributes","_this$props4","textBuffer","attributes","startIndices","numInstances","autoCharacterSet","Set","_getTextFromBuffer","ArrayBuffer","isView","texts","characterCount","_","_ref2","_createIterable","iterable","_iterator","_createForOfIteratorHelper","_step","s","n","done","from","forEach","add","push","err","e","f","renderLayers","_this$state2","_this$state2$fontAtla","scale","texture","_this$props5","_dataDiff","transitions","updateTriggers","CharactersLayerClass","getSubLayerClass","BackgroundLayerClass","getFillColor","getLineColor","getLineWidth","padding","fontSize","getSubLayerProps","id","getBoundingRect","autoHighlight","sdf","smoothing","isFinite","iconAtlas","getIcon","getIconOffsets","set","limit","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/layers/src/text-layer/text-layer.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer, createIterable} from '@deck.gl/core';\nimport MultiIconLayer from './multi-icon-layer/multi-icon-layer';\nimport FontAtlasManager, {\n  DEFAULT_FONT_SETTINGS,\n  setFontAtlasCacheLimit\n} from './font-atlas-manager';\nimport {transformParagraph, getTextFromBuffer} from './utils';\n\nimport TextBackgroundLayer from './text-background-layer/text-background-layer';\n\nimport type {FontSettings} from './font-atlas-manager';\nimport type {\n  LayerProps,\n  Accessor,\n  AccessorFunction,\n  Unit,\n  Position,\n  Color,\n  UpdateParameters,\n  GetPickingInfoParams,\n  PickingInfo,\n  DefaultProps\n} from '@deck.gl/core';\n\nconst TEXT_ANCHOR = {\n  start: 1,\n  middle: 0,\n  end: -1\n} as const;\n\nconst ALIGNMENT_BASELINE = {\n  top: 1,\n  center: 0,\n  bottom: -1\n} as const;\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\nconst DEFAULT_LINE_HEIGHT = 1.0;\n\ntype _TextLayerProps<DataT> = {\n  /** If `true`, the text always faces camera. Otherwise the text faces up (z).\n   * @default true\n   */\n  billboard?: boolean;\n  /**\n   * Text size multiplier.\n   * @default 1\n   */\n  sizeScale?: number;\n  /**\n   * The units of the size, one of `'meters'`, `'common'`, and `'pixels'`.\n   * @default 'pixels'\n   */\n  sizeUnits?: Unit;\n  /**\n   * The minimum size in pixels. When using non-pixel `sizeUnits`, this prop can be used to prevent the icon from getting too small when zoomed out.\n   * @default 0\n   */\n  sizeMinPixels?: number;\n  /**\n   * The maximum size in pixels. When using non-pixel `sizeUnits`, this prop can be used to prevent the icon from getting too big when zoomed in.\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  sizeMaxPixels?: number;\n\n  /** Whether to render background for the text blocks.\n   * @default false\n   */\n  background?: boolean;\n  /** Background color accessor.\n   * @default [255, 255, 255, 255]\n   */\n  getBackgroundColor?: Accessor<DataT, Color>;\n  /** Border color accessor.\n   * @default [0, 0, 0, 255]\n   */\n  getBorderColor?: Accessor<DataT, Color>;\n  /** Border width accessor.\n   * @default 0\n   */\n  getBorderWidth?: Accessor<DataT, number>;\n  /**\n   * The padding of the background..\n   * If an array of 2 is supplied, it is interpreted as `[padding_x, padding_y]` in pixels.\n   * If an array of 4 is supplied, it is interpreted as `[padding_left, padding_top, padding_right, padding_bottom]` in pixels.\n   * @default [0, 0, 0, 0]\n   */\n  backgroundPadding?: [number, number] | [number, number, number, number];\n  /**\n   * Specifies a list of characters to include in the font. If set to 'auto', will be automatically generated from the data set.\n   * @default (ASCII characters 32-128)\n   */\n  characterSet?: FontSettings['characterSet'] | 'auto';\n  /** CSS font family\n   * @default 'Monaco, monospace'\n   */\n  fontFamily?: FontSettings['fontFamily'];\n  /** CSS font weight\n   * @default 'normal'\n   */\n  fontWeight?: FontSettings['fontWeight'];\n  /** A unitless number that will be multiplied with the current font size to set the line height.\n   * @default 'normal'\n   */\n  lineHeight?: number;\n  /**\n   * Width of outline around the text, relative to the font size. Only effective if `fontSettings.sdf` is `true`.\n   * @default 0\n   */\n  outlineWidth?: number;\n  /**\n   * Color of outline around the text, in `[r, g, b, [a]]`. Each channel is a number between 0-255 and `a` is 255 if not supplied.\n   * @default [0, 0, 0, 255]\n   */\n  outlineColor?: Color;\n  /**\n   * Advance options for fine tuning the appearance and performance of the generated shared `fontAtlas`.\n   */\n  fontSettings?: FontSettings;\n  /**\n   * Available options are `break-all` and `break-word`. A valid `maxWidth` has to be provided to use `wordBreak`.\n   * @default 'break-word'\n   */\n  wordBreak?: 'break-word' | 'break-all';\n  /**\n   * `maxWidth` is used together with `break-word` for wrapping text. The value of `maxWidth` specifies the width limit to break the text into multiple lines.\n   * @default -1\n   */\n  maxWidth?: number;\n  /**\n   * Label text accessor\n   */\n  getText?: AccessorFunction<DataT, string>;\n  /**\n   * Anchor position accessor\n   */\n  getPosition?: Accessor<DataT, Position>;\n  /**\n   * Label color accessor\n   * @default [0, 0, 0, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /**\n   * Label size accessor\n   * @default 32\n   */\n  getSize?: Accessor<DataT, number>;\n  /**\n   * Label rotation accessor, in degrees\n   * @default 0\n   */\n  getAngle?: Accessor<DataT, number>;\n  /**\n   * Horizontal alignment accessor\n   * @default 'middle'\n   */\n  getTextAnchor?: Accessor<DataT, 'start' | 'middle' | 'end'>;\n  /**\n   * Vertical alignment accessor\n   * @default 'center'\n   */\n  getAlignmentBaseline?: Accessor<DataT, 'top' | 'center' | 'bottom'>;\n  /**\n   * Label offset from the anchor position, [x, y] in pixels\n   * @default [0, 0]\n   */\n  getPixelOffset?: Accessor<DataT, [number, number]>;\n  /**\n   * @deprecated Use `background` and `getBackgroundColor` instead\n   */\n  backgroundColor?: Color;\n};\n\nexport type TextLayerProps<DataT = any> = _TextLayerProps<DataT> & LayerProps<DataT>;\n\nconst defaultProps: DefaultProps<TextLayerProps> = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n\n  background: false,\n  getBackgroundColor: {type: 'accessor', value: [255, 255, 255, 255]},\n  getBorderColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getBorderWidth: {type: 'accessor', value: 0},\n  backgroundPadding: {type: 'array', value: [0, 0, 0, 0]},\n\n  characterSet: {type: 'object', value: DEFAULT_FONT_SETTINGS.characterSet},\n  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,\n  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,\n  lineHeight: DEFAULT_LINE_HEIGHT,\n  outlineWidth: {type: 'number', value: 0, min: 0},\n  outlineColor: {type: 'color', value: DEFAULT_COLOR},\n  fontSettings: {},\n\n  // auto wrapping options\n  wordBreak: 'break-word',\n  maxWidth: {type: 'number', value: -1},\n\n  getText: {type: 'accessor', value: x => x.text},\n  getPosition: {type: 'accessor', value: x => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getSize: {type: 'accessor', value: 32},\n  getAngle: {type: 'accessor', value: 0},\n  getTextAnchor: {type: 'accessor', value: 'middle'},\n  getAlignmentBaseline: {type: 'accessor', value: 'center'},\n  getPixelOffset: {type: 'accessor', value: [0, 0]},\n\n  // deprecated\n  backgroundColor: {deprecatedFor: ['background', 'getBackgroundColor']}\n};\n\n/** Render text labels at given coordinates. */\nexport default class TextLayer<DataT = any, ExtraPropsT = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_TextLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'TextLayer';\n\n  state!: {\n    styleVersion: number;\n    fontAtlasManager: FontAtlasManager;\n    characterSet?: Set<string>;\n    startIndices?: number[];\n    numInstances?: number;\n    getText?: AccessorFunction<DataT, string>;\n  };\n\n  initializeState() {\n    this.state = {\n      styleVersion: 0,\n      fontAtlasManager: new FontAtlasManager()\n    };\n  }\n\n  // eslint-disable-next-line complexity\n  updateState(params: UpdateParameters<this>) {\n    const {props, oldProps, changeFlags} = params;\n    const textChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText));\n\n    if (textChanged) {\n      this._updateText();\n    }\n\n    const fontChanged = this._updateFontAtlas();\n\n    const styleChanged =\n      fontChanged ||\n      props.lineHeight !== oldProps.lineHeight ||\n      props.wordBreak !== oldProps.wordBreak ||\n      props.maxWidth !== oldProps.maxWidth;\n\n    if (styleChanged) {\n      this.setState({\n        styleVersion: this.state.styleVersion + 1\n      });\n    }\n  }\n\n  getPickingInfo({info}: GetPickingInfoParams): PickingInfo {\n    // because `TextLayer` assign the same pickingInfoIndex for one text label,\n    // here info.index refers the index of text label in props.data\n    info.object = info.index >= 0 ? this.props.data[info.index] : null;\n    return info;\n  }\n\n  /** Returns true if font has changed */\n  private _updateFontAtlas(): boolean {\n    const {fontSettings, fontFamily, fontWeight} = this.props;\n    const {fontAtlasManager, characterSet} = this.state;\n\n    const fontProps = {\n      ...fontSettings,\n      characterSet,\n      fontFamily,\n      fontWeight\n    };\n\n    if (!fontAtlasManager.mapping) {\n      // This is the first update\n      fontAtlasManager.setProps(fontProps);\n      return true;\n    }\n\n    for (const key in fontProps) {\n      if (fontProps[key] !== fontAtlasManager.props[key]) {\n        fontAtlasManager.setProps(fontProps);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // Text strings are variable width objects\n  // Count characters and start offsets\n  private _updateText() {\n    const {data, characterSet} = this.props;\n    const textBuffer = (data as any).attributes?.getText;\n    let {getText} = this.props;\n    let startIndices: number[] = (data as any).startIndices;\n    let numInstances: number;\n\n    const autoCharacterSet = characterSet === 'auto' && new Set();\n\n    if (textBuffer && startIndices) {\n      const {texts, characterCount} = getTextFromBuffer({\n        ...(ArrayBuffer.isView(textBuffer) ? {value: textBuffer} : textBuffer),\n        // @ts-ignore if data.attribute is defined then length is expected\n        length: data.length,\n        startIndices,\n        characterSet: autoCharacterSet\n      });\n      numInstances = characterCount;\n      getText = (_, {index}) => texts[index];\n    } else {\n      const {iterable, objectInfo} = createIterable(data);\n      startIndices = [0];\n      numInstances = 0;\n\n      for (const object of iterable) {\n        objectInfo.index++;\n        // Break into an array of characters\n        // When dealing with double-length unicode characters, `str.length` or `str[i]` do not work\n        const text = Array.from(getText(object, objectInfo) || '');\n        if (autoCharacterSet) {\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          text.forEach(autoCharacterSet.add, autoCharacterSet);\n        }\n        numInstances += text.length;\n        startIndices.push(numInstances);\n      }\n    }\n\n    this.setState({\n      getText,\n      startIndices,\n      numInstances,\n      characterSet: autoCharacterSet || characterSet\n    });\n  }\n\n  // Returns the x, y offsets of each character in a text string\n  private getBoundingRect: AccessorFunction<DataT, [number, number, number, number]> = (\n    object,\n    objectInfo\n  ) => {\n    const iconMapping = this.state.fontAtlasManager.mapping!;\n    const getText = this.state.getText!;\n    const {wordBreak, maxWidth, lineHeight, getTextAnchor, getAlignmentBaseline} = this.props;\n\n    const paragraph = getText(object, objectInfo) || '';\n    const {\n      size: [width, height]\n    } = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping);\n    const anchorX =\n      TEXT_ANCHOR[\n        typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor\n      ];\n    const anchorY =\n      ALIGNMENT_BASELINE[\n        typeof getAlignmentBaseline === 'function'\n          ? getAlignmentBaseline(object, objectInfo)\n          : getAlignmentBaseline\n      ];\n\n    return [((anchorX - 1) * width) / 2, ((anchorY - 1) * height) / 2, width, height];\n  };\n\n  // Returns the x, y, w, h of each text object\n  private getIconOffsets: AccessorFunction<DataT, number[]> = (object, objectInfo) => {\n    const iconMapping = this.state.fontAtlasManager.mapping!;\n    const getText = this.state.getText!;\n    const {wordBreak, maxWidth, lineHeight, getTextAnchor, getAlignmentBaseline} = this.props;\n\n    const paragraph = getText(object, objectInfo) || '';\n    const {\n      x,\n      y,\n      rowWidth,\n      size: [width, height]\n    } = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping);\n    const anchorX =\n      TEXT_ANCHOR[\n        typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor\n      ];\n    const anchorY =\n      ALIGNMENT_BASELINE[\n        typeof getAlignmentBaseline === 'function'\n          ? getAlignmentBaseline(object, objectInfo)\n          : getAlignmentBaseline\n      ];\n\n    const numCharacters = x.length;\n    const offsets = new Array(numCharacters * 2);\n    let index = 0;\n\n    for (let i = 0; i < numCharacters; i++) {\n      // For a multi-line object, offset in x-direction needs consider\n      // the row offset in the paragraph and the object offset in the row\n      const rowOffset = ((1 - anchorX) * (width - rowWidth[i])) / 2;\n      offsets[index++] = ((anchorX - 1) * width) / 2 + rowOffset + x[i];\n      offsets[index++] = ((anchorY - 1) * height) / 2 + y[i];\n    }\n    return offsets;\n  };\n\n  renderLayers() {\n    const {\n      startIndices,\n      numInstances,\n      getText,\n      fontAtlasManager: {scale, texture, mapping},\n      styleVersion\n    } = this.state;\n\n    const {\n      data,\n      _dataDiff,\n      getPosition,\n      getColor,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      getBackgroundColor,\n      getBorderColor,\n      getBorderWidth,\n      backgroundPadding,\n      background,\n      billboard,\n      fontSettings,\n      outlineWidth,\n      outlineColor,\n      sizeScale,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      transitions,\n      updateTriggers\n    } = this.props;\n\n    const CharactersLayerClass = this.getSubLayerClass('characters', MultiIconLayer);\n    const BackgroundLayerClass = this.getSubLayerClass('background', TextBackgroundLayer);\n\n    return [\n      background &&\n        new BackgroundLayerClass(\n          {\n            // background props\n            getFillColor: getBackgroundColor,\n            getLineColor: getBorderColor,\n            getLineWidth: getBorderWidth,\n            padding: backgroundPadding,\n\n            // props shared with characters layer\n            getPosition,\n            getSize,\n            getAngle,\n            getPixelOffset,\n            billboard,\n            sizeScale: sizeScale / this.state.fontAtlasManager.props.fontSize,\n            sizeUnits,\n            sizeMinPixels,\n            sizeMaxPixels,\n\n            transitions: transitions && {\n              getPosition: transitions.getPosition,\n              getAngle: transitions.getAngle,\n              getSize: transitions.getSize,\n              getFillColor: transitions.getBackgroundColor,\n              getLineColor: transitions.getBorderColor,\n              getLineWidth: transitions.getBorderWidth,\n              getPixelOffset: transitions.getPixelOffset\n            }\n          },\n          this.getSubLayerProps({\n            id: 'background',\n            updateTriggers: {\n              getPosition: updateTriggers.getPosition,\n              getAngle: updateTriggers.getAngle,\n              getSize: updateTriggers.getSize,\n              getFillColor: updateTriggers.getBackgroundColor,\n              getLineColor: updateTriggers.getBorderColor,\n              getLineWidth: updateTriggers.getBorderWidth,\n              getPixelOffset: updateTriggers.getPixelOffset,\n              getBoundingRect: {\n                getText: updateTriggers.getText,\n                getTextAnchor: updateTriggers.getTextAnchor,\n                getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n                styleVersion\n              }\n            }\n          }),\n          {\n            data:\n              // @ts-ignore (2339) attribute is not defined on all data types\n              data.attributes && data.attributes.background\n                ? // @ts-ignore (2339) attribute is not defined on all data types\n                  {length: data.length, attributes: data.attributes.background}\n                : data,\n            _dataDiff,\n            // Maintain the same background behavior as <=8.3. Remove in v9?\n            autoHighlight: false,\n            getBoundingRect: this.getBoundingRect\n          }\n        ),\n      new CharactersLayerClass(\n        {\n          sdf: fontSettings.sdf,\n          smoothing: Number.isFinite(fontSettings.smoothing)\n            ? fontSettings.smoothing\n            : DEFAULT_FONT_SETTINGS.smoothing,\n          outlineWidth,\n          outlineColor,\n          iconAtlas: texture,\n          iconMapping: mapping,\n\n          getPosition,\n          getColor,\n          getSize,\n          getAngle,\n          getPixelOffset,\n\n          billboard,\n          sizeScale: sizeScale * scale,\n          sizeUnits,\n          sizeMinPixels: sizeMinPixels * scale,\n          sizeMaxPixels: sizeMaxPixels * scale,\n\n          transitions: transitions && {\n            getPosition: transitions.getPosition,\n            getAngle: transitions.getAngle,\n            getColor: transitions.getColor,\n            getSize: transitions.getSize,\n            getPixelOffset: transitions.getPixelOffset\n          }\n        },\n        this.getSubLayerProps({\n          id: 'characters',\n          updateTriggers: {\n            getIcon: updateTriggers.getText,\n            getPosition: updateTriggers.getPosition,\n            getAngle: updateTriggers.getAngle,\n            getColor: updateTriggers.getColor,\n            getSize: updateTriggers.getSize,\n            getPixelOffset: updateTriggers.getPixelOffset,\n            getIconOffsets: {\n              getText: updateTriggers.getText,\n              getTextAnchor: updateTriggers.getTextAnchor,\n              getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n              styleVersion\n            }\n          }\n        }),\n        {\n          data,\n          _dataDiff,\n          startIndices,\n          numInstances,\n          getIconOffsets: this.getIconOffsets,\n          getIcon: getText\n        }\n      )\n    ];\n  }\n\n  static set fontAtlasCacheLimit(limit: number) {\n    setFontAtlasCacheLimit(limit);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}