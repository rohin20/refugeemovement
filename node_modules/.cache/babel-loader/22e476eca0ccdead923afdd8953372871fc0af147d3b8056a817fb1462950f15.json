{"ast":null,"code":"import _objectSpread from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { convert } from './convert';\nimport { clip } from './clip';\nimport { wrap } from './wrap';\nimport { transformTile } from './transform';\nimport { createTile } from './tile';\nvar DEFAULT_OPTIONS = {\n  maxZoom: 14,\n  indexMaxZoom: 5,\n  indexMaxPoints: 100000,\n  tolerance: 3,\n  extent: 4096,\n  buffer: 64,\n  lineMetrics: false,\n  promoteId: undefined,\n  generateId: false,\n  debug: 0\n};\nexport var GeoJSONTiler = /*#__PURE__*/function () {\n  function GeoJSONTiler(data, options) {\n    _classCallCheck(this, GeoJSONTiler);\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"tiles\", {});\n    _defineProperty(this, \"tileCoords\", []);\n    _defineProperty(this, \"stats\", {});\n    _defineProperty(this, \"total\", 0);\n    this.options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);\n    options = this.options;\n    var debug = options.debug;\n    if (debug) console.time('preprocess data');\n    if (this.options.maxZoom < 0 || this.options.maxZoom > 24) {\n      throw new Error('maxZoom should be in the 0-24 range');\n    }\n    if (options.promoteId && this.options.generateId) {\n      throw new Error('promoteId and generateId cannot be used together.');\n    }\n    var features = convert(data, options);\n    if (debug) {\n      console.timeEnd('preprocess data');\n      console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);\n      console.time('generate tiles');\n    }\n    features = wrap(features, this.options);\n    if (features.length) {\n      this.splitTile(features, 0, 0, 0);\n    }\n    if (debug) {\n      if (features.length) {\n        console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);\n      }\n      console.timeEnd('generate tiles');\n      console.log('tiles generated:', this.total, JSON.stringify(this.stats));\n    }\n  }\n  _createClass(GeoJSONTiler, [{\n    key: \"getTile\",\n    value: function getTile(z, x, y) {\n      var _this$options = this.options,\n        extent = _this$options.extent,\n        debug = _this$options.debug;\n      if (z < 0 || z > 24) {\n        return null;\n      }\n      var z2 = 1 << z;\n      x = x + z2 & z2 - 1;\n      var id = toID(z, x, y);\n      if (this.tiles[id]) {\n        return transformTile(this.tiles[id], extent);\n      }\n      if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);\n      var z0 = z;\n      var x0 = x;\n      var y0 = y;\n      var parent;\n      while (!parent && z0 > 0) {\n        z0--;\n        x0 = x0 >> 1;\n        y0 = y0 >> 1;\n        parent = this.tiles[toID(z0, x0, y0)];\n      }\n      if (!parent || !parent.source) {\n        return null;\n      }\n      if (debug > 1) {\n        console.log('found parent tile z%d-%d-%d', z0, x0, y0);\n        console.time('drilling down');\n      }\n      this.splitTile(parent.source, z0, x0, y0, z, x, y);\n      if (debug > 1) {\n        console.timeEnd('drilling down');\n      }\n      return this.tiles[id] ? transformTile(this.tiles[id], extent) : null;\n    }\n  }, {\n    key: \"splitTile\",\n    value: function splitTile(features, z, x, y, cz, cx, cy) {\n      var stack = [features, z, x, y];\n      var options = this.options;\n      var debug = options.debug;\n      while (stack.length) {\n        y = stack.pop();\n        x = stack.pop();\n        z = stack.pop();\n        features = stack.pop();\n        var z2 = 1 << z;\n        var id = toID(z, x, y);\n        var tile = this.tiles[id];\n        if (!tile) {\n          if (debug > 1) {\n            console.time('creation');\n          }\n          tile = this.tiles[id] = createTile(features, z, x, y, options);\n          this.tileCoords.push({\n            z: z,\n            x: x,\n            y: y\n          });\n          if (debug) {\n            if (debug > 1) {\n              console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)', z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);\n              console.timeEnd('creation');\n            }\n            var key = \"z\".concat(z);\n            this.stats[key] = (this.stats[key] || 0) + 1;\n            this.total++;\n          }\n        }\n        tile.source = features;\n        if (cz === undefined) {\n          if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;\n        } else if (z === options.maxZoom || z === cz) {\n          continue;\n        } else if (cz !== undefined) {\n          var zoomSteps = cz - z;\n          if (x !== cx >> zoomSteps || y !== cy >> zoomSteps) continue;\n        }\n        tile.source = null;\n        if (features.length === 0) continue;\n        if (debug > 1) console.time('clipping');\n        var k1 = 0.5 * options.buffer / options.extent;\n        var k2 = 0.5 - k1;\n        var k3 = 0.5 + k1;\n        var k4 = 1 + k1;\n        var tl = null;\n        var bl = null;\n        var tr = null;\n        var br = null;\n        var left = clip(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, options);\n        var right = clip(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, options);\n        features = null;\n        if (left) {\n          tl = clip(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n          bl = clip(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n          left = null;\n        }\n        if (right) {\n          tr = clip(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n          br = clip(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n          right = null;\n        }\n        if (debug > 1) console.timeEnd('clipping');\n        stack.push(tl || [], z + 1, x * 2, y * 2);\n        stack.push(bl || [], z + 1, x * 2, y * 2 + 1);\n        stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n        stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n      }\n    }\n  }]);\n  return GeoJSONTiler;\n}();\nfunction toID(z, x, y) {\n  return ((1 << z) * y + x) * 32 + z;\n}","map":{"version":3,"names":["convert","clip","wrap","transformTile","createTile","DEFAULT_OPTIONS","maxZoom","indexMaxZoom","indexMaxPoints","tolerance","extent","buffer","lineMetrics","promoteId","undefined","generateId","debug","GeoJSONTiler","data","options","_classCallCheck","_defineProperty","_objectSpread","console","time","Error","features","timeEnd","log","length","splitTile","tiles","numFeatures","numPoints","total","JSON","stringify","stats","_createClass","key","value","getTile","z","x","y","_this$options","z2","id","toID","z0","x0","y0","parent","source","cz","cx","cy","stack","pop","tile","tileCoords","push","numSimplified","concat","zoomSteps","k1","k2","k3","k4","tl","bl","tr","br","left","minX","maxX","right","minY","maxY"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/mvt/src/lib/geojson-tiler/geojson-tiler.ts"],"sourcesContent":["// loaders.gl, MIT license\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\n\n/* eslint-disable no-console, no-continue */\n\nimport type {GeoJSONTile, GeoJSONTileFeature} from './tile';\n\nimport {convert} from './convert'; // GeoJSON conversion and preprocessing\nimport {clip} from './clip'; // stripe clipping algorithm\nimport {wrap} from './wrap'; // date line processing\nimport {transformTile} from './transform'; // coordinate transformation\nimport {createTile} from './tile'; // final simplified tile generation\n\n/** Options to configure tiling */\nexport type GeoJSONTilerOptions = {\n  maxZoom?: number /** max zoom to preserve detail on */;\n  indexMaxZoom?: number /** max zoom in the tile index */;\n  indexMaxPoints?: number /** max number of points per tile in the tile index */;\n  tolerance?: number /** simplification tolerance (higher means simpler) */;\n  extent?: number /** tile extent */;\n  buffer?: number /** tile buffer on each side */;\n  lineMetrics?: boolean /** whether to calculate line metrics */;\n  promoteId?: string /** name of a feature property to be promoted to feature.id */;\n  generateId?: boolean /** whether to generate feature ids. Cannot be used with promoteId */;\n  debug?: number /** logging level (0, 1 or 2) */;\n};\n\nconst DEFAULT_OPTIONS: Required<GeoJSONTilerOptions> = {\n  maxZoom: 14, // max zoom to preserve detail on\n  indexMaxZoom: 5, // max zoom in the tile index\n  indexMaxPoints: 100000, // max number of points per tile in the tile index\n  tolerance: 3, // simplification tolerance (higher means simpler)\n  extent: 4096, // tile extent\n  buffer: 64, // tile buffer on each side\n  lineMetrics: false, // whether to calculate line metrics\n  // @ts-expect-error Ensures all these required params have defaults\n  promoteId: undefined, // name of a feature property to be promoted to feature.id\n  generateId: false, // whether to generate feature ids. Cannot be used with promoteId\n  debug: 0 // logging level (0, 1 or 2)\n};\n\nexport class GeoJSONTiler {\n  options: Required<GeoJSONTilerOptions>;\n\n  // tiles and tileCoords are part of the public API\n  tiles: Record<string, GeoJSONTile> = {};\n  tileCoords: {x: number; y: number; z: number}[] = [];\n\n  stats: Record<string, number> = {};\n  total: number = 0;\n\n  constructor(data, options?: GeoJSONTilerOptions) {\n    this.options = {...DEFAULT_OPTIONS, ...options};\n    options = this.options;\n\n    const debug = options.debug;\n\n    if (debug) console.time('preprocess data');\n\n    if (this.options.maxZoom < 0 || this.options.maxZoom > 24) {\n      throw new Error('maxZoom should be in the 0-24 range');\n    }\n    if (options.promoteId && this.options.generateId) {\n      throw new Error('promoteId and generateId cannot be used together.');\n    }\n\n    // projects and adds simplification info\n    let features = convert(data, options);\n\n    if (debug) {\n      console.timeEnd('preprocess data');\n      console.log(\n        'index: maxZoom: %d, maxPoints: %d',\n        options.indexMaxZoom,\n        options.indexMaxPoints\n      );\n      console.time('generate tiles');\n    }\n\n    // wraps features (ie extreme west and extreme east)\n    features = wrap(features, this.options);\n\n    // start slicing from the top tile down\n    if (features.length) {\n      this.splitTile(features, 0, 0, 0);\n    }\n\n    if (debug) {\n      if (features.length) {\n        console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);\n      }\n      console.timeEnd('generate tiles');\n      console.log('tiles generated:', this.total, JSON.stringify(this.stats));\n    }\n  }\n\n  /**\n   * Get a tile at the specified index\n   * @param z\n   * @param x\n   * @param y\n   * @returns\n   */\n  // eslint-disable-next-line complexity, max-statements\n  getTile(z: number, x: number, y: number): GeoJSONTile | null {\n    // z = +z;\n    // x = +x;\n    // y = +y;\n\n    const {extent, debug} = this.options;\n\n    if (z < 0 || z > 24) {\n      return null;\n    }\n\n    const z2 = 1 << z;\n    x = (x + z2) & (z2 - 1); // wrap tile x coordinate\n\n    const id = toID(z, x, y);\n    if (this.tiles[id]) {\n      return transformTile(this.tiles[id], extent);\n    }\n\n    if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);\n\n    let z0 = z;\n    let x0 = x;\n    let y0 = y;\n    let parent;\n\n    while (!parent && z0 > 0) {\n      z0--;\n      x0 = x0 >> 1;\n      y0 = y0 >> 1;\n      parent = this.tiles[toID(z0, x0, y0)];\n    }\n\n    if (!parent || !parent.source) {\n      return null;\n    }\n\n    // if we found a parent tile containing the original geometry, we can drill down from it\n    if (debug > 1) {\n      console.log('found parent tile z%d-%d-%d', z0, x0, y0);\n      console.time('drilling down');\n    }\n    this.splitTile(parent.source, z0, x0, y0, z, x, y);\n    if (debug > 1) {\n      console.timeEnd('drilling down');\n    }\n\n    return this.tiles[id] ? transformTile(this.tiles[id], extent) : null;\n  }\n\n  /**\n   * splits features from a parent tile to sub-tiles.\n   * @param z, x, and y are the coordinates of the parent tile\n   * @param cz, cx, and cy are the coordinates of the target tile\n   *\n   * If no target tile is specified, splitting stops when we reach the maximum\n   * zoom or the number of points is low as specified in the options.\n   */\n  // eslint-disable-next-line max-params, max-statements, complexity\n  splitTile(\n    features: GeoJSONTileFeature[],\n    z: number,\n    x: number,\n    y: number,\n    cz?: number,\n    cx?: number,\n    cy?: number\n  ): void {\n    const stack: any[] = [features, z, x, y];\n    const options = this.options;\n    const debug = options.debug;\n\n    // avoid recursion by using a processing queue\n    while (stack.length) {\n      y = stack.pop();\n      x = stack.pop();\n      z = stack.pop();\n      features = stack.pop();\n\n      const z2 = 1 << z;\n      const id = toID(z, x, y);\n      let tile = this.tiles[id];\n\n      if (!tile) {\n        if (debug > 1) {\n          console.time('creation');\n        }\n\n        tile = this.tiles[id] = createTile(features, z, x, y, options);\n        this.tileCoords.push({z, x, y});\n\n        if (debug) {\n          if (debug > 1) {\n            console.log(\n              'tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',\n              z,\n              x,\n              y,\n              tile.numFeatures,\n              tile.numPoints,\n              tile.numSimplified\n            );\n            console.timeEnd('creation');\n          }\n          const key = `z${z}`;\n          this.stats[key] = (this.stats[key] || 0) + 1;\n          this.total++;\n        }\n      }\n\n      // save reference to original geometry in tile so that we can drill down later if we stop now\n      tile.source = features;\n\n      // if it's the first-pass tiling\n      if (cz === undefined) {\n        // stop tiling if we reached max zoom, or if the tile is too simple\n        if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;\n        // if a drilldown to a specific tile\n      } else if (z === options.maxZoom || z === cz) {\n        // stop tiling if we reached base zoom or our target tile zoom\n        continue;\n      } else if (cz !== undefined) {\n        // stop tiling if it's not an ancestor of the target tile\n        const zoomSteps = cz - z;\n        // @ts-expect-error TODO fix the types of cx cy\n        if (x !== cx >> zoomSteps || y !== cy >> zoomSteps) continue;\n      }\n\n      // if we slice further down, no need to keep source geometry\n      tile.source = null;\n\n      if (features.length === 0) continue;\n\n      if (debug > 1) console.time('clipping');\n\n      // values we'll use for clipping\n      const k1 = (0.5 * options.buffer) / options.extent;\n      const k2 = 0.5 - k1;\n      const k3 = 0.5 + k1;\n      const k4 = 1 + k1;\n\n      let tl: GeoJSONTileFeature[] | null = null;\n      let bl: GeoJSONTileFeature[] | null = null;\n      let tr: GeoJSONTileFeature[] | null = null;\n      let br: GeoJSONTileFeature[] | null = null;\n\n      let left = clip(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, options);\n      let right = clip(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, options);\n\n      // @ts-expect-error - unclear why this is needed?\n      features = null;\n\n      if (left) {\n        tl = clip(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n        bl = clip(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n        left = null;\n      }\n\n      if (right) {\n        tr = clip(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n        br = clip(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n        right = null;\n      }\n\n      if (debug > 1) console.timeEnd('clipping');\n\n      stack.push(tl || [], z + 1, x * 2, y * 2);\n      stack.push(bl || [], z + 1, x * 2, y * 2 + 1);\n      stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n      stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n    }\n  }\n}\n\nfunction toID(z, x, y) {\n  return ((1 << z) * y + x) * 32 + z;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}