{"ast":null,"code":"/*\n * Copyright 2012-2016 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n'use strict';\n\nvar defaultClient, mixin, responsePromise, client;\ndefaultClient = require('./client/default');\nmixin = require('./util/mixin');\nresponsePromise = require('./util/responsePromise');\nclient = require('./client');\n\n/**\n * Interceptors have the ability to intercept the request and/org response\n * objects.  They may augment, prune, transform or replace the\n * request/response as needed.  Clients may be composed by wrapping\n * together multiple interceptors.\n *\n * Configured interceptors are functional in nature.  Wrapping a client in\n * an interceptor will not affect the client, merely the data that flows in\n * and out of that client.  A common configuration can be created once and\n * shared; specialization can be created by further wrapping that client\n * with custom interceptors.\n *\n * @param {Client} [target] client to wrap\n * @param {Object} [config] configuration for the interceptor, properties will be specific to the interceptor implementation\n * @returns {Client} A client wrapped with the interceptor\n *\n * @class Interceptor\n */\n\nfunction defaultInitHandler(config) {\n  return config;\n}\nfunction defaultRequestHandler(request /*, config, meta */) {\n  return request;\n}\nfunction defaultResponseHandler(response /*, config, meta */) {\n  return response;\n}\n\n/**\n * Alternate return type for the request handler that allows for more complex interactions.\n *\n * @param properties.request the traditional request return object\n * @param {Promise} [properties.abort] promise that resolves if/when the request is aborted\n * @param {Client} [properties.client] override the defined client with an alternate client\n * @param [properties.response] response for the request, short circuit the request\n */\nfunction ComplexRequest(properties) {\n  if (!(this instanceof ComplexRequest)) {\n    // in case users forget the 'new' don't mix into the interceptor\n    return new ComplexRequest(properties);\n  }\n  mixin(this, properties);\n}\n\n/**\n * Create a new interceptor for the provided handlers.\n *\n * @param {Function} [handlers.init] one time intialization, must return the config object\n * @param {Function} [handlers.request] request handler\n * @param {Function} [handlers.response] response handler regardless of error state\n * @param {Function} [handlers.success] response handler when the request is not in error\n * @param {Function} [handlers.error] response handler when the request is in error, may be used to 'unreject' an error state\n * @param {Function} [handlers.client] the client to use if otherwise not specified, defaults to platform default client\n *\n * @returns {Interceptor}\n */\nfunction interceptor(handlers) {\n  var initHandler, requestHandler, successResponseHandler, errorResponseHandler;\n  handlers = handlers || {};\n  initHandler = handlers.init || defaultInitHandler;\n  requestHandler = handlers.request || defaultRequestHandler;\n  successResponseHandler = handlers.success || handlers.response || defaultResponseHandler;\n  errorResponseHandler = handlers.error || function () {\n    // Propagate the rejection, with the result of the handler\n    return Promise.resolve((handlers.response || defaultResponseHandler).apply(this, arguments)).then(Promise.reject.bind(Promise));\n  };\n  return function (target, config) {\n    if (typeof target === 'object') {\n      config = target;\n    }\n    if (typeof target !== 'function') {\n      target = handlers.client || defaultClient;\n    }\n    config = initHandler(config || {});\n    function interceptedClient(request) {\n      var context, meta;\n      context = {};\n      meta = {\n        'arguments': Array.prototype.slice.call(arguments),\n        client: interceptedClient\n      };\n      request = typeof request === 'string' ? {\n        path: request\n      } : request || {};\n      request.originator = request.originator || interceptedClient;\n      return responsePromise(requestHandler.call(context, request, config, meta), function (request) {\n        var response, abort, next;\n        next = target;\n        if (request instanceof ComplexRequest) {\n          // unpack request\n          abort = request.abort;\n          next = request.client || next;\n          response = request.response;\n          // normalize request, must be last\n          request = request.request;\n        }\n        response = response || Promise.resolve(request).then(function (request) {\n          return Promise.resolve(next(request)).then(function (response) {\n            return successResponseHandler.call(context, response, config, meta);\n          }, function (response) {\n            return errorResponseHandler.call(context, response, config, meta);\n          });\n        });\n        return abort ? Promise.race([response, abort]) : response;\n      }, function (error) {\n        return Promise.reject({\n          request: request,\n          error: error\n        });\n      });\n    }\n    return client(interceptedClient, target);\n  };\n}\ninterceptor.ComplexRequest = ComplexRequest;\nmodule.exports = interceptor;","map":{"version":3,"names":["defaultClient","mixin","responsePromise","client","require","defaultInitHandler","config","defaultRequestHandler","request","defaultResponseHandler","response","ComplexRequest","properties","interceptor","handlers","initHandler","requestHandler","successResponseHandler","errorResponseHandler","init","success","error","Promise","resolve","apply","arguments","then","reject","bind","target","interceptedClient","context","meta","Array","prototype","slice","call","path","originator","abort","next","race","module","exports"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/rest/interceptor.js"],"sourcesContent":["/*\n * Copyright 2012-2016 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n'use strict';\n\nvar defaultClient, mixin, responsePromise, client;\n\ndefaultClient = require('./client/default');\nmixin = require('./util/mixin');\nresponsePromise = require('./util/responsePromise');\nclient = require('./client');\n\n/**\n * Interceptors have the ability to intercept the request and/org response\n * objects.  They may augment, prune, transform or replace the\n * request/response as needed.  Clients may be composed by wrapping\n * together multiple interceptors.\n *\n * Configured interceptors are functional in nature.  Wrapping a client in\n * an interceptor will not affect the client, merely the data that flows in\n * and out of that client.  A common configuration can be created once and\n * shared; specialization can be created by further wrapping that client\n * with custom interceptors.\n *\n * @param {Client} [target] client to wrap\n * @param {Object} [config] configuration for the interceptor, properties will be specific to the interceptor implementation\n * @returns {Client} A client wrapped with the interceptor\n *\n * @class Interceptor\n */\n\nfunction defaultInitHandler(config) {\n\treturn config;\n}\n\nfunction defaultRequestHandler(request /*, config, meta */) {\n\treturn request;\n}\n\nfunction defaultResponseHandler(response /*, config, meta */) {\n\treturn response;\n}\n\n/**\n * Alternate return type for the request handler that allows for more complex interactions.\n *\n * @param properties.request the traditional request return object\n * @param {Promise} [properties.abort] promise that resolves if/when the request is aborted\n * @param {Client} [properties.client] override the defined client with an alternate client\n * @param [properties.response] response for the request, short circuit the request\n */\nfunction ComplexRequest(properties) {\n\tif (!(this instanceof ComplexRequest)) {\n\t\t// in case users forget the 'new' don't mix into the interceptor\n\t\treturn new ComplexRequest(properties);\n\t}\n\tmixin(this, properties);\n}\n\n/**\n * Create a new interceptor for the provided handlers.\n *\n * @param {Function} [handlers.init] one time intialization, must return the config object\n * @param {Function} [handlers.request] request handler\n * @param {Function} [handlers.response] response handler regardless of error state\n * @param {Function} [handlers.success] response handler when the request is not in error\n * @param {Function} [handlers.error] response handler when the request is in error, may be used to 'unreject' an error state\n * @param {Function} [handlers.client] the client to use if otherwise not specified, defaults to platform default client\n *\n * @returns {Interceptor}\n */\nfunction interceptor(handlers) {\n\n\tvar initHandler, requestHandler, successResponseHandler, errorResponseHandler;\n\n\thandlers = handlers || {};\n\n\tinitHandler            = handlers.init    || defaultInitHandler;\n\trequestHandler         = handlers.request || defaultRequestHandler;\n\tsuccessResponseHandler = handlers.success || handlers.response || defaultResponseHandler;\n\terrorResponseHandler   = handlers.error   || function () {\n\t\t// Propagate the rejection, with the result of the handler\n\t\treturn Promise.resolve((handlers.response || defaultResponseHandler).apply(this, arguments))\n\t\t\t.then(Promise.reject.bind(Promise));\n\t};\n\n\treturn function (target, config) {\n\n\t\tif (typeof target === 'object') {\n\t\t\tconfig = target;\n\t\t}\n\t\tif (typeof target !== 'function') {\n\t\t\ttarget = handlers.client || defaultClient;\n\t\t}\n\n\t\tconfig = initHandler(config || {});\n\n\t\tfunction interceptedClient(request) {\n\t\t\tvar context, meta;\n\t\t\tcontext = {};\n\t\t\tmeta = { 'arguments': Array.prototype.slice.call(arguments), client: interceptedClient };\n\t\t\trequest = typeof request === 'string' ? { path: request } : request || {};\n\t\t\trequest.originator = request.originator || interceptedClient;\n\t\t\treturn responsePromise(\n\t\t\t\trequestHandler.call(context, request, config, meta),\n\t\t\t\tfunction (request) {\n\t\t\t\t\tvar response, abort, next;\n\t\t\t\t\tnext = target;\n\t\t\t\t\tif (request instanceof ComplexRequest) {\n\t\t\t\t\t\t// unpack request\n\t\t\t\t\t\tabort = request.abort;\n\t\t\t\t\t\tnext = request.client || next;\n\t\t\t\t\t\tresponse = request.response;\n\t\t\t\t\t\t// normalize request, must be last\n\t\t\t\t\t\trequest = request.request;\n\t\t\t\t\t}\n\t\t\t\t\tresponse = response || Promise.resolve(request).then(function (request) {\n\t\t\t\t\t\treturn Promise.resolve(next(request)).then(\n\t\t\t\t\t\t\tfunction (response) {\n\t\t\t\t\t\t\t\treturn successResponseHandler.call(context, response, config, meta);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfunction (response) {\n\t\t\t\t\t\t\t\treturn errorResponseHandler.call(context, response, config, meta);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\treturn abort ? Promise.race([response, abort]) : response;\n\t\t\t\t},\n\t\t\t\tfunction (error) {\n\t\t\t\t\treturn Promise.reject({ request: request, error: error });\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\treturn client(interceptedClient, target);\n\t};\n}\n\ninterceptor.ComplexRequest = ComplexRequest;\n\nmodule.exports = interceptor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}