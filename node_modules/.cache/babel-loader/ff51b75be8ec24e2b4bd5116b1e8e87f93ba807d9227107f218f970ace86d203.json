{"ast":null,"code":"import _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { isWebGL2 } from '@luma.gl/core';\nexport function getBounds(points) {\n  var x = points.map(function (p) {\n    return p[0];\n  });\n  var y = points.map(function (p) {\n    return p[1];\n  });\n  var xMin = Math.min.apply(null, x);\n  var xMax = Math.max.apply(null, x);\n  var yMin = Math.min.apply(null, y);\n  var yMax = Math.max.apply(null, y);\n  return [xMin, yMin, xMax, yMax];\n}\nexport function boundsContain(currentBounds, targetBounds) {\n  if (targetBounds[0] >= currentBounds[0] && targetBounds[2] <= currentBounds[2] && targetBounds[1] >= currentBounds[1] && targetBounds[3] <= currentBounds[3]) {\n    return true;\n  }\n  return false;\n}\nvar scratchArray = new Float32Array(12);\nexport function packVertices(points) {\n  var dimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  var index = 0;\n  var _iterator = _createForOfIteratorHelper(points),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var point = _step.value;\n      for (var i = 0; i < dimensions; i++) {\n        scratchArray[index++] = point[i] || 0;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return scratchArray;\n}\nexport function scaleToAspectRatio(boundingBox, width, height) {\n  var _boundingBox = _slicedToArray(boundingBox, 4),\n    xMin = _boundingBox[0],\n    yMin = _boundingBox[1],\n    xMax = _boundingBox[2],\n    yMax = _boundingBox[3];\n  var currentWidth = xMax - xMin;\n  var currentHeight = yMax - yMin;\n  var newWidth = currentWidth;\n  var newHeight = currentHeight;\n  if (currentWidth / currentHeight < width / height) {\n    newWidth = width / height * currentHeight;\n  } else {\n    newHeight = height / width * currentWidth;\n  }\n  if (newWidth < width) {\n    newWidth = width;\n    newHeight = height;\n  }\n  var xCenter = (xMax + xMin) / 2;\n  var yCenter = (yMax + yMin) / 2;\n  return [xCenter - newWidth / 2, yCenter - newHeight / 2, xCenter + newWidth / 2, yCenter + newHeight / 2];\n}\nexport function getTextureCoordinates(point, bounds) {\n  var _bounds = _slicedToArray(bounds, 4),\n    xMin = _bounds[0],\n    yMin = _bounds[1],\n    xMax = _bounds[2],\n    yMax = _bounds[3];\n  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\n}\nexport function getTextureParams(_ref) {\n  var gl = _ref.gl,\n    floatTargetSupport = _ref.floatTargetSupport;\n  return {\n    format: isWebGL2(gl) ? 34836 : 6408,\n    type: floatTargetSupport ? 5126 : 5121\n  };\n}","map":{"version":3,"names":["isWebGL2","getBounds","points","x","map","p","y","xMin","Math","min","apply","xMax","max","yMin","yMax","boundsContain","currentBounds","targetBounds","scratchArray","Float32Array","packVertices","dimensions","arguments","length","undefined","index","_iterator","_createForOfIteratorHelper","_step","s","n","done","point","value","i","err","e","f","scaleToAspectRatio","boundingBox","width","height","_boundingBox","_slicedToArray","currentWidth","currentHeight","newWidth","newHeight","xCenter","yCenter","getTextureCoordinates","bounds","_bounds","getTextureParams","_ref","gl","floatTargetSupport","format","type"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/aggregation-layers/src/heatmap-layer/heatmap-layer-utils.js"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport {isWebGL2} from '@luma.gl/core';\n\nexport function getBounds(points) {\n  // Now build bounding box in world space (aligned to world coordiante system)\n  const x = points.map(p => p[0]);\n  const y = points.map(p => p[1]);\n\n  const xMin = Math.min.apply(null, x);\n  const xMax = Math.max.apply(null, x);\n  const yMin = Math.min.apply(null, y);\n  const yMax = Math.max.apply(null, y);\n\n  return [xMin, yMin, xMax, yMax];\n}\n\n// true if currentBounds contains targetBounds, false otherwise\nexport function boundsContain(currentBounds, targetBounds) {\n  if (\n    targetBounds[0] >= currentBounds[0] &&\n    targetBounds[2] <= currentBounds[2] &&\n    targetBounds[1] >= currentBounds[1] &&\n    targetBounds[3] <= currentBounds[3]\n  ) {\n    return true;\n  }\n  return false;\n}\n\nconst scratchArray = new Float32Array(12);\n\n// For given rectangle bounds generates two triangles vertices that coverit completely\nexport function packVertices(points, dimensions = 2) {\n  let index = 0;\n  for (const point of points) {\n    for (let i = 0; i < dimensions; i++) {\n      scratchArray[index++] = point[i] || 0;\n    }\n  }\n  return scratchArray;\n}\n\n// Expands boundingBox:[xMin, yMin, xMax, yMax] to match aspect ratio of given width and height\nexport function scaleToAspectRatio(boundingBox, width, height) {\n  const [xMin, yMin, xMax, yMax] = boundingBox;\n\n  const currentWidth = xMax - xMin;\n  const currentHeight = yMax - yMin;\n\n  let newWidth = currentWidth;\n  let newHeight = currentHeight;\n  if (currentWidth / currentHeight < width / height) {\n    // expand bounding box width\n    newWidth = (width / height) * currentHeight;\n  } else {\n    newHeight = (height / width) * currentWidth;\n  }\n\n  if (newWidth < width) {\n    newWidth = width;\n    newHeight = height;\n  }\n\n  const xCenter = (xMax + xMin) / 2;\n  const yCenter = (yMax + yMin) / 2;\n\n  return [\n    xCenter - newWidth / 2,\n    yCenter - newHeight / 2,\n    xCenter + newWidth / 2,\n    yCenter + newHeight / 2\n  ];\n}\n\n// Get texture coordiante of point inside a bounding box\nexport function getTextureCoordinates(point, bounds) {\n  const [xMin, yMin, xMax, yMax] = bounds;\n  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\n}\n\n// Returns format and type for creating texture objects\nexport function getTextureParams({gl, floatTargetSupport}) {\n  return {\n    // format:  should be RGBA32F on WebGL2 (float textures), RGBA in WebGL1 for float or non float textures\n    format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n    type: floatTargetSupport ? GL.FLOAT : GL.UNSIGNED_BYTE\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}