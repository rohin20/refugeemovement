{"ast":null,"code":"import _toConsumableArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { Quaternion, Vector3, Matrix3, Matrix4, degrees } from '@math.gl/core';\nimport { BoundingSphere, OrientedBoundingBox } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { assert } from '@loaders.gl/loader-utils';\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\nvar scratchScale = new Vector3();\nvar scratchNorthWest = new Vector3();\nvar scratchSouthEast = new Vector3();\nexport function createBoundingVolume(boundingVolumeHeader, transform, result) {\n  assert(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n  if (boundingVolumeHeader.box) {\n    return createBox(boundingVolumeHeader.box, transform, result);\n  }\n  if (boundingVolumeHeader.region) {\n    var _boundingVolumeHeader = _slicedToArray(boundingVolumeHeader.region, 6),\n      west = _boundingVolumeHeader[0],\n      south = _boundingVolumeHeader[1],\n      east = _boundingVolumeHeader[2],\n      north = _boundingVolumeHeader[3],\n      minHeight = _boundingVolumeHeader[4],\n      maxHeight = _boundingVolumeHeader[5];\n    var northWest = Ellipsoid.WGS84.cartographicToCartesian([degrees(west), degrees(north), minHeight], scratchNorthWest);\n    var southEast = Ellipsoid.WGS84.cartographicToCartesian([degrees(east), degrees(south), maxHeight], scratchSouthEast);\n    var centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyScalar(0.5);\n    var radius = new Vector3().subVectors(northWest, southEast).len() / 2.0;\n    return createSphere([centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius], new Matrix4());\n  }\n  if (boundingVolumeHeader.sphere) {\n    return createSphere(boundingVolumeHeader.sphere, transform, result);\n  }\n  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\nfunction createBox(box, transform, result) {\n  var center = new Vector3(box[0], box[1], box[2]);\n  transform.transform(center, center);\n  var origin = [];\n  if (box.length === 10) {\n    var halfSize = box.slice(3, 6);\n    var quaternion = new Quaternion();\n    quaternion.fromArray(box, 6);\n    var x = new Vector3([1, 0, 0]);\n    var y = new Vector3([0, 1, 0]);\n    var z = new Vector3([0, 0, 1]);\n    x.transformByQuaternion(quaternion);\n    x.scale(halfSize[0]);\n    y.transformByQuaternion(quaternion);\n    y.scale(halfSize[1]);\n    z.transformByQuaternion(quaternion);\n    z.scale(halfSize[2]);\n    origin = [].concat(_toConsumableArray(x.toArray()), _toConsumableArray(y.toArray()), _toConsumableArray(z.toArray()));\n  } else {\n    origin = [].concat(_toConsumableArray(box.slice(3, 6)), _toConsumableArray(box.slice(6, 9)), _toConsumableArray(box.slice(9, 12)));\n  }\n  var xAxis = transform.transformAsVector(origin.slice(0, 3));\n  var yAxis = transform.transformAsVector(origin.slice(3, 6));\n  var zAxis = transform.transformAsVector(origin.slice(6, 9));\n  var halfAxes = new Matrix3([xAxis[0], xAxis[1], xAxis[2], yAxis[0], yAxis[1], yAxis[2], zAxis[0], zAxis[1], zAxis[2]]);\n  if (defined(result)) {\n    result.center = center;\n    result.halfAxes = halfAxes;\n    return result;\n  }\n  return new OrientedBoundingBox(center, halfAxes);\n}\nfunction createSphere(sphere, transform, result) {\n  var center = new Vector3(sphere[0], sphere[1], sphere[2]);\n  transform.transform(center, center);\n  var scale = transform.getScale(scratchScale);\n  var uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n  var radius = sphere[3] * uniformScale;\n  if (defined(result)) {\n    result.center = center;\n    result.radius = radius;\n    return result;\n  }\n  return new BoundingSphere(center, radius);\n}","map":{"version":3,"names":["Quaternion","Vector3","Matrix3","Matrix4","degrees","BoundingSphere","OrientedBoundingBox","Ellipsoid","assert","defined","x","undefined","scratchScale","scratchNorthWest","scratchSouthEast","createBoundingVolume","boundingVolumeHeader","transform","result","box","createBox","region","_boundingVolumeHeader","_slicedToArray","west","south","east","north","minHeight","maxHeight","northWest","WGS84","cartographicToCartesian","southEast","centerInCartesian","addVectors","multiplyScalar","radius","subVectors","len","createSphere","sphere","Error","center","origin","length","halfSize","slice","quaternion","fromArray","y","z","transformByQuaternion","scale","concat","_toConsumableArray","toArray","xAxis","transformAsVector","yAxis","zAxis","halfAxes","getScale","uniformScale","Math","max"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/geo-layers/node_modules/@loaders.gl/tiles/src/tileset/helpers/bounding-volume.ts"],"sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Quaternion, Vector3, Matrix3, Matrix4, degrees} from '@math.gl/core';\nimport {BoundingSphere, OrientedBoundingBox} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {assert} from '@loaders.gl/loader-utils';\n\n// const scratchProjectedBoundingSphere = new BoundingSphere();\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\n// const scratchMatrix = new Matrix3();\nconst scratchScale = new Vector3();\nconst scratchNorthWest = new Vector3();\nconst scratchSouthEast = new Vector3();\n// const scratchRectangle = new Rectangle();\n// const scratchOrientedBoundingBox = new OrientedBoundingBox();\n// const scratchTransform = new Matrix4();\n\n/**\n * Create a bounding volume from the tile's bounding volume header.\n * @param {Object} boundingVolumeHeader The tile's bounding volume header.\n * @param {Matrix4} transform The transform to apply to the bounding volume.\n * @param [result] The object onto which to store the result.\n * @returns The modified result parameter or a new TileBoundingVolume instance if none was provided.\n */\nexport function createBoundingVolume(boundingVolumeHeader, transform, result) {\n  assert(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n\n  // boundingVolume schema:\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/schema/boundingVolume.schema.json\n  if (boundingVolumeHeader.box) {\n    return createBox(boundingVolumeHeader.box, transform, result);\n  }\n  if (boundingVolumeHeader.region) {\n    // [west, south, east, north, minimum height, maximum height]\n    // Latitudes and longitudes are in the WGS 84 datum as defined in EPSG 4979 and are in radians.\n    // Heights are in meters above (or below) the WGS 84 ellipsoid.\n    const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;\n\n    const northWest = Ellipsoid.WGS84.cartographicToCartesian(\n      [degrees(west), degrees(north), minHeight],\n      scratchNorthWest\n    );\n    const southEast = Ellipsoid.WGS84.cartographicToCartesian(\n      [degrees(east), degrees(south), maxHeight],\n      scratchSouthEast\n    );\n    const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyScalar(0.5);\n    const radius = new Vector3().subVectors(northWest, southEast).len() / 2.0;\n\n    // TODO improve region boundingVolume\n    // for now, create a sphere as the boundingVolume instead of box\n    return createSphere(\n      [centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius],\n      new Matrix4()\n    );\n  }\n\n  if (boundingVolumeHeader.sphere) {\n    return createSphere(boundingVolumeHeader.sphere, transform, result);\n  }\n\n  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\n\nfunction createBox(box, transform, result) {\n  // https://math.gl/modules/culling/docs/api-reference/oriented-bounding-box\n  // 1. A half-axes based representation.\n  // box: An array of 12 numbers that define an oriented bounding box.\n  // The first three elements define the x, y, and z values for the center of the box.\n  // The next three elements (with indices 3, 4, and 5) define the x axis direction and half-length.\n  // The next three elements (indices 6, 7, and 8) define the y axis direction and half-length.\n  // The last three elements (indices 9, 10, and 11) define the z axis direction and half-length.\n  // 2. A half-size-quaternion based representation.\n  // box: An array of 10 numbers that define an oriented bounding box.\n  // The first three elements define the x, y, and z values for the center of the box in a right-handed 3-axis (x, y, z) Cartesian coordinate system where the z-axis is up.\n  // The next three elements (with indices 3, 4, and 5) define the halfSize.\n  // The last four elements (indices 6, 7, 8 and 10) define the quaternion.\n  const center = new Vector3(box[0], box[1], box[2]);\n  transform.transform(center, center);\n  let origin: number[] = [];\n  if (box.length === 10) {\n    const halfSize = box.slice(3, 6);\n    const quaternion = new Quaternion();\n    quaternion.fromArray(box, 6);\n    const x = new Vector3([1, 0, 0]);\n    const y = new Vector3([0, 1, 0]);\n    const z = new Vector3([0, 0, 1]);\n    x.transformByQuaternion(quaternion);\n    x.scale(halfSize[0]);\n    y.transformByQuaternion(quaternion);\n    y.scale(halfSize[1]);\n    z.transformByQuaternion(quaternion);\n    z.scale(halfSize[2]);\n    origin = [...x.toArray(), ...y.toArray(), ...z.toArray()];\n  } else {\n    origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];\n  }\n  const xAxis = transform.transformAsVector(origin.slice(0, 3));\n  const yAxis = transform.transformAsVector(origin.slice(3, 6));\n  const zAxis = transform.transformAsVector(origin.slice(6, 9));\n  const halfAxes = new Matrix3([\n    xAxis[0],\n    xAxis[1],\n    xAxis[2],\n    yAxis[0],\n    yAxis[1],\n    yAxis[2],\n    zAxis[0],\n    zAxis[1],\n    zAxis[2]\n  ]);\n\n  if (defined(result)) {\n    result.center = center;\n    result.halfAxes = halfAxes;\n    return result;\n  }\n\n  return new OrientedBoundingBox(center, halfAxes);\n}\n\n/*\nfunction createBoxFromTransformedRegion(region, transform, initialTransform, result) {\n  const rectangle = Rectangle.unpack(region, 0, scratchRectangle);\n  const minimumHeight = region[4];\n  const maximumHeight = region[5];\n\n  const orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    Ellipsoid.WGS84,\n    scratchOrientedBoundingBox\n  );\n  const center = orientedBoundingBox.center;\n  const halfAxes = orientedBoundingBox.halfAxes;\n\n  // A region bounding volume is not transformed by the transform in the tileset JSON,\n  // but may be transformed by additional transforms applied in Cesium.\n  // This is why the transform is calculated as the difference between the initial transform and the current transform.\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.inverseTransformation(initialTransform, scratchTransform),\n    scratchTransform\n  );\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const rotationScale = Matrix4.getRotation(transform, scratchMatrix);\n  halfAxes = Matrix3.multiply(rotationScale, halfAxes, halfAxes);\n\n  if (defined(result) && result instanceof TileOrientedBoundingBox) {\n    result.update(center, halfAxes);\n    return result;\n  }\n\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\nfunction createRegion(region, transform, initialTransform, result) {\n  if (!Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {\n    return createBoxFromTransformedRegion(region, transform, initialTransform, result);\n  }\n\n  if (defined(result)) {\n    return result;\n  }\n\n  const rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);\n\n  return new TileBoundingRegion({\n    rectangle: rectangleRegion,\n    minimumHeight: region[4],\n    maximumHeight: region[5]\n  });\n}\n*/\n\nfunction createSphere(sphere, transform, result?) {\n  // Find the transformed center\n  const center = new Vector3(sphere[0], sphere[1], sphere[2]);\n  transform.transform(center, center);\n  const scale = transform.getScale(scratchScale);\n\n  const uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n  const radius = sphere[3] * uniformScale;\n\n  if (defined(result)) {\n    result.center = center;\n    result.radius = radius;\n    return result;\n  }\n\n  return new BoundingSphere(center, radius);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}