{"ast":null,"code":"import _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport Resource from './resource';\nimport Accessor from './accessor';\nimport { getGLTypeFromTypedArray, getTypedArrayFromGLType } from '../webgl-utils/typed-array-utils';\nimport { assertWebGL2Context, log } from '@luma.gl/gltools';\nimport { assert } from '../utils/assert';\nimport { checkProps } from '../utils/check-props';\nvar DEBUG_DATA_LENGTH = 10;\nvar DEPRECATED_PROPS = {\n  offset: 'accessor.offset',\n  stride: 'accessor.stride',\n  type: 'accessor.type',\n  size: 'accessor.size',\n  divisor: 'accessor.divisor',\n  normalized: 'accessor.normalized',\n  integer: 'accessor.integer',\n  instanced: 'accessor.divisor',\n  isInstanced: 'accessor.divisor'\n};\nvar PROP_CHECKS_INITIALIZE = {\n  removedProps: {},\n  replacedProps: {\n    bytes: 'byteLength'\n  },\n  deprecatedProps: DEPRECATED_PROPS\n};\nvar PROP_CHECKS_SET_PROPS = {\n  removedProps: DEPRECATED_PROPS\n};\nvar Buffer = /*#__PURE__*/function (_Resource, _Symbol$toStringTag) {\n  _inherits(Buffer, _Resource);\n  var _super = _createSuper(Buffer);\n  function Buffer(gl) {\n    var _this;\n    _classCallCheck(this, Buffer);\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _this = _super.call(this, gl, props);\n    _this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);\n    _this.target = props.target || (_this.gl.webgl2 ? 36662 : 34962);\n    _this.initialize(props);\n    Object.seal(_assertThisInitialized(_this));\n    return _this;\n  }\n  _createClass(Buffer, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'Buffer';\n    }\n  }, {\n    key: \"getElementCount\",\n    value: function getElementCount() {\n      var accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;\n      return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));\n    }\n  }, {\n    key: \"getVertexCount\",\n    value: function getVertexCount() {\n      var accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;\n      return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (ArrayBuffer.isView(props)) {\n        props = {\n          data: props\n        };\n      }\n      if (Number.isFinite(props)) {\n        props = {\n          byteLength: props\n        };\n      }\n      props = checkProps('Buffer', props, PROP_CHECKS_INITIALIZE);\n      this.usage = props.usage || 35044;\n      this.debugData = null;\n      this.setAccessor(Object.assign({}, props, props.accessor));\n      if (props.data) {\n        this._setData(props.data, props.offset, props.byteLength);\n      } else {\n        this._setByteLength(props.byteLength || 0);\n      }\n      return this;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      props = checkProps('Buffer', props, PROP_CHECKS_SET_PROPS);\n      if ('accessor' in props) {\n        this.setAccessor(props.accessor);\n      }\n      return this;\n    }\n  }, {\n    key: \"setAccessor\",\n    value: function setAccessor(accessor) {\n      accessor = Object.assign({}, accessor);\n      delete accessor.buffer;\n      this.accessor = new Accessor(accessor);\n      return this;\n    }\n  }, {\n    key: \"reallocate\",\n    value: function reallocate(byteLength) {\n      if (byteLength > this.byteLength) {\n        this._setByteLength(byteLength);\n        return true;\n      }\n      this.bytesUsed = byteLength;\n      return false;\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(props) {\n      return this.initialize(props);\n    }\n  }, {\n    key: \"subData\",\n    value: function subData(props) {\n      if (ArrayBuffer.isView(props)) {\n        props = {\n          data: props\n        };\n      }\n      var _props = props,\n        data = _props.data,\n        _props$offset = _props.offset,\n        offset = _props$offset === void 0 ? 0 : _props$offset,\n        _props$srcOffset = _props.srcOffset,\n        srcOffset = _props$srcOffset === void 0 ? 0 : _props$srcOffset;\n      var byteLength = props.byteLength || props.length;\n      assert(data);\n      var target = this.gl.webgl2 ? 36663 : this.target;\n      this.gl.bindBuffer(target, this.handle);\n      if (srcOffset !== 0 || byteLength !== undefined) {\n        assertWebGL2Context(this.gl);\n        this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);\n      } else {\n        this.gl.bufferSubData(target, offset, data);\n      }\n      this.gl.bindBuffer(target, null);\n      this.debugData = null;\n      this._inferType(data);\n      return this;\n    }\n  }, {\n    key: \"copyData\",\n    value: function copyData(_ref) {\n      var sourceBuffer = _ref.sourceBuffer,\n        _ref$readOffset = _ref.readOffset,\n        readOffset = _ref$readOffset === void 0 ? 0 : _ref$readOffset,\n        _ref$writeOffset = _ref.writeOffset,\n        writeOffset = _ref$writeOffset === void 0 ? 0 : _ref$writeOffset,\n        size = _ref.size;\n      var gl = this.gl;\n      assertWebGL2Context(gl);\n      gl.bindBuffer(36662, sourceBuffer.handle);\n      gl.bindBuffer(36663, this.handle);\n      gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);\n      gl.bindBuffer(36662, null);\n      gl.bindBuffer(36663, null);\n      this.debugData = null;\n      return this;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$dstData = _ref2.dstData,\n        dstData = _ref2$dstData === void 0 ? null : _ref2$dstData,\n        _ref2$srcByteOffset = _ref2.srcByteOffset,\n        srcByteOffset = _ref2$srcByteOffset === void 0 ? 0 : _ref2$srcByteOffset,\n        _ref2$dstOffset = _ref2.dstOffset,\n        dstOffset = _ref2$dstOffset === void 0 ? 0 : _ref2$dstOffset,\n        _ref2$length = _ref2.length,\n        length = _ref2$length === void 0 ? 0 : _ref2$length;\n      assertWebGL2Context(this.gl);\n      var ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {\n        clamped: false\n      });\n      var sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);\n      var dstElementOffset = dstOffset;\n      var dstAvailableElementCount;\n      var dstElementCount;\n      if (dstData) {\n        dstElementCount = dstData.length;\n        dstAvailableElementCount = dstElementCount - dstElementOffset;\n      } else {\n        dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);\n        dstElementCount = dstElementOffset + dstAvailableElementCount;\n      }\n      var copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);\n      length = length || copyElementCount;\n      assert(length <= copyElementCount);\n      dstData = dstData || new ArrayType(dstElementCount);\n      this.gl.bindBuffer(36662, this.handle);\n      this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);\n      this.gl.bindBuffer(36662, null);\n      return dstData;\n    }\n  }, {\n    key: \"bind\",\n    value: function bind() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$target = _ref3.target,\n        target = _ref3$target === void 0 ? this.target : _ref3$target,\n        _ref3$index = _ref3.index,\n        index = _ref3$index === void 0 ? this.accessor && this.accessor.index : _ref3$index,\n        _ref3$offset = _ref3.offset,\n        offset = _ref3$offset === void 0 ? 0 : _ref3$offset,\n        size = _ref3.size;\n      if (target === 35345 || target === 35982) {\n        if (size !== undefined) {\n          this.gl.bindBufferRange(target, index, this.handle, offset, size);\n        } else {\n          assert(offset === 0);\n          this.gl.bindBufferBase(target, index, this.handle);\n        }\n      } else {\n        this.gl.bindBuffer(target, this.handle);\n      }\n      return this;\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref4$target = _ref4.target,\n        target = _ref4$target === void 0 ? this.target : _ref4$target,\n        _ref4$index = _ref4.index,\n        index = _ref4$index === void 0 ? this.accessor && this.accessor.index : _ref4$index;\n      var isIndexedBuffer = target === 35345 || target === 35982;\n      if (isIndexedBuffer) {\n        this.gl.bindBufferBase(target, index, null);\n      } else {\n        this.gl.bindBuffer(target, null);\n      }\n      return this;\n    }\n  }, {\n    key: \"getDebugData\",\n    value: function getDebugData() {\n      if (!this.debugData) {\n        this.debugData = this.getData({\n          length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)\n        });\n        return {\n          data: this.debugData,\n          changed: true\n        };\n      }\n      return {\n        data: this.debugData,\n        changed: false\n      };\n    }\n  }, {\n    key: \"invalidateDebugData\",\n    value: function invalidateDebugData() {\n      this.debugData = null;\n    }\n  }, {\n    key: \"_setData\",\n    value: function _setData(data) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var byteLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : data.byteLength + offset;\n      assert(ArrayBuffer.isView(data));\n      this._trackDeallocatedMemory();\n      var target = this._getTarget();\n      this.gl.bindBuffer(target, this.handle);\n      this.gl.bufferData(target, byteLength, this.usage);\n      this.gl.bufferSubData(target, offset, data);\n      this.gl.bindBuffer(target, null);\n      this.debugData = data.slice(0, DEBUG_DATA_LENGTH);\n      this.bytesUsed = byteLength;\n      this._trackAllocatedMemory(byteLength);\n      var type = getGLTypeFromTypedArray(data);\n      assert(type);\n      this.setAccessor(new Accessor(this.accessor, {\n        type: type\n      }));\n      return this;\n    }\n  }, {\n    key: \"_setByteLength\",\n    value: function _setByteLength(byteLength) {\n      var usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;\n      assert(byteLength >= 0);\n      this._trackDeallocatedMemory();\n      var data = byteLength;\n      if (byteLength === 0) {\n        data = new Float32Array(0);\n      }\n      var target = this._getTarget();\n      this.gl.bindBuffer(target, this.handle);\n      this.gl.bufferData(target, data, usage);\n      this.gl.bindBuffer(target, null);\n      this.usage = usage;\n      this.debugData = null;\n      this.bytesUsed = byteLength;\n      this._trackAllocatedMemory(byteLength);\n      return this;\n    }\n  }, {\n    key: \"_getTarget\",\n    value: function _getTarget() {\n      return this.gl.webgl2 ? 36663 : this.target;\n    }\n  }, {\n    key: \"_getAvailableElementCount\",\n    value: function _getAvailableElementCount(srcByteOffset) {\n      var ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {\n        clamped: false\n      });\n      var sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;\n      return this.getElementCount() - sourceElementOffset;\n    }\n  }, {\n    key: \"_inferType\",\n    value: function _inferType(data) {\n      if (!this.accessor.type) {\n        this.setAccessor(new Accessor(this.accessor, {\n          type: getGLTypeFromTypedArray(data)\n        }));\n      }\n    }\n  }, {\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return this.gl.createBuffer();\n    }\n  }, {\n    key: \"_deleteHandle\",\n    value: function _deleteHandle() {\n      this.gl.deleteBuffer(this.handle);\n      this._trackDeallocatedMemory();\n    }\n  }, {\n    key: \"_getParameter\",\n    value: function _getParameter(pname) {\n      this.gl.bindBuffer(this.target, this.handle);\n      var value = this.gl.getBufferParameter(this.target, pname);\n      this.gl.bindBuffer(this.target, null);\n      return value;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      log.deprecated('Buffer.type', 'Buffer.accessor.type')();\n      return this.accessor.type;\n    }\n  }, {\n    key: \"bytes\",\n    get: function get() {\n      log.deprecated('Buffer.bytes', 'Buffer.byteLength')();\n      return this.byteLength;\n    }\n  }, {\n    key: \"setByteLength\",\n    value: function setByteLength(byteLength) {\n      log.deprecated('setByteLength', 'reallocate')();\n      return this.reallocate(byteLength);\n    }\n  }, {\n    key: \"updateAccessor\",\n    value: function updateAccessor(opts) {\n      log.deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)')();\n      this.accessor = new Accessor(this.accessor, opts);\n      return this;\n    }\n  }]);\n  return Buffer;\n}(Resource, Symbol.toStringTag);\nexport { Buffer as default };","map":{"version":3,"names":["Resource","Accessor","getGLTypeFromTypedArray","getTypedArrayFromGLType","assertWebGL2Context","log","assert","checkProps","DEBUG_DATA_LENGTH","DEPRECATED_PROPS","offset","stride","type","size","divisor","normalized","integer","instanced","isInstanced","PROP_CHECKS_INITIALIZE","removedProps","replacedProps","bytes","deprecatedProps","PROP_CHECKS_SET_PROPS","Buffer","_Resource","_Symbol$toStringTag","_inherits","_super","_createSuper","gl","_this","_classCallCheck","props","arguments","length","undefined","call","stubRemovedMethods","target","webgl2","initialize","Object","seal","_assertThisInitialized","_createClass","key","get","value","getElementCount","accessor","Math","round","byteLength","getBytesPerElement","getVertexCount","getBytesPerVertex","ArrayBuffer","isView","data","Number","isFinite","usage","debugData","setAccessor","assign","_setData","_setByteLength","setProps","buffer","reallocate","bytesUsed","setData","subData","_props","_props$offset","_props$srcOffset","srcOffset","bindBuffer","handle","bufferSubData","_inferType","copyData","_ref","sourceBuffer","_ref$readOffset","readOffset","_ref$writeOffset","writeOffset","copyBufferSubData","getData","_ref2","_ref2$dstData","dstData","_ref2$srcByteOffset","srcByteOffset","_ref2$dstOffset","dstOffset","_ref2$length","ArrayType","clamped","sourceAvailableElementCount","_getAvailableElementCount","dstElementOffset","dstAvailableElementCount","dstElementCount","min","copyElementCount","getBufferSubData","bind","_ref3","_ref3$target","_ref3$index","index","_ref3$offset","bindBufferRange","bindBufferBase","unbind","_ref4","_ref4$target","_ref4$index","isIndexedBuffer","getDebugData","changed","invalidateDebugData","_trackDeallocatedMemory","_getTarget","bufferData","slice","_trackAllocatedMemory","Float32Array","sourceElementOffset","BYTES_PER_ELEMENT","_createHandle","createBuffer","_deleteHandle","deleteBuffer","_getParameter","pname","getBufferParameter","deprecated","setByteLength","updateAccessor","opts","Symbol","toStringTag","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@luma.gl/webgl/src/classes/buffer.js"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport Resource from './resource';\nimport Accessor from './accessor';\nimport {getGLTypeFromTypedArray, getTypedArrayFromGLType} from '../webgl-utils/typed-array-utils';\nimport {assertWebGL2Context, log} from '@luma.gl/gltools';\nimport {assert} from '../utils/assert';\nimport {checkProps} from '../utils/check-props';\n\nconst DEBUG_DATA_LENGTH = 10;\n\n// Shared prop checks for constructor and setProps\nconst DEPRECATED_PROPS = {\n  offset: 'accessor.offset',\n  stride: 'accessor.stride',\n  type: 'accessor.type',\n  size: 'accessor.size',\n  divisor: 'accessor.divisor',\n  normalized: 'accessor.normalized',\n  integer: 'accessor.integer',\n  instanced: 'accessor.divisor',\n  isInstanced: 'accessor.divisor'\n};\n\n// Prop checks for constructor\nconst PROP_CHECKS_INITIALIZE = {\n  removedProps: {},\n  replacedProps: {\n    bytes: 'byteLength'\n  },\n  // new Buffer() with individual accessor props is still used in apps, emit warnings\n  deprecatedProps: DEPRECATED_PROPS\n};\n\n// Prop checks for setProps\nconst PROP_CHECKS_SET_PROPS = {\n  // Buffer.setProps() with individual accessor props is rare => emit errors\n  removedProps: DEPRECATED_PROPS\n};\n\nexport default class Buffer extends Resource {\n  // eslint-disable-next-line accessor-pairs\n  get [Symbol.toStringTag]() {\n    return 'Buffer';\n  }\n  constructor(gl, props = {}) {\n    super(gl, props);\n\n    this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);\n    // this.stubRemovedMethods('Buffer', 'v7.0', ['updateAccessor']);\n\n    // In WebGL1, need to make sure we use GL.ELEMENT_ARRAY_BUFFER when initializing element buffers\n    // otherwise buffer type will lock to generic (non-element) buffer\n    // In WebGL2, we can use GL.COPY_READ_BUFFER which avoids locking the type here\n    this.target = props.target || (this.gl.webgl2 ? GL.COPY_READ_BUFFER : GL.ARRAY_BUFFER);\n\n    this.initialize(props);\n\n    Object.seal(this);\n  }\n\n  // returns number of elements in the buffer (assuming that the full buffer is used)\n  getElementCount(accessor = this.accessor) {\n    return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));\n  }\n\n  // returns number of vertices in the buffer (assuming that the full buffer is used)\n  getVertexCount(accessor = this.accessor) {\n    return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));\n  }\n\n  // Creates and initializes the buffer object's data store.\n  // Signature: `new Buffer(gl, {data: new Float32Array(...)})`\n  // Signature: `new Buffer(gl, new Float32Array(...))`\n  // Signature: `new Buffer(gl, 100)`\n  initialize(props = {}) {\n    // Signature `new Buffer(gl, new Float32Array(...)`\n    if (ArrayBuffer.isView(props)) {\n      props = {data: props};\n    }\n\n    // Signature: `new Buffer(gl, 100)`\n    if (Number.isFinite(props)) {\n      props = {byteLength: props};\n    }\n\n    props = checkProps('Buffer', props, PROP_CHECKS_INITIALIZE);\n\n    // Initialize member fields\n    this.usage = props.usage || GL.STATIC_DRAW;\n    this.debugData = null;\n\n    // Deprecated: Merge main props and accessor\n    this.setAccessor(Object.assign({}, props, props.accessor));\n\n    // Set data: (re)initializes the buffer\n    if (props.data) {\n      this._setData(props.data, props.offset, props.byteLength);\n    } else {\n      this._setByteLength(props.byteLength || 0);\n    }\n\n    return this;\n  }\n\n  setProps(props) {\n    props = checkProps('Buffer', props, PROP_CHECKS_SET_PROPS);\n\n    if ('accessor' in props) {\n      this.setAccessor(props.accessor);\n    }\n\n    return this;\n  }\n\n  // Optionally stores an accessor with the buffer, makes it easier to use it as an attribute later\n  // {type, size = 1, offset = 0, stride = 0, normalized = false, integer = false, divisor = 0}\n  setAccessor(accessor) {\n    // NOTE: From luma.gl v7.0, Accessors have an optional `buffer `field\n    // (mainly to support \"interleaving\")\n    // To avoid confusion, ensure `buffer.accessor` does not have a `buffer.accessor.buffer` field:\n    accessor = Object.assign({}, accessor);\n    delete accessor.buffer;\n\n    // This new statement ensures that an \"accessor object\" is re-packaged as an Accessor instance\n    this.accessor = new Accessor(accessor);\n    return this;\n  }\n\n  // Allocate a bigger GPU buffer (if the current buffer is not big enough).\n  // If a reallocation is triggered it clears the buffer\n  // Returns:\n  //  `true`: buffer was reallocated, data was cleared\n  //  `false`: buffer was big enough, data is intact\n  reallocate(byteLength) {\n    if (byteLength > this.byteLength) {\n      this._setByteLength(byteLength);\n      return true;\n    }\n    this.bytesUsed = byteLength;\n    return false;\n  }\n\n  // Update with new data. Reinitializes the buffer\n  setData(props) {\n    return this.initialize(props);\n  }\n\n  // Updates a subset of a buffer object's data store.\n  // Data (Typed Array or ArrayBuffer), length is inferred unless provided\n  // Offset into buffer\n  // WebGL2 only: Offset into srcData\n  // WebGL2 only: Number of bytes to be copied\n  subData(props) {\n    // Signature: buffer.subData(new Float32Array([...]))\n    if (ArrayBuffer.isView(props)) {\n      props = {data: props};\n    }\n\n    const {data, offset = 0, srcOffset = 0} = props;\n    const byteLength = props.byteLength || props.length;\n\n    assert(data);\n\n    // Create the buffer - binding it here for the first time locks the type\n    // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n    const target = this.gl.webgl2 ? GL.COPY_WRITE_BUFFER : this.target;\n    this.gl.bindBuffer(target, this.handle);\n    // WebGL2: subData supports additional srcOffset and length parameters\n    if (srcOffset !== 0 || byteLength !== undefined) {\n      assertWebGL2Context(this.gl);\n      this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);\n    } else {\n      this.gl.bufferSubData(target, offset, data);\n    }\n    this.gl.bindBuffer(target, null);\n\n    // TODO - update local `data` if offsets are right\n    this.debugData = null;\n\n    this._inferType(data);\n\n    return this;\n  }\n\n  // WEBGL2 ONLY: Copies part of the data of another buffer into this buffer\n  copyData({sourceBuffer, readOffset = 0, writeOffset = 0, size}) {\n    const {gl} = this;\n    assertWebGL2Context(gl);\n\n    // Use GL.COPY_READ_BUFFER+GL.COPY_WRITE_BUFFER avoid disturbing other targets and locking type\n    gl.bindBuffer(GL.COPY_READ_BUFFER, sourceBuffer.handle);\n    gl.bindBuffer(GL.COPY_WRITE_BUFFER, this.handle);\n    gl.copyBufferSubData(GL.COPY_READ_BUFFER, GL.COPY_WRITE_BUFFER, readOffset, writeOffset, size);\n    gl.bindBuffer(GL.COPY_READ_BUFFER, null);\n    gl.bindBuffer(GL.COPY_WRITE_BUFFER, null);\n\n    // TODO - update local `data` if offsets are 0\n    this.debugData = null;\n\n    return this;\n  }\n\n  // WEBGL2 ONLY: Reads data from buffer into an ArrayBufferView or SharedArrayBuffer.\n  getData({dstData = null, srcByteOffset = 0, dstOffset = 0, length = 0} = {}) {\n    assertWebGL2Context(this.gl);\n\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || GL.FLOAT, {clamped: false});\n    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);\n\n    const dstElementOffset = dstOffset;\n\n    let dstAvailableElementCount;\n    let dstElementCount;\n    if (dstData) {\n      dstElementCount = dstData.length;\n      dstAvailableElementCount = dstElementCount - dstElementOffset;\n    } else {\n      // Allocate ArrayBufferView with enough size to copy all eligible data.\n      dstAvailableElementCount = Math.min(\n        sourceAvailableElementCount,\n        length || sourceAvailableElementCount\n      );\n      dstElementCount = dstElementOffset + dstAvailableElementCount;\n    }\n\n    const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);\n    length = length || copyElementCount;\n    assert(length <= copyElementCount);\n    dstData = dstData || new ArrayType(dstElementCount);\n\n    // Use GL.COPY_READ_BUFFER to avoid disturbing other targets and locking type\n    this.gl.bindBuffer(GL.COPY_READ_BUFFER, this.handle);\n    this.gl.getBufferSubData(GL.COPY_READ_BUFFER, srcByteOffset, dstData, dstOffset, length);\n    this.gl.bindBuffer(GL.COPY_READ_BUFFER, null);\n\n    // TODO - update local `data` if offsets are 0\n    return dstData;\n  }\n\n  /**\n   * Binds a buffer to a given binding point (target).\n   *   GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER take an index, and optionally a range.\n   *   - GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER need an index to affect state\n   *   - GL.UNIFORM_BUFFER: `offset` must be aligned to GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT.\n   *   - GL.UNIFORM_BUFFER: `size` must be a minimum of GL.UNIFORM_BLOCK_SIZE_DATA.\n   */\n  bind({\n    target = this.target, // target for the bind operation\n    index = this.accessor && this.accessor.index, // index = index of target (indexed bind point)\n    offset = 0,\n    size\n  } = {}) {\n    // NOTE: While GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER could\n    // be used as direct binding points, they will not affect transform feedback or\n    // uniform buffer state. Instead indexed bindings need to be made.\n    if (target === GL.UNIFORM_BUFFER || target === GL.TRANSFORM_FEEDBACK_BUFFER) {\n      if (size !== undefined) {\n        this.gl.bindBufferRange(target, index, this.handle, offset, size);\n      } else {\n        assert(offset === 0); // Make sure offset wasn't supplied\n        this.gl.bindBufferBase(target, index, this.handle);\n      }\n    } else {\n      this.gl.bindBuffer(target, this.handle);\n    }\n\n    return this;\n  }\n\n  unbind({target = this.target, index = this.accessor && this.accessor.index} = {}) {\n    const isIndexedBuffer = target === GL.UNIFORM_BUFFER || target === GL.TRANSFORM_FEEDBACK_BUFFER;\n    if (isIndexedBuffer) {\n      this.gl.bindBufferBase(target, index, null);\n    } else {\n      this.gl.bindBuffer(target, null);\n    }\n    return this;\n  }\n\n  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)\n\n  // Returns a short initial data array\n  getDebugData() {\n    if (!this.debugData) {\n      this.debugData = this.getData({length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)});\n      return {data: this.debugData, changed: true};\n    }\n    return {data: this.debugData, changed: false};\n  }\n\n  invalidateDebugData() {\n    this.debugData = null;\n  }\n\n  // PRIVATE METHODS\n\n  // Allocate a new buffer and initialize to contents of typed array\n  _setData(data, offset = 0, byteLength = data.byteLength + offset) {\n    assert(ArrayBuffer.isView(data));\n\n    this._trackDeallocatedMemory();\n\n    const target = this._getTarget();\n    this.gl.bindBuffer(target, this.handle);\n    this.gl.bufferData(target, byteLength, this.usage);\n    this.gl.bufferSubData(target, offset, data);\n    this.gl.bindBuffer(target, null);\n\n    this.debugData = data.slice(0, DEBUG_DATA_LENGTH);\n    this.bytesUsed = byteLength;\n\n    this._trackAllocatedMemory(byteLength);\n\n    // infer GL type from supplied typed array\n    const type = getGLTypeFromTypedArray(data);\n    assert(type);\n    this.setAccessor(new Accessor(this.accessor, {type}));\n    return this;\n  }\n\n  // Allocate a GPU buffer of specified size.\n  _setByteLength(byteLength, usage = this.usage) {\n    assert(byteLength >= 0);\n\n    this._trackDeallocatedMemory();\n\n    // Workaround needed for Safari (#291):\n    // gl.bufferData with size equal to 0 crashes. Instead create zero sized array.\n    let data = byteLength;\n    if (byteLength === 0) {\n      data = new Float32Array(0);\n    }\n\n    const target = this._getTarget();\n    this.gl.bindBuffer(target, this.handle);\n    this.gl.bufferData(target, data, usage);\n    this.gl.bindBuffer(target, null);\n\n    this.usage = usage;\n    this.debugData = null;\n    this.bytesUsed = byteLength;\n\n    this._trackAllocatedMemory(byteLength);\n\n    return this;\n  }\n\n  // Binding a buffer for the first time locks the type\n  // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n  _getTarget() {\n    return this.gl.webgl2 ? GL.COPY_WRITE_BUFFER : this.target;\n  }\n\n  _getAvailableElementCount(srcByteOffset) {\n    const ArrayType = getTypedArrayFromGLType(this.accessor.type || GL.FLOAT, {clamped: false});\n    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;\n    return this.getElementCount() - sourceElementOffset;\n  }\n\n  // Automatically infers type from typed array passed to setData\n  // Note: No longer that useful, since type is now autodeduced from the compiled shaders\n  _inferType(data) {\n    if (!this.accessor.type) {\n      this.setAccessor(new Accessor(this.accessor, {type: getGLTypeFromTypedArray(data)}));\n    }\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createBuffer();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteBuffer(this.handle);\n    this._trackDeallocatedMemory();\n  }\n\n  _getParameter(pname) {\n    this.gl.bindBuffer(this.target, this.handle);\n    const value = this.gl.getBufferParameter(this.target, pname);\n    this.gl.bindBuffer(this.target, null);\n    return value;\n  }\n\n  // DEPRECATIONS - v7.0\n  get type() {\n    log.deprecated('Buffer.type', 'Buffer.accessor.type')();\n    return this.accessor.type;\n  }\n\n  get bytes() {\n    log.deprecated('Buffer.bytes', 'Buffer.byteLength')();\n    return this.byteLength;\n  }\n\n  // DEPRECATIONS - v6.0\n  // Deprecated in v6.x, but not warnings not properly implemented\n  setByteLength(byteLength) {\n    log.deprecated('setByteLength', 'reallocate')();\n    return this.reallocate(byteLength);\n  }\n\n  // Deprecated in v6.x, but not warnings not properly implemented\n  updateAccessor(opts) {\n    log.deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)')();\n    this.accessor = new Accessor(this.accessor, opts);\n    return this;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}