{"ast":null,"code":"import { log } from '@deck.gl/core';\nexport function getGeojsonFeatures(geojson) {\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n  log.assert(geojson.type, 'GeoJSON does not have type');\n  switch (geojson.type) {\n    case 'Feature':\n      return [geojson];\n    case 'FeatureCollection':\n      log.assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');\n      return geojson.features;\n    default:\n      return [{\n        geometry: geojson\n      }];\n  }\n}\nexport function separateGeojsonFeatures(features, wrapFeature) {\n  var dataRange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var separated = {\n    pointFeatures: [],\n    lineFeatures: [],\n    polygonFeatures: [],\n    polygonOutlineFeatures: []\n  };\n  var _dataRange$startRow = dataRange.startRow,\n    startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow,\n    _dataRange$endRow = dataRange.endRow,\n    endRow = _dataRange$endRow === void 0 ? features.length : _dataRange$endRow;\n  for (var featureIndex = startRow; featureIndex < endRow; featureIndex++) {\n    var feature = features[featureIndex];\n    var geometry = feature.geometry;\n    if (!geometry) {\n      continue;\n    }\n    if (geometry.type === 'GeometryCollection') {\n      log.assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');\n      var geometries = geometry.geometries;\n      for (var i = 0; i < geometries.length; i++) {\n        var subGeometry = geometries[i];\n        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);\n      }\n    } else {\n      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);\n    }\n  }\n  return separated;\n}\nfunction separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {\n  var type = geometry.type,\n    coordinates = geometry.coordinates;\n  var pointFeatures = separated.pointFeatures,\n    lineFeatures = separated.lineFeatures,\n    polygonFeatures = separated.polygonFeatures,\n    polygonOutlineFeatures = separated.polygonOutlineFeatures;\n  if (!validateGeometry(type, coordinates)) {\n    log.warn(\"\".concat(type, \" coordinates are malformed\"))();\n    return;\n  }\n  switch (type) {\n    case 'Point':\n      pointFeatures.push(wrapFeature({\n        geometry: geometry\n      }, sourceFeature, sourceFeatureIndex));\n      break;\n    case 'MultiPoint':\n      coordinates.forEach(function (point) {\n        pointFeatures.push(wrapFeature({\n          geometry: {\n            type: 'Point',\n            coordinates: point\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n    case 'LineString':\n      lineFeatures.push(wrapFeature({\n        geometry: geometry\n      }, sourceFeature, sourceFeatureIndex));\n      break;\n    case 'MultiLineString':\n      coordinates.forEach(function (path) {\n        lineFeatures.push(wrapFeature({\n          geometry: {\n            type: 'LineString',\n            coordinates: path\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n    case 'Polygon':\n      polygonFeatures.push(wrapFeature({\n        geometry: geometry\n      }, sourceFeature, sourceFeatureIndex));\n      coordinates.forEach(function (path) {\n        polygonOutlineFeatures.push(wrapFeature({\n          geometry: {\n            type: 'LineString',\n            coordinates: path\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n    case 'MultiPolygon':\n      coordinates.forEach(function (polygon) {\n        polygonFeatures.push(wrapFeature({\n          geometry: {\n            type: 'Polygon',\n            coordinates: polygon\n          }\n        }, sourceFeature, sourceFeatureIndex));\n        polygon.forEach(function (path) {\n          polygonOutlineFeatures.push(wrapFeature({\n            geometry: {\n              type: 'LineString',\n              coordinates: path\n            }\n          }, sourceFeature, sourceFeatureIndex));\n        });\n      });\n      break;\n    default:\n  }\n}\nvar COORDINATE_NEST_LEVEL = {\n  Point: 1,\n  MultiPoint: 2,\n  LineString: 2,\n  MultiLineString: 3,\n  Polygon: 3,\n  MultiPolygon: 4\n};\nexport function validateGeometry(type, coordinates) {\n  var nestLevel = COORDINATE_NEST_LEVEL[type];\n  log.assert(nestLevel, \"Unknown GeoJSON type \".concat(type));\n  while (coordinates && --nestLevel > 0) {\n    coordinates = coordinates[0];\n  }\n  return coordinates && Number.isFinite(coordinates[0]);\n}","map":{"version":3,"names":["log","getGeojsonFeatures","geojson","Array","isArray","assert","type","features","geometry","separateGeojsonFeatures","wrapFeature","dataRange","arguments","length","undefined","separated","pointFeatures","lineFeatures","polygonFeatures","polygonOutlineFeatures","_dataRange$startRow","startRow","_dataRange$endRow","endRow","featureIndex","feature","geometries","i","subGeometry","separateGeometry","sourceFeature","sourceFeatureIndex","coordinates","validateGeometry","warn","concat","push","forEach","point","path","polygon","COORDINATE_NEST_LEVEL","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","nestLevel","Number","isFinite"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/layers/src/geojson-layer/geojson.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {log} from '@deck.gl/core';\nimport type {\n  Feature,\n  GeoJSON,\n  GeoJsonGeometryTypes,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon\n} from 'geojson';\n\ntype SupportedGeometry = Point | MultiPoint | LineString | MultiLineString | Polygon | MultiPolygon;\n\nexport type SeparatedGeometries = {\n  pointFeatures: {geometry: Point}[];\n  lineFeatures: {geometry: LineString}[];\n  polygonFeatures: {geometry: Polygon}[];\n  polygonOutlineFeatures: {geometry: LineString}[];\n};\n\n/**\n * \"Normalizes\" complete or partial GeoJSON data into iterable list of features\n * Can accept GeoJSON geometry or \"Feature\", \"FeatureCollection\" in addition\n * to plain arrays and iterables.\n * Works by extracting the feature array or wrapping single objects in an array,\n * so that subsequent code can simply iterate over features.\n *\n * @param {object} geojson - geojson data\n * @param {Object|Array} data - geojson object (FeatureCollection, Feature or\n *  Geometry) or array of features\n * @return {Array|\"iteratable\"} - iterable list of features\n */\nexport function getGeojsonFeatures(geojson: GeoJSON): Feature[] {\n  // If array, assume this is a list of features\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  log.assert(geojson.type, 'GeoJSON does not have type');\n\n  switch (geojson.type) {\n    case 'Feature':\n      // Wrap the feature in a 'Features' array\n      return [geojson];\n    case 'FeatureCollection':\n      // Just return the 'Features' array from the collection\n      log.assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');\n      return geojson.features;\n    default:\n      // Assume it's a geometry, we'll check type in separateGeojsonFeatures\n      // Wrap the geometry object in a 'Feature' object and wrap in an array\n      return [{geometry: geojson}] as Feature[];\n  }\n}\n\n// Linearize\nexport function separateGeojsonFeatures(\n  features: Feature[],\n  wrapFeature: <T>(row: T, sourceObject: any, sourceObjectIndex: number) => T,\n  dataRange: {startRow?: number; endRow?: number} = {}\n): SeparatedGeometries {\n  const separated: SeparatedGeometries = {\n    pointFeatures: [],\n    lineFeatures: [],\n    polygonFeatures: [],\n    polygonOutlineFeatures: []\n  };\n  const {startRow = 0, endRow = features.length} = dataRange;\n\n  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {\n    const feature = features[featureIndex];\n    const {geometry} = feature;\n\n    if (!geometry) {\n      // geometry can be null per specification\n      continue;\n    }\n\n    if (geometry.type === 'GeometryCollection') {\n      log.assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');\n      const {geometries} = geometry;\n      for (let i = 0; i < geometries.length; i++) {\n        const subGeometry = geometries[i];\n        separateGeometry(\n          subGeometry as SupportedGeometry,\n          separated,\n          wrapFeature,\n          feature,\n          featureIndex\n        );\n      }\n    } else {\n      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);\n    }\n  }\n\n  return separated;\n}\n\nfunction separateGeometry(\n  geometry: SupportedGeometry,\n  separated: SeparatedGeometries,\n  wrapFeature: <T>(row: T, sourceObject: any, sourceObjectIndex: number) => T,\n  sourceFeature: Feature,\n  sourceFeatureIndex: number\n) {\n  const {type, coordinates} = geometry;\n  const {pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures} = separated;\n\n  if (!validateGeometry(type, coordinates)) {\n    // Avoid hard failure if some features are malformed\n    log.warn(`${type} coordinates are malformed`)();\n    return;\n  }\n\n  // Split each feature, but keep track of the source feature and index (for Multi* geometries)\n  switch (type) {\n    case 'Point':\n      pointFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      break;\n    case 'MultiPoint':\n      coordinates.forEach(point => {\n        pointFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'Point', coordinates: point}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'LineString':\n      lineFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      break;\n    case 'MultiLineString':\n      // Break multilinestrings into multiple lines\n      coordinates.forEach(path => {\n        lineFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'LineString', coordinates: path}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'Polygon':\n      polygonFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      // Break polygon into multiple lines\n      coordinates.forEach(path => {\n        polygonOutlineFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'LineString', coordinates: path}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'MultiPolygon':\n      // Break multipolygons into multiple polygons\n      coordinates.forEach(polygon => {\n        polygonFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'Polygon', coordinates: polygon}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n        // Break polygon into multiple lines\n        polygon.forEach(path => {\n          polygonOutlineFeatures.push(\n            wrapFeature(\n              {\n                geometry: {type: 'LineString', coordinates: path}\n              },\n              sourceFeature,\n              sourceFeatureIndex\n            )\n          );\n        });\n      });\n      break;\n    default:\n  }\n}\n\n/**\n * Simple GeoJSON validation util. For perf reasons we do not validate against the full spec,\n * only the following:\n   - geometry.type is supported\n   - geometry.coordinate has correct nesting level\n */\nconst COORDINATE_NEST_LEVEL: Record<SupportedGeometry['type'], number> = {\n  Point: 1,\n  MultiPoint: 2,\n  LineString: 2,\n  MultiLineString: 3,\n  Polygon: 3,\n  MultiPolygon: 4\n};\n\nexport function validateGeometry(type: GeoJsonGeometryTypes, coordinates: any): boolean {\n  let nestLevel = COORDINATE_NEST_LEVEL[type] as number;\n\n  log.assert(nestLevel, `Unknown GeoJSON type ${type}`);\n\n  while (coordinates && --nestLevel > 0) {\n    coordinates = coordinates[0];\n  }\n\n  return coordinates && Number.isFinite(coordinates[0]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}