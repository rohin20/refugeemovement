{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _asyncIterator from \"@babel/runtime/helpers/esm/asyncIterator\";\nimport Papa from '../libs/papaparse';\nvar ChunkStreamer = Papa.ChunkStreamer;\nexport default function AsyncIteratorStreamer(config) {\n  config = config || {};\n  ChunkStreamer.call(this, config);\n  this.textDecoder = new TextDecoder(this._config.encoding);\n  this.stream = function () {\n    var _ref = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(asyncIterator) {\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              this._input = asyncIterator;\n              _context.prev = 1;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context.prev = 4;\n              _iterator = _asyncIterator(asyncIterator);\n            case 6:\n              _context.next = 8;\n              return _iterator.next();\n            case 8:\n              _step = _context.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context.next = 12;\n              return _step.value;\n            case 12:\n              _value = _context.sent;\n              if (_iteratorNormalCompletion) {\n                _context.next = 19;\n                break;\n              }\n              chunk = _value;\n              this.parseChunk(this.getStringChunk(chunk));\n            case 16:\n              _iteratorNormalCompletion = true;\n              _context.next = 6;\n              break;\n            case 19:\n              _context.next = 25;\n              break;\n            case 21:\n              _context.prev = 21;\n              _context.t0 = _context[\"catch\"](4);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n            case 25:\n              _context.prev = 25;\n              _context.prev = 26;\n              if (!(!_iteratorNormalCompletion && _iterator[\"return\"] != null)) {\n                _context.next = 30;\n                break;\n              }\n              _context.next = 30;\n              return _iterator[\"return\"]();\n            case 30:\n              _context.prev = 30;\n              if (!_didIteratorError) {\n                _context.next = 33;\n                break;\n              }\n              throw _iteratorError;\n            case 33:\n              return _context.finish(30);\n            case 34:\n              return _context.finish(25);\n            case 35:\n              this._finished = true;\n              this.parseChunk('');\n              _context.next = 42;\n              break;\n            case 39:\n              _context.prev = 39;\n              _context.t1 = _context[\"catch\"](1);\n              this._sendError(_context.t1);\n            case 42:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this, [[1, 39], [4, 21, 25, 35], [26,, 30, 34]]);\n    }));\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  this._nextChunk = function nextChunk() {};\n  this.getStringChunk = function (chunk) {\n    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {\n      stream: true\n    });\n  };\n}\nAsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);\nAsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;","map":{"version":3,"names":["Papa","ChunkStreamer","AsyncIteratorStreamer","config","call","textDecoder","TextDecoder","_config","encoding","stream","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","asyncIterator","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","_value","chunk","wrap","_callee$","_context","prev","next","_input","_asyncIterator","sent","done","value","parseChunk","getStringChunk","t0","finish","_finished","t1","_sendError","stop","_x","apply","arguments","_nextChunk","nextChunk","decode","prototype","Object","create","constructor"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@loaders.gl/csv/src/lib/async-iterator-streamer.js"],"sourcesContent":["// A custom papaparse `Streamer` for async iterators\n// Ideally this can be contributed back to papaparse\n// Or papaparse can expose Streamer API so we can extend without forking.\n\n// @ts-nocheck\n/* eslint-disable no-invalid-this */\n/* global TextDecoder */\n\n// Note: papaparse is not an ES6 module\nimport Papa from '../libs/papaparse';\nconst {ChunkStreamer} = Papa;\n\nexport default function AsyncIteratorStreamer(config) {\n  config = config || {};\n\n  ChunkStreamer.call(this, config);\n\n  this.textDecoder = new TextDecoder(this._config.encoding);\n\n  // Implement ChunkStreamer base class methods\n\n  // this.pause = function() {\n  //   ChunkStreamer.prototype.pause.apply(this, arguments);\n  // };\n\n  // this.resume = function() {\n  //   ChunkStreamer.prototype.resume.apply(this, arguments);\n  //   this._input.resume();\n  // };\n\n  this.stream = async function(asyncIterator) {\n    this._input = asyncIterator;\n\n    try {\n      // ES2018 version\n      // TODO - check for pause and abort flags?\n      for await (const chunk of asyncIterator) {\n        this.parseChunk(this.getStringChunk(chunk));\n      }\n\n      // ES5 VERSION\n      // while (true) {\n      //   asyncIterator.next().then(function(value) {\n      //     if (value.done) {\n      //       // finalize iterator?\n      //     }\n      //   }\n      //   const  = await ;\n      //   if (done) return total;\n      //   total += value.length;\n      // }\n\n      this._finished = true;\n      this.parseChunk('');\n    } catch (error) {\n      // Inform ChunkStreamer base class of error\n      this._sendError(error);\n    }\n  };\n\n  this._nextChunk = function nextChunk() {\n    // Left empty, as async iterator automatically pulls next chunk\n  };\n\n  // HELPER METHODS\n  this.getStringChunk = function(chunk) {\n    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {stream: true});\n  };\n}\n\nAsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);\nAsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}