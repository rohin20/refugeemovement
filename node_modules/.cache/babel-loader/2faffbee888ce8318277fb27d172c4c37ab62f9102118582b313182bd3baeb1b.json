{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\nvar _SCALE_FUNCTIONS;\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport { scaleLinear, scalePoint, scaleOrdinal, scaleLog, scaleTime, scaleUtc } from 'd3-scale';\nimport { extent } from 'd3-array';\nimport { set } from 'd3-collection';\nimport { hsl } from 'd3-color';\nimport PropTypes from 'prop-types';\nimport { warning } from './react-utils';\nimport { getUniquePropertyValues, addValueToArray } from './data-utils';\n\n/**\n * Linear scale name.\n * @type {string}\n * @const\n */\nvar LINEAR_SCALE_TYPE = 'linear';\n\n/**\n * Ordinal scale name.\n * @type {string}\n * @const\n */\nvar ORDINAL_SCALE_TYPE = 'ordinal';\n\n/**\n * Category scale.\n * @type {string}\n * @const\n */\nvar CATEGORY_SCALE_TYPE = 'category';\n\n/**\n * Literal scale.\n * Differs slightly from d3's identity scale in that it does not coerce value\n * into numbers, it simply returns exactly what you give it\n * @type {string}\n * @const\n */\nvar LITERAL_SCALE_TYPE = 'literal';\n\n/**\n * Log scale name.\n * @type {string}\n * @const\n */\nvar LOG_SCALE_TYPE = 'log';\n\n/**\n * Time scale name.\n * @type {string}\n * @const\n */\nvar TIME_SCALE_TYPE = 'time';\n\n/**\n * Time UTC scale name.\n * @type {string}\n * @const\n */\nvar TIME_UTC_SCALE_TYPE = 'time-utc';\n\n/**\n * Scale functions that are supported in the library.\n * @type {Object}\n * @const\n */\nvar SCALE_FUNCTIONS = (_SCALE_FUNCTIONS = {}, _defineProperty(_SCALE_FUNCTIONS, LINEAR_SCALE_TYPE, scaleLinear), _defineProperty(_SCALE_FUNCTIONS, ORDINAL_SCALE_TYPE, scalePoint), _defineProperty(_SCALE_FUNCTIONS, CATEGORY_SCALE_TYPE, scaleOrdinal), _defineProperty(_SCALE_FUNCTIONS, LITERAL_SCALE_TYPE, literalScale), _defineProperty(_SCALE_FUNCTIONS, LOG_SCALE_TYPE, scaleLog), _defineProperty(_SCALE_FUNCTIONS, TIME_SCALE_TYPE, scaleTime), _defineProperty(_SCALE_FUNCTIONS, TIME_UTC_SCALE_TYPE, scaleUtc), _SCALE_FUNCTIONS);\n\n/**\n * Attrs for which a scale can be set up at XYPlot level\n * @type {Array}\n * @const\n */\n\nvar XYPLOT_ATTR = ['color', 'fill', 'opacity', 'stroke'];\n\n/**\n * Title case a given string\n * @param {String} str Array of values.\n * @returns {String} titlecased string\n */\nfunction toTitleCase(str) {\n  return '' + str[0].toUpperCase() + str.slice(1);\n}\n\n/**\n * Find the smallest distance between the values on a given scale and return\n * the index of the element, where the smallest distance was found.\n * It returns the first occurrence of i where\n * `scale(value[i]) - scale(value[i - 1])` is minimal\n * @param {Array} values Array of values.\n * @param {Object} scaleObject Scale object.\n * @returns {number} Index of an element where the smallest distance was found.\n * @private\n */\nexport function _getSmallestDistanceIndex(values, scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var result = 0;\n  if (scaleFn) {\n    var nextValue = void 0;\n    var currentValue = scaleFn(values[0]);\n    var distance = Infinity;\n    var nextDistance = void 0;\n    for (var i = 1; i < values.length; i++) {\n      nextValue = scaleFn(values[i]);\n      nextDistance = Math.abs(nextValue - currentValue);\n      if (nextDistance < distance) {\n        distance = nextDistance;\n        result = i;\n      }\n      currentValue = nextValue;\n    }\n  }\n  return result;\n}\n\n/**\n * This is a workaround for issue that ordinal scale\n * does not have invert method implemented in d3-scale.\n * @param {Object} Ordinal d3-scale object.\n * @returns {void}\n * @private\n */\n\nfunction addInvertFunctionToOrdinalScaleObject(scale) {\n  if (scale.invert) {\n    return;\n  }\n  scale.invert = function invert(value) {\n    var _scale$range = scale.range(),\n      _scale$range2 = _slicedToArray(_scale$range, 2),\n      lower = _scale$range2[0],\n      upper = _scale$range2[1];\n    var start = Math.min(lower, upper);\n    var stop = Math.max(lower, upper);\n    if (value < start + scale.padding() * scale.step()) {\n      return scale.domain()[0];\n    }\n    if (value > stop - scale.padding() * scale.step()) {\n      return scale.domain()[scale.domain().length - 1];\n    }\n    var index = Math.floor((value - start - scale.padding() * scale.step()) / scale.step());\n    return scale.domain()[index];\n  };\n}\n\n/**\n * Crate a scale function from the scale object.\n * @param {Object} scaleObject Scale object.\n - scaleObject.domain {Array}\n - scaleObject.range {Array}\n - scaleObject.type {string}\n - scaleObject.attr {string}\n * @returns {*} Scale function.\n * @private\n */\nexport function getScaleFnFromScaleObject(scaleObject) {\n  if (!scaleObject) {\n    return null;\n  }\n  var type = scaleObject.type,\n    domain = scaleObject.domain,\n    range = scaleObject.range;\n  var modDomain = domain[0] === domain[1] ? domain[0] === 0 ? [-1, 0] : [-domain[0], domain[0]] : domain;\n  if (type === LITERAL_SCALE_TYPE) {\n    return literalScale(range[0]);\n  }\n  var scale = SCALE_FUNCTIONS[type]().domain(modDomain).range(range);\n  if (type === ORDINAL_SCALE_TYPE) {\n    scale.padding(0.5);\n    addInvertFunctionToOrdinalScaleObject(scale);\n  }\n  return scale;\n}\n\n/**\n * Get the domain from the array of data.\n * @param {Array} allData All data.\n * @param {function} accessor - accessor for main value.\n * @param {function} accessor0 - accessor for the naught value.\n * @param {string} type Scale type.\n * @returns {Array} Domain.\n * @private\n */\nexport function getDomainByAccessor(allData, accessor, accessor0, type) {\n  var domain = void 0;\n\n  // Collect both attr and available attr0 values from the array of data.\n  var values = allData.reduce(function (data, d) {\n    var value = accessor(d);\n    var value0 = accessor0(d);\n    if (_isDefined(value)) {\n      data.push(value);\n    }\n    if (_isDefined(value0)) {\n      data.push(value0);\n    }\n    return data;\n  }, []);\n  if (!values.length) {\n    return [];\n  }\n\n  // Create proper domain depending on the type of the scale.\n  if (type !== ORDINAL_SCALE_TYPE && type !== CATEGORY_SCALE_TYPE) {\n    domain = extent(values);\n  } else {\n    domain = set(values).values();\n  }\n  return domain;\n}\n\n/**\n * Create custom scale object from the value. When the scale is created from\n * this object, it should return the same value all time.\n * @param {string} attr Attribute.\n * @param {*} value Value.\n * @param {string} type - the type of scale being used\n * @param {function} accessor - the accessor function\n * @param {function} accessor0 - the accessor function for the potential naught value\n * @returns {Object} Custom scale object.\n * @private\n */\nfunction _createScaleObjectForValue(attr, value, type, accessor, accessor0) {\n  if (type === LITERAL_SCALE_TYPE) {\n    return {\n      type: LITERAL_SCALE_TYPE,\n      domain: [],\n      range: [value],\n      distance: 0,\n      attr: attr,\n      baseValue: undefined,\n      isValue: true,\n      accessor: accessor,\n      accessor0: accessor0\n    };\n  }\n  if (typeof value === 'undefined') {\n    return null;\n  }\n  return {\n    type: CATEGORY_SCALE_TYPE,\n    range: [value],\n    domain: [],\n    distance: 0,\n    attr: attr,\n    baseValue: undefined,\n    isValue: true,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n\n/**\n * Create a regular scale object for a further use from the existing parameters.\n * @param {Array} domain - Domain.\n * @param {Array} range - Range.\n * @param {string} type - Type.\n * @param {number} distance - Distance.\n * @param {string} attr - Attribute.\n * @param {number} baseValue - Base value.\n * @param {function} accessor - Attribute accesor\n * @param {function} accessor0 - Attribute accesor for potential naught value\n * @returns {Object} Scale object.\n * @private\n */\nfunction _createScaleObjectForFunction(_ref) {\n  var domain = _ref.domain,\n    range = _ref.range,\n    type = _ref.type,\n    distance = _ref.distance,\n    attr = _ref.attr,\n    baseValue = _ref.baseValue,\n    accessor = _ref.accessor,\n    accessor0 = _ref.accessor0;\n  return {\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    isValue: false,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n\n/**\n * Get scale object from props. E. g. object like {xRange, xDomain, xDistance,\n * xType} is transformed into {range, domain, distance, type}.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {*} Null or an object with the scale.\n * @private\n */\nfunction _collectScaleObjectFromProps(props, attr) {\n  var value = props[attr],\n    fallbackValue = props['_' + attr + 'Value'],\n    range = props[attr + 'Range'],\n    _props$ = props[attr + 'Distance'],\n    distance = _props$ === undefined ? 0 : _props$,\n    baseValue = props[attr + 'BaseValue'],\n    _props$2 = props[attr + 'Type'],\n    type = _props$2 === undefined ? LINEAR_SCALE_TYPE : _props$2,\n    noFallBack = props[attr + 'NoFallBack'],\n    _props$3 = props['get' + toTitleCase(attr)],\n    accessor = _props$3 === undefined ? function (d) {\n      return d[attr];\n    } : _props$3,\n    _props$4 = props['get' + toTitleCase(attr) + '0'],\n    accessor0 = _props$4 === undefined ? function (d) {\n      return d[attr + '0'];\n    } : _props$4;\n  var domain = props[attr + 'Domain'];\n  // Return value-based scale if the value is assigned.\n\n  if (!noFallBack && typeof value !== 'undefined') {\n    return _createScaleObjectForValue(attr, value, props[attr + 'Type'], accessor, accessor0);\n  }\n  // Pick up the domain from the properties and create a new one if it's not\n  // available.\n  if (typeof baseValue !== 'undefined') {\n    domain = addValueToArray(domain, baseValue);\n  }\n\n  // Make sure that the minimum necessary properties exist.\n  if (!range || !domain || !domain.length) {\n    // Try to use the fallback value if it is available.\n    return _createScaleObjectForValue(attr, fallbackValue, props[attr + 'Type'], accessor, accessor0);\n  }\n  return _createScaleObjectForFunction({\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    accessor: accessor,\n    accessor0: accessor0\n  });\n}\n\n/**\n * Compute left domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\nfunction _computeLeftDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[1] - values[0]) / 2;\n  }\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n  return 0;\n}\n\n/**\n * Compute right domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\nfunction _computeRightDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[values.length - 1] - values[values.length - 2]) / 2;\n  }\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n  return 0;\n}\n\n/**\n * Compute distance for the given values.\n * @param {Array} values Array of values.\n * @param {Array} domain Domain.\n * @param {number} bestDistIndex Index of a best distance found.\n * @param {function} scaleFn Scale function.\n * @returns {number} Domain adjustment.\n * @private\n */\nfunction _computeScaleDistance(values, domain, bestDistIndex, scaleFn) {\n  if (values.length > 1) {\n    // Avoid zero indexes.\n    var i = Math.max(bestDistIndex, 1);\n    return Math.abs(scaleFn(values[i]) - scaleFn(values[i - 1]));\n  }\n  if (values.length === 1) {\n    return Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  }\n  return 0;\n}\n\n/**\n * Normilize array of values with a single value.\n * @param {Array} arr Array of data.\n * @param {Array} values Array of values.\n * @param {string} attr Attribute.\n * @param {string} type Type.\n * @private\n */\nfunction _normalizeValues(data, values, accessor0, type) {\n  if (type === TIME_SCALE_TYPE && values.length === 1) {\n    var attr0 = accessor0(data[0]);\n    return [attr0].concat(_toConsumableArray(values));\n  }\n  return values;\n}\n\n/**\n * Get the distance, the smallest and the largest value of the domain.\n * @param {Array} data Array of data for the single series.\n * @param {Object} scaleObject Scale object.\n * @returns {{domain0: number, domainN: number, distance: number}} Result.\n * @private\n */\nexport function _getScaleDistanceAndAdjustedDomain(data, scaleObject) {\n  var domain = scaleObject.domain,\n    type = scaleObject.type,\n    accessor = scaleObject.accessor,\n    accessor0 = scaleObject.accessor0;\n  var uniqueValues = getUniquePropertyValues(data, accessor);\n\n  // Fix time scale if a data has only one value.\n  var values = _normalizeValues(data, uniqueValues, accessor0, type);\n  var index = _getSmallestDistanceIndex(values, scaleObject);\n  var adjustedDomain = [].concat(domain);\n  adjustedDomain[0] -= _computeLeftDomainAdjustment(values);\n  adjustedDomain[domain.length - 1] += _computeRightDomainAdjustment(values);\n  // Fix log scale if it's too small.\n  if (type === LOG_SCALE_TYPE && domain[0] <= 0) {\n    adjustedDomain[0] = Math.min(domain[1] / 10, 1);\n  }\n  var adjustedScaleFn = getScaleFnFromScaleObject(_extends({}, scaleObject, {\n    domain: adjustedDomain\n  }));\n  var distance = _computeScaleDistance(values, adjustedDomain, index, adjustedScaleFn);\n  return {\n    domain0: adjustedDomain[0],\n    domainN: adjustedDomain[adjustedDomain.length - 1],\n    distance: distance\n  };\n}\n\n/**\n * Returns true if scale adjustments are possible for a given scale.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {boolean} True if scale adjustments possible.\n * @private\n */\nfunction _isScaleAdjustmentPossible(props, scaleObject) {\n  var attr = scaleObject.attr;\n  var _props$_adjustBy = props._adjustBy,\n    adjustBy = _props$_adjustBy === undefined ? [] : _props$_adjustBy,\n    _props$_adjustWhat = props._adjustWhat,\n    adjustWhat = _props$_adjustWhat === undefined ? [] : _props$_adjustWhat;\n\n  // The scale cannot be adjusted if there's no attributes to adjust, no\n  // suitable values\n\n  return adjustWhat.length && adjustBy.length && adjustBy.indexOf(attr) !== -1;\n}\n\n/**\n * Adjust continuous scales (e.g. 'linear', 'log' and 'time') by adding the\n * space from the left and right of them and by computing the best distance.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\nfunction _adjustContinuousScale(props, scaleObject) {\n  var allSeriesData = props._allData,\n    _props$_adjustWhat2 = props._adjustWhat,\n    adjustWhat = _props$_adjustWhat2 === undefined ? [] : _props$_adjustWhat2;\n\n  // Assign the initial values.\n\n  var domainLength = scaleObject.domain.length;\n  var domain = scaleObject.domain;\n  var scaleDomain0 = domain[0];\n  var scaleDomainN = domain[domainLength - 1];\n  var scaleDistance = scaleObject.distance;\n\n  // Find the smallest left position of the domain, the largest right position\n  // of the domain and the best distance for them.\n  allSeriesData.forEach(function (data, index) {\n    if (adjustWhat.indexOf(index) === -1) {\n      return;\n    }\n    if (data && data.length) {\n      var _getScaleDistanceAndA = _getScaleDistanceAndAdjustedDomain(data, scaleObject),\n        domain0 = _getScaleDistanceAndA.domain0,\n        domainN = _getScaleDistanceAndA.domainN,\n        distance = _getScaleDistanceAndA.distance;\n      scaleDomain0 = Math.min(scaleDomain0, domain0);\n      scaleDomainN = Math.max(scaleDomainN, domainN);\n      scaleDistance = Math.max(scaleDistance, distance);\n    }\n  });\n  scaleObject.domain = [scaleDomain0].concat(_toConsumableArray(domain.slice(1, -1)), [scaleDomainN]);\n  scaleObject.distance = scaleDistance;\n  return scaleObject;\n}\n\n/**\n * Get an adjusted scale. Suitable for 'category' and 'ordinal' scales.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\nexport function _adjustCategoricalScale(scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var domain = scaleObject.domain,\n    range = scaleObject.range;\n  if (domain.length > 1) {\n    scaleObject.distance = Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  } else {\n    scaleObject.distance = Math.abs(range[1] - range[0]);\n  }\n  return scaleObject;\n}\n\n/**\n * Retrieve a scale object or a value from the properties passed.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute.\n * @returns {*} Scale object, value or null.\n */\nexport function getScaleObjectFromProps(props, attr) {\n  // Create the initial scale object.\n  var scaleObject = _collectScaleObjectFromProps(props, attr);\n  if (!scaleObject) {\n    return null;\n  }\n\n  // Make sure if it's possible to add space to the scale object. If not,\n  // return the object immediately.\n  if (!_isScaleAdjustmentPossible(props, scaleObject)) {\n    return scaleObject;\n  }\n  var type = scaleObject.type;\n  // Depending on what type the scale is, apply different adjustments. Distances\n  // for the ordinal and category scales are even, equal domains cannot be\n  // adjusted.\n\n  if (type === ORDINAL_SCALE_TYPE || type === CATEGORY_SCALE_TYPE) {\n    return _adjustCategoricalScale(scaleObject);\n  }\n  return _adjustContinuousScale(props, scaleObject);\n}\n\n/**\n * Get d3 scale for a given prop.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {function} d3 scale function.\n */\nexport function getAttributeScale(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  return getScaleFnFromScaleObject(scaleObject);\n}\n\n/**\n * Get the value of `attr` from the object.\n * @param {Object} d - data Object.\n * @param {Function} accessor - accessor function.\n * @returns {*} Value of the point.\n * @private\n */\nfunction _getAttrValue(d, accessor) {\n  return accessor(d.data ? d.data : d);\n}\nfunction _isDefined(value) {\n  return typeof value !== 'undefined';\n}\n\n/*\n * Adds a percentage of padding to a given domain\n * @param {Array} domain X or Y domain to pad.\n * @param {Number} padding Percentage of padding to add to domain\n * @returns {Array} Padded Domain\n */\nfunction _padDomain(domain, padding) {\n  if (!domain) {\n    return domain;\n  }\n  if (isNaN(parseFloat(domain[0])) || isNaN(parseFloat(domain[1]))) {\n    return domain;\n  }\n  var _domain = _slicedToArray(domain, 2),\n    min = _domain[0],\n    max = _domain[1];\n  var domainPadding = (max - min) * (padding * 0.01);\n  return [min - domainPadding, max + domainPadding];\n}\n\n/**\n * Get prop functor (either a value or a function) for a given attribute.\n * @param {Object} props Series props.\n * @param {Function} accessor - Property accessor.\n * @returns {*} Function or value.\n */\nexport function getAttributeFunctor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      return scaleFn(_getAttrValue(d, scaleObject.accessor));\n    };\n  }\n  return null;\n}\n\n/**\n * Get the functor which extracts value form [attr]0 property. Use baseValue if\n * no attr0 property for a given object is defined. Fall back to domain[0] if no\n * base value is available.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute name.\n * @returns {*} Function which returns value or null if no values available.\n */\nexport function getAttr0Functor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    var domain = scaleObject.domain;\n    var _scaleObject$baseValu = scaleObject.baseValue,\n      baseValue = _scaleObject$baseValu === undefined ? domain[0] : _scaleObject$baseValu;\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      var value = _getAttrValue(d, scaleObject.accessor0);\n      return scaleFn(_isDefined(value) ? value : baseValue);\n    };\n  }\n  return null;\n}\n\n/**\n * Tries to get the string|number value of the attr and falls back to\n * a fallback property in case if the value is a scale.\n * @param {Object} props Series props.\n * @param {string} attr Property name.\n * @returns {*} Function or value.\n */\nexport function getAttributeValue(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    if (!scaleObject.isValue && props['_' + attr + 'Value'] === undefined) {\n      warning('[React-vis] Cannot use data defined ' + attr + ' for this ' + 'series type. Using fallback value instead.');\n    }\n    return props['_' + attr + 'Value'] || scaleObject.range[0];\n  }\n  return null;\n}\n\n/**\n * Get prop types by the attribute.\n * @param {string} attr Attribute.\n * @returns {Object} Object of xDomain, xRange, xType, xDistance and _xValue,\n * where x is an attribute passed to the function.\n */\nexport function getScalePropTypesByAttribute(attr) {\n  var _ref2;\n  return _ref2 = {}, _defineProperty(_ref2, '_' + attr + 'Value', PropTypes.any), _defineProperty(_ref2, attr + 'Domain', PropTypes.array), _defineProperty(_ref2, 'get' + toTitleCase(attr), PropTypes.func), _defineProperty(_ref2, 'get' + toTitleCase(attr) + '0', PropTypes.func), _defineProperty(_ref2, attr + 'Range', PropTypes.array), _defineProperty(_ref2, attr + 'Type', PropTypes.oneOf(Object.keys(SCALE_FUNCTIONS))), _defineProperty(_ref2, attr + 'Distance', PropTypes.number), _defineProperty(_ref2, attr + 'BaseValue', PropTypes.any), _ref2;\n}\n\n/**\n * Extract the list of scale properties from the entire props object.\n * @param {Object} props Props.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\nexport function extractScalePropsFromProps(props, attributes) {\n  var result = {};\n  Object.keys(props).forEach(function (key) {\n    // this filtering is critical for extracting the correct accessors!\n    var attr = attributes.find(function (a) {\n      // width\n      var isPlainSet = key.indexOf(a) === 0;\n      // Ex: _data\n      var isUnderscoreSet = key.indexOf('_' + a) === 0;\n      // EX: getX\n      var usesGet = key.indexOf('get' + toTitleCase(a)) === 0;\n      return isPlainSet || isUnderscoreSet || usesGet;\n    });\n    if (!attr) {\n      return;\n    }\n    result[key] = props[key];\n  });\n  return result;\n}\n\n/**\n * Extract the missing scale props from the given data and return them as\n * an object.\n * @param {Object} props Props.\n * @param {Array} data Array of all data.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\nexport function getMissingScaleProps(props, data, attributes) {\n  var result = {};\n  // Make sure that the domain is set pad it if specified\n  attributes.forEach(function (attr) {\n    if (!props['get' + toTitleCase(attr)]) {\n      result['get' + toTitleCase(attr)] = function (d) {\n        return d[attr];\n      };\n    }\n    if (!props['get' + toTitleCase(attr) + '0']) {\n      result['get' + toTitleCase(attr) + '0'] = function (d) {\n        return d[attr + '0'];\n      };\n    }\n    if (!props[attr + 'Domain']) {\n      result[attr + 'Domain'] = getDomainByAccessor(data, props['get' + toTitleCase(attr)] || result['get' + toTitleCase(attr)], props['get' + toTitleCase(attr) + '0'] || result['get' + toTitleCase(attr) + '0'], props[attr + 'Type']);\n      if (props[attr + 'Padding']) {\n        result[attr + 'Domain'] = _padDomain(result[attr + 'Domain'], props[attr + 'Padding']);\n      }\n    }\n  });\n  return result;\n}\n\n/**\n * Return a d3 scale that returns the literal value that was given to it\n * @returns {function} literal scale.\n */\nexport function literalScale(defaultValue) {\n  function scale(d) {\n    if (d === undefined) {\n      return defaultValue;\n    }\n    return d;\n  }\n  function response() {\n    return scale;\n  }\n  scale.domain = response;\n  scale.range = response;\n  scale.unknown = response;\n  scale.copy = response;\n  return scale;\n}\nexport function getFontColorFromBackground(background) {\n  if (background) {\n    return hsl(background).l > 0.57 ? '#222' : '#fff';\n  }\n  return null;\n}\n\n/**\n * Creates fallback values for series from scales defined at XYPlot level.\n * @param {Object} props Props of the XYPlot object.\n * @param {Array<Object>} children Array of components, children of XYPlot\n * @returns {Array<Object>} Collected props.\n */\n\nexport function getXYPlotValues(props, children) {\n  var XYPlotScales = XYPLOT_ATTR.reduce(function (prev, attr) {\n    var domain = props[attr + 'Domain'],\n      range = props[attr + 'Range'],\n      type = props[attr + 'Type'];\n    if (domain && range && type) {\n      return _extends({}, prev, _defineProperty({}, attr, SCALE_FUNCTIONS[type]().domain(domain).range(range)));\n    }\n    return prev;\n  }, {});\n  return children.map(function (child) {\n    return XYPLOT_ATTR.reduce(function (prev, attr) {\n      if (child.props && child.props[attr] !== undefined) {\n        var scaleInput = child.props[attr];\n        var scale = XYPlotScales[attr];\n        var fallbackValue = scale ? scale(scaleInput) : scaleInput;\n        return _extends({}, prev, _defineProperty({}, '_' + attr + 'Value', fallbackValue));\n      }\n      return prev;\n    }, {});\n  });\n}\nvar OPTIONAL_SCALE_PROPS = ['Padding'];\nvar OPTIONAL_SCALE_PROPS_REGS = OPTIONAL_SCALE_PROPS.map(function (str) {\n  return new RegExp(str + '$', 'i');\n});\n/**\n * Get the list of optional scale-related settings for XYPlot\n * mostly just used to find padding properties\n * @param {Object} props Object of props.\n * @returns {Object} Optional Props.\n * @private\n */\nexport function getOptionalScaleProps(props) {\n  return Object.keys(props).reduce(function (acc, prop) {\n    var propIsNotOptional = OPTIONAL_SCALE_PROPS_REGS.every(function (reg) {\n      return !prop.match(reg);\n    });\n    if (propIsNotOptional) {\n      return acc;\n    }\n    acc[prop] = props[prop];\n    return acc;\n  }, {});\n}\nexport default {\n  extractScalePropsFromProps: extractScalePropsFromProps,\n  getAttributeScale: getAttributeScale,\n  getAttributeFunctor: getAttributeFunctor,\n  getAttr0Functor: getAttr0Functor,\n  getAttributeValue: getAttributeValue,\n  getDomainByAccessor: getDomainByAccessor,\n  getFontColorFromBackground: getFontColorFromBackground,\n  getMissingScaleProps: getMissingScaleProps,\n  getOptionalScaleProps: getOptionalScaleProps,\n  getScaleObjectFromProps: getScaleObjectFromProps,\n  getScalePropTypesByAttribute: getScalePropTypesByAttribute,\n  getXYPlotValues: getXYPlotValues,\n  literalScale: literalScale\n};","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","err","Array","isArray","TypeError","_SCALE_FUNCTIONS","_toConsumableArray","arr2","from","_defineProperty","obj","defineProperty","enumerable","configurable","writable","scaleLinear","scalePoint","scaleOrdinal","scaleLog","scaleTime","scaleUtc","extent","set","hsl","PropTypes","warning","getUniquePropertyValues","addValueToArray","LINEAR_SCALE_TYPE","ORDINAL_SCALE_TYPE","CATEGORY_SCALE_TYPE","LITERAL_SCALE_TYPE","LOG_SCALE_TYPE","TIME_SCALE_TYPE","TIME_UTC_SCALE_TYPE","SCALE_FUNCTIONS","literalScale","XYPLOT_ATTR","toTitleCase","str","toUpperCase","slice","_getSmallestDistanceIndex","values","scaleObject","scaleFn","getScaleFnFromScaleObject","result","nextValue","currentValue","distance","Infinity","nextDistance","Math","abs","addInvertFunctionToOrdinalScaleObject","scale","invert","_scale$range","range","_scale$range2","lower","upper","start","min","stop","max","padding","step","domain","index","floor","type","modDomain","getDomainByAccessor","allData","accessor","accessor0","reduce","data","d","value0","_isDefined","_createScaleObjectForValue","attr","baseValue","isValue","_createScaleObjectForFunction","_ref","_collectScaleObjectFromProps","props","fallbackValue","_props$","_props$2","noFallBack","_props$3","_props$4","_computeLeftDomainAdjustment","_computeRightDomainAdjustment","_computeScaleDistance","bestDistIndex","_normalizeValues","attr0","concat","_getScaleDistanceAndAdjustedDomain","uniqueValues","adjustedDomain","adjustedScaleFn","domain0","domainN","_isScaleAdjustmentPossible","_props$_adjustBy","_adjustBy","adjustBy","_props$_adjustWhat","_adjustWhat","adjustWhat","indexOf","_adjustContinuousScale","allSeriesData","_allData","_props$_adjustWhat2","domainLength","scaleDomain0","scaleDomainN","scaleDistance","forEach","_getScaleDistanceAndA","_adjustCategoricalScale","getScaleObjectFromProps","getAttributeScale","_getAttrValue","_padDomain","isNaN","parseFloat","_domain","domainPadding","getAttributeFunctor","getAttr0Functor","_scaleObject$baseValu","getAttributeValue","getScalePropTypesByAttribute","_ref2","any","array","func","oneOf","keys","number","extractScalePropsFromProps","attributes","find","a","isPlainSet","isUnderscoreSet","usesGet","getMissingScaleProps","defaultValue","response","unknown","copy","getFontColorFromBackground","background","l","getXYPlotValues","children","XYPlotScales","prev","map","child","scaleInput","OPTIONAL_SCALE_PROPS","OPTIONAL_SCALE_PROPS_REGS","RegExp","getOptionalScaleProps","acc","prop","propIsNotOptional","every","reg","match"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/react-vis/es/utils/scales-utils.js"],"sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _SCALE_FUNCTIONS;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport { scaleLinear, scalePoint, scaleOrdinal, scaleLog, scaleTime, scaleUtc } from 'd3-scale';\nimport { extent } from 'd3-array';\nimport { set } from 'd3-collection';\nimport { hsl } from 'd3-color';\n\nimport PropTypes from 'prop-types';\n\nimport { warning } from './react-utils';\nimport { getUniquePropertyValues, addValueToArray } from './data-utils';\n\n/**\n * Linear scale name.\n * @type {string}\n * @const\n */\nvar LINEAR_SCALE_TYPE = 'linear';\n\n/**\n * Ordinal scale name.\n * @type {string}\n * @const\n */\nvar ORDINAL_SCALE_TYPE = 'ordinal';\n\n/**\n * Category scale.\n * @type {string}\n * @const\n */\nvar CATEGORY_SCALE_TYPE = 'category';\n\n/**\n * Literal scale.\n * Differs slightly from d3's identity scale in that it does not coerce value\n * into numbers, it simply returns exactly what you give it\n * @type {string}\n * @const\n */\nvar LITERAL_SCALE_TYPE = 'literal';\n\n/**\n * Log scale name.\n * @type {string}\n * @const\n */\nvar LOG_SCALE_TYPE = 'log';\n\n/**\n * Time scale name.\n * @type {string}\n * @const\n */\nvar TIME_SCALE_TYPE = 'time';\n\n/**\n * Time UTC scale name.\n * @type {string}\n * @const\n */\nvar TIME_UTC_SCALE_TYPE = 'time-utc';\n\n/**\n * Scale functions that are supported in the library.\n * @type {Object}\n * @const\n */\nvar SCALE_FUNCTIONS = (_SCALE_FUNCTIONS = {}, _defineProperty(_SCALE_FUNCTIONS, LINEAR_SCALE_TYPE, scaleLinear), _defineProperty(_SCALE_FUNCTIONS, ORDINAL_SCALE_TYPE, scalePoint), _defineProperty(_SCALE_FUNCTIONS, CATEGORY_SCALE_TYPE, scaleOrdinal), _defineProperty(_SCALE_FUNCTIONS, LITERAL_SCALE_TYPE, literalScale), _defineProperty(_SCALE_FUNCTIONS, LOG_SCALE_TYPE, scaleLog), _defineProperty(_SCALE_FUNCTIONS, TIME_SCALE_TYPE, scaleTime), _defineProperty(_SCALE_FUNCTIONS, TIME_UTC_SCALE_TYPE, scaleUtc), _SCALE_FUNCTIONS);\n\n/**\n * Attrs for which a scale can be set up at XYPlot level\n * @type {Array}\n * @const\n */\n\nvar XYPLOT_ATTR = ['color', 'fill', 'opacity', 'stroke'];\n\n/**\n * Title case a given string\n * @param {String} str Array of values.\n * @returns {String} titlecased string\n */\nfunction toTitleCase(str) {\n  return '' + str[0].toUpperCase() + str.slice(1);\n}\n\n/**\n * Find the smallest distance between the values on a given scale and return\n * the index of the element, where the smallest distance was found.\n * It returns the first occurrence of i where\n * `scale(value[i]) - scale(value[i - 1])` is minimal\n * @param {Array} values Array of values.\n * @param {Object} scaleObject Scale object.\n * @returns {number} Index of an element where the smallest distance was found.\n * @private\n */\nexport function _getSmallestDistanceIndex(values, scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var result = 0;\n  if (scaleFn) {\n    var nextValue = void 0;\n    var currentValue = scaleFn(values[0]);\n    var distance = Infinity;\n    var nextDistance = void 0;\n\n    for (var i = 1; i < values.length; i++) {\n      nextValue = scaleFn(values[i]);\n      nextDistance = Math.abs(nextValue - currentValue);\n      if (nextDistance < distance) {\n        distance = nextDistance;\n        result = i;\n      }\n      currentValue = nextValue;\n    }\n  }\n  return result;\n}\n\n/**\n * This is a workaround for issue that ordinal scale\n * does not have invert method implemented in d3-scale.\n * @param {Object} Ordinal d3-scale object.\n * @returns {void}\n * @private\n */\n\nfunction addInvertFunctionToOrdinalScaleObject(scale) {\n  if (scale.invert) {\n    return;\n  }\n\n  scale.invert = function invert(value) {\n    var _scale$range = scale.range(),\n        _scale$range2 = _slicedToArray(_scale$range, 2),\n        lower = _scale$range2[0],\n        upper = _scale$range2[1];\n\n    var start = Math.min(lower, upper);\n    var stop = Math.max(lower, upper);\n\n    if (value < start + scale.padding() * scale.step()) {\n      return scale.domain()[0];\n    }\n\n    if (value > stop - scale.padding() * scale.step()) {\n      return scale.domain()[scale.domain().length - 1];\n    }\n\n    var index = Math.floor((value - start - scale.padding() * scale.step()) / scale.step());\n    return scale.domain()[index];\n  };\n}\n\n/**\n * Crate a scale function from the scale object.\n * @param {Object} scaleObject Scale object.\n - scaleObject.domain {Array}\n - scaleObject.range {Array}\n - scaleObject.type {string}\n - scaleObject.attr {string}\n * @returns {*} Scale function.\n * @private\n */\nexport function getScaleFnFromScaleObject(scaleObject) {\n  if (!scaleObject) {\n    return null;\n  }\n  var type = scaleObject.type,\n      domain = scaleObject.domain,\n      range = scaleObject.range;\n\n  var modDomain = domain[0] === domain[1] ? domain[0] === 0 ? [-1, 0] : [-domain[0], domain[0]] : domain;\n  if (type === LITERAL_SCALE_TYPE) {\n    return literalScale(range[0]);\n  }\n  var scale = SCALE_FUNCTIONS[type]().domain(modDomain).range(range);\n  if (type === ORDINAL_SCALE_TYPE) {\n    scale.padding(0.5);\n    addInvertFunctionToOrdinalScaleObject(scale);\n  }\n  return scale;\n}\n\n/**\n * Get the domain from the array of data.\n * @param {Array} allData All data.\n * @param {function} accessor - accessor for main value.\n * @param {function} accessor0 - accessor for the naught value.\n * @param {string} type Scale type.\n * @returns {Array} Domain.\n * @private\n */\nexport function getDomainByAccessor(allData, accessor, accessor0, type) {\n  var domain = void 0;\n\n  // Collect both attr and available attr0 values from the array of data.\n  var values = allData.reduce(function (data, d) {\n    var value = accessor(d);\n    var value0 = accessor0(d);\n    if (_isDefined(value)) {\n      data.push(value);\n    }\n    if (_isDefined(value0)) {\n      data.push(value0);\n    }\n    return data;\n  }, []);\n\n  if (!values.length) {\n    return [];\n  }\n\n  // Create proper domain depending on the type of the scale.\n  if (type !== ORDINAL_SCALE_TYPE && type !== CATEGORY_SCALE_TYPE) {\n    domain = extent(values);\n  } else {\n    domain = set(values).values();\n  }\n  return domain;\n}\n\n/**\n * Create custom scale object from the value. When the scale is created from\n * this object, it should return the same value all time.\n * @param {string} attr Attribute.\n * @param {*} value Value.\n * @param {string} type - the type of scale being used\n * @param {function} accessor - the accessor function\n * @param {function} accessor0 - the accessor function for the potential naught value\n * @returns {Object} Custom scale object.\n * @private\n */\nfunction _createScaleObjectForValue(attr, value, type, accessor, accessor0) {\n  if (type === LITERAL_SCALE_TYPE) {\n    return {\n      type: LITERAL_SCALE_TYPE,\n      domain: [],\n      range: [value],\n      distance: 0,\n      attr: attr,\n      baseValue: undefined,\n      isValue: true,\n      accessor: accessor,\n      accessor0: accessor0\n    };\n  }\n  if (typeof value === 'undefined') {\n    return null;\n  }\n  return {\n    type: CATEGORY_SCALE_TYPE,\n    range: [value],\n    domain: [],\n    distance: 0,\n    attr: attr,\n    baseValue: undefined,\n    isValue: true,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n\n/**\n * Create a regular scale object for a further use from the existing parameters.\n * @param {Array} domain - Domain.\n * @param {Array} range - Range.\n * @param {string} type - Type.\n * @param {number} distance - Distance.\n * @param {string} attr - Attribute.\n * @param {number} baseValue - Base value.\n * @param {function} accessor - Attribute accesor\n * @param {function} accessor0 - Attribute accesor for potential naught value\n * @returns {Object} Scale object.\n * @private\n */\nfunction _createScaleObjectForFunction(_ref) {\n  var domain = _ref.domain,\n      range = _ref.range,\n      type = _ref.type,\n      distance = _ref.distance,\n      attr = _ref.attr,\n      baseValue = _ref.baseValue,\n      accessor = _ref.accessor,\n      accessor0 = _ref.accessor0;\n\n  return {\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    isValue: false,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n\n/**\n * Get scale object from props. E. g. object like {xRange, xDomain, xDistance,\n * xType} is transformed into {range, domain, distance, type}.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {*} Null or an object with the scale.\n * @private\n */\nfunction _collectScaleObjectFromProps(props, attr) {\n  var value = props[attr],\n      fallbackValue = props['_' + attr + 'Value'],\n      range = props[attr + 'Range'],\n      _props$ = props[attr + 'Distance'],\n      distance = _props$ === undefined ? 0 : _props$,\n      baseValue = props[attr + 'BaseValue'],\n      _props$2 = props[attr + 'Type'],\n      type = _props$2 === undefined ? LINEAR_SCALE_TYPE : _props$2,\n      noFallBack = props[attr + 'NoFallBack'],\n      _props$3 = props['get' + toTitleCase(attr)],\n      accessor = _props$3 === undefined ? function (d) {\n    return d[attr];\n  } : _props$3,\n      _props$4 = props['get' + toTitleCase(attr) + '0'],\n      accessor0 = _props$4 === undefined ? function (d) {\n    return d[attr + '0'];\n  } : _props$4;\n  var domain = props[attr + 'Domain'];\n  // Return value-based scale if the value is assigned.\n\n  if (!noFallBack && typeof value !== 'undefined') {\n    return _createScaleObjectForValue(attr, value, props[attr + 'Type'], accessor, accessor0);\n  }\n  // Pick up the domain from the properties and create a new one if it's not\n  // available.\n  if (typeof baseValue !== 'undefined') {\n    domain = addValueToArray(domain, baseValue);\n  }\n\n  // Make sure that the minimum necessary properties exist.\n  if (!range || !domain || !domain.length) {\n    // Try to use the fallback value if it is available.\n    return _createScaleObjectForValue(attr, fallbackValue, props[attr + 'Type'], accessor, accessor0);\n  }\n\n  return _createScaleObjectForFunction({\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    accessor: accessor,\n    accessor0: accessor0\n  });\n}\n\n/**\n * Compute left domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\nfunction _computeLeftDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[1] - values[0]) / 2;\n  }\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n  return 0;\n}\n\n/**\n * Compute right domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\nfunction _computeRightDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[values.length - 1] - values[values.length - 2]) / 2;\n  }\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n  return 0;\n}\n\n/**\n * Compute distance for the given values.\n * @param {Array} values Array of values.\n * @param {Array} domain Domain.\n * @param {number} bestDistIndex Index of a best distance found.\n * @param {function} scaleFn Scale function.\n * @returns {number} Domain adjustment.\n * @private\n */\nfunction _computeScaleDistance(values, domain, bestDistIndex, scaleFn) {\n  if (values.length > 1) {\n    // Avoid zero indexes.\n    var i = Math.max(bestDistIndex, 1);\n    return Math.abs(scaleFn(values[i]) - scaleFn(values[i - 1]));\n  }\n  if (values.length === 1) {\n    return Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  }\n  return 0;\n}\n\n/**\n * Normilize array of values with a single value.\n * @param {Array} arr Array of data.\n * @param {Array} values Array of values.\n * @param {string} attr Attribute.\n * @param {string} type Type.\n * @private\n */\nfunction _normalizeValues(data, values, accessor0, type) {\n  if (type === TIME_SCALE_TYPE && values.length === 1) {\n    var attr0 = accessor0(data[0]);\n\n    return [attr0].concat(_toConsumableArray(values));\n  }\n\n  return values;\n}\n\n/**\n * Get the distance, the smallest and the largest value of the domain.\n * @param {Array} data Array of data for the single series.\n * @param {Object} scaleObject Scale object.\n * @returns {{domain0: number, domainN: number, distance: number}} Result.\n * @private\n */\nexport function _getScaleDistanceAndAdjustedDomain(data, scaleObject) {\n  var domain = scaleObject.domain,\n      type = scaleObject.type,\n      accessor = scaleObject.accessor,\n      accessor0 = scaleObject.accessor0;\n\n\n  var uniqueValues = getUniquePropertyValues(data, accessor);\n\n  // Fix time scale if a data has only one value.\n  var values = _normalizeValues(data, uniqueValues, accessor0, type);\n  var index = _getSmallestDistanceIndex(values, scaleObject);\n\n  var adjustedDomain = [].concat(domain);\n\n  adjustedDomain[0] -= _computeLeftDomainAdjustment(values);\n  adjustedDomain[domain.length - 1] += _computeRightDomainAdjustment(values);\n  // Fix log scale if it's too small.\n  if (type === LOG_SCALE_TYPE && domain[0] <= 0) {\n    adjustedDomain[0] = Math.min(domain[1] / 10, 1);\n  }\n\n  var adjustedScaleFn = getScaleFnFromScaleObject(_extends({}, scaleObject, {\n    domain: adjustedDomain\n  }));\n\n  var distance = _computeScaleDistance(values, adjustedDomain, index, adjustedScaleFn);\n\n  return {\n    domain0: adjustedDomain[0],\n    domainN: adjustedDomain[adjustedDomain.length - 1],\n    distance: distance\n  };\n}\n\n/**\n * Returns true if scale adjustments are possible for a given scale.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {boolean} True if scale adjustments possible.\n * @private\n */\nfunction _isScaleAdjustmentPossible(props, scaleObject) {\n  var attr = scaleObject.attr;\n  var _props$_adjustBy = props._adjustBy,\n      adjustBy = _props$_adjustBy === undefined ? [] : _props$_adjustBy,\n      _props$_adjustWhat = props._adjustWhat,\n      adjustWhat = _props$_adjustWhat === undefined ? [] : _props$_adjustWhat;\n\n  // The scale cannot be adjusted if there's no attributes to adjust, no\n  // suitable values\n\n  return adjustWhat.length && adjustBy.length && adjustBy.indexOf(attr) !== -1;\n}\n\n/**\n * Adjust continuous scales (e.g. 'linear', 'log' and 'time') by adding the\n * space from the left and right of them and by computing the best distance.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\nfunction _adjustContinuousScale(props, scaleObject) {\n  var allSeriesData = props._allData,\n      _props$_adjustWhat2 = props._adjustWhat,\n      adjustWhat = _props$_adjustWhat2 === undefined ? [] : _props$_adjustWhat2;\n\n  // Assign the initial values.\n\n  var domainLength = scaleObject.domain.length;\n  var domain = scaleObject.domain;\n\n  var scaleDomain0 = domain[0];\n  var scaleDomainN = domain[domainLength - 1];\n  var scaleDistance = scaleObject.distance;\n\n  // Find the smallest left position of the domain, the largest right position\n  // of the domain and the best distance for them.\n  allSeriesData.forEach(function (data, index) {\n    if (adjustWhat.indexOf(index) === -1) {\n      return;\n    }\n    if (data && data.length) {\n      var _getScaleDistanceAndA = _getScaleDistanceAndAdjustedDomain(data, scaleObject),\n          domain0 = _getScaleDistanceAndA.domain0,\n          domainN = _getScaleDistanceAndA.domainN,\n          distance = _getScaleDistanceAndA.distance;\n\n      scaleDomain0 = Math.min(scaleDomain0, domain0);\n      scaleDomainN = Math.max(scaleDomainN, domainN);\n      scaleDistance = Math.max(scaleDistance, distance);\n    }\n  });\n\n  scaleObject.domain = [scaleDomain0].concat(_toConsumableArray(domain.slice(1, -1)), [scaleDomainN]);\n\n  scaleObject.distance = scaleDistance;\n\n  return scaleObject;\n}\n\n/**\n * Get an adjusted scale. Suitable for 'category' and 'ordinal' scales.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\nexport function _adjustCategoricalScale(scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var domain = scaleObject.domain,\n      range = scaleObject.range;\n\n  if (domain.length > 1) {\n    scaleObject.distance = Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  } else {\n    scaleObject.distance = Math.abs(range[1] - range[0]);\n  }\n\n  return scaleObject;\n}\n\n/**\n * Retrieve a scale object or a value from the properties passed.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute.\n * @returns {*} Scale object, value or null.\n */\nexport function getScaleObjectFromProps(props, attr) {\n  // Create the initial scale object.\n  var scaleObject = _collectScaleObjectFromProps(props, attr);\n  if (!scaleObject) {\n    return null;\n  }\n\n  // Make sure if it's possible to add space to the scale object. If not,\n  // return the object immediately.\n  if (!_isScaleAdjustmentPossible(props, scaleObject)) {\n    return scaleObject;\n  }\n\n  var type = scaleObject.type;\n  // Depending on what type the scale is, apply different adjustments. Distances\n  // for the ordinal and category scales are even, equal domains cannot be\n  // adjusted.\n\n  if (type === ORDINAL_SCALE_TYPE || type === CATEGORY_SCALE_TYPE) {\n    return _adjustCategoricalScale(scaleObject);\n  }\n  return _adjustContinuousScale(props, scaleObject);\n}\n\n/**\n * Get d3 scale for a given prop.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {function} d3 scale function.\n */\nexport function getAttributeScale(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  return getScaleFnFromScaleObject(scaleObject);\n}\n\n/**\n * Get the value of `attr` from the object.\n * @param {Object} d - data Object.\n * @param {Function} accessor - accessor function.\n * @returns {*} Value of the point.\n * @private\n */\nfunction _getAttrValue(d, accessor) {\n  return accessor(d.data ? d.data : d);\n}\n\nfunction _isDefined(value) {\n  return typeof value !== 'undefined';\n}\n\n/*\n * Adds a percentage of padding to a given domain\n * @param {Array} domain X or Y domain to pad.\n * @param {Number} padding Percentage of padding to add to domain\n * @returns {Array} Padded Domain\n */\nfunction _padDomain(domain, padding) {\n  if (!domain) {\n    return domain;\n  }\n  if (isNaN(parseFloat(domain[0])) || isNaN(parseFloat(domain[1]))) {\n    return domain;\n  }\n\n  var _domain = _slicedToArray(domain, 2),\n      min = _domain[0],\n      max = _domain[1];\n\n  var domainPadding = (max - min) * (padding * 0.01);\n  return [min - domainPadding, max + domainPadding];\n}\n\n/**\n * Get prop functor (either a value or a function) for a given attribute.\n * @param {Object} props Series props.\n * @param {Function} accessor - Property accessor.\n * @returns {*} Function or value.\n */\nexport function getAttributeFunctor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      return scaleFn(_getAttrValue(d, scaleObject.accessor));\n    };\n  }\n  return null;\n}\n\n/**\n * Get the functor which extracts value form [attr]0 property. Use baseValue if\n * no attr0 property for a given object is defined. Fall back to domain[0] if no\n * base value is available.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute name.\n * @returns {*} Function which returns value or null if no values available.\n */\nexport function getAttr0Functor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    var domain = scaleObject.domain;\n    var _scaleObject$baseValu = scaleObject.baseValue,\n        baseValue = _scaleObject$baseValu === undefined ? domain[0] : _scaleObject$baseValu;\n\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      var value = _getAttrValue(d, scaleObject.accessor0);\n      return scaleFn(_isDefined(value) ? value : baseValue);\n    };\n  }\n  return null;\n}\n\n/**\n * Tries to get the string|number value of the attr and falls back to\n * a fallback property in case if the value is a scale.\n * @param {Object} props Series props.\n * @param {string} attr Property name.\n * @returns {*} Function or value.\n */\nexport function getAttributeValue(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    if (!scaleObject.isValue && props['_' + attr + 'Value'] === undefined) {\n      warning('[React-vis] Cannot use data defined ' + attr + ' for this ' + 'series type. Using fallback value instead.');\n    }\n    return props['_' + attr + 'Value'] || scaleObject.range[0];\n  }\n  return null;\n}\n\n/**\n * Get prop types by the attribute.\n * @param {string} attr Attribute.\n * @returns {Object} Object of xDomain, xRange, xType, xDistance and _xValue,\n * where x is an attribute passed to the function.\n */\nexport function getScalePropTypesByAttribute(attr) {\n  var _ref2;\n\n  return _ref2 = {}, _defineProperty(_ref2, '_' + attr + 'Value', PropTypes.any), _defineProperty(_ref2, attr + 'Domain', PropTypes.array), _defineProperty(_ref2, 'get' + toTitleCase(attr), PropTypes.func), _defineProperty(_ref2, 'get' + toTitleCase(attr) + '0', PropTypes.func), _defineProperty(_ref2, attr + 'Range', PropTypes.array), _defineProperty(_ref2, attr + 'Type', PropTypes.oneOf(Object.keys(SCALE_FUNCTIONS))), _defineProperty(_ref2, attr + 'Distance', PropTypes.number), _defineProperty(_ref2, attr + 'BaseValue', PropTypes.any), _ref2;\n}\n\n/**\n * Extract the list of scale properties from the entire props object.\n * @param {Object} props Props.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\nexport function extractScalePropsFromProps(props, attributes) {\n  var result = {};\n  Object.keys(props).forEach(function (key) {\n    // this filtering is critical for extracting the correct accessors!\n    var attr = attributes.find(function (a) {\n      // width\n      var isPlainSet = key.indexOf(a) === 0;\n      // Ex: _data\n      var isUnderscoreSet = key.indexOf('_' + a) === 0;\n      // EX: getX\n      var usesGet = key.indexOf('get' + toTitleCase(a)) === 0;\n      return isPlainSet || isUnderscoreSet || usesGet;\n    });\n    if (!attr) {\n      return;\n    }\n    result[key] = props[key];\n  });\n  return result;\n}\n\n/**\n * Extract the missing scale props from the given data and return them as\n * an object.\n * @param {Object} props Props.\n * @param {Array} data Array of all data.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\nexport function getMissingScaleProps(props, data, attributes) {\n  var result = {};\n  // Make sure that the domain is set pad it if specified\n  attributes.forEach(function (attr) {\n    if (!props['get' + toTitleCase(attr)]) {\n      result['get' + toTitleCase(attr)] = function (d) {\n        return d[attr];\n      };\n    }\n    if (!props['get' + toTitleCase(attr) + '0']) {\n      result['get' + toTitleCase(attr) + '0'] = function (d) {\n        return d[attr + '0'];\n      };\n    }\n    if (!props[attr + 'Domain']) {\n      result[attr + 'Domain'] = getDomainByAccessor(data, props['get' + toTitleCase(attr)] || result['get' + toTitleCase(attr)], props['get' + toTitleCase(attr) + '0'] || result['get' + toTitleCase(attr) + '0'], props[attr + 'Type']);\n      if (props[attr + 'Padding']) {\n        result[attr + 'Domain'] = _padDomain(result[attr + 'Domain'], props[attr + 'Padding']);\n      }\n    }\n  });\n\n  return result;\n}\n\n/**\n * Return a d3 scale that returns the literal value that was given to it\n * @returns {function} literal scale.\n */\nexport function literalScale(defaultValue) {\n  function scale(d) {\n    if (d === undefined) {\n      return defaultValue;\n    }\n    return d;\n  }\n\n  function response() {\n    return scale;\n  }\n\n  scale.domain = response;\n  scale.range = response;\n  scale.unknown = response;\n  scale.copy = response;\n\n  return scale;\n}\n\nexport function getFontColorFromBackground(background) {\n  if (background) {\n    return hsl(background).l > 0.57 ? '#222' : '#fff';\n  }\n  return null;\n}\n\n/**\n * Creates fallback values for series from scales defined at XYPlot level.\n * @param {Object} props Props of the XYPlot object.\n * @param {Array<Object>} children Array of components, children of XYPlot\n * @returns {Array<Object>} Collected props.\n */\n\nexport function getXYPlotValues(props, children) {\n  var XYPlotScales = XYPLOT_ATTR.reduce(function (prev, attr) {\n    var domain = props[attr + 'Domain'],\n        range = props[attr + 'Range'],\n        type = props[attr + 'Type'];\n\n\n    if (domain && range && type) {\n      return _extends({}, prev, _defineProperty({}, attr, SCALE_FUNCTIONS[type]().domain(domain).range(range)));\n    }\n    return prev;\n  }, {});\n\n  return children.map(function (child) {\n    return XYPLOT_ATTR.reduce(function (prev, attr) {\n      if (child.props && child.props[attr] !== undefined) {\n        var scaleInput = child.props[attr];\n        var scale = XYPlotScales[attr];\n        var fallbackValue = scale ? scale(scaleInput) : scaleInput;\n        return _extends({}, prev, _defineProperty({}, '_' + attr + 'Value', fallbackValue));\n      }\n      return prev;\n    }, {});\n  });\n}\n\nvar OPTIONAL_SCALE_PROPS = ['Padding'];\nvar OPTIONAL_SCALE_PROPS_REGS = OPTIONAL_SCALE_PROPS.map(function (str) {\n  return new RegExp(str + '$', 'i');\n});\n/**\n * Get the list of optional scale-related settings for XYPlot\n * mostly just used to find padding properties\n * @param {Object} props Object of props.\n * @returns {Object} Optional Props.\n * @private\n */\nexport function getOptionalScaleProps(props) {\n  return Object.keys(props).reduce(function (acc, prop) {\n    var propIsNotOptional = OPTIONAL_SCALE_PROPS_REGS.every(function (reg) {\n      return !prop.match(reg);\n    });\n    if (propIsNotOptional) {\n      return acc;\n    }\n    acc[prop] = props[prop];\n    return acc;\n  }, {});\n}\n\nexport default {\n  extractScalePropsFromProps: extractScalePropsFromProps,\n  getAttributeScale: getAttributeScale,\n  getAttributeFunctor: getAttributeFunctor,\n  getAttr0Functor: getAttr0Functor,\n  getAttributeValue: getAttributeValue,\n  getDomainByAccessor: getDomainByAccessor,\n  getFontColorFromBackground: getFontColorFromBackground,\n  getMissingScaleProps: getMissingScaleProps,\n  getOptionalScaleProps: getOptionalScaleProps,\n  getScaleObjectFromProps: getScaleObjectFromProps,\n  getScalePropTypesByAttribute: getScalePropTypesByAttribute,\n  getXYPlotValues: getXYPlotValues,\n  literalScale: literalScale\n};"],"mappings":"AAAA,IAAIA,QAAQ,GAAGC,MAAM,CAACC,MAAM,IAAI,UAAUC,MAAM,EAAE;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;IAAE,IAAIG,MAAM,GAAGF,SAAS,CAACD,CAAC,CAAC;IAAE,KAAK,IAAII,GAAG,IAAID,MAAM,EAAE;MAAE,IAAIN,MAAM,CAACQ,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,MAAM,EAAEC,GAAG,CAAC,EAAE;QAAEL,MAAM,CAACK,GAAG,CAAC,GAAGD,MAAM,CAACC,GAAG,CAAC;MAAE;IAAE;EAAE;EAAE,OAAOL,MAAM;AAAE,CAAC;AAEhQ,IAAIS,cAAc,GAAG,YAAY;EAAE,SAASC,aAAaA,CAACC,GAAG,EAAEV,CAAC,EAAE;IAAE,IAAIW,IAAI,GAAG,EAAE;IAAE,IAAIC,EAAE,GAAG,IAAI;IAAE,IAAIC,EAAE,GAAG,KAAK;IAAE,IAAIC,EAAE,GAAGC,SAAS;IAAE,IAAI;MAAE,KAAK,IAAIC,EAAE,GAAGN,GAAG,CAACO,MAAM,CAACC,QAAQ,CAAC,EAAE,EAAEC,EAAE,EAAE,EAAEP,EAAE,GAAG,CAACO,EAAE,GAAGH,EAAE,CAACI,IAAI,EAAE,EAAEC,IAAI,CAAC,EAAET,EAAE,GAAG,IAAI,EAAE;QAAED,IAAI,CAACW,IAAI,CAACH,EAAE,CAACI,KAAK,CAAC;QAAE,IAAIvB,CAAC,IAAIW,IAAI,CAACT,MAAM,KAAKF,CAAC,EAAE;MAAO;IAAE,CAAC,CAAC,OAAOwB,GAAG,EAAE;MAAEX,EAAE,GAAG,IAAI;MAAEC,EAAE,GAAGU,GAAG;IAAE,CAAC,SAAS;MAAE,IAAI;QAAE,IAAI,CAACZ,EAAE,IAAII,EAAE,CAAC,QAAQ,CAAC,EAAEA,EAAE,CAAC,QAAQ,CAAC,EAAE;MAAE,CAAC,SAAS;QAAE,IAAIH,EAAE,EAAE,MAAMC,EAAE;MAAE;IAAE;IAAE,OAAOH,IAAI;EAAE;EAAE,OAAO,UAAUD,GAAG,EAAEV,CAAC,EAAE;IAAE,IAAIyB,KAAK,CAACC,OAAO,CAAChB,GAAG,CAAC,EAAE;MAAE,OAAOA,GAAG;IAAE,CAAC,MAAM,IAAIO,MAAM,CAACC,QAAQ,IAAIrB,MAAM,CAACa,GAAG,CAAC,EAAE;MAAE,OAAOD,aAAa,CAACC,GAAG,EAAEV,CAAC,CAAC;IAAE,CAAC,MAAM;MAAE,MAAM,IAAI2B,SAAS,CAAC,sDAAsD,CAAC;IAAE;EAAE,CAAC;AAAE,CAAC,EAAE;AAEvpB,IAAIC,gBAAgB;AAEpB,SAASC,kBAAkBA,CAACnB,GAAG,EAAE;EAAE,IAAIe,KAAK,CAACC,OAAO,CAAChB,GAAG,CAAC,EAAE;IAAE,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAE8B,IAAI,GAAGL,KAAK,CAACf,GAAG,CAACR,MAAM,CAAC,EAAEF,CAAC,GAAGU,GAAG,CAACR,MAAM,EAAEF,CAAC,EAAE,EAAE;MAAE8B,IAAI,CAAC9B,CAAC,CAAC,GAAGU,GAAG,CAACV,CAAC,CAAC;IAAE;IAAE,OAAO8B,IAAI;EAAE,CAAC,MAAM;IAAE,OAAOL,KAAK,CAACM,IAAI,CAACrB,GAAG,CAAC;EAAE;AAAE;AAElM,SAASsB,eAAeA,CAACC,GAAG,EAAE7B,GAAG,EAAEmB,KAAK,EAAE;EAAE,IAAInB,GAAG,IAAI6B,GAAG,EAAE;IAAEpC,MAAM,CAACqC,cAAc,CAACD,GAAG,EAAE7B,GAAG,EAAE;MAAEmB,KAAK,EAAEA,KAAK;MAAEY,UAAU,EAAE,IAAI;MAAEC,YAAY,EAAE,IAAI;MAAEC,QAAQ,EAAE;IAAK,CAAC,CAAC;EAAE,CAAC,MAAM;IAAEJ,GAAG,CAAC7B,GAAG,CAAC,GAAGmB,KAAK;EAAE;EAAE,OAAOU,GAAG;AAAE;;AAEhN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASK,WAAW,EAAEC,UAAU,EAAEC,YAAY,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,QAAQ,QAAQ,UAAU;AAC/F,SAASC,MAAM,QAAQ,UAAU;AACjC,SAASC,GAAG,QAAQ,eAAe;AACnC,SAASC,GAAG,QAAQ,UAAU;AAE9B,OAAOC,SAAS,MAAM,YAAY;AAElC,SAASC,OAAO,QAAQ,eAAe;AACvC,SAASC,uBAAuB,EAAEC,eAAe,QAAQ,cAAc;;AAEvE;AACA;AACA;AACA;AACA;AACA,IAAIC,iBAAiB,GAAG,QAAQ;;AAEhC;AACA;AACA;AACA;AACA;AACA,IAAIC,kBAAkB,GAAG,SAAS;;AAElC;AACA;AACA;AACA;AACA;AACA,IAAIC,mBAAmB,GAAG,UAAU;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,kBAAkB,GAAG,SAAS;;AAElC;AACA;AACA;AACA;AACA;AACA,IAAIC,cAAc,GAAG,KAAK;;AAE1B;AACA;AACA;AACA;AACA;AACA,IAAIC,eAAe,GAAG,MAAM;;AAE5B;AACA;AACA;AACA;AACA;AACA,IAAIC,mBAAmB,GAAG,UAAU;;AAEpC;AACA;AACA;AACA;AACA;AACA,IAAIC,eAAe,IAAI9B,gBAAgB,GAAG,CAAC,CAAC,EAAEI,eAAe,CAACJ,gBAAgB,EAAEuB,iBAAiB,EAAEb,WAAW,CAAC,EAAEN,eAAe,CAACJ,gBAAgB,EAAEwB,kBAAkB,EAAEb,UAAU,CAAC,EAAEP,eAAe,CAACJ,gBAAgB,EAAEyB,mBAAmB,EAAEb,YAAY,CAAC,EAAER,eAAe,CAACJ,gBAAgB,EAAE0B,kBAAkB,EAAEK,YAAY,CAAC,EAAE3B,eAAe,CAACJ,gBAAgB,EAAE2B,cAAc,EAAEd,QAAQ,CAAC,EAAET,eAAe,CAACJ,gBAAgB,EAAE4B,eAAe,EAAEd,SAAS,CAAC,EAAEV,eAAe,CAACJ,gBAAgB,EAAE6B,mBAAmB,EAAEd,QAAQ,CAAC,EAAEf,gBAAgB,CAAC;;AAE9gB;AACA;AACA;AACA;AACA;;AAEA,IAAIgC,WAAW,GAAG,CAAC,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,QAAQ,CAAC;;AAExD;AACA;AACA;AACA;AACA;AACA,SAASC,WAAWA,CAACC,GAAG,EAAE;EACxB,OAAO,EAAE,GAAGA,GAAG,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE,GAAGD,GAAG,CAACE,KAAK,CAAC,CAAC,CAAC;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,yBAAyBA,CAACC,MAAM,EAAEC,WAAW,EAAE;EAC7D,IAAIC,OAAO,GAAGC,yBAAyB,CAACF,WAAW,CAAC;EACpD,IAAIG,MAAM,GAAG,CAAC;EACd,IAAIF,OAAO,EAAE;IACX,IAAIG,SAAS,GAAG,KAAK,CAAC;IACtB,IAAIC,YAAY,GAAGJ,OAAO,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC;IACrC,IAAIO,QAAQ,GAAGC,QAAQ;IACvB,IAAIC,YAAY,GAAG,KAAK,CAAC;IAEzB,KAAK,IAAI3E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkE,MAAM,CAAChE,MAAM,EAAEF,CAAC,EAAE,EAAE;MACtCuE,SAAS,GAAGH,OAAO,CAACF,MAAM,CAAClE,CAAC,CAAC,CAAC;MAC9B2E,YAAY,GAAGC,IAAI,CAACC,GAAG,CAACN,SAAS,GAAGC,YAAY,CAAC;MACjD,IAAIG,YAAY,GAAGF,QAAQ,EAAE;QAC3BA,QAAQ,GAAGE,YAAY;QACvBL,MAAM,GAAGtE,CAAC;MACZ;MACAwE,YAAY,GAAGD,SAAS;IAC1B;EACF;EACA,OAAOD,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASQ,qCAAqCA,CAACC,KAAK,EAAE;EACpD,IAAIA,KAAK,CAACC,MAAM,EAAE;IAChB;EACF;EAEAD,KAAK,CAACC,MAAM,GAAG,SAASA,MAAMA,CAACzD,KAAK,EAAE;IACpC,IAAI0D,YAAY,GAAGF,KAAK,CAACG,KAAK,EAAE;MAC5BC,aAAa,GAAG3E,cAAc,CAACyE,YAAY,EAAE,CAAC,CAAC;MAC/CG,KAAK,GAAGD,aAAa,CAAC,CAAC,CAAC;MACxBE,KAAK,GAAGF,aAAa,CAAC,CAAC,CAAC;IAE5B,IAAIG,KAAK,GAAGV,IAAI,CAACW,GAAG,CAACH,KAAK,EAAEC,KAAK,CAAC;IAClC,IAAIG,IAAI,GAAGZ,IAAI,CAACa,GAAG,CAACL,KAAK,EAAEC,KAAK,CAAC;IAEjC,IAAI9D,KAAK,GAAG+D,KAAK,GAAGP,KAAK,CAACW,OAAO,EAAE,GAAGX,KAAK,CAACY,IAAI,EAAE,EAAE;MAClD,OAAOZ,KAAK,CAACa,MAAM,EAAE,CAAC,CAAC,CAAC;IAC1B;IAEA,IAAIrE,KAAK,GAAGiE,IAAI,GAAGT,KAAK,CAACW,OAAO,EAAE,GAAGX,KAAK,CAACY,IAAI,EAAE,EAAE;MACjD,OAAOZ,KAAK,CAACa,MAAM,EAAE,CAACb,KAAK,CAACa,MAAM,EAAE,CAAC1F,MAAM,GAAG,CAAC,CAAC;IAClD;IAEA,IAAI2F,KAAK,GAAGjB,IAAI,CAACkB,KAAK,CAAC,CAACvE,KAAK,GAAG+D,KAAK,GAAGP,KAAK,CAACW,OAAO,EAAE,GAAGX,KAAK,CAACY,IAAI,EAAE,IAAIZ,KAAK,CAACY,IAAI,EAAE,CAAC;IACvF,OAAOZ,KAAK,CAACa,MAAM,EAAE,CAACC,KAAK,CAAC;EAC9B,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASxB,yBAAyBA,CAACF,WAAW,EAAE;EACrD,IAAI,CAACA,WAAW,EAAE;IAChB,OAAO,IAAI;EACb;EACA,IAAI4B,IAAI,GAAG5B,WAAW,CAAC4B,IAAI;IACvBH,MAAM,GAAGzB,WAAW,CAACyB,MAAM;IAC3BV,KAAK,GAAGf,WAAW,CAACe,KAAK;EAE7B,IAAIc,SAAS,GAAGJ,MAAM,CAAC,CAAC,CAAC,KAAKA,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAACA,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGA,MAAM;EACtG,IAAIG,IAAI,KAAKzC,kBAAkB,EAAE;IAC/B,OAAOK,YAAY,CAACuB,KAAK,CAAC,CAAC,CAAC,CAAC;EAC/B;EACA,IAAIH,KAAK,GAAGrB,eAAe,CAACqC,IAAI,CAAC,EAAE,CAACH,MAAM,CAACI,SAAS,CAAC,CAACd,KAAK,CAACA,KAAK,CAAC;EAClE,IAAIa,IAAI,KAAK3C,kBAAkB,EAAE;IAC/B2B,KAAK,CAACW,OAAO,CAAC,GAAG,CAAC;IAClBZ,qCAAqC,CAACC,KAAK,CAAC;EAC9C;EACA,OAAOA,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASkB,mBAAmBA,CAACC,OAAO,EAAEC,QAAQ,EAAEC,SAAS,EAAEL,IAAI,EAAE;EACtE,IAAIH,MAAM,GAAG,KAAK,CAAC;;EAEnB;EACA,IAAI1B,MAAM,GAAGgC,OAAO,CAACG,MAAM,CAAC,UAAUC,IAAI,EAAEC,CAAC,EAAE;IAC7C,IAAIhF,KAAK,GAAG4E,QAAQ,CAACI,CAAC,CAAC;IACvB,IAAIC,MAAM,GAAGJ,SAAS,CAACG,CAAC,CAAC;IACzB,IAAIE,UAAU,CAAClF,KAAK,CAAC,EAAE;MACrB+E,IAAI,CAAChF,IAAI,CAACC,KAAK,CAAC;IAClB;IACA,IAAIkF,UAAU,CAACD,MAAM,CAAC,EAAE;MACtBF,IAAI,CAAChF,IAAI,CAACkF,MAAM,CAAC;IACnB;IACA,OAAOF,IAAI;EACb,CAAC,EAAE,EAAE,CAAC;EAEN,IAAI,CAACpC,MAAM,CAAChE,MAAM,EAAE;IAClB,OAAO,EAAE;EACX;;EAEA;EACA,IAAI6F,IAAI,KAAK3C,kBAAkB,IAAI2C,IAAI,KAAK1C,mBAAmB,EAAE;IAC/DuC,MAAM,GAAGhD,MAAM,CAACsB,MAAM,CAAC;EACzB,CAAC,MAAM;IACL0B,MAAM,GAAG/C,GAAG,CAACqB,MAAM,CAAC,CAACA,MAAM,EAAE;EAC/B;EACA,OAAO0B,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASc,0BAA0BA,CAACC,IAAI,EAAEpF,KAAK,EAAEwE,IAAI,EAAEI,QAAQ,EAAEC,SAAS,EAAE;EAC1E,IAAIL,IAAI,KAAKzC,kBAAkB,EAAE;IAC/B,OAAO;MACLyC,IAAI,EAAEzC,kBAAkB;MACxBsC,MAAM,EAAE,EAAE;MACVV,KAAK,EAAE,CAAC3D,KAAK,CAAC;MACdkD,QAAQ,EAAE,CAAC;MACXkC,IAAI,EAAEA,IAAI;MACVC,SAAS,EAAE7F,SAAS;MACpB8F,OAAO,EAAE,IAAI;MACbV,QAAQ,EAAEA,QAAQ;MAClBC,SAAS,EAAEA;IACb,CAAC;EACH;EACA,IAAI,OAAO7E,KAAK,KAAK,WAAW,EAAE;IAChC,OAAO,IAAI;EACb;EACA,OAAO;IACLwE,IAAI,EAAE1C,mBAAmB;IACzB6B,KAAK,EAAE,CAAC3D,KAAK,CAAC;IACdqE,MAAM,EAAE,EAAE;IACVnB,QAAQ,EAAE,CAAC;IACXkC,IAAI,EAAEA,IAAI;IACVC,SAAS,EAAE7F,SAAS;IACpB8F,OAAO,EAAE,IAAI;IACbV,QAAQ,EAAEA,QAAQ;IAClBC,SAAS,EAAEA;EACb,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASU,6BAA6BA,CAACC,IAAI,EAAE;EAC3C,IAAInB,MAAM,GAAGmB,IAAI,CAACnB,MAAM;IACpBV,KAAK,GAAG6B,IAAI,CAAC7B,KAAK;IAClBa,IAAI,GAAGgB,IAAI,CAAChB,IAAI;IAChBtB,QAAQ,GAAGsC,IAAI,CAACtC,QAAQ;IACxBkC,IAAI,GAAGI,IAAI,CAACJ,IAAI;IAChBC,SAAS,GAAGG,IAAI,CAACH,SAAS;IAC1BT,QAAQ,GAAGY,IAAI,CAACZ,QAAQ;IACxBC,SAAS,GAAGW,IAAI,CAACX,SAAS;EAE9B,OAAO;IACLR,MAAM,EAAEA,MAAM;IACdV,KAAK,EAAEA,KAAK;IACZa,IAAI,EAAEA,IAAI;IACVtB,QAAQ,EAAEA,QAAQ;IAClBkC,IAAI,EAAEA,IAAI;IACVC,SAAS,EAAEA,SAAS;IACpBC,OAAO,EAAE,KAAK;IACdV,QAAQ,EAAEA,QAAQ;IAClBC,SAAS,EAAEA;EACb,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASY,4BAA4BA,CAACC,KAAK,EAAEN,IAAI,EAAE;EACjD,IAAIpF,KAAK,GAAG0F,KAAK,CAACN,IAAI,CAAC;IACnBO,aAAa,GAAGD,KAAK,CAAC,GAAG,GAAGN,IAAI,GAAG,OAAO,CAAC;IAC3CzB,KAAK,GAAG+B,KAAK,CAACN,IAAI,GAAG,OAAO,CAAC;IAC7BQ,OAAO,GAAGF,KAAK,CAACN,IAAI,GAAG,UAAU,CAAC;IAClClC,QAAQ,GAAG0C,OAAO,KAAKpG,SAAS,GAAG,CAAC,GAAGoG,OAAO;IAC9CP,SAAS,GAAGK,KAAK,CAACN,IAAI,GAAG,WAAW,CAAC;IACrCS,QAAQ,GAAGH,KAAK,CAACN,IAAI,GAAG,MAAM,CAAC;IAC/BZ,IAAI,GAAGqB,QAAQ,KAAKrG,SAAS,GAAGoC,iBAAiB,GAAGiE,QAAQ;IAC5DC,UAAU,GAAGJ,KAAK,CAACN,IAAI,GAAG,YAAY,CAAC;IACvCW,QAAQ,GAAGL,KAAK,CAAC,KAAK,GAAGpD,WAAW,CAAC8C,IAAI,CAAC,CAAC;IAC3CR,QAAQ,GAAGmB,QAAQ,KAAKvG,SAAS,GAAG,UAAUwF,CAAC,EAAE;MACnD,OAAOA,CAAC,CAACI,IAAI,CAAC;IAChB,CAAC,GAAGW,QAAQ;IACRC,QAAQ,GAAGN,KAAK,CAAC,KAAK,GAAGpD,WAAW,CAAC8C,IAAI,CAAC,GAAG,GAAG,CAAC;IACjDP,SAAS,GAAGmB,QAAQ,KAAKxG,SAAS,GAAG,UAAUwF,CAAC,EAAE;MACpD,OAAOA,CAAC,CAACI,IAAI,GAAG,GAAG,CAAC;IACtB,CAAC,GAAGY,QAAQ;EACZ,IAAI3B,MAAM,GAAGqB,KAAK,CAACN,IAAI,GAAG,QAAQ,CAAC;EACnC;;EAEA,IAAI,CAACU,UAAU,IAAI,OAAO9F,KAAK,KAAK,WAAW,EAAE;IAC/C,OAAOmF,0BAA0B,CAACC,IAAI,EAAEpF,KAAK,EAAE0F,KAAK,CAACN,IAAI,GAAG,MAAM,CAAC,EAAER,QAAQ,EAAEC,SAAS,CAAC;EAC3F;EACA;EACA;EACA,IAAI,OAAOQ,SAAS,KAAK,WAAW,EAAE;IACpChB,MAAM,GAAG1C,eAAe,CAAC0C,MAAM,EAAEgB,SAAS,CAAC;EAC7C;;EAEA;EACA,IAAI,CAAC1B,KAAK,IAAI,CAACU,MAAM,IAAI,CAACA,MAAM,CAAC1F,MAAM,EAAE;IACvC;IACA,OAAOwG,0BAA0B,CAACC,IAAI,EAAEO,aAAa,EAAED,KAAK,CAACN,IAAI,GAAG,MAAM,CAAC,EAAER,QAAQ,EAAEC,SAAS,CAAC;EACnG;EAEA,OAAOU,6BAA6B,CAAC;IACnClB,MAAM,EAAEA,MAAM;IACdV,KAAK,EAAEA,KAAK;IACZa,IAAI,EAAEA,IAAI;IACVtB,QAAQ,EAAEA,QAAQ;IAClBkC,IAAI,EAAEA,IAAI;IACVC,SAAS,EAAEA,SAAS;IACpBT,QAAQ,EAAEA,QAAQ;IAClBC,SAAS,EAAEA;EACb,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoB,4BAA4BA,CAACtD,MAAM,EAAE;EAC5C,IAAIA,MAAM,CAAChE,MAAM,GAAG,CAAC,EAAE;IACrB,OAAO,CAACgE,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;EACpC;EACA,IAAIA,MAAM,CAAChE,MAAM,KAAK,CAAC,EAAE;IACvB,OAAOgE,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG;EACxB;EACA,OAAO,CAAC;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASuD,6BAA6BA,CAACvD,MAAM,EAAE;EAC7C,IAAIA,MAAM,CAAChE,MAAM,GAAG,CAAC,EAAE;IACrB,OAAO,CAACgE,MAAM,CAACA,MAAM,CAAChE,MAAM,GAAG,CAAC,CAAC,GAAGgE,MAAM,CAACA,MAAM,CAAChE,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC;EACpE;EACA,IAAIgE,MAAM,CAAChE,MAAM,KAAK,CAAC,EAAE;IACvB,OAAOgE,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG;EACxB;EACA,OAAO,CAAC;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASwD,qBAAqBA,CAACxD,MAAM,EAAE0B,MAAM,EAAE+B,aAAa,EAAEvD,OAAO,EAAE;EACrE,IAAIF,MAAM,CAAChE,MAAM,GAAG,CAAC,EAAE;IACrB;IACA,IAAIF,CAAC,GAAG4E,IAAI,CAACa,GAAG,CAACkC,aAAa,EAAE,CAAC,CAAC;IAClC,OAAO/C,IAAI,CAACC,GAAG,CAACT,OAAO,CAACF,MAAM,CAAClE,CAAC,CAAC,CAAC,GAAGoE,OAAO,CAACF,MAAM,CAAClE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC9D;EACA,IAAIkE,MAAM,CAAChE,MAAM,KAAK,CAAC,EAAE;IACvB,OAAO0E,IAAI,CAACC,GAAG,CAACT,OAAO,CAACwB,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGxB,OAAO,CAACwB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;EAC1D;EACA,OAAO,CAAC;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgC,gBAAgBA,CAACtB,IAAI,EAAEpC,MAAM,EAAEkC,SAAS,EAAEL,IAAI,EAAE;EACvD,IAAIA,IAAI,KAAKvC,eAAe,IAAIU,MAAM,CAAChE,MAAM,KAAK,CAAC,EAAE;IACnD,IAAI2H,KAAK,GAAGzB,SAAS,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC;IAE9B,OAAO,CAACuB,KAAK,CAAC,CAACC,MAAM,CAACjG,kBAAkB,CAACqC,MAAM,CAAC,CAAC;EACnD;EAEA,OAAOA,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS6D,kCAAkCA,CAACzB,IAAI,EAAEnC,WAAW,EAAE;EACpE,IAAIyB,MAAM,GAAGzB,WAAW,CAACyB,MAAM;IAC3BG,IAAI,GAAG5B,WAAW,CAAC4B,IAAI;IACvBI,QAAQ,GAAGhC,WAAW,CAACgC,QAAQ;IAC/BC,SAAS,GAAGjC,WAAW,CAACiC,SAAS;EAGrC,IAAI4B,YAAY,GAAG/E,uBAAuB,CAACqD,IAAI,EAAEH,QAAQ,CAAC;;EAE1D;EACA,IAAIjC,MAAM,GAAG0D,gBAAgB,CAACtB,IAAI,EAAE0B,YAAY,EAAE5B,SAAS,EAAEL,IAAI,CAAC;EAClE,IAAIF,KAAK,GAAG5B,yBAAyB,CAACC,MAAM,EAAEC,WAAW,CAAC;EAE1D,IAAI8D,cAAc,GAAG,EAAE,CAACH,MAAM,CAAClC,MAAM,CAAC;EAEtCqC,cAAc,CAAC,CAAC,CAAC,IAAIT,4BAA4B,CAACtD,MAAM,CAAC;EACzD+D,cAAc,CAACrC,MAAM,CAAC1F,MAAM,GAAG,CAAC,CAAC,IAAIuH,6BAA6B,CAACvD,MAAM,CAAC;EAC1E;EACA,IAAI6B,IAAI,KAAKxC,cAAc,IAAIqC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;IAC7CqC,cAAc,CAAC,CAAC,CAAC,GAAGrD,IAAI,CAACW,GAAG,CAACK,MAAM,CAAC,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;EACjD;EAEA,IAAIsC,eAAe,GAAG7D,yBAAyB,CAACzE,QAAQ,CAAC,CAAC,CAAC,EAAEuE,WAAW,EAAE;IACxEyB,MAAM,EAAEqC;EACV,CAAC,CAAC,CAAC;EAEH,IAAIxD,QAAQ,GAAGiD,qBAAqB,CAACxD,MAAM,EAAE+D,cAAc,EAAEpC,KAAK,EAAEqC,eAAe,CAAC;EAEpF,OAAO;IACLC,OAAO,EAAEF,cAAc,CAAC,CAAC,CAAC;IAC1BG,OAAO,EAAEH,cAAc,CAACA,cAAc,CAAC/H,MAAM,GAAG,CAAC,CAAC;IAClDuE,QAAQ,EAAEA;EACZ,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS4D,0BAA0BA,CAACpB,KAAK,EAAE9C,WAAW,EAAE;EACtD,IAAIwC,IAAI,GAAGxC,WAAW,CAACwC,IAAI;EAC3B,IAAI2B,gBAAgB,GAAGrB,KAAK,CAACsB,SAAS;IAClCC,QAAQ,GAAGF,gBAAgB,KAAKvH,SAAS,GAAG,EAAE,GAAGuH,gBAAgB;IACjEG,kBAAkB,GAAGxB,KAAK,CAACyB,WAAW;IACtCC,UAAU,GAAGF,kBAAkB,KAAK1H,SAAS,GAAG,EAAE,GAAG0H,kBAAkB;;EAE3E;EACA;;EAEA,OAAOE,UAAU,CAACzI,MAAM,IAAIsI,QAAQ,CAACtI,MAAM,IAAIsI,QAAQ,CAACI,OAAO,CAACjC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkC,sBAAsBA,CAAC5B,KAAK,EAAE9C,WAAW,EAAE;EAClD,IAAI2E,aAAa,GAAG7B,KAAK,CAAC8B,QAAQ;IAC9BC,mBAAmB,GAAG/B,KAAK,CAACyB,WAAW;IACvCC,UAAU,GAAGK,mBAAmB,KAAKjI,SAAS,GAAG,EAAE,GAAGiI,mBAAmB;;EAE7E;;EAEA,IAAIC,YAAY,GAAG9E,WAAW,CAACyB,MAAM,CAAC1F,MAAM;EAC5C,IAAI0F,MAAM,GAAGzB,WAAW,CAACyB,MAAM;EAE/B,IAAIsD,YAAY,GAAGtD,MAAM,CAAC,CAAC,CAAC;EAC5B,IAAIuD,YAAY,GAAGvD,MAAM,CAACqD,YAAY,GAAG,CAAC,CAAC;EAC3C,IAAIG,aAAa,GAAGjF,WAAW,CAACM,QAAQ;;EAExC;EACA;EACAqE,aAAa,CAACO,OAAO,CAAC,UAAU/C,IAAI,EAAET,KAAK,EAAE;IAC3C,IAAI8C,UAAU,CAACC,OAAO,CAAC/C,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;MACpC;IACF;IACA,IAAIS,IAAI,IAAIA,IAAI,CAACpG,MAAM,EAAE;MACvB,IAAIoJ,qBAAqB,GAAGvB,kCAAkC,CAACzB,IAAI,EAAEnC,WAAW,CAAC;QAC7EgE,OAAO,GAAGmB,qBAAqB,CAACnB,OAAO;QACvCC,OAAO,GAAGkB,qBAAqB,CAAClB,OAAO;QACvC3D,QAAQ,GAAG6E,qBAAqB,CAAC7E,QAAQ;MAE7CyE,YAAY,GAAGtE,IAAI,CAACW,GAAG,CAAC2D,YAAY,EAAEf,OAAO,CAAC;MAC9CgB,YAAY,GAAGvE,IAAI,CAACa,GAAG,CAAC0D,YAAY,EAAEf,OAAO,CAAC;MAC9CgB,aAAa,GAAGxE,IAAI,CAACa,GAAG,CAAC2D,aAAa,EAAE3E,QAAQ,CAAC;IACnD;EACF,CAAC,CAAC;EAEFN,WAAW,CAACyB,MAAM,GAAG,CAACsD,YAAY,CAAC,CAACpB,MAAM,CAACjG,kBAAkB,CAAC+D,MAAM,CAAC5B,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAACmF,YAAY,CAAC,CAAC;EAEnGhF,WAAW,CAACM,QAAQ,GAAG2E,aAAa;EAEpC,OAAOjF,WAAW;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASoF,uBAAuBA,CAACpF,WAAW,EAAE;EACnD,IAAIC,OAAO,GAAGC,yBAAyB,CAACF,WAAW,CAAC;EACpD,IAAIyB,MAAM,GAAGzB,WAAW,CAACyB,MAAM;IAC3BV,KAAK,GAAGf,WAAW,CAACe,KAAK;EAE7B,IAAIU,MAAM,CAAC1F,MAAM,GAAG,CAAC,EAAE;IACrBiE,WAAW,CAACM,QAAQ,GAAGG,IAAI,CAACC,GAAG,CAACT,OAAO,CAACwB,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGxB,OAAO,CAACwB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;EAC1E,CAAC,MAAM;IACLzB,WAAW,CAACM,QAAQ,GAAGG,IAAI,CAACC,GAAG,CAACK,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,CAAC;EACtD;EAEA,OAAOf,WAAW;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASqF,uBAAuBA,CAACvC,KAAK,EAAEN,IAAI,EAAE;EACnD;EACA,IAAIxC,WAAW,GAAG6C,4BAA4B,CAACC,KAAK,EAAEN,IAAI,CAAC;EAC3D,IAAI,CAACxC,WAAW,EAAE;IAChB,OAAO,IAAI;EACb;;EAEA;EACA;EACA,IAAI,CAACkE,0BAA0B,CAACpB,KAAK,EAAE9C,WAAW,CAAC,EAAE;IACnD,OAAOA,WAAW;EACpB;EAEA,IAAI4B,IAAI,GAAG5B,WAAW,CAAC4B,IAAI;EAC3B;EACA;EACA;;EAEA,IAAIA,IAAI,KAAK3C,kBAAkB,IAAI2C,IAAI,KAAK1C,mBAAmB,EAAE;IAC/D,OAAOkG,uBAAuB,CAACpF,WAAW,CAAC;EAC7C;EACA,OAAO0E,sBAAsB,CAAC5B,KAAK,EAAE9C,WAAW,CAAC;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASsF,iBAAiBA,CAACxC,KAAK,EAAEN,IAAI,EAAE;EAC7C,IAAIxC,WAAW,GAAGqF,uBAAuB,CAACvC,KAAK,EAAEN,IAAI,CAAC;EACtD,OAAOtC,yBAAyB,CAACF,WAAW,CAAC;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASuF,aAAaA,CAACnD,CAAC,EAAEJ,QAAQ,EAAE;EAClC,OAAOA,QAAQ,CAACI,CAAC,CAACD,IAAI,GAAGC,CAAC,CAACD,IAAI,GAAGC,CAAC,CAAC;AACtC;AAEA,SAASE,UAAUA,CAAClF,KAAK,EAAE;EACzB,OAAO,OAAOA,KAAK,KAAK,WAAW;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoI,UAAUA,CAAC/D,MAAM,EAAEF,OAAO,EAAE;EACnC,IAAI,CAACE,MAAM,EAAE;IACX,OAAOA,MAAM;EACf;EACA,IAAIgE,KAAK,CAACC,UAAU,CAACjE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIgE,KAAK,CAACC,UAAU,CAACjE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;IAChE,OAAOA,MAAM;EACf;EAEA,IAAIkE,OAAO,GAAGtJ,cAAc,CAACoF,MAAM,EAAE,CAAC,CAAC;IACnCL,GAAG,GAAGuE,OAAO,CAAC,CAAC,CAAC;IAChBrE,GAAG,GAAGqE,OAAO,CAAC,CAAC,CAAC;EAEpB,IAAIC,aAAa,GAAG,CAACtE,GAAG,GAAGF,GAAG,KAAKG,OAAO,GAAG,IAAI,CAAC;EAClD,OAAO,CAACH,GAAG,GAAGwE,aAAa,EAAEtE,GAAG,GAAGsE,aAAa,CAAC;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,mBAAmBA,CAAC/C,KAAK,EAAEN,IAAI,EAAE;EAC/C,IAAIxC,WAAW,GAAGqF,uBAAuB,CAACvC,KAAK,EAAEN,IAAI,CAAC;EACtD,IAAIxC,WAAW,EAAE;IACf,IAAIC,OAAO,GAAGC,yBAAyB,CAACF,WAAW,CAAC;IACpD,OAAO,UAAUoC,CAAC,EAAE;MAClB,OAAOnC,OAAO,CAACsF,aAAa,CAACnD,CAAC,EAAEpC,WAAW,CAACgC,QAAQ,CAAC,CAAC;IACxD,CAAC;EACH;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS8D,eAAeA,CAAChD,KAAK,EAAEN,IAAI,EAAE;EAC3C,IAAIxC,WAAW,GAAGqF,uBAAuB,CAACvC,KAAK,EAAEN,IAAI,CAAC;EACtD,IAAIxC,WAAW,EAAE;IACf,IAAIyB,MAAM,GAAGzB,WAAW,CAACyB,MAAM;IAC/B,IAAIsE,qBAAqB,GAAG/F,WAAW,CAACyC,SAAS;MAC7CA,SAAS,GAAGsD,qBAAqB,KAAKnJ,SAAS,GAAG6E,MAAM,CAAC,CAAC,CAAC,GAAGsE,qBAAqB;IAEvF,IAAI9F,OAAO,GAAGC,yBAAyB,CAACF,WAAW,CAAC;IACpD,OAAO,UAAUoC,CAAC,EAAE;MAClB,IAAIhF,KAAK,GAAGmI,aAAa,CAACnD,CAAC,EAAEpC,WAAW,CAACiC,SAAS,CAAC;MACnD,OAAOhC,OAAO,CAACqC,UAAU,CAAClF,KAAK,CAAC,GAAGA,KAAK,GAAGqF,SAAS,CAAC;IACvD,CAAC;EACH;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASuD,iBAAiBA,CAAClD,KAAK,EAAEN,IAAI,EAAE;EAC7C,IAAIxC,WAAW,GAAGqF,uBAAuB,CAACvC,KAAK,EAAEN,IAAI,CAAC;EACtD,IAAIxC,WAAW,EAAE;IACf,IAAI,CAACA,WAAW,CAAC0C,OAAO,IAAII,KAAK,CAAC,GAAG,GAAGN,IAAI,GAAG,OAAO,CAAC,KAAK5F,SAAS,EAAE;MACrEiC,OAAO,CAAC,sCAAsC,GAAG2D,IAAI,GAAG,YAAY,GAAG,4CAA4C,CAAC;IACtH;IACA,OAAOM,KAAK,CAAC,GAAG,GAAGN,IAAI,GAAG,OAAO,CAAC,IAAIxC,WAAW,CAACe,KAAK,CAAC,CAAC,CAAC;EAC5D;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASkF,4BAA4BA,CAACzD,IAAI,EAAE;EACjD,IAAI0D,KAAK;EAET,OAAOA,KAAK,GAAG,CAAC,CAAC,EAAErI,eAAe,CAACqI,KAAK,EAAE,GAAG,GAAG1D,IAAI,GAAG,OAAO,EAAE5D,SAAS,CAACuH,GAAG,CAAC,EAAEtI,eAAe,CAACqI,KAAK,EAAE1D,IAAI,GAAG,QAAQ,EAAE5D,SAAS,CAACwH,KAAK,CAAC,EAAEvI,eAAe,CAACqI,KAAK,EAAE,KAAK,GAAGxG,WAAW,CAAC8C,IAAI,CAAC,EAAE5D,SAAS,CAACyH,IAAI,CAAC,EAAExI,eAAe,CAACqI,KAAK,EAAE,KAAK,GAAGxG,WAAW,CAAC8C,IAAI,CAAC,GAAG,GAAG,EAAE5D,SAAS,CAACyH,IAAI,CAAC,EAAExI,eAAe,CAACqI,KAAK,EAAE1D,IAAI,GAAG,OAAO,EAAE5D,SAAS,CAACwH,KAAK,CAAC,EAAEvI,eAAe,CAACqI,KAAK,EAAE1D,IAAI,GAAG,MAAM,EAAE5D,SAAS,CAAC0H,KAAK,CAAC5K,MAAM,CAAC6K,IAAI,CAAChH,eAAe,CAAC,CAAC,CAAC,EAAE1B,eAAe,CAACqI,KAAK,EAAE1D,IAAI,GAAG,UAAU,EAAE5D,SAAS,CAAC4H,MAAM,CAAC,EAAE3I,eAAe,CAACqI,KAAK,EAAE1D,IAAI,GAAG,WAAW,EAAE5D,SAAS,CAACuH,GAAG,CAAC,EAAED,KAAK;AACpiB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,0BAA0BA,CAAC3D,KAAK,EAAE4D,UAAU,EAAE;EAC5D,IAAIvG,MAAM,GAAG,CAAC,CAAC;EACfzE,MAAM,CAAC6K,IAAI,CAACzD,KAAK,CAAC,CAACoC,OAAO,CAAC,UAAUjJ,GAAG,EAAE;IACxC;IACA,IAAIuG,IAAI,GAAGkE,UAAU,CAACC,IAAI,CAAC,UAAUC,CAAC,EAAE;MACtC;MACA,IAAIC,UAAU,GAAG5K,GAAG,CAACwI,OAAO,CAACmC,CAAC,CAAC,KAAK,CAAC;MACrC;MACA,IAAIE,eAAe,GAAG7K,GAAG,CAACwI,OAAO,CAAC,GAAG,GAAGmC,CAAC,CAAC,KAAK,CAAC;MAChD;MACA,IAAIG,OAAO,GAAG9K,GAAG,CAACwI,OAAO,CAAC,KAAK,GAAG/E,WAAW,CAACkH,CAAC,CAAC,CAAC,KAAK,CAAC;MACvD,OAAOC,UAAU,IAAIC,eAAe,IAAIC,OAAO;IACjD,CAAC,CAAC;IACF,IAAI,CAACvE,IAAI,EAAE;MACT;IACF;IACArC,MAAM,CAAClE,GAAG,CAAC,GAAG6G,KAAK,CAAC7G,GAAG,CAAC;EAC1B,CAAC,CAAC;EACF,OAAOkE,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS6G,oBAAoBA,CAAClE,KAAK,EAAEX,IAAI,EAAEuE,UAAU,EAAE;EAC5D,IAAIvG,MAAM,GAAG,CAAC,CAAC;EACf;EACAuG,UAAU,CAACxB,OAAO,CAAC,UAAU1C,IAAI,EAAE;IACjC,IAAI,CAACM,KAAK,CAAC,KAAK,GAAGpD,WAAW,CAAC8C,IAAI,CAAC,CAAC,EAAE;MACrCrC,MAAM,CAAC,KAAK,GAAGT,WAAW,CAAC8C,IAAI,CAAC,CAAC,GAAG,UAAUJ,CAAC,EAAE;QAC/C,OAAOA,CAAC,CAACI,IAAI,CAAC;MAChB,CAAC;IACH;IACA,IAAI,CAACM,KAAK,CAAC,KAAK,GAAGpD,WAAW,CAAC8C,IAAI,CAAC,GAAG,GAAG,CAAC,EAAE;MAC3CrC,MAAM,CAAC,KAAK,GAAGT,WAAW,CAAC8C,IAAI,CAAC,GAAG,GAAG,CAAC,GAAG,UAAUJ,CAAC,EAAE;QACrD,OAAOA,CAAC,CAACI,IAAI,GAAG,GAAG,CAAC;MACtB,CAAC;IACH;IACA,IAAI,CAACM,KAAK,CAACN,IAAI,GAAG,QAAQ,CAAC,EAAE;MAC3BrC,MAAM,CAACqC,IAAI,GAAG,QAAQ,CAAC,GAAGV,mBAAmB,CAACK,IAAI,EAAEW,KAAK,CAAC,KAAK,GAAGpD,WAAW,CAAC8C,IAAI,CAAC,CAAC,IAAIrC,MAAM,CAAC,KAAK,GAAGT,WAAW,CAAC8C,IAAI,CAAC,CAAC,EAAEM,KAAK,CAAC,KAAK,GAAGpD,WAAW,CAAC8C,IAAI,CAAC,GAAG,GAAG,CAAC,IAAIrC,MAAM,CAAC,KAAK,GAAGT,WAAW,CAAC8C,IAAI,CAAC,GAAG,GAAG,CAAC,EAAEM,KAAK,CAACN,IAAI,GAAG,MAAM,CAAC,CAAC;MACnO,IAAIM,KAAK,CAACN,IAAI,GAAG,SAAS,CAAC,EAAE;QAC3BrC,MAAM,CAACqC,IAAI,GAAG,QAAQ,CAAC,GAAGgD,UAAU,CAACrF,MAAM,CAACqC,IAAI,GAAG,QAAQ,CAAC,EAAEM,KAAK,CAACN,IAAI,GAAG,SAAS,CAAC,CAAC;MACxF;IACF;EACF,CAAC,CAAC;EAEF,OAAOrC,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASX,YAAYA,CAACyH,YAAY,EAAE;EACzC,SAASrG,KAAKA,CAACwB,CAAC,EAAE;IAChB,IAAIA,CAAC,KAAKxF,SAAS,EAAE;MACnB,OAAOqK,YAAY;IACrB;IACA,OAAO7E,CAAC;EACV;EAEA,SAAS8E,QAAQA,CAAA,EAAG;IAClB,OAAOtG,KAAK;EACd;EAEAA,KAAK,CAACa,MAAM,GAAGyF,QAAQ;EACvBtG,KAAK,CAACG,KAAK,GAAGmG,QAAQ;EACtBtG,KAAK,CAACuG,OAAO,GAAGD,QAAQ;EACxBtG,KAAK,CAACwG,IAAI,GAAGF,QAAQ;EAErB,OAAOtG,KAAK;AACd;AAEA,OAAO,SAASyG,0BAA0BA,CAACC,UAAU,EAAE;EACrD,IAAIA,UAAU,EAAE;IACd,OAAO3I,GAAG,CAAC2I,UAAU,CAAC,CAACC,CAAC,GAAG,IAAI,GAAG,MAAM,GAAG,MAAM;EACnD;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,eAAeA,CAAC1E,KAAK,EAAE2E,QAAQ,EAAE;EAC/C,IAAIC,YAAY,GAAGjI,WAAW,CAACyC,MAAM,CAAC,UAAUyF,IAAI,EAAEnF,IAAI,EAAE;IAC1D,IAAIf,MAAM,GAAGqB,KAAK,CAACN,IAAI,GAAG,QAAQ,CAAC;MAC/BzB,KAAK,GAAG+B,KAAK,CAACN,IAAI,GAAG,OAAO,CAAC;MAC7BZ,IAAI,GAAGkB,KAAK,CAACN,IAAI,GAAG,MAAM,CAAC;IAG/B,IAAIf,MAAM,IAAIV,KAAK,IAAIa,IAAI,EAAE;MAC3B,OAAOnG,QAAQ,CAAC,CAAC,CAAC,EAAEkM,IAAI,EAAE9J,eAAe,CAAC,CAAC,CAAC,EAAE2E,IAAI,EAAEjD,eAAe,CAACqC,IAAI,CAAC,EAAE,CAACH,MAAM,CAACA,MAAM,CAAC,CAACV,KAAK,CAACA,KAAK,CAAC,CAAC,CAAC;IAC3G;IACA,OAAO4G,IAAI;EACb,CAAC,EAAE,CAAC,CAAC,CAAC;EAEN,OAAOF,QAAQ,CAACG,GAAG,CAAC,UAAUC,KAAK,EAAE;IACnC,OAAOpI,WAAW,CAACyC,MAAM,CAAC,UAAUyF,IAAI,EAAEnF,IAAI,EAAE;MAC9C,IAAIqF,KAAK,CAAC/E,KAAK,IAAI+E,KAAK,CAAC/E,KAAK,CAACN,IAAI,CAAC,KAAK5F,SAAS,EAAE;QAClD,IAAIkL,UAAU,GAAGD,KAAK,CAAC/E,KAAK,CAACN,IAAI,CAAC;QAClC,IAAI5B,KAAK,GAAG8G,YAAY,CAAClF,IAAI,CAAC;QAC9B,IAAIO,aAAa,GAAGnC,KAAK,GAAGA,KAAK,CAACkH,UAAU,CAAC,GAAGA,UAAU;QAC1D,OAAOrM,QAAQ,CAAC,CAAC,CAAC,EAAEkM,IAAI,EAAE9J,eAAe,CAAC,CAAC,CAAC,EAAE,GAAG,GAAG2E,IAAI,GAAG,OAAO,EAAEO,aAAa,CAAC,CAAC;MACrF;MACA,OAAO4E,IAAI;IACb,CAAC,EAAE,CAAC,CAAC,CAAC;EACR,CAAC,CAAC;AACJ;AAEA,IAAII,oBAAoB,GAAG,CAAC,SAAS,CAAC;AACtC,IAAIC,yBAAyB,GAAGD,oBAAoB,CAACH,GAAG,CAAC,UAAUjI,GAAG,EAAE;EACtE,OAAO,IAAIsI,MAAM,CAACtI,GAAG,GAAG,GAAG,EAAE,GAAG,CAAC;AACnC,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASuI,qBAAqBA,CAACpF,KAAK,EAAE;EAC3C,OAAOpH,MAAM,CAAC6K,IAAI,CAACzD,KAAK,CAAC,CAACZ,MAAM,CAAC,UAAUiG,GAAG,EAAEC,IAAI,EAAE;IACpD,IAAIC,iBAAiB,GAAGL,yBAAyB,CAACM,KAAK,CAAC,UAAUC,GAAG,EAAE;MACrE,OAAO,CAACH,IAAI,CAACI,KAAK,CAACD,GAAG,CAAC;IACzB,CAAC,CAAC;IACF,IAAIF,iBAAiB,EAAE;MACrB,OAAOF,GAAG;IACZ;IACAA,GAAG,CAACC,IAAI,CAAC,GAAGtF,KAAK,CAACsF,IAAI,CAAC;IACvB,OAAOD,GAAG;EACZ,CAAC,EAAE,CAAC,CAAC,CAAC;AACR;AAEA,eAAe;EACb1B,0BAA0B,EAAEA,0BAA0B;EACtDnB,iBAAiB,EAAEA,iBAAiB;EACpCO,mBAAmB,EAAEA,mBAAmB;EACxCC,eAAe,EAAEA,eAAe;EAChCE,iBAAiB,EAAEA,iBAAiB;EACpClE,mBAAmB,EAAEA,mBAAmB;EACxCuF,0BAA0B,EAAEA,0BAA0B;EACtDL,oBAAoB,EAAEA,oBAAoB;EAC1CkB,qBAAqB,EAAEA,qBAAqB;EAC5C7C,uBAAuB,EAAEA,uBAAuB;EAChDY,4BAA4B,EAAEA,4BAA4B;EAC1DuB,eAAe,EAAEA,eAAe;EAChChI,YAAY,EAAEA;AAChB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}