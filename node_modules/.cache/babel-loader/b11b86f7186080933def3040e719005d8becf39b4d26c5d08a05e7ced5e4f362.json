{"ast":null,"code":"// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setFilterGpuMode = setFilterGpuMode;\nexports.assignGpuChannels = assignGpuChannels;\nexports.assignGpuChannel = assignGpuChannel;\nexports.resetFilterGpuMode = resetFilterGpuMode;\nexports.getGpuFilterProps = getGpuFilterProps;\nexports.getDatasetFieldIndexForFilter = getDatasetFieldIndexForFilter;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _moment = _interopRequireDefault(require(\"moment\"));\nvar _constants = require(\"@kepler.gl/constants\");\nvar _utils = require(\"@kepler.gl/utils\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n\n/**\n * Set gpu mode based on current number of gpu filters exists\n */\nfunction setFilterGpuMode(filter, filters) {\n  // filter can be applied to multiple datasets, hence gpu filter mode should also be\n  // an array, however, to keep us sane, for now, we only check if there is available channel for every dataId,\n  // if all of them has, we set gpu mode to true\n  // TODO: refactor filter so we don't keep an array of everything\n  filter.dataId.forEach(function (dataId, datasetIdx) {\n    var gpuFilters = filters.filter(function (f) {\n      return f.dataId.includes(dataId) && f.gpu;\n    });\n    if (filter.gpu && gpuFilters.length === _constants.MAX_GPU_FILTERS) {\n      return (0, _utils.set)(['gpu'], false, filter);\n    }\n  });\n  return filter;\n}\n/**\n * Scan though all filters and assign gpu chanel to gpu filter\n */\n\nfunction assignGpuChannels(allFilters) {\n  return allFilters.reduce(function (accu, f, index) {\n    var filters = accu; // if gpu is true assign and validate gpu Channel\n\n    if (f.gpu) {\n      f = assignGpuChannel(f, accu);\n      filters = (0, _utils.set)([index], f, accu);\n    }\n    return filters;\n  }, allFilters);\n}\n/**\n * Assign a new gpu filter a channel based on first availability\n */\n\nfunction assignGpuChannel(filter, filters) {\n  // find first available channel\n  if (!filter.gpu) {\n    return filter;\n  }\n  var gpuChannel = filter.gpuChannel || [];\n  filter.dataId.forEach(function (dataId, datasetIdx) {\n    var findGpuChannel = function findGpuChannel(channel) {\n      return function (f) {\n        var dataIdx = (0, _utils.toArray)(f.dataId).indexOf(dataId);\n        return f.id !== filter.id && dataIdx > -1 && f.gpu && (0, _utils.toArray)(f.gpuChannel)[dataIdx] === channel;\n      };\n    };\n    if (Number.isFinite(gpuChannel[datasetIdx]) && !filters.find(findGpuChannel(gpuChannel[datasetIdx]))) {\n      // if value is already assigned and valid\n      return;\n    }\n    var i = 0;\n    while (i < _constants.MAX_GPU_FILTERS) {\n      if (!filters.find(findGpuChannel(i))) {\n        gpuChannel[datasetIdx] = i;\n        return;\n      }\n      i++;\n    }\n  }); // if cannot find channel for all dataid, set gpu back to false\n  // TODO: refactor filter to handle same filter different gpu mode\n\n  if (!gpuChannel.length || !gpuChannel.every(Number.isFinite)) {\n    return _objectSpread(_objectSpread({}, filter), {}, {\n      gpu: false\n    });\n  }\n  return _objectSpread(_objectSpread({}, filter), {}, {\n    gpuChannel: gpuChannel\n  });\n}\n/**\n * Edit filter.gpu to ensure that only\n * X number of gpu filers can coexist.\n */\n\nfunction resetFilterGpuMode(filters) {\n  var gpuPerDataset = {};\n  return filters.map(function (f, i) {\n    if (f.gpu) {\n      var gpu = true;\n      (0, _utils.toArray)(f.dataId).forEach(function (dataId) {\n        var count = gpuPerDataset[dataId];\n        if (count === _constants.MAX_GPU_FILTERS) {\n          gpu = false;\n        } else {\n          gpuPerDataset[dataId] = count ? count + 1 : 1;\n        }\n      });\n      if (!gpu) {\n        return (0, _utils.set)(['gpu'], false, f);\n      }\n    }\n    return f;\n  });\n}\n/**\n * Initial filter uniform\n */\n\nfunction getEmptyFilterRange() {\n  return new Array(_constants.MAX_GPU_FILTERS).fill(0).map(function (d) {\n    return [0, 0];\n  });\n}\n/**\n * Returns index of the data element.\n * @param {any} d Data element with row index info.\n * @returns number\n */\n\nvar defaultGetIndex = function defaultGetIndex(d) {\n  return d.index;\n};\n/**\n * Returns value at the specified row from the data container.\n * @param dc Data container.\n * @param d Data element with row index info.\n * @param fieldIndex Column index in the data container.\n * @returns\n */\n\nvar defaultGetData = function defaultGetData(dc, d, fieldIndex) {\n  return dc.valueAt(d.index, fieldIndex);\n};\n/**\n * @param channels\n * @param dataId\n * @param fields\n * @return {Function} getFilterValue\n */\n\nvar getFilterValueAccessor = function getFilterValueAccessor(channels, dataId, fields) {\n  return function (dc) {\n    return function () {\n      var getIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetIndex;\n      var getData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetData;\n      return function (d) {\n        return (\n          // for empty channel, value is 0 and min max would be [0, 0]\n          channels.map(function (filter) {\n            var _filter$domain;\n            if (!filter) {\n              return 0;\n            }\n            var fieldIndex = getDatasetFieldIndexForFilter(dataId, filter);\n            var field = fields[fieldIndex];\n            var value = filter.type === _constants.FILTER_TYPES.timeRange ? field.filterProps && Array.isArray(field.filterProps.mappedValue) ? field.filterProps.mappedValue[getIndex(d)] : _moment[\"default\"].utc(getData(dc, d, fieldIndex)).valueOf() : getData(dc, d, fieldIndex);\n            return (0, _utils.notNullorUndefined)(value) ? value - ((_filter$domain = filter.domain) === null || _filter$domain === void 0 ? void 0 : _filter$domain[0]) : Number.MIN_SAFE_INTEGER;\n          })\n        );\n      };\n    };\n  };\n};\n/**\n * Get filter properties for gpu filtering\n */\n\nfunction getGpuFilterProps(filters, dataId, fields) {\n  var filterRange = getEmptyFilterRange();\n  var triggers = {}; // array of filter for each channel, undefined, if no filter is assigned to that channel\n\n  var channels = [];\n  var _loop = function _loop(i) {\n    var _filter$domain2, _filter$domain3;\n    var filter = filters.find(function (f) {\n      return f.gpu && f.dataId.includes(dataId) && f.gpuChannel && f.gpuChannel[f.dataId.indexOf(dataId)] === i;\n    });\n    filterRange[i][0] = filter ? filter.value[0] - ((_filter$domain2 = filter.domain) === null || _filter$domain2 === void 0 ? void 0 : _filter$domain2[0]) : 0;\n    filterRange[i][1] = filter ? filter.value[1] - ((_filter$domain3 = filter.domain) === null || _filter$domain3 === void 0 ? void 0 : _filter$domain3[0]) : 0;\n    triggers[\"gpuFilter_\".concat(i)] = filter ? filter.name[filter.dataId.indexOf(dataId)] : null;\n    channels.push(filter);\n  };\n  for (var i = 0; i < _constants.MAX_GPU_FILTERS; i++) {\n    _loop(i);\n  }\n  var filterValueAccessor = getFilterValueAccessor(channels, dataId, fields);\n  return {\n    filterRange: filterRange,\n    filterValueUpdateTriggers: triggers,\n    // @ts-expect-error\n    filterValueAccessor: filterValueAccessor\n  };\n}\n/**\n * Return dataset field index from filter.fieldIdx\n * The index matches the same dataset index for filter.dataId\n */\n\nfunction getDatasetFieldIndexForFilter(dataId, filter) {\n  var datasetIndex = (0, _utils.toArray)(filter.dataId).indexOf(dataId);\n  if (datasetIndex < 0) {\n    return -1;\n  }\n  var fieldIndex = filter.fieldIdx[datasetIndex];\n  return (0, _utils.notNullorUndefined)(fieldIndex) ? fieldIndex : -1;\n}","map":{"version":3,"names":["exports","setFilterGpuMode","assignGpuChannels","assignGpuChannel","resetFilterGpuMode","getGpuFilterProps","getDatasetFieldIndexForFilter","_defineProperty2","_interopRequireDefault","require","_moment","_utils","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","dataId","datasetIdx","gpuFilters","filters","f","includes","gpu","_constants","MAX_GPU_FILTERS","set","allFilters","reduce","accu","index","gpuChannel","findGpuChannel","channel","dataIdx","toArray","indexOf","id","Number","isFinite","find","every","gpuPerDataset","map","count","getEmptyFilterRange","Array","fill","d","defaultGetIndex","dc","valueAt","fieldIndex","getFilterValueAccessor","channels","fields","getIndex","undefined","getData","defaultGetData","field","value","type","FILTER_TYPES","timeRange","filterProps","isArray","mappedValue","utc","valueOf","triggers","_loop","_filter$domain2","_filter$domain3","filterRange","domain","filterValueUpdateTriggers"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@kepler.gl/table/src/gpu-filter-utils.ts"],"sourcesContent":["// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport moment from 'moment';\nimport {MAX_GPU_FILTERS, FILTER_TYPES} from '@kepler.gl/constants';\nimport {Field, Filter} from '@kepler.gl/types';\n\nimport {set, toArray, notNullorUndefined, DataContainerInterface} from '@kepler.gl/utils';\nimport {GpuFilter} from './kepler-table';\n\n/**\n * Set gpu mode based on current number of gpu filters exists\n */\nexport function setFilterGpuMode(filter: Filter, filters: Filter[]) {\n  // filter can be applied to multiple datasets, hence gpu filter mode should also be\n  // an array, however, to keep us sane, for now, we only check if there is available channel for every dataId,\n  // if all of them has, we set gpu mode to true\n  // TODO: refactor filter so we don't keep an array of everything\n\n  filter.dataId.forEach((dataId, datasetIdx) => {\n    const gpuFilters = filters.filter(f => f.dataId.includes(dataId) && f.gpu);\n\n    if (filter.gpu && gpuFilters.length === MAX_GPU_FILTERS) {\n      return set(['gpu'], false, filter);\n    }\n  });\n\n  return filter;\n}\n\n/**\n * Scan though all filters and assign gpu chanel to gpu filter\n */\nexport function assignGpuChannels(allFilters: Filter[]) {\n  return allFilters.reduce((accu, f, index) => {\n    let filters = accu;\n\n    // if gpu is true assign and validate gpu Channel\n    if (f.gpu) {\n      f = assignGpuChannel(f, accu);\n      filters = set([index], f, accu);\n    }\n\n    return filters;\n  }, allFilters);\n}\n/**\n * Assign a new gpu filter a channel based on first availability\n */\nexport function assignGpuChannel(filter: Filter, filters: Filter[]) {\n  // find first available channel\n  if (!filter.gpu) {\n    return filter;\n  }\n\n  const gpuChannel = filter.gpuChannel || [];\n\n  filter.dataId.forEach((dataId, datasetIdx) => {\n    const findGpuChannel = channel => f => {\n      const dataIdx = toArray(f.dataId).indexOf(dataId);\n      return (\n        f.id !== filter.id && dataIdx > -1 && f.gpu && toArray(f.gpuChannel)[dataIdx] === channel\n      );\n    };\n\n    if (\n      Number.isFinite(gpuChannel[datasetIdx]) &&\n      !filters.find(findGpuChannel(gpuChannel[datasetIdx]))\n    ) {\n      // if value is already assigned and valid\n      return;\n    }\n\n    let i = 0;\n\n    while (i < MAX_GPU_FILTERS) {\n      if (!filters.find(findGpuChannel(i))) {\n        gpuChannel[datasetIdx] = i;\n        return;\n      }\n      i++;\n    }\n  });\n\n  // if cannot find channel for all dataid, set gpu back to false\n  // TODO: refactor filter to handle same filter different gpu mode\n  if (!gpuChannel.length || !gpuChannel.every(Number.isFinite)) {\n    return {\n      ...filter,\n      gpu: false\n    };\n  }\n\n  return {\n    ...filter,\n    gpuChannel\n  };\n}\n/**\n * Edit filter.gpu to ensure that only\n * X number of gpu filers can coexist.\n */\nexport function resetFilterGpuMode(filters: Filter[]): Filter[] {\n  const gpuPerDataset = {};\n\n  return filters.map((f, i) => {\n    if (f.gpu) {\n      let gpu = true;\n      toArray(f.dataId).forEach(dataId => {\n        const count = gpuPerDataset[dataId];\n\n        if (count === MAX_GPU_FILTERS) {\n          gpu = false;\n        } else {\n          gpuPerDataset[dataId] = count ? count + 1 : 1;\n        }\n      });\n\n      if (!gpu) {\n        return set(['gpu'], false, f);\n      }\n    }\n\n    return f;\n  });\n}\n\n/**\n * Initial filter uniform\n */\nfunction getEmptyFilterRange() {\n  return new Array(MAX_GPU_FILTERS).fill(0).map(d => [0, 0]);\n}\n\n/**\n * Returns index of the data element.\n * @param {any} d Data element with row index info.\n * @returns number\n */\nconst defaultGetIndex = d => d.index;\n\n/**\n * Returns value at the specified row from the data container.\n * @param dc Data container.\n * @param d Data element with row index info.\n * @param fieldIndex Column index in the data container.\n * @returns\n */\nconst defaultGetData = (dc: DataContainerInterface, d: any, fieldIndex: number) => {\n  return dc.valueAt(d.index, fieldIndex);\n};\n\n/**\n * @param channels\n * @param dataId\n * @param fields\n * @return {Function} getFilterValue\n */\nconst getFilterValueAccessor = (\n  channels: (Filter | undefined)[],\n  dataId: string,\n  fields: any[]\n) => (dc: DataContainerInterface) => (getIndex = defaultGetIndex, getData = defaultGetData) => d =>\n  // for empty channel, value is 0 and min max would be [0, 0]\n  channels.map(filter => {\n    if (!filter) {\n      return 0;\n    }\n    const fieldIndex = getDatasetFieldIndexForFilter(dataId, filter);\n    const field = fields[fieldIndex];\n\n    const value =\n      filter.type === FILTER_TYPES.timeRange\n        ? field.filterProps && Array.isArray(field.filterProps.mappedValue)\n          ? field.filterProps.mappedValue[getIndex(d)]\n          : moment.utc(getData(dc, d, fieldIndex)).valueOf()\n        : getData(dc, d, fieldIndex);\n\n    return notNullorUndefined(value) ? value - filter.domain?.[0] : Number.MIN_SAFE_INTEGER;\n  });\n\n/**\n * Get filter properties for gpu filtering\n */\nexport function getGpuFilterProps(filters: Filter[], dataId: string, fields: Field[]): GpuFilter {\n  const filterRange = getEmptyFilterRange();\n  const triggers = {};\n\n  // array of filter for each channel, undefined, if no filter is assigned to that channel\n  const channels: (Filter | undefined)[] = [];\n\n  for (let i = 0; i < MAX_GPU_FILTERS; i++) {\n    const filter = filters.find(\n      f =>\n        f.gpu &&\n        f.dataId.includes(dataId) &&\n        f.gpuChannel &&\n        f.gpuChannel[f.dataId.indexOf(dataId)] === i\n    );\n\n    filterRange[i][0] = filter ? filter.value[0] - filter.domain?.[0] : 0;\n    filterRange[i][1] = filter ? filter.value[1] - filter.domain?.[0] : 0;\n\n    triggers[`gpuFilter_${i}`] = filter ? filter.name[filter.dataId.indexOf(dataId)] : null;\n    channels.push(filter);\n  }\n\n  const filterValueAccessor = getFilterValueAccessor(channels, dataId, fields);\n\n  return {\n    filterRange,\n    filterValueUpdateTriggers: triggers,\n    // @ts-expect-error\n    filterValueAccessor\n  };\n}\n\n/**\n * Return dataset field index from filter.fieldIdx\n * The index matches the same dataset index for filter.dataId\n */\nexport function getDatasetFieldIndexForFilter(dataId: string, filter: Filter): number {\n  const datasetIndex = toArray(filter.dataId).indexOf(dataId);\n  if (datasetIndex < 0) {\n    return -1;\n  }\n\n  const fieldIndex = filter.fieldIdx[datasetIndex];\n\n  return notNullorUndefined(fieldIndex) ? fieldIndex : -1;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}