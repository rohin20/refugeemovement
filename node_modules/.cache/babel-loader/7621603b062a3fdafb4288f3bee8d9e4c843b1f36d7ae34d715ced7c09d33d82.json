{"ast":null,"code":"import _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _SRC_TEX_PARAMETER_OV;\nimport { cloneTextureFrom, readPixelsToArray, getShaderVersion, Buffer, Texture2D, Framebuffer } from '@luma.gl/webgl';\nimport { _transform as transformModule, getPassthroughFS, typeToChannelCount, combineInjects } from '@luma.gl/shadertools';\nimport { updateForTextures, getSizeUniforms } from './transform-shader-utils';\nvar SRC_TEX_PARAMETER_OVERRIDES = (_SRC_TEX_PARAMETER_OV = {}, _defineProperty(_SRC_TEX_PARAMETER_OV, 10241, 9728), _defineProperty(_SRC_TEX_PARAMETER_OV, 10240, 9728), _defineProperty(_SRC_TEX_PARAMETER_OV, 10242, 33071), _defineProperty(_SRC_TEX_PARAMETER_OV, 10243, 33071), _SRC_TEX_PARAMETER_OV);\nvar FS_OUTPUT_VARIABLE = 'transform_output';\nvar TextureTransform = /*#__PURE__*/function () {\n  function TextureTransform(gl) {\n    _classCallCheck(this, TextureTransform);\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.id = this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = [];\n    this.resources = {};\n    this._initialize(props);\n    Object.seal(this);\n  }\n  _createClass(TextureTransform, [{\n    key: \"updateModelProps\",\n    value: function updateModelProps() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var updatedModelProps = this._processVertexShader(props);\n      return Object.assign({}, props, updatedModelProps);\n    }\n  }, {\n    key: \"getDrawOptions\",\n    value: function getDrawOptions() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _this$bindings$this$c = this.bindings[this.currentIndex],\n        sourceBuffers = _this$bindings$this$c.sourceBuffers,\n        sourceTextures = _this$bindings$this$c.sourceTextures,\n        framebuffer = _this$bindings$this$c.framebuffer,\n        targetTexture = _this$bindings$this$c.targetTexture;\n      var attributes = Object.assign({}, sourceBuffers, opts.attributes);\n      var uniforms = Object.assign({}, opts.uniforms);\n      var parameters = Object.assign({}, opts.parameters);\n      var discard = opts.discard;\n      if (this.hasSourceTextures || this.hasTargetTexture) {\n        attributes.transform_elementID = this.elementIDBuffer;\n        for (var sampler in this.samplerTextureMap) {\n          var textureName = this.samplerTextureMap[sampler];\n          uniforms[sampler] = sourceTextures[textureName];\n        }\n        this._setSourceTextureParameters();\n        var sizeUniforms = getSizeUniforms({\n          sourceTextureMap: sourceTextures,\n          targetTextureVarying: this.targetTextureVarying,\n          targetTexture: targetTexture\n        });\n        Object.assign(uniforms, sizeUniforms);\n      }\n      if (this.hasTargetTexture) {\n        discard = false;\n        parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n      }\n      return {\n        attributes: attributes,\n        framebuffer: framebuffer,\n        uniforms: uniforms,\n        discard: discard,\n        parameters: parameters\n      };\n    }\n  }, {\n    key: \"swap\",\n    value: function swap() {\n      if (this._swapTexture) {\n        this.currentIndex = this._getNextIndex();\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this._setupTextures(opts);\n    }\n  }, {\n    key: \"getTargetTexture\",\n    value: function getTargetTexture() {\n      var targetTexture = this.bindings[this.currentIndex].targetTexture;\n      return targetTexture;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$packed = _ref.packed,\n        packed = _ref$packed === void 0 ? false : _ref$packed;\n      var framebuffer = this.bindings[this.currentIndex].framebuffer;\n      var pixels = readPixelsToArray(framebuffer);\n      if (!packed) {\n        return pixels;\n      }\n      var ArrayType = pixels.constructor;\n      var channelCount = typeToChannelCount(this.targetTextureType);\n      var packedPixels = new ArrayType(pixels.length * channelCount / 4);\n      var packCount = 0;\n      for (var i = 0; i < pixels.length; i += 4) {\n        for (var j = 0; j < channelCount; j++) {\n          packedPixels[packCount++] = pixels[i + j];\n        }\n      }\n      return packedPixels;\n    }\n  }, {\n    key: \"getFramebuffer\",\n    value: function getFramebuffer() {\n      var currentResources = this.bindings[this.currentIndex];\n      return currentResources.framebuffer;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      if (this.ownTexture) {\n        this.ownTexture.delete();\n      }\n      if (this.elementIDBuffer) {\n        this.elementIDBuffer.delete();\n      }\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _targetTextureVarying = props._targetTextureVarying,\n        _swapTexture = props._swapTexture;\n      this._swapTexture = _swapTexture;\n      this.targetTextureVarying = _targetTextureVarying;\n      this.hasTargetTexture = _targetTextureVarying;\n      this._setupTextures(props);\n    }\n  }, {\n    key: \"_createTargetTexture\",\n    value: function _createTargetTexture(props) {\n      var sourceTextures = props.sourceTextures,\n        textureOrReference = props.textureOrReference;\n      if (textureOrReference instanceof Texture2D) {\n        return textureOrReference;\n      }\n      var refTexture = sourceTextures[textureOrReference];\n      if (!refTexture) {\n        return null;\n      }\n      this._targetRefTexName = textureOrReference;\n      return this._createNewTexture(refTexture);\n    }\n  }, {\n    key: \"_setupTextures\",\n    value: function _setupTextures() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var sourceBuffers = props.sourceBuffers,\n        _props$_sourceTexture = props._sourceTextures,\n        _sourceTextures = _props$_sourceTexture === void 0 ? {} : _props$_sourceTexture,\n        _targetTexture = props._targetTexture;\n      var targetTexture = this._createTargetTexture({\n        sourceTextures: _sourceTextures,\n        textureOrReference: _targetTexture\n      });\n      this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;\n      this._updateBindings({\n        sourceBuffers: sourceBuffers,\n        sourceTextures: _sourceTextures,\n        targetTexture: targetTexture\n      });\n      if ('elementCount' in props) {\n        this._updateElementIDBuffer(props.elementCount);\n      }\n    }\n  }, {\n    key: \"_updateElementIDBuffer\",\n    value: function _updateElementIDBuffer(elementCount) {\n      if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n        return;\n      }\n      var elementIds = new Float32Array(elementCount);\n      elementIds.forEach(function (_, index, array) {\n        array[index] = index;\n      });\n      if (!this.elementIDBuffer) {\n        this.elementIDBuffer = new Buffer(this.gl, {\n          data: elementIds,\n          accessor: {\n            size: 1\n          }\n        });\n      } else {\n        this.elementIDBuffer.setData({\n          data: elementIds\n        });\n      }\n      this.elementCount = elementCount;\n    }\n  }, {\n    key: \"_updateBindings\",\n    value: function _updateBindings(opts) {\n      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n      if (this._swapTexture) {\n        var _this$_swapTextures = this._swapTextures(this.bindings[this.currentIndex]),\n          sourceTextures = _this$_swapTextures.sourceTextures,\n          targetTexture = _this$_swapTextures.targetTexture;\n        var nextIndex = this._getNextIndex();\n        this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n          sourceTextures: sourceTextures,\n          targetTexture: targetTexture\n        });\n      }\n    }\n  }, {\n    key: \"_updateBinding\",\n    value: function _updateBinding(binding, opts) {\n      var sourceBuffers = opts.sourceBuffers,\n        sourceTextures = opts.sourceTextures,\n        targetTexture = opts.targetTexture;\n      if (!binding) {\n        binding = {\n          sourceBuffers: {},\n          sourceTextures: {},\n          targetTexture: null\n        };\n      }\n      Object.assign(binding.sourceTextures, sourceTextures);\n      Object.assign(binding.sourceBuffers, sourceBuffers);\n      if (targetTexture) {\n        binding.targetTexture = targetTexture;\n        var width = targetTexture.width,\n          height = targetTexture.height;\n        var _binding = binding,\n          framebuffer = _binding.framebuffer;\n        if (framebuffer) {\n          framebuffer.update({\n            attachments: _defineProperty({}, 36064, targetTexture),\n            resizeAttachments: false\n          });\n          framebuffer.resize({\n            width: width,\n            height: height\n          });\n        } else {\n          binding.framebuffer = new Framebuffer(this.gl, {\n            id: \"transform-framebuffer\",\n            width: width,\n            height: height,\n            attachments: _defineProperty({}, 36064, targetTexture)\n          });\n        }\n      }\n      return binding;\n    }\n  }, {\n    key: \"_setSourceTextureParameters\",\n    value: function _setSourceTextureParameters() {\n      var index = this.currentIndex;\n      var sourceTextures = this.bindings[index].sourceTextures;\n      for (var name in sourceTextures) {\n        sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n      }\n    }\n  }, {\n    key: \"_swapTextures\",\n    value: function _swapTextures(opts) {\n      if (!this._swapTexture) {\n        return null;\n      }\n      var sourceTextures = Object.assign({}, opts.sourceTextures);\n      sourceTextures[this._swapTexture] = opts.targetTexture;\n      var targetTexture = opts.sourceTextures[this._swapTexture];\n      return {\n        sourceTextures: sourceTextures,\n        targetTexture: targetTexture\n      };\n    }\n  }, {\n    key: \"_createNewTexture\",\n    value: function _createNewTexture(refTexture) {\n      var _parameters;\n      var texture = cloneTextureFrom(refTexture, {\n        parameters: (_parameters = {}, _defineProperty(_parameters, 10241, 9728), _defineProperty(_parameters, 10240, 9728), _defineProperty(_parameters, 10242, 33071), _defineProperty(_parameters, 10243, 33071), _parameters),\n        pixelStore: _defineProperty({}, 37440, false)\n      });\n      if (this.ownTexture) {\n        this.ownTexture.delete();\n      }\n      this.ownTexture = texture;\n      return texture;\n    }\n  }, {\n    key: \"_getNextIndex\",\n    value: function _getNextIndex() {\n      return (this.currentIndex + 1) % 2;\n    }\n  }, {\n    key: \"_processVertexShader\",\n    value: function _processVertexShader() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _this$bindings$this$c2 = this.bindings[this.currentIndex],\n        sourceTextures = _this$bindings$this$c2.sourceTextures,\n        targetTexture = _this$bindings$this$c2.targetTexture;\n      var _updateForTextures = updateForTextures({\n          vs: props.vs,\n          sourceTextureMap: sourceTextures,\n          targetTextureVarying: this.targetTextureVarying,\n          targetTexture: targetTexture\n        }),\n        vs = _updateForTextures.vs,\n        uniforms = _updateForTextures.uniforms,\n        targetTextureType = _updateForTextures.targetTextureType,\n        inject = _updateForTextures.inject,\n        samplerTextureMap = _updateForTextures.samplerTextureMap;\n      var combinedInject = combineInjects([props.inject || {}, inject]);\n      this.targetTextureType = targetTextureType;\n      this.samplerTextureMap = samplerTextureMap;\n      var fs = props._fs || getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n      var modules = this.hasSourceTextures || this.targetTextureVarying ? [transformModule].concat(props.modules || []) : props.modules;\n      return {\n        vs: vs,\n        fs: fs,\n        modules: modules,\n        uniforms: uniforms,\n        inject: combinedInject\n      };\n    }\n  }]);\n  return TextureTransform;\n}();\nexport { TextureTransform as default };","map":{"version":3,"names":["cloneTextureFrom","readPixelsToArray","getShaderVersion","Buffer","Texture2D","Framebuffer","_transform","transformModule","getPassthroughFS","typeToChannelCount","combineInjects","updateForTextures","getSizeUniforms","SRC_TEX_PARAMETER_OVERRIDES","_SRC_TEX_PARAMETER_OV","_defineProperty","FS_OUTPUT_VARIABLE","TextureTransform","gl","_classCallCheck","props","arguments","length","undefined","id","currentIndex","_swapTexture","targetTextureVarying","targetTextureType","samplerTextureMap","bindings","resources","_initialize","Object","seal","_createClass","key","value","updateModelProps","updatedModelProps","_processVertexShader","assign","getDrawOptions","opts","_this$bindings$this$c","sourceBuffers","sourceTextures","framebuffer","targetTexture","attributes","uniforms","parameters","discard","hasSourceTextures","hasTargetTexture","transform_elementID","elementIDBuffer","sampler","textureName","_setSourceTextureParameters","sizeUniforms","sourceTextureMap","viewport","width","height","swap","_getNextIndex","update","_setupTextures","getTargetTexture","getData","_ref","_ref$packed","packed","pixels","ArrayType","constructor","channelCount","packedPixels","packCount","i","j","getFramebuffer","currentResources","_delete","ownTexture","delete","_targetTextureVarying","_createTargetTexture","textureOrReference","refTexture","_targetRefTexName","_createNewTexture","_props$_sourceTexture","_sourceTextures","_targetTexture","keys","_updateBindings","_updateElementIDBuffer","elementCount","elementIds","Float32Array","forEach","_","index","array","data","accessor","size","setData","_updateBinding","_this$_swapTextures","_swapTextures","nextIndex","binding","_binding","attachments","resizeAttachments","resize","name","setParameters","_parameters","texture","pixelStore","_this$bindings$this$c2","_updateForTextures","vs","inject","combinedInject","fs","_fs","version","input","inputType","output","modules","concat","default"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@luma.gl/engine/src/transform/texture-transform.js"],"sourcesContent":["/** @typedef {import('./transform').TransformProps} TransformProps */\nimport GL from '@luma.gl/constants';\n\nimport {\n  cloneTextureFrom,\n  readPixelsToArray,\n  getShaderVersion,\n  Buffer,\n  Texture2D,\n  Framebuffer\n} from '@luma.gl/webgl';\n\nimport {\n  _transform as transformModule,\n  getPassthroughFS,\n  typeToChannelCount,\n  combineInjects\n} from '@luma.gl/shadertools';\n\nimport {updateForTextures, getSizeUniforms} from './transform-shader-utils';\n\n// TODO: move these constants to transform-shader-utils\n// Texture parameters needed so sample can precisely pick pixel for given element id.\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\nexport default class TextureTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.id = this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  updateModelProps(props = {}) {\n    const updatedModelProps = this._processVertexShader(props);\n    return Object.assign({}, props, updatedModelProps);\n  }\n\n  getDrawOptions(opts = {}) {\n    const {sourceBuffers, sourceTextures, framebuffer, targetTexture} = this.bindings[\n      this.currentIndex\n    ];\n\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n    const uniforms = Object.assign({}, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    let discard = opts.discard;\n\n    if (this.hasSourceTextures || this.hasTargetTexture) {\n      attributes.transform_elementID = this.elementIDBuffer;\n\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = sourceTextures[textureName];\n      }\n      this._setSourceTextureParameters();\n      // get texture size uniforms\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n\n    if (this.hasTargetTexture) {\n      discard = false;\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n    }\n\n    return {attributes, framebuffer, uniforms, discard, parameters};\n  }\n\n  swap() {\n    if (this._swapTexture) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupTextures(opts);\n  }\n\n  // returns current target texture\n  getTargetTexture() {\n    const {targetTexture} = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getData({packed = false} = {}) {\n    const {framebuffer} = this.bindings[this.currentIndex];\n    const pixels = readPixelsToArray(framebuffer);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    // readPixels returns 4 elements for each pixel, pack the elements when requested\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    // @ts-ignore\n    const packedPixels = new ArrayType((pixels.length * channelCount) / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n\n  // returns current framebuffer object that is being used.\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  // Delete owned resources.\n  delete() {\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    if (this.elementIDBuffer) {\n      this.elementIDBuffer.delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {_targetTextureVarying, _swapTexture} = props;\n    this._swapTexture = _swapTexture;\n    this.targetTextureVarying = _targetTextureVarying;\n    this.hasTargetTexture = _targetTextureVarying;\n    this._setupTextures(props);\n  }\n\n  // auto create target texture if requested\n  _createTargetTexture(props) {\n    const {sourceTextures, textureOrReference} = props;\n    if (textureOrReference instanceof Texture2D) {\n      return textureOrReference;\n    }\n    // 'targetTexture' is a reference souce texture.\n    const refTexture = sourceTextures[textureOrReference];\n    if (!refTexture) {\n      return null;\n    }\n\n    // save reference texture name, when corresponding source texture is updated\n    // we also update target texture.\n    this._targetRefTexName = textureOrReference;\n\n    return this._createNewTexture(refTexture);\n  }\n\n  /** @param {TransformProps} props */\n  _setupTextures(props = {}) {\n    const {sourceBuffers, _sourceTextures = {}, _targetTexture} = props;\n    const targetTexture = this._createTargetTexture({\n      sourceTextures: _sourceTextures,\n      textureOrReference: _targetTexture\n    });\n    this.hasSourceTextures =\n      this.hasSourceTextures || (_sourceTextures && Object.keys(_sourceTextures).length > 0);\n    this._updateBindings({sourceBuffers, sourceTextures: _sourceTextures, targetTexture});\n    if ('elementCount' in props) {\n      this._updateElementIDBuffer(props.elementCount);\n    }\n  }\n\n  _updateElementIDBuffer(elementCount) {\n    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n      return;\n    }\n    // NOTE: using float so this will work with GLSL 1.0 shaders.\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new Buffer(this.gl, {\n        data: elementIds,\n        accessor: {size: 1}\n      });\n    } else {\n      this.elementIDBuffer.setData({data: elementIds});\n    }\n    this.elementCount = elementCount;\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this._swapTexture) {\n      const {sourceTextures, targetTexture} = this._swapTextures(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceTextures,\n        targetTexture\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    const {sourceBuffers, sourceTextures, targetTexture} = opts;\n    if (!binding) {\n      binding = {\n        sourceBuffers: {},\n        sourceTextures: {},\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    Object.assign(binding.sourceBuffers, sourceBuffers);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n\n      const {width, height} = targetTexture;\n      const {framebuffer} = binding;\n      if (framebuffer) {\n        // First update texture without re-sizing attachments\n        framebuffer.update({\n          attachments: {[GL.COLOR_ATTACHMENT0]: targetTexture},\n          resizeAttachments: false\n        });\n        // Resize to new taget texture size\n        framebuffer.resize({width, height});\n      } else {\n        binding.framebuffer = new Framebuffer(this.gl, {\n          id: `transform-framebuffer`,\n          width,\n          height,\n          attachments: {\n            [GL.COLOR_ATTACHMENT0]: targetTexture\n          }\n        });\n      }\n    }\n    return binding;\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {sourceTextures} = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  _swapTextures(opts) {\n    if (!this._swapTexture) {\n      return null;\n    }\n    const sourceTextures = Object.assign({}, opts.sourceTextures);\n    sourceTextures[this._swapTexture] = opts.targetTexture;\n\n    const targetTexture = opts.sourceTextures[this._swapTexture];\n\n    return {sourceTextures, targetTexture};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewTexture(refTexture) {\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      }\n    });\n\n    // thre can only be one target texture\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    this.ownTexture = texture;\n\n    return texture;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n  // build and return shader releated parameters\n  _processVertexShader(props = {}) {\n    const {sourceTextures, targetTexture} = this.bindings[this.currentIndex];\n    // @ts-ignore TODO - uniforms is not present\n    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = updateForTextures({\n      vs: props.vs,\n      sourceTextureMap: sourceTextures,\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture\n    });\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    this.samplerTextureMap = samplerTextureMap;\n    const fs =\n      props._fs ||\n      getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n    const modules =\n      this.hasSourceTextures || this.targetTextureVarying\n        ? [transformModule].concat(props.modules || [])\n        : props.modules;\n    return {vs, fs, modules, uniforms, inject: combinedInject};\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}