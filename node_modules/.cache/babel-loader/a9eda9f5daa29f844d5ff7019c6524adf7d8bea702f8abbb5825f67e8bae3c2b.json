{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport AggregationLayer from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { Buffer } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport BinSorter from './utils/bin-sorter';\nimport { pointToDensityGridDataCPU } from './cpu-grid-layer/grid-aggregator';\nvar GridAggregationLayer = /*#__PURE__*/function (_AggregationLayer) {\n  _inherits(GridAggregationLayer, _AggregationLayer);\n  var _super = _createSuper(GridAggregationLayer);\n  function GridAggregationLayer() {\n    _classCallCheck(this, GridAggregationLayer);\n    return _super.apply(this, arguments);\n  }\n  _createClass(GridAggregationLayer, [{\n    key: \"initializeState\",\n    value: function initializeState(_ref) {\n      var dimensions = _ref.dimensions;\n      var gl = this.context.gl;\n      _get(_getPrototypeOf(GridAggregationLayer.prototype), \"initializeState\", this).call(this, dimensions);\n      this.setState({\n        layerData: {},\n        gpuGridAggregator: new GPUGridAggregator(gl, {\n          id: \"\".concat(this.id, \"-gpu-aggregator\")\n        }),\n        cpuGridAggregator: pointToDensityGridDataCPU\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts) {\n      _get(_getPrototypeOf(GridAggregationLayer.prototype), \"updateState\", this).call(this, opts);\n      this.updateAggregationState(opts);\n      var _this$state = this.state,\n        aggregationDataDirty = _this$state.aggregationDataDirty,\n        aggregationWeightsDirty = _this$state.aggregationWeightsDirty,\n        gpuAggregation = _this$state.gpuAggregation;\n      if (this.getNumInstances() <= 0) {\n        return;\n      }\n      var aggregationDirty = false;\n      if (aggregationDataDirty || gpuAggregation && aggregationWeightsDirty) {\n        this._updateAggregation(opts);\n        aggregationDirty = true;\n      }\n      if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n        this._updateWeightBins();\n        this._uploadAggregationResults();\n        aggregationDirty = true;\n      }\n      this.setState({\n        aggregationDirty: aggregationDirty\n      });\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      var _this$state$gpuGridAg;\n      var count = this.state.weights.count;\n      if (count && count.aggregationBuffer) {\n        count.aggregationBuffer.delete();\n      }\n      (_this$state$gpuGridAg = this.state.gpuGridAggregator) === null || _this$state$gpuGridAg === void 0 ? void 0 : _this$state$gpuGridAg.delete();\n      _get(_getPrototypeOf(GridAggregationLayer.prototype), \"finalizeState\", this).call(this);\n    }\n  }, {\n    key: \"updateShaders\",\n    value: function updateShaders(shaders) {\n      if (this.state.gpuAggregation) {\n        this.state.gpuGridAggregator.updateShaders(shaders);\n      }\n    }\n  }, {\n    key: \"updateAggregationState\",\n    value: function updateAggregationState(opts) {\n      log.assert(false);\n    }\n  }, {\n    key: \"allocateResources\",\n    value: function allocateResources(numRow, numCol) {\n      if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n        var dataBytes = numCol * numRow * 4 * 4;\n        var gl = this.context.gl;\n        var weights = this.state.weights;\n        for (var name in weights) {\n          var weight = weights[name];\n          if (weight.aggregationBuffer) {\n            weight.aggregationBuffer.delete();\n          }\n          weight.aggregationBuffer = new Buffer(gl, {\n            byteLength: dataBytes,\n            accessor: {\n              size: 4,\n              type: 5126,\n              divisor: 1\n            }\n          });\n        }\n      }\n    }\n  }, {\n    key: \"updateResults\",\n    value: function updateResults(_ref2) {\n      var aggregationData = _ref2.aggregationData,\n        maxMinData = _ref2.maxMinData,\n        maxData = _ref2.maxData,\n        minData = _ref2.minData;\n      var count = this.state.weights.count;\n      if (count) {\n        count.aggregationData = aggregationData;\n        count.maxMinData = maxMinData;\n        count.maxData = maxData;\n        count.minData = minData;\n      }\n    }\n  }, {\n    key: \"_updateAggregation\",\n    value: function _updateAggregation(opts) {\n      var _this$state2 = this.state,\n        cpuGridAggregator = _this$state2.cpuGridAggregator,\n        gpuGridAggregator = _this$state2.gpuGridAggregator,\n        gridOffset = _this$state2.gridOffset,\n        posOffset = _this$state2.posOffset,\n        _this$state2$translat = _this$state2.translation,\n        translation = _this$state2$translat === void 0 ? [0, 0] : _this$state2$translat,\n        _this$state2$scaling = _this$state2.scaling,\n        scaling = _this$state2$scaling === void 0 ? [0, 0, 0] : _this$state2$scaling,\n        boundingBox = _this$state2.boundingBox,\n        projectPoints = _this$state2.projectPoints,\n        gpuAggregation = _this$state2.gpuAggregation,\n        numCol = _this$state2.numCol,\n        numRow = _this$state2.numRow;\n      var props = opts.props;\n      var viewport = this.context.viewport;\n      var attributes = this.getAttributes();\n      var vertexCount = this.getNumInstances();\n      if (!gpuAggregation) {\n        var result = cpuGridAggregator(props, {\n          gridOffset: gridOffset,\n          projectPoints: projectPoints,\n          attributes: attributes,\n          viewport: viewport,\n          posOffset: posOffset,\n          boundingBox: boundingBox\n        });\n        this.setState({\n          layerData: result\n        });\n      } else {\n        var weights = this.state.weights;\n        gpuGridAggregator.run({\n          weights: weights,\n          cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n          numCol: numCol,\n          numRow: numRow,\n          translation: translation,\n          scaling: scaling,\n          vertexCount: vertexCount,\n          projectPoints: projectPoints,\n          attributes: attributes,\n          moduleSettings: this.getModuleSettings()\n        });\n      }\n    }\n  }, {\n    key: \"_updateWeightBins\",\n    value: function _updateWeightBins() {\n      var getValue = this.state.getValue;\n      var sortedBins = new BinSorter(this.state.layerData.data || [], {\n        getValue: getValue\n      });\n      this.setState({\n        sortedBins: sortedBins\n      });\n    }\n  }, {\n    key: \"_uploadAggregationResults\",\n    value: function _uploadAggregationResults() {\n      var _this$state3 = this.state,\n        numCol = _this$state3.numCol,\n        numRow = _this$state3.numRow;\n      var data = this.state.layerData.data;\n      var _this$state$sortedBin = this.state.sortedBins,\n        aggregatedBins = _this$state$sortedBin.aggregatedBins,\n        minValue = _this$state$sortedBin.minValue,\n        maxValue = _this$state$sortedBin.maxValue,\n        totalCount = _this$state$sortedBin.totalCount;\n      var ELEMENTCOUNT = 4;\n      var aggregationSize = numCol * numRow * ELEMENTCOUNT;\n      var aggregationData = new Float32Array(aggregationSize).fill(0);\n      var _iterator = _createForOfIteratorHelper(aggregatedBins),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var bin = _step.value;\n          var _data$bin$i = data[bin.i],\n            lonIdx = _data$bin$i.lonIdx,\n            latIdx = _data$bin$i.latIdx;\n          var value = bin.value,\n            counts = bin.counts;\n          var cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n          aggregationData[cellIndex] = value;\n          aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n      var maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n      var minData = new Float32Array([minValue, 0, 0, totalCount]);\n      this.updateResults({\n        aggregationData: aggregationData,\n        maxMinData: maxMinData,\n        maxData: maxData,\n        minData: minData\n      });\n    }\n  }]);\n  return GridAggregationLayer;\n}(AggregationLayer);\nexport { GridAggregationLayer as default };\nGridAggregationLayer.layerName = 'GridAggregationLayer';","map":{"version":3,"names":["AggregationLayer","GPUGridAggregator","Buffer","log","BinSorter","pointToDensityGridDataCPU","GridAggregationLayer","_AggregationLayer","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","initializeState","_ref","dimensions","gl","context","_get","_getPrototypeOf","prototype","call","setState","layerData","gpuGridAggregator","id","concat","cpuGridAggregator","updateState","opts","updateAggregationState","_this$state","state","aggregationDataDirty","aggregationWeightsDirty","gpuAggregation","getNumInstances","aggregationDirty","_updateAggregation","_updateWeightBins","_uploadAggregationResults","finalizeState","_this$state$gpuGridAg","count","weights","aggregationBuffer","delete","updateShaders","shaders","assert","allocateResources","numRow","numCol","dataBytes","name","weight","byteLength","accessor","size","type","divisor","updateResults","_ref2","aggregationData","maxMinData","maxData","minData","_this$state2","gridOffset","posOffset","_this$state2$translat","translation","_this$state2$scaling","scaling","boundingBox","projectPoints","props","viewport","attributes","getAttributes","vertexCount","result","run","cellSize","xOffset","yOffset","moduleSettings","getModuleSettings","getValue","sortedBins","data","_this$state3","_this$state$sortedBin","aggregatedBins","minValue","maxValue","totalCount","ELEMENTCOUNT","aggregationSize","Float32Array","fill","_iterator","_createForOfIteratorHelper","_step","s","n","done","bin","_data$bin$i","i","lonIdx","latIdx","counts","cellIndex","err","e","f","default","layerName"],"sources":["/Users/rohinphukan/Desktop/RefugeeWebsite/node_modules/@deck.gl/aggregation-layers/src/grid-aggregation-layer.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport AggregationLayer from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {Buffer} from '@luma.gl/core';\nimport {log} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport BinSorter from './utils/bin-sorter';\nimport {pointToDensityGridDataCPU} from './cpu-grid-layer/grid-aggregator';\n\nexport default class GridAggregationLayer extends AggregationLayer {\n  initializeState({dimensions}) {\n    const {gl} = this.context;\n    super.initializeState(dimensions);\n    this.setState({\n      // CPU aggregation results\n      layerData: {},\n      gpuGridAggregator: new GPUGridAggregator(gl, {id: `${this.id}-gpu-aggregator`}),\n      cpuGridAggregator: pointToDensityGridDataCPU\n    });\n  }\n\n  updateState(opts) {\n    // get current attributes\n    super.updateState(opts);\n\n    this.updateAggregationState(opts);\n\n    const {aggregationDataDirty, aggregationWeightsDirty, gpuAggregation} = this.state;\n    if (this.getNumInstances() <= 0) {\n      return;\n    }\n    let aggregationDirty = false;\n    // CPU aggregation is two steps\n    // 1. Create bins (based on cellSize and position) 2. Aggregate weights for each bin\n    // For GPU aggregation both above steps are combined into one step\n\n    // step-1\n    if (aggregationDataDirty || (gpuAggregation && aggregationWeightsDirty)) {\n      this._updateAggregation(opts);\n      aggregationDirty = true;\n    }\n    // step-2 (Applicalbe for CPU aggregation only)\n    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n      this._updateWeightBins();\n      this._uploadAggregationResults();\n      aggregationDirty = true;\n    }\n\n    this.setState({aggregationDirty});\n  }\n\n  finalizeState() {\n    const {count} = this.state.weights;\n    if (count && count.aggregationBuffer) {\n      count.aggregationBuffer.delete();\n    }\n    this.state.gpuGridAggregator?.delete();\n    super.finalizeState();\n  }\n\n  updateShaders(shaders) {\n    if (this.state.gpuAggregation) {\n      this.state.gpuGridAggregator.updateShaders(shaders);\n    }\n  }\n\n  // Methods that can be overriden by subclasses for customizations\n\n  updateAggregationState(opts) {\n    // Sublayers should implement this method.\n    log.assert(false);\n  }\n\n  allocateResources(numRow, numCol) {\n    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n      const dataBytes = numCol * numRow * 4 * 4;\n      const gl = this.context.gl;\n      const {weights} = this.state;\n      for (const name in weights) {\n        const weight = weights[name];\n        if (weight.aggregationBuffer) {\n          weight.aggregationBuffer.delete();\n        }\n        weight.aggregationBuffer = new Buffer(gl, {\n          byteLength: dataBytes,\n          accessor: {\n            size: 4,\n            type: GL.FLOAT,\n            divisor: 1\n          }\n        });\n      }\n    }\n  }\n\n  updateResults({aggregationData, maxMinData, maxData, minData}) {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = aggregationData;\n      count.maxMinData = maxMinData;\n      count.maxData = maxData;\n      count.minData = minData;\n    }\n  }\n\n  // Private\n\n  _updateAggregation(opts) {\n    const {\n      cpuGridAggregator,\n      gpuGridAggregator,\n      gridOffset,\n      posOffset,\n      translation = [0, 0],\n      scaling = [0, 0, 0],\n      boundingBox,\n      projectPoints,\n      gpuAggregation,\n      numCol,\n      numRow\n    } = this.state;\n    const {props} = opts;\n    const {viewport} = this.context;\n    const attributes = this.getAttributes();\n    const vertexCount = this.getNumInstances();\n\n    if (!gpuAggregation) {\n      const result = cpuGridAggregator(props, {\n        gridOffset,\n        projectPoints,\n        attributes,\n        viewport,\n        posOffset,\n        boundingBox\n      });\n      this.setState({\n        layerData: result\n      });\n    } else {\n      const {weights} = this.state;\n      gpuGridAggregator.run({\n        weights,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n        numCol,\n        numRow,\n        translation,\n        scaling,\n        vertexCount,\n        projectPoints,\n        attributes,\n        moduleSettings: this.getModuleSettings()\n      });\n    }\n  }\n\n  _updateWeightBins() {\n    const {getValue} = this.state;\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {getValue});\n    this.setState({sortedBins});\n  }\n\n  _uploadAggregationResults() {\n    const {numCol, numRow} = this.state;\n    const {data} = this.state.layerData;\n    const {aggregatedBins, minValue, maxValue, totalCount} = this.state.sortedBins;\n\n    const ELEMENTCOUNT = 4;\n    const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n    const aggregationData = new Float32Array(aggregationSize).fill(0);\n    for (const bin of aggregatedBins) {\n      const {lonIdx, latIdx} = data[bin.i];\n      const {value, counts} = bin;\n      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n      aggregationData[cellIndex] = value;\n      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n    }\n    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n    const minData = new Float32Array([minValue, 0, 0, totalCount]);\n    this.updateResults({aggregationData, maxMinData, maxData, minData});\n  }\n}\n\nGridAggregationLayer.layerName = 'GridAggregationLayer';\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}